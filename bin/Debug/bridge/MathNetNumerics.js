/**
 * @version 1.0.0.0
 * @copyright Copyright Â©  2019
 * @compiler Bridge.NET 17.10.1
 */
Bridge.assembly("MathNetNumerics", function ($asm, globals) {
    "use strict";

    /** @namespace MathNet.Numerics */

    /**
     * Integer number theory functions.
     *
     * @static
     * @abstract
     * @public
     * @class MathNet.Numerics.Euclid
     */
    Bridge.define("MathNet.Numerics.Euclid", {
        statics: {
            fields: {
                MultiplyDeBruijnBitPosition: null
            },
            ctors: {
                init: function () {
                    this.MultiplyDeBruijnBitPosition = System.Array.init([0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31], System.Int32);
                }
            },
            methods: {
                /**
                 * Canonical Modulus. The result has the sign of the divisor.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {number}    dividend    
                 * @param   {number}    divisor
                 * @return  {number}
                 */
                Modulus: function (dividend, divisor) {
                    return ((dividend % divisor) + divisor) % divisor;
                },
                /**
                 * Canonical Modulus. The result has the sign of the divisor.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {number}    dividend    
                 * @param   {number}    divisor
                 * @return  {number}
                 */
                Modulus$3: function (dividend, divisor) {
                    return ((dividend % divisor) + divisor) % divisor;
                },
                /**
                 * Canonical Modulus. The result has the sign of the divisor.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {number}    dividend    
                 * @param   {number}    divisor
                 * @return  {number}
                 */
                Modulus$1: function (dividend, divisor) {
                    return ((((dividend % divisor) + divisor) | 0)) % divisor;
                },
                /**
                 * Canonical Modulus. The result has the sign of the divisor.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {System.Int64}    dividend    
                 * @param   {System.Int64}    divisor
                 * @return  {System.Int64}
                 */
                Modulus$2: function (dividend, divisor) {
                    return ((dividend.mod(divisor)).add(divisor)).mod(divisor);
                },
                /**
                 * Canonical Modulus. The result has the sign of the divisor.
                 * Remainder (% operator). The result has the sign of the dividend.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {number}    dividend    
                 * @param   {number}    divisor
                 * @return  {number}
                 */
                Remainder: function (dividend, divisor) {
                    return dividend % divisor;
                },
                /**
                 * Remainder (% operator). The result has the sign of the dividend.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {number}    dividend    
                 * @param   {number}    divisor
                 * @return  {number}
                 */
                Remainder$3: function (dividend, divisor) {
                    return dividend % divisor;
                },
                /**
                 * Remainder (% operator). The result has the sign of the dividend.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {number}    dividend    
                 * @param   {number}    divisor
                 * @return  {number}
                 */
                Remainder$1: function (dividend, divisor) {
                    return dividend % divisor;
                },
                /**
                 * Remainder (% operator). The result has the sign of the dividend.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {System.Int64}    dividend    
                 * @param   {System.Int64}    divisor
                 * @return  {System.Int64}
                 */
                Remainder$2: function (dividend, divisor) {
                    return dividend.mod(divisor);
                },
                /**
                 * Remainder (% operator). The result has the sign of the dividend.
                 * Find out whether the provided 32 bit integer is an even number.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {number}     number    The number to very whether it's even.
                 * @return  {boolean}              True if and only if it is an even number.
                 */
                IsEven: function (number) {
                    return (number & 1) === 0;
                },
                /**
                 * Find out whether the provided 64 bit integer is an even number.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {System.Int64}    number    The number to very whether it's even.
                 * @return  {boolean}                   True if and only if it is an even number.
                 */
                IsEven$1: function (number) {
                    return (number.and(System.Int64(1))).equals(System.Int64(0));
                },
                /**
                 * Find out whether the provided 32 bit integer is an odd number.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {number}     number    The number to very whether it's odd.
                 * @return  {boolean}              True if and only if it is an odd number.
                 */
                IsOdd: function (number) {
                    return (number & 1) === 1;
                },
                /**
                 * Find out whether the provided 64 bit integer is an odd number.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {System.Int64}    number    The number to very whether it's odd.
                 * @return  {boolean}                   True if and only if it is an odd number.
                 */
                IsOdd$1: function (number) {
                    return (number.and(System.Int64(1))).equals(System.Int64(1));
                },
                /**
                 * Find out whether the provided 32 bit integer is a perfect power of two.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {number}     number    The number to very whether it's a power of two.
                 * @return  {boolean}              True if and only if it is a power of two.
                 */
                IsPowerOfTwo: function (number) {
                    return number > 0 && (number & (((number - 1) | 0))) === 0;
                },
                /**
                 * Find out whether the provided 64 bit integer is a perfect power of two.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {System.Int64}    number    The number to very whether it's a power of two.
                 * @return  {boolean}                   True if and only if it is a power of two.
                 */
                IsPowerOfTwo$1: function (number) {
                    return number.gt(System.Int64(0)) && (number.and((number.sub(System.Int64(1))))).equals(System.Int64(0));
                },
                /**
                 * Find out whether the provided 32 bit integer is a perfect square, i.e. a square of an integer.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {number}     number    The number to very whether it's a perfect square.
                 * @return  {boolean}              True if and only if it is a perfect square.
                 */
                IsPerfectSquare: function (number) {
                    if (number < 0) {
                        return false;
                    }

                    var lastHexDigit = number & 15;
                    if (lastHexDigit > 9) {
                        return false;
                    }

                    if (lastHexDigit === 0 || lastHexDigit === 1 || lastHexDigit === 4 || lastHexDigit === 9) {
                        var t = Bridge.Int.clip32(Math.floor(Math.sqrt(number) + 0.5));
                        return (Bridge.Int.mul(t, t)) === number;
                    }

                    return false;
                },
                /**
                 * Find out whether the provided 64 bit integer is a perfect square, i.e. a square of an integer.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {System.Int64}    number    The number to very whether it's a perfect square.
                 * @return  {boolean}                   True if and only if it is a perfect square.
                 */
                IsPerfectSquare$1: function (number) {
                    if (number.lt(System.Int64(0))) {
                        return false;
                    }

                    var lastHexDigit = System.Int64.clip32(number.and(System.Int64(15)));
                    if (lastHexDigit > 9) {
                        return false;
                    }

                    if (lastHexDigit === 0 || lastHexDigit === 1 || lastHexDigit === 4 || lastHexDigit === 9) {
                        var t = Bridge.Int.clip64(Math.floor(Math.sqrt(System.Int64.toNumber(number)) + 0.5));
                        return (t.mul(t)).equals(number);
                    }

                    return false;
                },
                /**
                 * Raises 2 to the provided integer exponent (0 &lt;= exponent &lt; 31).
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @throws 
                 * @param   {number}    exponent    The exponent to raise 2 up to.
                 * @return  {number}                2 ^ exponent.
                 */
                PowerOfTwo: function (exponent) {
                    if (exponent < 0 || exponent >= 31) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("exponent");
                    }

                    return 1 << exponent;
                },
                /**
                 * Raises 2 to the provided integer exponent (0 &lt;= exponent &lt; 63).
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @throws 
                 * @param   {System.Int64}    exponent    The exponent to raise 2 up to.
                 * @return  {System.Int64}                2 ^ exponent.
                 */
                PowerOfTwo$1: function (exponent) {
                    if (exponent.lt(System.Int64(0)) || exponent.gte(System.Int64(63))) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("exponent");
                    }

                    return (System.Int64(1)).shl(System.Int64.clip32(exponent));
                },
                /**
                 * Evaluate the binary logarithm of an integer number.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {number}    number
                 * @return  {number}
                 */
                Log2: function (number) {
                    number = number | (number >> 1);
                    number = number | (number >> 2);
                    number = number | (number >> 4);
                    number = number | (number >> 8);
                    number = number | (number >> 16);

                    return MathNet.Numerics.Euclid.MultiplyDeBruijnBitPosition[System.Array.index(System.Int64.clipu32((System.Int64(number).mul(System.Int64(130329821)))) >>> 27, MathNet.Numerics.Euclid.MultiplyDeBruijnBitPosition)];
                },
                /**
                 * Find the closest perfect power of two that is larger or equal to the provided
                 32 bit integer.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @throws 
                 * @param   {number}    number    The number of which to find the closest upper power of two.
                 * @return  {number}              A power of two.
                 */
                CeilingToPowerOfTwo: function (number) {
                    if (number === -2147483648) {
                        return 0;
                    }

                    var maxPowerOfTwo = 1073741824;
                    if (number > maxPowerOfTwo) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("number");
                    }

                    number = (number - 1) | 0;
                    number = number | (number >> 1);
                    number = number | (number >> 2);
                    number = number | (number >> 4);
                    number = number | (number >> 8);
                    number = number | (number >> 16);
                    return ((number + 1) | 0);
                },
                /**
                 * Find the closest perfect power of two that is larger or equal to the provided
                 64 bit integer.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @throws 
                 * @param   {System.Int64}    number    The number of which to find the closest upper power of two.
                 * @return  {System.Int64}              A power of two.
                 */
                CeilingToPowerOfTwo$1: function (number) {
                    if (number.equals(System.Int64.MinValue)) {
                        return System.Int64(0);
                    }

                    var maxPowerOfTwo = System.Int64([0,1073741824]);
                    if (number.gt(maxPowerOfTwo)) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("number");
                    }

                    number = number.dec();
                    number = number.or((number.shr(1)));
                    number = number.or((number.shr(2)));
                    number = number.or((number.shr(4)));
                    number = number.or((number.shr(8)));
                    number = number.or((number.shr(16)));
                    number = number.or((number.shr(32)));
                    return number.add(System.Int64(1));
                },
                /**
                 * Returns the greatest common divisor (<pre><code>gcd</code></pre>) of two integers using Euclid's algorithm.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {System.Int64}    a    First Integer: a.
                 * @param   {System.Int64}    b    Second Integer: b.
                 * @return  {System.Int64}         Greatest common divisor <pre><code>gcd</code></pre>(a,b)
                 */
                GreatestCommonDivisor$4: function (a, b) {
                    while (b.ne(System.Int64(0))) {
                        var remainder = a.mod(b);
                        a = b;
                        b = remainder;
                    }

                    return a.abs();
                },
                /**
                 * Returns the greatest common divisor (<pre><code>gcd</code></pre>) of a set of integers using Euclid's
                 algorithm.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {System.Collections.Generic.IList$1}    integers    List of Integers.
                 * @return  {System.Int64}                                      Greatest common divisor <pre><code>gcd</code></pre>(list of integers)
                 */
                GreatestCommonDivisor$3: function (integers) {
                    if (null == integers) {
                        throw new System.ArgumentNullException.$ctor1("integers");
                    }

                    if (System.Array.getCount(integers, System.Int64) === 0) {
                        return System.Int64(0);
                    }

                    var gcd = System.Array.getItem(integers, 0, System.Int64).abs();

                    for (var i = 1; (i < System.Array.getCount(integers, System.Int64)) && (gcd.gt(System.Int64(1))); i = (i + 1) | 0) {
                        gcd = MathNet.Numerics.Euclid.GreatestCommonDivisor$4(gcd, System.Array.getItem(integers, i, System.Int64));
                    }

                    return gcd;
                },
                /**
                 * Returns the greatest common divisor (<pre><code>gcd</code></pre>) of a set of integers using Euclid's algorithm.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {Array.<System.Int64>}    integers    List of Integers.
                 * @return  {System.Int64}                        Greatest common divisor <pre><code>gcd</code></pre>(list of integers)
                 */
                GreatestCommonDivisor$5: function (integers) {
                    if (integers === void 0) { integers = []; }
                    return MathNet.Numerics.Euclid.GreatestCommonDivisor$3(Bridge.cast(integers, System.Collections.Generic.IList$1(System.Int64)));
                },
                /**
                 * Returns the greatest common divisor (<pre><code>gcd</code></pre>) of two big integers.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {number}    a    First Integer: a.
                 * @param   {number}    b    Second Integer: b.
                 * @return  {number}         Greatest common divisor <pre><code>gcd</code></pre>(a,b)
                 */
                GreatestCommonDivisor$1: function (a, b) {
                    if (b === 0) {
                        return a;
                    }

                    var r = a % b;

                    return MathNet.Numerics.Euclid.GreatestCommonDivisor$1(b, r);
                },
                /**
                 * Returns the greatest common divisor (<pre><code>gcd</code></pre>) of a set of big integers.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {System.Collections.Generic.IList$1}    integers    List of Integers.
                 * @return  {number}                                            Greatest common divisor <pre><code>gcd</code></pre>(list of integers)
                 */
                GreatestCommonDivisor: function (integers) {
                    if (null == integers) {
                        throw new System.ArgumentNullException.$ctor1("integers");
                    }

                    if (System.Array.getCount(integers, System.Double) === 0) {
                        return 0;
                    }

                    var gcd = Math.abs(System.Array.getItem(integers, 0, System.Double));

                    for (var i = 1; (i < System.Array.getCount(integers, System.Double)) && (gcd > 1.0); i = (i + 1) | 0) {
                        gcd = MathNet.Numerics.Euclid.GreatestCommonDivisor$1(gcd, System.Array.getItem(integers, i, System.Double));
                    }

                    return gcd;
                },
                /**
                 * Returns the greatest common divisor (<pre><code>gcd</code></pre>) of a set of big integers.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {Array.<number>}    integers    List of Integers.
                 * @return  {number}                        Greatest common divisor <pre><code>gcd</code></pre>(list of integers)
                 */
                GreatestCommonDivisor$2: function (integers) {
                    if (integers === void 0) { integers = []; }
                    return MathNet.Numerics.Euclid.GreatestCommonDivisor(Bridge.cast(integers, System.Collections.Generic.IList$1(System.Double)));
                },
                /**
                 * Computes the extended greatest common divisor, such that a*x + b*y = <pre><code>gcd</code></pre>(a,b).
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @example The <pre><code>gcd</code></pre> of 45 and 18 is 9: 18 = 2*9, 45 = 5*9. 9 = 1*45 -2*18, therefore x=1 and y=-2.
                 *
                 * long x,y,d;
                 * d = Fn.GreatestCommonDivisor(45,18,out x, out y);
                 * -> d == 9 && x == 1 && y == -2
                 * 
                 *
                 *
                 * @param   {System.Int64}    a    First Integer: a.
                 * @param   {System.Int64}    b    Second Integer: b.
                 * @param   {System.Int64}    x    Resulting x, such that a*x + b*y = <pre><code>gcd</code></pre>(a,b).
                 * @param   {System.Int64}    y    Resulting y, such that a*x + b*y = <pre><code>gcd</code></pre>(a,b)
                 * @return  {System.Int64}         Greatest common divisor <pre><code>gcd</code></pre>(a,b)
                 */
                ExtendedGreatestCommonDivisor$1: function (a, b, x, y) {
                    var mp = System.Int64(1), np = System.Int64(0), m = System.Int64(0), n = System.Int64(1);

                    while (b.ne(System.Int64(0))) {
                        var rem = { };
                        var quot = System.Int64.divRem(a, b, rem);
                        a = b;
                        b = rem.v;

                        var tmp = m;
                        m = mp.sub((quot.mul(m)));
                        mp = tmp;

                        tmp = n;
                        n = np.sub((quot.mul(n)));
                        np = tmp;
                    }

                    if (a.gte(System.Int64(0))) {
                        x.v = mp;
                        y.v = np;
                        return a;
                    }

                    x.v = mp.neg();
                    y.v = np.neg();
                    return a.neg();
                },
                /**
                 * Computes the extended greatest common divisor, such that a*x + b*y = <pre><code>gcd</code></pre>(a,b).
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @example The <pre><code>gcd</code></pre> of 45 and 18 is 9: 18 = 2*9, 45 = 5*9. 9 = 1*45 -2*18, therefore x=1 and y=-2.
                 *
                 * long x,y,d;
                 * d = Fn.GreatestCommonDivisor(45,18,out x, out y);
                 * -> d == 9 && x == 1 && y == -2
                 * 
                 *
                 *
                 * @param   {number}           a    First Integer: a.
                 * @param   {number}           b    Second Integer: b.
                 * @param   {System.Double}    x    Resulting x, such that a*x + b*y = <pre><code>gcd</code></pre>(a,b).
                 * @param   {System.Double}    y    Resulting y, such that a*x + b*y = <pre><code>gcd</code></pre>(a,b)
                 * @return  {number}                Greatest common divisor <pre><code>gcd</code></pre>(a,b)
                 */
                ExtendedGreatestCommonDivisor: function (a, b, x, y) {
                    var mp = 1.0, np = 0.0, m = 0.0, n = 1.0;

                    while (b !== 0) {
                        var rem = a % b;


                        var quot = a / b;
                        a = b;
                        b = rem;

                        var tmp = m;
                        m = mp - (quot * m);
                        mp = tmp;

                        tmp = n;
                        n = np - (quot * n);
                        np = tmp;
                    }

                    if (a >= 0.0) {
                        x.v = mp;
                        y.v = np;
                        return a;
                    }

                    x.v = -mp;
                    y.v = -np;
                    return -a;
                },
                /**
                 * Returns the least common multiple (<pre><code>lcm</code></pre>) of two integers using Euclid's algorithm.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {System.Int64}    a    First Integer: a.
                 * @param   {System.Int64}    b    Second Integer: b.
                 * @return  {System.Int64}         Least common multiple <pre><code>lcm</code></pre>(a,b)
                 */
                LeastCommonMultiple$4: function (a, b) {
                    if ((a.equals(System.Int64(0))) || (b.equals(System.Int64(0)))) {
                        return System.Int64(0);
                    }

                    return (a.div(MathNet.Numerics.Euclid.GreatestCommonDivisor$4(a, b))).mul(b).abs();
                },
                /**
                 * Returns the least common multiple (<pre><code>lcm</code></pre>) of a set of integers using Euclid's algorithm.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {System.Collections.Generic.IList$1}    integers    List of Integers.
                 * @return  {System.Int64}                                      Least common multiple <pre><code>lcm</code></pre>(list of integers)
                 */
                LeastCommonMultiple$3: function (integers) {
                    if (null == integers) {
                        throw new System.ArgumentNullException.$ctor1("integers");
                    }

                    if (System.Array.getCount(integers, System.Int64) === 0) {
                        return System.Int64(1);
                    }

                    var lcm = System.Array.getItem(integers, 0, System.Int64).abs();

                    for (var i = 1; i < System.Array.getCount(integers, System.Int64); i = (i + 1) | 0) {
                        lcm = MathNet.Numerics.Euclid.LeastCommonMultiple$4(lcm, System.Array.getItem(integers, i, System.Int64));
                    }

                    return lcm;
                },
                /**
                 * Returns the least common multiple (<pre><code>lcm</code></pre>) of a set of integers using Euclid's algorithm.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {Array.<System.Int64>}    integers    List of Integers.
                 * @return  {System.Int64}                        Least common multiple <pre><code>lcm</code></pre>(list of integers)
                 */
                LeastCommonMultiple$5: function (integers) {
                    if (integers === void 0) { integers = []; }
                    return MathNet.Numerics.Euclid.LeastCommonMultiple$3(Bridge.cast(integers, System.Collections.Generic.IList$1(System.Int64)));
                },
                /**
                 * Returns the least common multiple (<pre><code>lcm</code></pre>) of two big integers.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {number}    a    First Integer: a.
                 * @param   {number}    b    Second Integer: b.
                 * @return  {number}         Least common multiple <pre><code>lcm</code></pre>(a,b)
                 */
                LeastCommonMultiple$1: function (a, b) {
                    if (a === 0.0 || b === 0.0) {
                        return 0.0;
                    }

                    return Math.abs((a / MathNet.Numerics.Euclid.GreatestCommonDivisor$1(a, b) * b));
                },
                /**
                 * Returns the least common multiple (<pre><code>lcm</code></pre>) of a set of big integers.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {System.Collections.Generic.IList$1}    integers    List of Integers.
                 * @return  {number}                                            Least common multiple <pre><code>lcm</code></pre>(list of integers)
                 */
                LeastCommonMultiple: function (integers) {
                    if (null == integers) {
                        throw new System.ArgumentNullException.$ctor1("integers");
                    }

                    if (System.Array.getCount(integers, System.Double) === 0) {
                        return 1;
                    }

                    var lcm = Math.abs(System.Array.getItem(integers, 0, System.Double));

                    for (var i = 1; i < System.Array.getCount(integers, System.Double); i = (i + 1) | 0) {
                        lcm = MathNet.Numerics.Euclid.LeastCommonMultiple$1(lcm, System.Array.getItem(integers, i, System.Double));
                    }

                    return lcm;
                },
                /**
                 * Returns the least common multiple (<pre><code>lcm</code></pre>) of a set of big integers.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Euclid
                 * @memberof MathNet.Numerics.Euclid
                 * @param   {Array.<number>}    integers    List of Integers.
                 * @return  {number}                        Least common multiple <pre><code>lcm</code></pre>(list of integers)
                 */
                LeastCommonMultiple$2: function (integers) {
                    if (integers === void 0) { integers = []; }
                    return MathNet.Numerics.Euclid.LeastCommonMultiple(Bridge.cast(integers, System.Collections.Generic.IList$1(System.Double)));
                }
            }
        }
    });

    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Func
     * @param   {number}    arg1    
     * @param   {number}    arg2
     * @return  {T}
     */

    Bridge.define("MathNet.Numerics.LinearAlgebra.CreateMatrix", {
        statics: {
            methods: {
                /**
                 * Create a new matrix straight from an initialized matrix storage instance.
                 If you have an instance of a discrete storage type instead, use their direct methods instead.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                                  T          
                 * @param   {MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1}    storage
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                WithStorage: function (T, storage) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.OfStorage(storage);
                },
                /**
                 * Create a new matrix with the same kind of the provided example.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T               
                 * @param   {Function}                                   TU              
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    example         
                 * @param   {number}                                     rows            
                 * @param   {number}                                     columns         
                 * @param   {boolean}                                    fullyMutable
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SameAs$4: function (T, TU, example, rows, columns, fullyMutable) {
                    if (fullyMutable === void 0) { fullyMutable = false; }
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SameAs$4(TU, example, rows, columns, fullyMutable);
                },
                /**
                 * Create a new matrix with the same kind and dimensions of the provided example.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {Function}                                   TU         
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    example
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SameAs$3: function (T, TU, example) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SameAs$3(TU, example);
                },
                /**
                 * Create a new matrix with the same kind of the provided example.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    example    
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SameAs$2: function (T, example, rows, columns) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SameAs$2(example, rows, columns);
                },
                /**
                 * Create a new matrix with a type that can represent and is closest to both provided samples.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T               
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    example         
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    otherExample    
                 * @param   {number}                                     rows            
                 * @param   {number}                                     columns         
                 * @param   {boolean}                                    fullyMutable
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SameAs$1: function (T, example, otherExample, rows, columns, fullyMutable) {
                    if (fullyMutable === void 0) { fullyMutable = false; }
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SameAs$1(example, otherExample, rows, columns, fullyMutable);
                },
                /**
                 * Create a new matrix with a type that can represent and is closest to both provided samples and the dimensions of example.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T               
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    example         
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    otherExample
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SameAs: function (T, example, otherExample) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SameAs(example, otherExample);
                },
                /**
                 * Create a new dense matrix with values sampled from the provided random distribution.
                 * Create a new dense matrix with values sampled from the standard distribution with a system random source.
                 * Create a new positive definite dense matrix where each value is the product
                 of two samples from the standard distribution.
                 * Create a new dense matrix straight from an initialized matrix storage instance.
                 The storage is used directly without copying.
                 Intended for advanced scenarios where you're working directly with
                 storage for performance or interop reasons.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                                                  T          
                 * @param   {MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1}    storage
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Dense: function (T, storage) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Dense(storage);
                },
                /**
                 * Create a new dense matrix with the given number of rows and columns.
                 All cells of the matrix will be initialized to zero.
                 Zero-length matrices are not supported.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Dense$1: function (T, rows, columns) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Dense$1(rows, columns);
                },
                /**
                 * Create a new dense matrix with the given number of rows and columns directly binding to a raw array.
                 The array is assumed to be in column-major order (column by column) and is used directly without copying.
                 Very efficient, but changes to the array and the matrix will affect each other.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns    
                 * @param   {Array.<T>}                                  storage
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 * @see {@link }
                 */
                Dense$3: function (T, rows, columns, storage) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Dense$3(rows, columns, storage);
                },
                /**
                 * Create a new dense matrix and initialize each value to the same provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns    
                 * @param   {T}                                          value
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Dense$2: function (T, rows, columns, value) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Dense$2(rows, columns, value);
                },
                /**
                 * Create a new dense matrix and initialize each value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns    
                 * @param   {System.Func}                                init
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Dense$4: function (T, rows, columns, init) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Dense$4(rows, columns, init);
                },
                /**
                 * Create a new diagonal dense matrix and initialize each diagonal value to the same provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns    
                 * @param   {T}                                          value
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseDiagonal$1: function (T, rows, columns, value) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseDiagonal$1(rows, columns, value);
                },
                /**
                 * Create a new diagonal dense matrix and initialize each diagonal value to the same provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T        
                 * @param   {number}                                     order    
                 * @param   {T}                                          value
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseDiagonal: function (T, order, value) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseDiagonal(order, value);
                },
                /**
                 * Create a new diagonal dense matrix and initialize each diagonal value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns    
                 * @param   {System.Func}                                init
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseDiagonal$2: function (T, rows, columns, init) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseDiagonal$2(rows, columns, init);
                },
                /**
                 * Create a new diagonal dense identity matrix with a one-diagonal.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseIdentity$1: function (T, rows, columns) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseIdentity$1(rows, columns);
                },
                /**
                 * Create a new diagonal dense identity matrix with a one-diagonal.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T        
                 * @param   {number}                                     order
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseIdentity: function (T, order) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseIdentity(order);
                },
                /**
                 * Create a new dense matrix as a copy of the given other matrix.
                 This new matrix will be independent from the other matrix.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T         
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfMatrix: function (T, matrix) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfMatrix(matrix);
                },
                /**
                 * Create a new dense matrix as a copy of the given two-dimensional array.
                 This new matrix will be independent from the provided array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T        
                 * @param   {Array.<T>}                                  array
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfArray: function (T, array) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfArray(array);
                },
                /**
                 * Create a new dense matrix as a copy of the given indexed enumerable.
                 Keys must be provided at most once, zero is assumed if a key is omitted.
                 This new matrix will be independent from the enumerable.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T             
                 * @param   {number}                                      rows          
                 * @param   {number}                                      columns       
                 * @param   {System.Collections.Generic.IEnumerable$1}    enumerable
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfIndexed: function (T, rows, columns, enumerable) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfIndexed(rows, columns, enumerable);
                },
                /**
                 * Create a new dense matrix as a copy of the given enumerable.
                 The enumerable is assumed to be in column-major order (column by column).
                 This new matrix will be independent from the enumerable.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T              
                 * @param   {number}                                      rows           
                 * @param   {number}                                      columns        
                 * @param   {System.Collections.Generic.IEnumerable$1}    columnMajor
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfColumnMajor: function (T, rows, columns, columnMajor) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfColumnMajor(rows, columns, columnMajor);
                },
                /**
                 * Create a new dense matrix as a copy of the given enumerable of enumerable columns.
                 Each enumerable in the master enumerable specifies a column.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T       
                 * @param   {System.Collections.Generic.IEnumerable$1}    data
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfColumns: function (T, data) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfColumns(data);
                },
                /**
                 * Create a new dense matrix as a copy of the given enumerable of enumerable columns.
                 Each enumerable in the master enumerable specifies a column.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T          
                 * @param   {number}                                      rows       
                 * @param   {number}                                      columns    
                 * @param   {System.Collections.Generic.IEnumerable$1}    data
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfColumns$1: function (T, rows, columns, data) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfColumns$1(rows, columns, data);
                },
                /**
                 * Create a new dense matrix of T as a copy of the given column arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {Array.<Array.<T>>}                          columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfColumnArrays: function (T, columns) {
                    if (columns === void 0) { columns = []; }
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfColumnArrays(columns);
                },
                /**
                 * Create a new dense matrix of T as a copy of the given column arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T          
                 * @param   {System.Collections.Generic.IEnumerable$1}    columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfColumnArrays$1: function (T, columns) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfColumnArrays$1(columns);
                },
                /**
                 * Create a new dense matrix as a copy of the given column vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                           T          
                 * @param   {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}    columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfColumnVectors: function (T, columns) {
                    if (columns === void 0) { columns = []; }
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfColumnVectors(columns);
                },
                /**
                 * Create a new dense matrix as a copy of the given column vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T          
                 * @param   {System.Collections.Generic.IEnumerable$1}    columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfColumnVectors$1: function (T, columns) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfColumnVectors$1(columns);
                },
                /**
                 * Create a new dense matrix as a copy of the given enumerable of enumerable rows.
                 Each enumerable in the master enumerable specifies a row.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T       
                 * @param   {System.Collections.Generic.IEnumerable$1}    data
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfRows: function (T, data) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfRows(data);
                },
                /**
                 * Create a new dense matrix as a copy of the given enumerable of enumerable rows.
                 Each enumerable in the master enumerable specifies a row.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T          
                 * @param   {number}                                      rows       
                 * @param   {number}                                      columns    
                 * @param   {System.Collections.Generic.IEnumerable$1}    data
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfRows$1: function (T, rows, columns, data) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfRows$1(rows, columns, data);
                },
                /**
                 * Create a new dense matrix of T as a copy of the given row arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T       
                 * @param   {Array.<Array.<T>>}                          rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfRowArrays: function (T, rows) {
                    if (rows === void 0) { rows = []; }
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfRowArrays(rows);
                },
                /**
                 * Create a new dense matrix of T as a copy of the given row arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T       
                 * @param   {System.Collections.Generic.IEnumerable$1}    rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfRowArrays$1: function (T, rows) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfRowArrays$1(rows);
                },
                /**
                 * Create a new dense matrix as a copy of the given row vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                           T       
                 * @param   {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}    rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfRowVectors: function (T, rows) {
                    if (rows === void 0) { rows = []; }
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfRowVectors(rows);
                },
                /**
                 * Create a new dense matrix as a copy of the given row vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T       
                 * @param   {System.Collections.Generic.IEnumerable$1}    rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfRowVectors$1: function (T, rows) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfRowVectors$1(rows);
                },
                /**
                 * Create a new dense matrix with the diagonal as a copy of the given vector.
                 This new matrix will be independent from the vector.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T           
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfDiagonalVector: function (T, diagonal) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfDiagonalVector(diagonal);
                },
                /**
                 * Create a new dense matrix with the diagonal as a copy of the given vector.
                 This new matrix will be independent from the vector.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T           
                 * @param   {number}                                     rows        
                 * @param   {number}                                     columns     
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfDiagonalVector$1: function (T, rows, columns, diagonal) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfDiagonalVector$1(rows, columns, diagonal);
                },
                /**
                 * Create a new dense matrix with the diagonal as a copy of the given array.
                 This new matrix will be independent from the array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T           
                 * @param   {Array.<T>}                                  diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfDiagonalArray: function (T, diagonal) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfDiagonalArray(diagonal);
                },
                /**
                 * Create a new dense matrix with the diagonal as a copy of the given array.
                 This new matrix will be independent from the array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T           
                 * @param   {number}                                     rows        
                 * @param   {number}                                     columns     
                 * @param   {Array.<T>}                                  diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfDiagonalArray$1: function (T, rows, columns, diagonal) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfDiagonalArray$1(rows, columns, diagonal);
                },
                /**
                 * Create a new dense matrix from a 2D array of existing matrices.
                 The matrices in the array are not required to be dense already.
                 If the matrices do not align properly, they are placed on the top left
                 corner of their cell with the remaining fields left zero.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                           T           
                 * @param   {Array.<MathNet.Numerics.LinearAlgebra.Matrix$1>}    matrices
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DenseOfMatrixArray: function (T, matrices) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DenseOfMatrixArray(matrices);
                },
                /**
                 * Create a new sparse matrix straight from an initialized matrix storage instance.
                 The storage is used directly without copying.
                 Intended for advanced scenarios where you're working directly with
                 storage for performance or interop reasons.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                                                     T          
                 * @param   {MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1}    storage
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Sparse: function (T, storage) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Sparse(storage);
                },
                /**
                 * Create a sparse matrix of T with the given number of rows and columns.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       The number of rows.
                 * @param   {number}                                     columns    The number of columns.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Sparse$1: function (T, rows, columns) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Sparse$1(rows, columns);
                },
                /**
                 * Create a new sparse matrix and initialize each value to the same provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns    
                 * @param   {T}                                          value
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Sparse$2: function (T, rows, columns, value) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Sparse$2(rows, columns, value);
                },
                /**
                 * Create a new sparse matrix and initialize each value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns    
                 * @param   {System.Func}                                init
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Sparse$3: function (T, rows, columns, init) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Sparse$3(rows, columns, init);
                },
                /**
                 * Create a new diagonal sparse matrix and initialize each diagonal value to the same provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns    
                 * @param   {T}                                          value
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseDiagonal$1: function (T, rows, columns, value) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseDiagonal$1(rows, columns, value);
                },
                /**
                 * Create a new diagonal sparse matrix and initialize each diagonal value to the same provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T        
                 * @param   {number}                                     order    
                 * @param   {T}                                          value
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseDiagonal: function (T, order, value) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseDiagonal(order, value);
                },
                /**
                 * Create a new diagonal sparse matrix and initialize each diagonal value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns    
                 * @param   {System.Func}                                init
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseDiagonal$2: function (T, rows, columns, init) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseDiagonal$2(rows, columns, init);
                },
                /**
                 * Create a new diagonal dense identity matrix with a one-diagonal.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseIdentity$1: function (T, rows, columns) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseIdentity$1(rows, columns);
                },
                /**
                 * Create a new diagonal dense identity matrix with a one-diagonal.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T        
                 * @param   {number}                                     order
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseIdentity: function (T, order) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseIdentity(order);
                },
                /**
                 * Create a new sparse matrix as a copy of the given other matrix.
                 This new matrix will be independent from the other matrix.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T         
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfMatrix: function (T, matrix) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfMatrix(matrix);
                },
                /**
                 * Create a new sparse matrix as a copy of the given two-dimensional array.
                 This new matrix will be independent from the provided array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T        
                 * @param   {Array.<T>}                                  array
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfArray: function (T, array) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfArray(array);
                },
                /**
                 * Create a new sparse matrix as a copy of the given indexed enumerable.
                 Keys must be provided at most once, zero is assumed if a key is omitted.
                 This new matrix will be independent from the enumerable.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T             
                 * @param   {number}                                      rows          
                 * @param   {number}                                      columns       
                 * @param   {System.Collections.Generic.IEnumerable$1}    enumerable
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfIndexed: function (T, rows, columns, enumerable) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfIndexed(rows, columns, enumerable);
                },
                /**
                 * Create a new sparse matrix as a copy of the given enumerable.
                 The enumerable is assumed to be in row-major order (row by row).
                 This new matrix will be independent from the enumerable.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T           
                 * @param   {number}                                      rows        
                 * @param   {number}                                      columns     
                 * @param   {System.Collections.Generic.IEnumerable$1}    rowMajor
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 * @see {@link }
                 */
                SparseOfRowMajor: function (T, rows, columns, rowMajor) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfRowMajor(rows, columns, rowMajor);
                },
                /**
                 * Create a new sparse matrix with the given number of rows and columns as a copy of the given array.
                 The array is assumed to be in column-major order (column by column).
                 This new matrix will be independent from the provided array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T              
                 * @param   {number}                                     rows           
                 * @param   {number}                                     columns        
                 * @param   {System.Collections.Generic.IList$1}         columnMajor
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 * @see {@link }
                 */
                SparseOfColumnMajor: function (T, rows, columns, columnMajor) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfColumnMajor(rows, columns, columnMajor);
                },
                /**
                 * Create a new sparse matrix as a copy of the given enumerable of enumerable columns.
                 Each enumerable in the master enumerable specifies a column.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T       
                 * @param   {System.Collections.Generic.IEnumerable$1}    data
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfColumns: function (T, data) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfColumns(data);
                },
                /**
                 * Create a new sparse matrix as a copy of the given enumerable of enumerable columns.
                 Each enumerable in the master enumerable specifies a column.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T          
                 * @param   {number}                                      rows       
                 * @param   {number}                                      columns    
                 * @param   {System.Collections.Generic.IEnumerable$1}    data
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfColumns$1: function (T, rows, columns, data) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfColumns$1(rows, columns, data);
                },
                /**
                 * Create a new sparse matrix as a copy of the given column arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {Array.<Array.<T>>}                          columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfColumnArrays: function (T, columns) {
                    if (columns === void 0) { columns = []; }
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfColumnArrays(columns);
                },
                /**
                 * Create a new sparse matrix as a copy of the given column arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T          
                 * @param   {System.Collections.Generic.IEnumerable$1}    columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfColumnArrays$1: function (T, columns) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfColumnArrays$1(columns);
                },
                /**
                 * Create a new sparse matrix as a copy of the given column vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                           T          
                 * @param   {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}    columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfColumnVectors: function (T, columns) {
                    if (columns === void 0) { columns = []; }
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfColumnVectors(columns);
                },
                /**
                 * Create a new sparse matrix as a copy of the given column vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T          
                 * @param   {System.Collections.Generic.IEnumerable$1}    columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfColumnVectors$1: function (T, columns) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfColumnVectors$1(columns);
                },
                /**
                 * Create a new sparse matrix as a copy of the given enumerable of enumerable rows.
                 Each enumerable in the master enumerable specifies a row.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T       
                 * @param   {System.Collections.Generic.IEnumerable$1}    data
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfRows: function (T, data) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfRows(data);
                },
                /**
                 * Create a new sparse matrix as a copy of the given enumerable of enumerable rows.
                 Each enumerable in the master enumerable specifies a row.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T          
                 * @param   {number}                                      rows       
                 * @param   {number}                                      columns    
                 * @param   {System.Collections.Generic.IEnumerable$1}    data
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfRows$1: function (T, rows, columns, data) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfRows$1(rows, columns, data);
                },
                /**
                 * Create a new sparse matrix as a copy of the given row arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T       
                 * @param   {Array.<Array.<T>>}                          rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfRowArrays: function (T, rows) {
                    if (rows === void 0) { rows = []; }
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfRowArrays(rows);
                },
                /**
                 * Create a new sparse matrix as a copy of the given row arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T       
                 * @param   {System.Collections.Generic.IEnumerable$1}    rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfRowArrays$1: function (T, rows) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfRowArrays$1(rows);
                },
                /**
                 * Create a new sparse matrix as a copy of the given row vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                           T       
                 * @param   {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}    rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfRowVectors: function (T, rows) {
                    if (rows === void 0) { rows = []; }
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfRowVectors(rows);
                },
                /**
                 * Create a new sparse matrix as a copy of the given row vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                    T       
                 * @param   {System.Collections.Generic.IEnumerable$1}    rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfRowVectors$1: function (T, rows) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfRowVectors$1(rows);
                },
                /**
                 * Create a new sparse matrix with the diagonal as a copy of the given vector.
                 This new matrix will be independent from the vector.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T           
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfDiagonalVector: function (T, diagonal) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfDiagonalVector(diagonal);
                },
                /**
                 * Create a new sparse matrix with the diagonal as a copy of the given vector.
                 This new matrix will be independent from the vector.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T           
                 * @param   {number}                                     rows        
                 * @param   {number}                                     columns     
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfDiagonalVector$1: function (T, rows, columns, diagonal) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfDiagonalVector$1(rows, columns, diagonal);
                },
                /**
                 * Create a new sparse matrix with the diagonal as a copy of the given array.
                 This new matrix will be independent from the array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T           
                 * @param   {Array.<T>}                                  diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfDiagonalArray: function (T, diagonal) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfDiagonalArray(diagonal);
                },
                /**
                 * Create a new sparse matrix with the diagonal as a copy of the given array.
                 This new matrix will be independent from the array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T           
                 * @param   {number}                                     rows        
                 * @param   {number}                                     columns     
                 * @param   {Array.<T>}                                  diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfDiagonalArray$1: function (T, rows, columns, diagonal) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfDiagonalArray$1(rows, columns, diagonal);
                },
                /**
                 * Create a new sparse matrix from a 2D array of existing matrices.
                 The matrices in the array are not required to be sparse already.
                 If the matrices do not align properly, they are placed on the top left
                 corner of their cell with the remaining fields left zero.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                           T           
                 * @param   {Array.<MathNet.Numerics.LinearAlgebra.Matrix$1>}    matrices
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                SparseOfMatrixArray: function (T, matrices) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.SparseOfMatrixArray(matrices);
                },
                /**
                 * Create a new diagonal matrix straight from an initialized matrix storage instance.
                 The storage is used directly without copying.
                 Intended for advanced scenarios where you're working directly with
                 storage for performance or interop reasons.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                                          T          
                 * @param   {MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1}    storage
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Diagonal$1: function (T, storage) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Diagonal$1(storage);
                },
                /**
                 * Create a new diagonal matrix with the given number of rows and columns.
                 All cells of the matrix will be initialized to zero.
                 Zero-length matrices are not supported.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Diagonal$2: function (T, rows, columns) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Diagonal$2(rows, columns);
                },
                /**
                 * Create a new diagonal matrix with the given number of rows and columns directly binding to a raw array.
                 The array is assumed to represent the diagonal values and is used directly without copying.
                 Very efficient, but changes to the array and the matrix will affect each other.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns    
                 * @param   {Array.<T>}                                  storage
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Diagonal$4: function (T, rows, columns, storage) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Diagonal$4(rows, columns, storage);
                },
                /**
                 * Create a new square diagonal matrix directly binding to a raw array.
                 The array is assumed to represent the diagonal values and is used directly without copying.
                 Very efficient, but changes to the array and the matrix will affect each other.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {Array.<T>}                                  storage
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Diagonal: function (T, storage) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Diagonal(storage);
                },
                /**
                 * Create a new diagonal matrix and initialize each diagonal value to the same provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns    
                 * @param   {T}                                          value
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Diagonal$3: function (T, rows, columns, value) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Diagonal$3(rows, columns, value);
                },
                /**
                 * Create a new diagonal matrix and initialize each diagonal value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns    
                 * @param   {System.Func}                                init
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Diagonal$5: function (T, rows, columns, init) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.Diagonal$5(rows, columns, init);
                },
                /**
                 * Create a new diagonal identity matrix with a one-diagonal.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T          
                 * @param   {number}                                     rows       
                 * @param   {number}                                     columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DiagonalIdentity$1: function (T, rows, columns) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DiagonalIdentity$1(rows, columns);
                },
                /**
                 * Create a new diagonal identity matrix with a one-diagonal.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T        
                 * @param   {number}                                     order
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DiagonalIdentity: function (T, order) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DiagonalIdentity(order);
                },
                /**
                 * Create a new diagonal matrix with the diagonal as a copy of the given vector.
                 This new matrix will be independent from the vector.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T           
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DiagonalOfDiagonalVector: function (T, diagonal) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DiagonalOfDiagonalVector(diagonal);
                },
                /**
                 * Create a new diagonal matrix with the diagonal as a copy of the given vector.
                 This new matrix will be independent from the vector.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T           
                 * @param   {number}                                     rows        
                 * @param   {number}                                     columns     
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DiagonalOfDiagonalVector$1: function (T, rows, columns, diagonal) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DiagonalOfDiagonalVector$1(rows, columns, diagonal);
                },
                /**
                 * Create a new diagonal matrix with the diagonal as a copy of the given array.
                 This new matrix will be independent from the array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T           
                 * @param   {Array.<T>}                                  diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DiagonalOfDiagonalArray: function (T, diagonal) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DiagonalOfDiagonalArray(diagonal);
                },
                /**
                 * Create a new diagonal matrix with the diagonal as a copy of the given array.
                 This new matrix will be independent from the array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateMatrix
                 * @param   {Function}                                   T           
                 * @param   {number}                                     rows        
                 * @param   {number}                                     columns     
                 * @param   {Array.<T>}                                  diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                DiagonalOfDiagonalArray$1: function (T, rows, columns, diagonal) {
                    var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
                    return m_builder.DiagonalOfDiagonalArray$1(rows, columns, diagonal);
                }
            }
        }
    });

    Bridge.define("MathNet.Numerics.LinearAlgebra.CreateVector", {
        statics: {
            methods: {
                /**
                 * Create a new vector straight from an initialized matrix storage instance.
                 If you have an instance of a discrete storage type instead, use their direct methods instead.
                 * Create a new vector with the same kind of the provided example.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T          
                 * @param   {Function}                                   TU         
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    example    
                 * @param   {number}                                     length
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                SameAs$5: function (T, TU, example, length) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;
                    return v_builder.SameAs$5(TU, example, length);
                },
                /**
                 * Create a new vector with the same kind and dimension of the provided example.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T          
                 * @param   {Function}                                   TU         
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    example
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                SameAs$4: function (T, TU, example) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;
                    return v_builder.SameAs$4(TU, example);
                },
                /**
                 * Create a new vector with the same kind of the provided example.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T          
                 * @param   {Function}                                   TU         
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    example    
                 * @param   {number}                                     length
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                SameAs$3: function (T, TU, example, length) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.SameAs$3(TU, example, length);
                },
                /**
                 * Create a new vector with a type that can represent and is closest to both provided samples.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T               
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    example         
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    otherExample    
                 * @param   {number}                                     length
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                SameAs$2: function (T, example, otherExample, length) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.SameAs$2(example, otherExample, length);
                },
                /**
                 * Create a new vector with a type that can represent and is closest to both provided samples and the dimensions of example.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T               
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    example         
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    otherExample
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                SameAs$1: function (T, example, otherExample) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.SameAs$1(example, otherExample);
                },
                /**
                 * Create a new vector with a type that can represent and is closest to both provided samples.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T         
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix    
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector    
                 * @param   {number}                                     length
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                SameAs: function (T, matrix, vector, length) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.SameAs(matrix, vector, length);
                },
                /**
                 * Create a new dense vector with values sampled from the provided random distribution.
                 * Create a new dense vector with values sampled from the standard distribution with a system random source.
                 * Create a new dense vector with values sampled from the standard distribution with a system random source.
                 * Create a new dense vector straight from an initialized vector storage instance.
                 The storage is used directly without copying.
                 Intended for advanced scenarios where you're working directly with
                 storage for performance or interop reasons.
                 * Create a dense vector of T with the given size.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T       
                 * @param   {number}                                     size    The size of the vector.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Dense$1: function (T, size) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.Dense$2(size);
                },
                /**
                 * Create a dense vector of T that is directly bound to the specified array.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T        
                 * @param   {Array.<T>}                                  array
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Dense: function (T, array) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.Dense(array);
                },
                /**
                 * Create a new dense vector and initialize each value using the provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T         
                 * @param   {number}                                     length    
                 * @param   {T}                                          value
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Dense$2: function (T, length, value) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.Dense$3(length, value);
                },
                /**
                 * Create a new dense vector and initialize each value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T         
                 * @param   {number}                                     length    
                 * @param   {System.Func}                                init
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Dense$3: function (T, length, init) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.Dense$4(length, init);
                },
                /**
                 * Create a new dense vector as a copy of the given other vector.
                 This new vector will be independent from the other vector.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T         
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                DenseOfVector: function (T, vector) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.DenseOfVector(vector);
                },
                /**
                 * Create a new dense vector as a copy of the given array.
                 This new vector will be independent from the array.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T        
                 * @param   {Array.<T>}                                  array
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                DenseOfArray: function (T, array) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.DenseOfArray(array);
                },
                /**
                 * Create a new dense vector as a copy of the given enumerable.
                 This new vector will be independent from the enumerable.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                    T             
                 * @param   {System.Collections.Generic.IEnumerable$1}    enumerable
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                DenseOfEnumerable: function (T, enumerable) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.DenseOfEnumerable(enumerable);
                },
                /**
                 * Create a new dense vector as a copy of the given indexed enumerable.
                 Keys must be provided at most once, zero is assumed if a key is omitted.
                 This new vector will be independent from the enumerable.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                    T             
                 * @param   {number}                                      length        
                 * @param   {System.Collections.Generic.IEnumerable$1}    enumerable
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                DenseOfIndexed: function (T, length, enumerable) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.DenseOfIndexed(length, enumerable);
                },
                /**
                 * Create a new sparse vector straight from an initialized vector storage instance.
                 The storage is used directly without copying.
                 Intended for advanced scenarios where you're working directly with
                 storage for performance or interop reasons.
                 * Create a sparse vector of T with the given size.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T       
                 * @param   {number}                                     size    The size of the vector.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Sparse: function (T, size) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.Sparse$1(size);
                },
                /**
                 * Create a new sparse vector and initialize each value using the provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T         
                 * @param   {number}                                     length    
                 * @param   {T}                                          value
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Sparse$1: function (T, length, value) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.Sparse$2(length, value);
                },
                /**
                 * Create a new sparse vector and initialize each value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T         
                 * @param   {number}                                     length    
                 * @param   {System.Func}                                init
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Sparse$2: function (T, length, init) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.Sparse$3(length, init);
                },
                /**
                 * Create a new sparse vector as a copy of the given other vector.
                 This new vector will be independent from the other vector.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T         
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                SparseOfVector: function (T, vector) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.SparseOfVector(vector);
                },
                /**
                 * Create a new sparse vector as a copy of the given array.
                 This new vector will be independent from the array.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                   T        
                 * @param   {Array.<T>}                                  array
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                SparseOfArray: function (T, array) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.SparseOfArray(array);
                },
                /**
                 * Create a new sparse vector as a copy of the given enumerable.
                 This new vector will be independent from the enumerable.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                    T             
                 * @param   {System.Collections.Generic.IEnumerable$1}    enumerable
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                SparseOfEnumerable: function (T, enumerable) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.SparseOfEnumerable(enumerable);
                },
                /**
                 * Create a new sparse vector as a copy of the given indexed enumerable.
                 Keys must be provided at most once, zero is assumed if a key is omitted.
                 This new vector will be independent from the enumerable.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.CreateVector
                 * @memberof MathNet.Numerics.LinearAlgebra.CreateVector
                 * @param   {Function}                                    T             
                 * @param   {number}                                      length        
                 * @param   {System.Collections.Generic.IEnumerable$1}    enumerable
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                SparseOfIndexed: function (T, length, enumerable) {
                    var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;

                    return v_builder.SparseOfIndexed(length, enumerable);
                }
            }
        }
    });

    /**
     * @memberof System
     * @callback System.Action
     * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    arg
     * @return  {void}
     */

    /** @namespace MathNet.Numerics.LinearAlgebra */

    /**
     * Defines the base class for <pre><code>Matrix</code></pre> classes.
     *
     * @abstract
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Matrix$1
     * @implements  System.IFormattable
     * @implements  System.IEquatable$1
     * @implements  System.ICloneable
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Matrix$1", function (T) { return {
        inherits: function () { return [System.IFormattable,System.IEquatable$1(MathNet.Numerics.LinearAlgebra.Matrix$1(T)),System.ICloneable]; },
        statics: {
            fields: {
                /**
                 * The value of 1.0.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @type T
                 */
                One: null,
                /**
                 * The value of 0.0.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @type T
                 */
                Zero: null
            },
            ctors: {
                init: function () {
                    this.One = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix.One;
                    this.Zero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix.Zero;
                }
            },
            methods: {
                IntPower: function (exponent, x, y, work) {


                    if (exponent === 1) {
                        if (y == null) {
                            return x;
                        }

                        if (work == null) {
                            work = y.Multiply$1(x);
                        } else {
                            y.Multiply$4(x, work);
                        }
                        return work;
                    }

                    if (exponent === 2) {
                        if (work == null) {
                            work = x.Multiply$1(x);
                        } else {
                            x.Multiply$4(x, work);
                        }

                        if (y == null) {
                            return work;
                        }

                        y.Multiply$4(work, x);
                        return x;
                    }

                    if (MathNet.Numerics.Euclid.IsEven(exponent)) {
                        if (work == null) {
                            work = x.Multiply$1(x);
                        } else {
                            x.Multiply$4(x, work);
                        }
                        return MathNet.Numerics.LinearAlgebra.Matrix$1(T).IntPower(((Bridge.Int.div(exponent, 2)) | 0), work, y, x);
                    }

                    if (y == null) {
                        if (work == null) {
                            work = x.Multiply$1(x);
                        } else {
                            x.Multiply$4(x, work);
                        }
                        return MathNet.Numerics.LinearAlgebra.Matrix$1(T).IntPower(((Bridge.Int.div((((exponent - 1) | 0)), 2)) | 0), work, x, null);
                    }

                    if (work == null) {
                        work = y.Multiply$1(x);
                    } else {
                        y.Multiply$4(x, work);
                    }
                    x.Multiply$4(x, y);
                    return MathNet.Numerics.LinearAlgebra.Matrix$1(T).IntPower(((Bridge.Int.div((((exponent - 1) | 0)), 2)) | 0), y, work, x);
                },
                DimensionsDontMatch$1: function (TException, left, right, result, paramName) {
                    if (paramName === void 0) { paramName = null; }
                    var message = System.String.format("Resources.ArgumentMatrixDimensions3", left.RowCount + "x" + left.ColumnCount, right.RowCount + "x" + right.ColumnCount, result.RowCount + "x" + result.ColumnCount);
                    return MathNet.Numerics.LinearAlgebra.Matrix$1(T).CreateException(TException, message, paramName);
                },
                DimensionsDontMatch$2: function (TException, left, right, paramName) {
                    if (paramName === void 0) { paramName = null; }
                    var message = System.String.format("Resources.ArgumentMatrixDimensions2", left.RowCount + "x" + left.ColumnCount, right.RowCount + "x" + right.ColumnCount);
                    return MathNet.Numerics.LinearAlgebra.Matrix$1(T).CreateException(TException, message, paramName);
                },
                DimensionsDontMatch: function (TException, matrix) {
                    var message = System.String.format("Resources.ArgumentMatrixDimensions1", [matrix.RowCount + "x" + matrix.ColumnCount]);
                    return MathNet.Numerics.LinearAlgebra.Matrix$1(T).CreateException(TException, message);
                },
                DimensionsDontMatch$3: function (TException, left, right, result, paramName) {
                    if (paramName === void 0) { paramName = null; }
                    return MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(TException, left, right.ToColumnMatrix(), result.ToColumnMatrix(), paramName);
                },
                DimensionsDontMatch$4: function (TException, left, right, paramName) {
                    if (paramName === void 0) { paramName = null; }
                    return MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(TException, left, right.ToColumnMatrix(), paramName);
                },
                DimensionsDontMatch$5: function (TException, left, right, paramName) {
                    if (paramName === void 0) { paramName = null; }
                    return MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(TException, left.ToColumnMatrix(), right, paramName);
                },
                DimensionsDontMatch$6: function (TException, left, right, paramName) {
                    if (paramName === void 0) { paramName = null; }
                    return MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(TException, left.ToColumnMatrix(), right.ToColumnMatrix(), paramName);
                },
                CreateException: function (TException, message, paramName) {
                    if (paramName === void 0) { paramName = null; }
                    if (Bridge.referenceEquals(TException, System.ArgumentException)) {
                        return new System.ArgumentException.$ctor3(message, paramName);
                    }
                    if (Bridge.referenceEquals(TException, System.ArgumentOutOfRangeException)) {
                        return new System.ArgumentOutOfRangeException.$ctor4(paramName, message);
                    }
                    return new System.Exception(message);
                },
                FormatStringArrayToString: function (array, columnSeparator, rowSeparator) {
                    var rows = System.Array.getLength(array, 0);
                    var cols = System.Array.getLength(array, 1);

                    var widths = System.Array.init(cols, 0, System.Int32);
                    for (var i = 0; i < rows; i = (i + 1) | 0) {
                        for (var j = 0; j < cols; j = (j + 1) | 0) {
                            widths[System.Array.index(j, widths)] = Math.max(widths[System.Array.index(j, widths)], array.get([i, j]).length);
                        }
                    }

                    var sb = new System.Text.StringBuilder();
                    for (var i1 = 0; i1 < rows; i1 = (i1 + 1) | 0) {
                        sb.append(System.String.alignString(array.get([i1, 0]), widths[System.Array.index(0, widths)]));
                        for (var j1 = 1; j1 < cols; j1 = (j1 + 1) | 0) {
                            sb.append(columnSeparator);
                            sb.append(System.String.alignString(array.get([i1, j1]), widths[System.Array.index(j1, widths)]));
                        }
                        sb.append(rowSeparator);
                    }
                    return sb.toString();
                },
                op_DotMultiply: function (x, y) {
                    return x.PointwiseMultiply(y);
                },
                op_DotDivide: function (dividend, divisor) {
                    return dividend.PointwiseDivide(divisor);
                },
                op_DotPercent: function (dividend, divisor) {
                    return dividend.PointwiseRemainder(divisor);
                },
                op_DotHat$1: function (matrix, exponent) {
                    return matrix.PointwisePower$1(exponent);
                },
                op_DotHat: function (matrix, exponent) {
                    return matrix.PointwisePower(exponent);
                },
                /**
                 * Computes the sqrt of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Sqrt: function (x) {
                    return x.PointwiseSqrt();
                },
                /**
                 * Computes the exponential of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Exp: function (x) {
                    return x.PointwiseExp();
                },
                /**
                 * Computes the log of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Log: function (x) {
                    return x.PointwiseLog();
                },
                /**
                 * Computes the log10 of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Log10: function (x) {
                    return x.PointwiseLog10();
                },
                /**
                 * Computes the sin of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Sin: function (x) {
                    return x.PointwiseSin();
                },
                /**
                 * Computes the cos of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Cos: function (x) {
                    return x.PointwiseCos();
                },
                /**
                 * Computes the tan of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Tan: function (x) {
                    return x.PointwiseTan();
                },
                /**
                 * Computes the asin of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Asin: function (x) {
                    return x.PointwiseAsin();
                },
                /**
                 * Computes the acos of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Acos: function (x) {
                    return x.PointwiseAcos();
                },
                /**
                 * Computes the atan of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Atan: function (x) {
                    return x.PointwiseAtan();
                },
                /**
                 * Computes the sinh of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Sinh: function (x) {
                    return x.PointwiseSinh();
                },
                /**
                 * Computes the cosh of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Cosh: function (x) {
                    return x.PointwiseCosh();
                },
                /**
                 * Computes the tanh of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Tanh: function (x) {
                    return x.PointwiseTanh();
                },
                /**
                 * Computes the absolute value of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Abs: function (x) {
                    return x.PointwiseAbs();
                },
                /**
                 * Computes the floor of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Floor: function (x) {
                    return x.PointwiseFloor();
                },
                /**
                 * Computes the ceiling of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Ceiling: function (x) {
                    return x.PointwiseCeiling();
                },
                /**
                 * Computes the rounded value of a matrix pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    x    The input matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Round: function (x) {
                    return x.PointwiseRound();
                }/**
                 * Returns a <strong>Matrix</strong> containing the same values of <b />.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    rightSide    The matrix to get the values from.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                 A matrix containing a the same values as <b />.
                 */
                ,
                op_UnaryPlus: function (rightSide) {
                    return rightSide.Clone();
                }/**
                 * Negates each element of the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    rightSide    The matrix to negate.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                 A matrix containing the negated values.
                 */
                ,
                op_UnaryNegation: function (rightSide) {
                    return rightSide.Negate();
                }/**
                 * Adds two matrices together and returns the results.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> and <b /> don't have the same dimensions.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    leftSide     The left matrix to add.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    rightSide    The right matrix to add.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                 The result of the addition.
                 */
                ,
                op_Addition$2: function (leftSide, rightSide) {
                    return leftSide.Add$1(rightSide);
                }/**
                 * Adds a scalar to each element of the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    leftSide     The left matrix to add.
                 * @param   {T}                                          rightSide    The scalar value to add.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                 The result of the addition.
                 */
                ,
                op_Addition$1: function (leftSide, rightSide) {
                    return leftSide.Add(rightSide);
                }/**
                 * Adds a scalar to each element of the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {T}                                          leftSide     The scalar value to add.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    rightSide    The right matrix to add.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                 The result of the addition.
                 */
                ,
                op_Addition: function (leftSide, rightSide) {
                    return rightSide.Add(leftSide);
                }/**
                 * Subtracts two matrices together and returns the results.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> and <b /> don't have the same dimensions.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    leftSide     The left matrix to subtract.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    rightSide    The right matrix to subtract.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                 The result of the subtraction.
                 */
                ,
                op_Subtraction$2: function (leftSide, rightSide) {
                    return leftSide.Subtract$1(rightSide);
                }/**
                 * Subtracts a scalar from each element of a matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> and <b /> don't have the same dimensions.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    leftSide     The left matrix to subtract.
                 * @param   {T}                                          rightSide    The scalar value to subtract.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                 The result of the subtraction.
                 */
                ,
                op_Subtraction$1: function (leftSide, rightSide) {
                    return leftSide.Subtract(rightSide);
                }/**
                 * Subtracts each element of a matrix from a scalar.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> and <b /> don't have the same dimensions.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {T}                                          leftSide     The scalar value to subtract.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    rightSide    The right matrix to subtract.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                 The result of the subtraction.
                 */
                ,
                op_Subtraction: function (leftSide, rightSide) {
                    return rightSide.SubtractFrom(leftSide);
                }/**
                 * Multiplies a <strong>Matrix</strong> by a constant and returns the result.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    leftSide     The matrix to multiply.
                 * @param   {T}                                          rightSide    The constant to multiply the matrix by.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                 The result of the multiplication.
                 */
                ,
                op_Multiply$1: function (leftSide, rightSide) {
                    return leftSide.Multiply(rightSide);
                }/**
                 * Multiplies a <strong>Matrix</strong> by a constant and returns the result.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {T}                                          leftSide     The matrix to multiply.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    rightSide    The constant to multiply the matrix by.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                 The result of the multiplication.
                 */
                ,
                op_Multiply: function (leftSide, rightSide) {
                    return rightSide.Multiply(leftSide);
                }/**
                 * Multiplies two matrices.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @throws If the dimensions of <b /> or <b /> don't conform.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    leftSide     The left matrix to multiply.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    rightSide    The right matrix to multiply.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                 The result of multiplication.
                 */
                ,
                op_Multiply$2: function (leftSide, rightSide) {
                    return leftSide.Multiply$1(rightSide);
                }/**
                 * Multiplies a <strong>Matrix</strong> and a Vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    leftSide     The matrix to multiply.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 The result of multiplication.
                 */
                ,
                op_Multiply$3: function (leftSide, rightSide) {
                    return leftSide.Multiply$2(rightSide);
                }/**
                 * Multiplies a Vector and a <strong>Matrix</strong>.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    leftSide     The vector to multiply.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    rightSide    The matrix to multiply.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 The result of multiplication.
                 */
                ,
                op_Multiply$4: function (leftSide, rightSide) {
                    return rightSide.LeftMultiply(leftSide);
                }/**
                 * Divides a scalar with a matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {T}                                          dividend    The scalar to divide.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor     The matrix.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                The result of the division.
                 */
                ,
                op_Division: function (dividend, divisor) {
                    return divisor.DivideByThis(dividend);
                }/**
                 * Divides a matrix with a scalar.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    dividend    The matrix to divide.
                 * @param   {T}                                          divisor     The scalar value.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                The result of the division.
                 */
                ,
                op_Division$1: function (dividend, divisor) {
                    return dividend.Divide(divisor);
                }/**
                 * Computes the pointwise remainder (% operator), where the result has the sign of the dividend,
                 of each element of the matrix of the given divisor.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    dividend    The matrix whose elements we want to compute the modulus of.
                 * @param   {T}                                          divisor     The divisor to use.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                The result of the calculation
                 */
                ,
                op_Modulus$1: function (dividend, divisor) {
                    return dividend.Remainder(divisor);
                }/**
                 * Computes the pointwise remainder (% operator), where the result has the sign of the dividend,
                 of the given dividend of each element of the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {T}                                          dividend    The dividend we want to compute the modulus of.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor     The matrix whose elements we want to use as divisor.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                The result of the calculation
                 */
                ,
                op_Modulus: function (dividend, divisor) {
                    return divisor.RemainderByThis(dividend);
                }/**
                 * Computes the pointwise remainder (% operator), where the result has the sign of the dividend,
                 of each element of two matrices.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
                 * @throws If <b /> and <b /> are not the same size.
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    dividend    The matrix whose elements we want to compute the remainder of.
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor     The divisor to use.
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                ,
                op_Modulus$2: function (dividend, divisor) {
                    return dividend.PointwiseRemainder(divisor);
                }
            }
        },
        fields: {
            v_builder: null,
            m_builder: null,
            /**
             * Gets the raw matrix data storage.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @function Storage
             * @type MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             */
            Storage: null,
            /**
             * Gets the number of columns.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @function ColumnCount
             * @type number
             */
            ColumnCount: 0,
            /**
             * Gets the number of rows.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @function RowCount
             * @type number
             */
            RowCount: 0
        },
        alias: [
            "equalsT", "System$IEquatable$1$MathNet$Numerics$LinearAlgebra$Matrix$1$" + Bridge.getTypeAlias(T) + "$equalsT",
            "format", "System$IFormattable$format"
        ],
        ctors: {
            init: function () {
                this.v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;
                this.m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
            },
            /**
             * Initializes a new instance of the Matrix class.
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1}    storage
             * @return  {void}
             */
            ctor: function (storage) {
                this.$initialize();
                this.Storage = storage;
                this.RowCount = storage.RowCount;
                this.ColumnCount = storage.ColumnCount;
            }
        },
        methods: {
            /**
             * Gets or sets the value at the given row and column, with range checking.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}    row       The row of the element.
             * @param   {number}    column    The column of the element.
             * @return  {T}
             */
            getItem: function (row, column) {
                return this.Storage.getItem(row, column);
            },
            /**
             * Gets or sets the value at the given row and column, with range checking.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}    row       The row of the element.
             * @param   {number}    column    The column of the element.
             * @param   {T}         value     The value to get or set.
             * @return  {void}
             */
            setItem: function (row, column, value) {
                this.Storage.setItem(row, column, value);
            },
            /**
             * Subtracts each element of the matrix from a scalar and stores the result in the result matrix.
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          scalar    The scalar to subtract from.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the subtraction.
             * @return  {void}
             */
            DoSubtractFrom: function (scalar, result) {
                this.DoNegate(result);
                result.DoAdd(scalar, result);
            },
            /**
             * Adds a scalar to each element of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the two matrices don't have the same dimensions.
             * @param   {T}                                          scalar    The scalar to add.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}              The result of the addition.
             */
            Add: function (scalar) {
                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Matrix$1(T).Zero)) {
                    return this.Clone();
                }

                var result = this.m_builder.SameAs$3(T, this);
                this.DoAdd(scalar, result);
                return result;
            },
            /**
             * Adds a scalar to each element of the matrix and stores the result in the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the two matrices don't have the same dimensions.
             * @param   {T}                                          scalar    The scalar to add.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the addition.
             * @return  {void}
             */
            Add$2: function (scalar, result) {
                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentOutOfRangeException, this, result, "result");
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Matrix$1(T).Zero)) {
                    this.CopyTo(result);
                    return;
                }

                this.DoAdd(scalar, result);
            },
            /**
             * Adds another matrix to this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the two matrices don't have the same dimensions.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The matrix to add to this matrix.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The result of the addition.
             */
            Add$1: function (other) {
                if (other.RowCount !== this.RowCount || other.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentOutOfRangeException, this, other);
                }

                var result = this.m_builder.SameAs$1(this, other, this.RowCount, this.ColumnCount);
                this.DoAdd$1(other, result);
                return result;
            },
            /**
             * Adds another matrix to this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the two matrices don't have the same dimensions.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to add to this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the addition.
             * @return  {void}
             */
            Add$3: function (other, result) {
                if (other.RowCount !== this.RowCount || other.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentOutOfRangeException, this, other, "other");
                }

                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentOutOfRangeException, this, result, "result");
                }

                this.DoAdd$1(other, result);
            },
            /**
             * Subtracts a scalar from each element of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          scalar    The scalar to subtract.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}              A new matrix containing the subtraction of this matrix and the scalar.
             */
            Subtract: function (scalar) {
                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Matrix$1(T).Zero)) {
                    return this.Clone();
                }

                var result = this.m_builder.SameAs$3(T, this);
                this.DoSubtract(scalar, result);
                return result;
            },
            /**
             * Subtracts a scalar from each element of the matrix and stores the result in the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar to subtract.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the subtraction.
             * @return  {void}
             */
            Subtract$2: function (scalar, result) {
                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentOutOfRangeException, this, result, "result");
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Matrix$1(T).Zero)) {
                    this.CopyTo(result);
                    return;
                }

                this.DoSubtract(scalar, result);
            },
            /**
             * Subtracts another matrix from this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the two matrices don't have the same dimensions.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The matrix to subtract.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The result of the subtraction.
             */
            Subtract$1: function (other) {
                if (other.RowCount !== this.RowCount || other.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentOutOfRangeException, this, other);
                }

                var result = this.m_builder.SameAs$1(this, other, this.RowCount, this.ColumnCount);
                this.DoSubtract$1(other, result);
                return result;
            },
            /**
             * Subtracts another matrix from this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the two matrices don't have the same dimensions.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to subtract.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the subtraction.
             * @return  {void}
             */
            Subtract$3: function (other, result) {
                if (other.RowCount !== this.RowCount || other.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentOutOfRangeException, this, other, "other");
                }

                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentOutOfRangeException, this, result, "result");
                }

                this.DoSubtract$1(other, result);
            },
            /**
             * Subtracts each element of the matrix from a scalar.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          scalar    The scalar to subtract from.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}              A new matrix containing the subtraction of the scalar and this matrix.
             */
            SubtractFrom: function (scalar) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoSubtractFrom(scalar, result);
                return result;
            },
            /**
             * Subtracts each element of the matrix from a scalar and stores the result in the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar to subtract from.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the subtraction.
             * @return  {void}
             */
            SubtractFrom$1: function (scalar, result) {
                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentOutOfRangeException, this, result, "result");
                }

                this.DoSubtractFrom(scalar, result);
            },
            /**
             * Multiplies each element of this matrix with a scalar.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          scalar    The scalar to multiply with.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}              The result of the multiplication.
             */
            Multiply: function (scalar) {
                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Matrix$1(T).One)) {
                    return this.Clone();
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Matrix$1(T).Zero)) {
                    return this.m_builder.SameAs$3(T, this);
                }

                var result = this.m_builder.SameAs$3(T, this);
                this.DoMultiply(scalar, result);
                return result;
            },
            /**
             * Multiplies each element of the matrix by a scalar and places results into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {T}                                          scalar    The scalar to multiply the matrix with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the multiplication.
             * @return  {void}
             */
            Multiply$3: function (scalar, result) {
                if (result.RowCount !== this.RowCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameRowDimension", "result");
                }

                if (result.ColumnCount !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameColumnDimension", "result");
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Matrix$1(T).One)) {
                    this.CopyTo(result);
                    return;
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Matrix$1(T).Zero)) {
                    result.Clear();
                    return;
                }

                this.DoMultiply(scalar, result);
            },
            /**
             * Multiplies this matrix by a vector and returns the result.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <pre><code>this.ColumnCount != rightSide.Count</code></pre>.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 The result of the multiplication.
             */
            Multiply$2: function (rightSide) {
                if (this.ColumnCount !== rightSide.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$4(System.ArgumentException, this, rightSide, "rightSide");
                }

                var ret = this.v_builder.SameAs(this, rightSide, this.RowCount);
                this.DoMultiply$2(rightSide, ret);
                return ret;
            },
            /**
             * Multiplies this matrix with a vector and places the results into the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>result.Count != this.RowCount</strong>.
             * @throws If <strong>this.ColumnCount != <paramref name="rightSide" />.Count</strong>.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result       The result of the multiplication.
             * @return  {void}
             */
            Multiply$5: function (rightSide, result) {
                if (this.ColumnCount !== rightSide.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$4(System.ArgumentException, this, rightSide, "rightSide");
                }

                if (this.RowCount !== result.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$4(System.ArgumentException, this, result, "result");
                }

                if (Bridge.referenceEquals(rightSide, result)) {
                    var tmp = this.v_builder.SameAs$4(T, result);
                    this.DoMultiply$2(rightSide, tmp);
                    tmp.CopyTo(result);
                } else {
                    this.DoMultiply$2(rightSide, result);
                }
            },
            /**
             * Multiplies this matrix with another matrix and places the results into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>this.Columns != other.Rows</strong>.
             * @throws If the result matrix's dimensions are not the this.Rows x other.Columns.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            Multiply$4: function (other, result) {
                if (this.ColumnCount !== other.RowCount || result.RowCount !== this.RowCount || result.ColumnCount !== other.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, other, result);
                }

                if (Bridge.referenceEquals(this, result) || Bridge.referenceEquals(other, result)) {
                    var tmp = this.m_builder.SameAs$3(T, result);
                    this.DoMultiply$1(other, tmp);
                    tmp.CopyTo(result);
                } else {
                    this.DoMultiply$1(other, result);
                }
            },
            /**
             * Multiplies this matrix with another matrix and returns the result.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>this.Columns != other.Rows</strong>.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The matrix to multiply with.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The result of the multiplication.
             */
            Multiply$1: function (other) {
                if (this.ColumnCount !== other.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, other);
                }

                var result = this.m_builder.SameAs$1(this, other, this.RowCount, other.ColumnCount);
                this.DoMultiply$1(other, result);
                return result;
            },
            /**
             * Divides each element of this matrix with a scalar.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          scalar    The scalar to divide with.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}              The result of the division.
             */
            Divide: function (scalar) {
                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Matrix$1(T).One)) {
                    return this.Clone();
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Matrix$1(T).Zero)) {
                    throw new System.DivideByZeroException.ctor();
                }

                var result = this.m_builder.SameAs$3(T, this);
                this.DoDivide(scalar, result);
                return result;
            },
            /**
             * Divides each element of the matrix by a scalar and places results into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {T}                                          scalar    The scalar to divide the matrix with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the division.
             * @return  {void}
             */
            Divide$1: function (scalar, result) {
                if (result.RowCount !== this.RowCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameRowDimension", "result");
                }

                if (result.ColumnCount !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameColumnDimension", "result");
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Matrix$1(T).One)) {
                    this.CopyTo(result);
                    return;
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Matrix$1(T).Zero)) {
                    throw new System.DivideByZeroException.ctor();
                }

                this.DoDivide(scalar, result);
            },
            /**
             * Divides a scalar by each element of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          scalar    The scalar to divide.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}              The result of the division.
             */
            DivideByThis: function (scalar) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoDivideByThis(scalar, result);
                return result;
            },
            /**
             * Divides a scalar by each element of the matrix and places results into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {T}                                          scalar    The scalar to divide.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the division.
             * @return  {void}
             */
            DivideByThis$1: function (scalar, result) {
                if (result.RowCount !== this.RowCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameRowDimension", "result");
                }

                if (result.ColumnCount !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameColumnDimension", "result");
                }

                this.DoDivideByThis(scalar, result);
            },
            /**
             * Left multiply a matrix with a vector ( = vector * matrix ).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>this.RowCount != <paramref name="leftSide" />.Count</strong>.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    leftSide    The vector to multiply with.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                The result of the multiplication.
             */
            LeftMultiply: function (leftSide) {
                if (this.RowCount !== leftSide.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$4(System.ArgumentException, this, leftSide, "leftSide");
                }

                var ret = this.v_builder.SameAs(this, leftSide, this.ColumnCount);
                this.DoLeftMultiply(leftSide, ret);
                return ret;
            },
            /**
             * Left multiply a matrix with a vector ( = vector * matrix ) and place the result in the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>result.Count != this.ColumnCount</strong>.
             * @throws If <strong>this.RowCount != <paramref name="leftSide" />.Count</strong>.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    leftSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result      The result of the multiplication.
             * @return  {void}
             */
            LeftMultiply$1: function (leftSide, result) {
                if (this.RowCount !== leftSide.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$4(System.ArgumentException, this, leftSide, "leftSide");
                }

                if (this.ColumnCount !== result.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$4(System.ArgumentException, this, result, "result");
                }

                if (Bridge.referenceEquals(leftSide, result)) {
                    var tmp = this.v_builder.SameAs$4(T, result);
                    this.DoLeftMultiply(leftSide, tmp);
                    tmp.CopyTo(result);
                } else {
                    this.DoLeftMultiply(leftSide, result);
                }
            },
            /**
             * Left multiply a matrix with a vector ( = vector * matrix ) and place the result in the result vector.
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    leftSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result      The result of the multiplication.
             * @return  {void}
             */
            DoLeftMultiply: function (leftSide, result) {
                this.DoTransposeThisAndMultiply$1(leftSide, result);
            },
            /**
             * Multiplies this matrix with transpose of another matrix and places the results into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>this.Columns != other.ColumnCount</strong>.
             * @throws If the result matrix's dimensions are not the this.RowCount x other.RowCount.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            TransposeAndMultiply$1: function (other, result) {
                if (this.ColumnCount !== other.ColumnCount || result.RowCount !== this.RowCount || result.ColumnCount !== other.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, other, result);
                }

                if (Bridge.referenceEquals(this, result) || Bridge.referenceEquals(other, result)) {
                    var tmp = this.m_builder.SameAs$3(T, result);
                    this.DoTransposeAndMultiply(other, tmp);
                    tmp.CopyTo(result);
                } else {
                    this.DoTransposeAndMultiply(other, result);
                }
            },
            /**
             * Multiplies this matrix with transpose of another matrix and returns the result.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>this.Columns != other.ColumnCount</strong>.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The matrix to multiply with.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The result of the multiplication.
             */
            TransposeAndMultiply: function (other) {
                if (this.ColumnCount !== other.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, other);
                }

                var result = this.m_builder.SameAs$1(this, other, this.RowCount, other.RowCount);
                this.DoTransposeAndMultiply(other, result);
                return result;
            },
            /**
             * Multiplies the transpose of this matrix by a vector and returns the result.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <pre><code>this.RowCount != rightSide.Count</code></pre>.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 The result of the multiplication.
             */
            TransposeThisAndMultiply$1: function (rightSide) {
                if (this.RowCount !== rightSide.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$4(System.ArgumentException, this, rightSide, "rightSide");
                }

                var result = this.v_builder.SameAs(this, rightSide, this.ColumnCount);
                this.DoTransposeThisAndMultiply$1(rightSide, result);
                return result;
            },
            /**
             * Multiplies the transpose of this matrix with a vector and places the results into the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>result.Count != this.ColumnCount</strong>.
             * @throws If <strong>this.RowCount != <paramref name="rightSide" />.Count</strong>.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result       The result of the multiplication.
             * @return  {void}
             */
            TransposeThisAndMultiply$3: function (rightSide, result) {
                if (this.RowCount !== rightSide.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$4(System.ArgumentException, this, rightSide, "rightSide");
                }

                if (this.ColumnCount !== result.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$4(System.ArgumentException, this, result, "result");
                }

                if (Bridge.referenceEquals(rightSide, result)) {
                    var tmp = this.v_builder.SameAs$4(T, result);
                    this.DoTransposeThisAndMultiply$1(rightSide, tmp);
                    tmp.CopyTo(result);
                } else {
                    this.DoTransposeThisAndMultiply$1(rightSide, result);
                }
            },
            /**
             * Multiplies the transpose of this matrix with another matrix and places the results into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>this.Rows != other.RowCount</strong>.
             * @throws If the result matrix's dimensions are not the this.ColumnCount x other.ColumnCount.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            TransposeThisAndMultiply$2: function (other, result) {
                if (this.RowCount !== other.RowCount || result.RowCount !== this.ColumnCount || result.ColumnCount !== other.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, other, result);
                }

                if (Bridge.referenceEquals(this, result) || Bridge.referenceEquals(other, result)) {
                    var tmp = this.m_builder.SameAs$3(T, result);
                    this.DoTransposeThisAndMultiply(other, tmp);
                    tmp.CopyTo(result);
                } else {
                    this.DoTransposeThisAndMultiply(other, result);
                }
            },
            /**
             * Multiplies the transpose of this matrix with another matrix and returns the result.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>this.Rows != other.RowCount</strong>.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The matrix to multiply with.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The result of the multiplication.
             */
            TransposeThisAndMultiply: function (other) {
                if (this.RowCount !== other.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, other);
                }

                var result = this.m_builder.SameAs$1(this, other, this.ColumnCount, other.ColumnCount);
                this.DoTransposeThisAndMultiply(other, result);
                return result;
            },
            /**
             * Multiplies this matrix with the conjugate transpose of another matrix and places the results into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>this.Columns != other.ColumnCount</strong>.
             * @throws If the result matrix's dimensions are not the this.RowCount x other.RowCount.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            ConjugateTransposeAndMultiply$1: function (other, result) {
                if (this.ColumnCount !== other.ColumnCount || result.RowCount !== this.RowCount || result.ColumnCount !== other.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, other, result);
                }

                if (Bridge.referenceEquals(this, result) || Bridge.referenceEquals(other, result)) {
                    var tmp = this.m_builder.SameAs$3(T, result);
                    this.DoConjugateTransposeAndMultiply(other, tmp);
                    tmp.CopyTo(result);
                } else {
                    this.DoConjugateTransposeAndMultiply(other, result);
                }
            },
            /**
             * Multiplies this matrix with the conjugate transpose of another matrix and returns the result.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>this.Columns != other.ColumnCount</strong>.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The matrix to multiply with.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The result of the multiplication.
             */
            ConjugateTransposeAndMultiply: function (other) {
                if (this.ColumnCount !== other.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, other);
                }

                var result = this.m_builder.SameAs$1(this, other, this.RowCount, other.RowCount);
                this.DoConjugateTransposeAndMultiply(other, result);
                return result;
            },
            /**
             * Multiplies the conjugate transpose of this matrix by a vector and returns the result.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <pre><code>this.RowCount != rightSide.Count</code></pre>.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 The result of the multiplication.
             */
            ConjugateTransposeThisAndMultiply$1: function (rightSide) {
                if (this.RowCount !== rightSide.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$4(System.ArgumentException, this, rightSide, "rightSide");
                }

                var result = this.v_builder.SameAs(this, rightSide, this.ColumnCount);
                this.DoConjugateTransposeThisAndMultiply$1(rightSide, result);
                return result;
            },
            /**
             * Multiplies the conjugate transpose of this matrix with a vector and places the results into the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>result.Count != this.ColumnCount</strong>.
             * @throws If <strong>this.RowCount != <paramref name="rightSide" />.Count</strong>.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result       The result of the multiplication.
             * @return  {void}
             */
            ConjugateTransposeThisAndMultiply$3: function (rightSide, result) {
                if (this.RowCount !== rightSide.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$4(System.ArgumentException, this, rightSide, "rightSide");
                }

                if (this.ColumnCount !== result.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$4(System.ArgumentException, this, result, "result");
                }

                if (Bridge.referenceEquals(rightSide, result)) {
                    var tmp = this.v_builder.SameAs$4(T, result);
                    this.DoConjugateTransposeThisAndMultiply$1(rightSide, tmp);
                    tmp.CopyTo(result);
                } else {
                    this.DoConjugateTransposeThisAndMultiply$1(rightSide, result);
                }
            },
            /**
             * Multiplies the conjugate transpose of this matrix with another matrix and places the results into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>this.Rows != other.RowCount</strong>.
             * @throws If the result matrix's dimensions are not the this.ColumnCount x other.ColumnCount.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            ConjugateTransposeThisAndMultiply$2: function (other, result) {
                if (this.RowCount !== other.RowCount || result.RowCount !== this.ColumnCount || result.ColumnCount !== other.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, other, result);
                }

                if (Bridge.referenceEquals(this, result) || Bridge.referenceEquals(other, result)) {
                    var tmp = this.m_builder.SameAs$3(T, result);
                    this.DoConjugateTransposeThisAndMultiply(other, tmp);
                    tmp.CopyTo(result);
                } else {
                    this.DoConjugateTransposeThisAndMultiply(other, result);
                }
            },
            /**
             * Multiplies the conjugate transpose of this matrix with another matrix and returns the result.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <strong>this.Rows != other.RowCount</strong>.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The matrix to multiply with.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The result of the multiplication.
             */
            ConjugateTransposeThisAndMultiply: function (other) {
                if (this.RowCount !== other.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, other);
                }

                var result = this.m_builder.SameAs$1(this, other, this.ColumnCount, other.ColumnCount);
                this.DoConjugateTransposeThisAndMultiply(other, result);
                return result;
            },
            /**
             * Raises this square matrix to a positive integer exponent and places the results into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}                                     exponent    The positive integer exponent to raise the matrix to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      The result of the power.
             * @return  {void}
             */
            Power$1: function (exponent, result) {
                if (this.RowCount !== this.ColumnCount || result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result);
                }
                if (exponent < 0) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentNotNegative");
                }
                if (exponent === 0) {
                    this.m_builder.DiagonalIdentity$1(this.RowCount, this.ColumnCount).CopyTo(result);
                    return;
                }
                if (exponent === 1) {
                    this.CopyTo(result);
                    return;
                }
                if (exponent === 2) {
                    this.Multiply$4(this, result);
                    return;
                }

                var res = MathNet.Numerics.LinearAlgebra.Matrix$1(T).IntPower(exponent, this.Clone(), null, result);
                if (!Bridge.referenceEquals(res, result)) {
                    res.CopyTo(result);
                }
            },
            /**
             * Multiplies this square matrix with another matrix and returns the result.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}                                     exponent    The positive integer exponent to raise the matrix to.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Power: function (exponent) {
                if (this.RowCount !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSquare");
                }
                if (exponent < 0) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentNotNegative");
                }

                if (exponent === 0) {
                    return this.m_builder.DiagonalIdentity$1(this.RowCount, this.ColumnCount);
                }
                if (exponent === 1) {
                    return this;
                }
                if (exponent === 2) {
                    return this.Multiply$1(this);
                }

                return MathNet.Numerics.LinearAlgebra.Matrix$1(T).IntPower(exponent, this.Clone(), null, null);
            },
            /**
             * Negate each element of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        A matrix containing the negated values.
             */
            Negate: function () {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoNegate(result);
                return result;
            },
            /**
             * Negate each element of this matrix and place the results into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws if the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the negation.
             * @return  {void}
             */
            Negate$1: function (result) {
                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result);
                }

                this.DoNegate(result);
            },
            /**
             * Complex conjugate each element of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        A matrix containing the conjugated values.
             */
            Conjugate: function () {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoConjugate(result);
                return result;
            },
            /**
             * Complex conjugate each element of this matrix and place the results into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws if the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the conjugation.
             * @return  {void}
             */
            Conjugate$1: function (result) {
                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result);
                }

                this.DoConjugate(result);
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for each element of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          divisor    The scalar denominator to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}               A matrix containing the results.
             */
            Modulus: function (divisor) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoModulus(divisor, result);
                return result;
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for each element of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     Matrix to store the results in.
             * @return  {void}
             */
            Modulus$1: function (divisor, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result);
                }

                this.DoModulus(divisor, result);
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for each element of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          dividend    The scalar numerator to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                A matrix containing the results.
             */
            ModulusByThis: function (dividend) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoModulusByThis(dividend, result);
                return result;
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for each element of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          dividend    The scalar numerator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      Matrix to store the results in.
             * @return  {void}
             */
            ModulusByThis$1: function (dividend, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result);
                }

                this.DoModulusByThis(dividend, result);
            },
            /**
             * Computes the remainder (matrix % divisor), where the result has the sign of the dividend,
             for each element of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          divisor    The scalar denominator to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}               A matrix containing the results.
             */
            Remainder: function (divisor) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoRemainder(divisor, result);
                return result;
            },
            /**
             * Computes the remainder (matrix % divisor), where the result has the sign of the dividend,
             for each element of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     Matrix to store the results in.
             * @return  {void}
             */
            Remainder$1: function (divisor, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result);
                }

                this.DoRemainder(divisor, result);
            },
            /**
             * Computes the remainder (dividend % matrix), where the result has the sign of the dividend,
             for each element of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          dividend    The scalar numerator to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                A matrix containing the results.
             */
            RemainderByThis: function (dividend) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoRemainderByThis(dividend, result);
                return result;
            },
            /**
             * Computes the remainder (dividend % matrix), where the result has the sign of the dividend,
             for each element of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          dividend    The scalar numerator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      Matrix to store the results in.
             * @return  {void}
             */
            RemainderByThis$1: function (dividend, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result);
                }

                this.DoRemainderByThis(dividend, result);
            },
            /**
             * Pointwise multiplies this matrix with another matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The matrix to pointwise multiply with this one.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             A new matrix that is the pointwise multiplication of this matrix and <b />.
             */
            PointwiseMultiply: function (other) {
                if (this.ColumnCount !== other.ColumnCount || this.RowCount !== other.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, other, "other");
                }

                var result = this.m_builder.SameAs(this, other);
                this.DoPointwiseMultiply(other, result);
                return result;
            },
            /**
             * Pointwise multiplies this matrix with another matrix and stores the result into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to pointwise multiply with this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the pointwise multiplication.
             * @return  {void}
             */
            PointwiseMultiply$1: function (other, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount || this.ColumnCount !== other.ColumnCount || this.RowCount !== other.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, other, result);
                }

                this.DoPointwiseMultiply(other, result);
            },
            /**
             * Pointwise divide this matrix by another matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor    The pointwise denominator matrix to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}               A new matrix that is the pointwise division of this matrix and <b />.
             */
            PointwiseDivide: function (divisor) {
                if (this.ColumnCount !== divisor.ColumnCount || this.RowCount !== divisor.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, divisor);
                }

                var result = this.m_builder.SameAs(this, divisor);
                this.DoPointwiseDivide(divisor, result);
                return result;
            },
            /**
             * Pointwise divide this matrix by another matrix and stores the result into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor    The pointwise denominator matrix to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     The matrix to store the result of the pointwise division.
             * @return  {void}
             */
            PointwiseDivide$1: function (divisor, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount || this.ColumnCount !== divisor.ColumnCount || this.RowCount !== divisor.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, divisor, result);
                }

                this.DoPointwiseDivide(divisor, result);
            },
            /**
             * Pointwise raise this matrix to an exponent and store the result into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          exponent    The exponent to raise this matrix values to.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwisePower: function (exponent) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoPointwisePower(exponent, result);
                return result;
            },
            /**
             * Pointwise raise this matrix to an exponent.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {T}                                          exponent    The exponent to raise this matrix values to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      The matrix to store the result into.
             * @return  {void}
             */
            PointwisePower$2: function (exponent, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result);
                }

                this.DoPointwisePower(exponent, result);
            },
            /**
             * Pointwise raise this matrix to an exponent and store the result into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    exponent    The exponent to raise this matrix values to.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwisePower$1: function (exponent) {
                if (this.ColumnCount !== exponent.ColumnCount || this.RowCount !== exponent.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, exponent);
                }

                var result = this.m_builder.SameAs$3(T, this);
                this.DoPointwisePower$1(exponent, result);
                return result;
            },
            /**
             * Pointwise raise this matrix to an exponent.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    exponent    The exponent to raise this matrix values to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      The matrix to store the result into.
             * @return  {void}
             */
            PointwisePower$3: function (exponent, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount || this.ColumnCount !== exponent.ColumnCount || this.RowCount !== exponent.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, exponent, result);
                }

                this.DoPointwisePower$1(exponent, result);
            },
            /**
             * Pointwise canonical modulus, where the result has the sign of the divisor,
             of this matrix by another matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor    The pointwise denominator matrix to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseModulus: function (divisor) {
                if (this.ColumnCount !== divisor.ColumnCount || this.RowCount !== divisor.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, divisor);
                }

                var result = this.m_builder.SameAs(this, divisor);
                this.DoPointwiseModulus(divisor, result);
                return result;
            },
            /**
             * Pointwise canonical modulus, where the result has the sign of the divisor,
             of this matrix by another matrix and stores the result into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor    The pointwise denominator matrix to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     The matrix to store the result of the pointwise modulus.
             * @return  {void}
             */
            PointwiseModulus$1: function (divisor, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount || this.ColumnCount !== divisor.ColumnCount || this.RowCount !== divisor.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, divisor, result);
                }

                this.DoPointwiseModulus(divisor, result);
            },
            /**
             * Pointwise remainder (% operator), where the result has the sign of the dividend,
             of this matrix by another matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor    The pointwise denominator matrix to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseRemainder: function (divisor) {
                if (this.ColumnCount !== divisor.ColumnCount || this.RowCount !== divisor.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, divisor);
                }

                var result = this.m_builder.SameAs(this, divisor);
                this.DoPointwiseRemainder(divisor, result);
                return result;
            },
            /**
             * Pointwise remainder (% operator), where the result has the sign of the dividend,
             of this matrix by another matrix and stores the result into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor    The pointwise denominator matrix to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     The matrix to store the result of the pointwise remainder.
             * @return  {void}
             */
            PointwiseRemainder$1: function (divisor, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount || this.ColumnCount !== divisor.ColumnCount || this.RowCount !== divisor.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, divisor, result);
                }

                this.DoPointwiseRemainder(divisor, result);
            },
            /**
             * Helper function to apply a unary function to a matrix. The function
             f modifies the matrix given to it in place.  Before its
             called, a copy of the 'this' matrix is first created, then passed to
             f.  The copy is then returned as the result
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Action}                              f    Function which takes a matrix, modifies it in place and returns void
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}         New instance of matrix which is the result
             */
            PointwiseUnary: function (f) {
                var result = this.m_builder.SameAs$3(T, this);
                f(result);
                return result;
            },
            /**
             * Helper function to apply a unary function which modifies a matrix
             in place.
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {System.Action}                              f         Function which takes a matrix, modifies it in place and returns void
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to be passed to f and where the result is to be stored
             * @return  {void}
             */
            PointwiseUnary$1: function (f, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result);
                }
                f(result);
            },
            /**
             * Helper function to apply a binary function which takes two matrices
             and modifies the latter in place.  A copy of the "this" matrix is
             first made and then passed to f together with the other matrix. The
             copy is then returned as the result
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same dimension.
             * @param   {System.Action}                              f        Function which takes two matrices, modifies the second in place and returns void
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The other matrix to be passed to the function as argument. It is not modified
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The resulting matrix
             */
            PointwiseBinary: function (f, other) {
                if (this.ColumnCount !== other.ColumnCount || this.RowCount !== other.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, other);
                }

                var result = this.m_builder.SameAs(this, other);
                f(other, result);
                return result;
            },
            /**
             * Helper function to apply a binary function which takes two matrices
             and modifies the second one in place
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same dimension.
             * @param   {System.Action}                              f         Function which takes two matrices, modifies the second in place and returns void
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The other matrix to be passed to the function as argument. It is not modified
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result.
             * @return  {void}                                                 The resulting matrix
             */
            PointwiseBinary$1: function (f, other, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount || this.ColumnCount !== other.ColumnCount || this.RowCount !== other.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, other, result);
                }

                f(other, result);
            },
            /**
             * Pointwise applies the exponent function to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseExp: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseExp));
            },
            /**
             * Pointwise applies the exponent function to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result.
             * @return  {void}
             */
            PointwiseExp$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseExp), result);
            },
            /**
             * Pointwise applies the natural logarithm function to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseLog: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseLog));
            },
            /**
             * Pointwise applies the natural logarithm function to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result.
             * @return  {void}
             */
            PointwiseLog$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseLog), result);
            },
            /**
             * Pointwise applies the abs function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseAbs: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseAbs));
            },
            /**
             * Pointwise applies the abs function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseAbs$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseAbs), result);
            },
            /**
             * Pointwise applies the acos function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseAcos: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseAcos));
            },
            /**
             * Pointwise applies the acos function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseAcos$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseAcos), result);
            },
            /**
             * Pointwise applies the asin function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseAsin: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseAsin));
            },
            /**
             * Pointwise applies the asin function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseAsin$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseAsin), result);
            },
            /**
             * Pointwise applies the atan function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseAtan: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseAtan));
            },
            /**
             * Pointwise applies the atan function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseAtan$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseAtan), result);
            },
            /**
             * Pointwise applies the atan2 function to each value of the current
             matrix and a given other matrix being the 'x' of atan2 and the
             'this' matrix being the 'y'
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseAtan2: function (other) {
                return this.PointwiseBinary(Bridge.fn.cacheBind(this, this.DoPointwiseAtan2), other);
            },
            /**
             * Pointwise applies the atan2 function to each value of the current
             matrix and a given other matrix being the 'x' of atan2 and the
             'this' matrix being the 'y'
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The other matrix 'y'
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix with the result and 'x'
             * @return  {void}
             */
            PointwiseAtan2$1: function (other, result) {
                this.PointwiseBinary$1(Bridge.fn.cacheBind(this, this.DoPointwiseAtan2), other, result);
            },
            /**
             * Pointwise applies the ceiling function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseCeiling: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseCeiling));
            },
            /**
             * Pointwise applies the ceiling function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseCeiling$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseCeiling), result);
            },
            /**
             * Pointwise applies the cos function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseCos: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseCos));
            },
            /**
             * Pointwise applies the cos function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseCos$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseCos), result);
            },
            /**
             * Pointwise applies the cosh function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseCosh: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseCosh));
            },
            /**
             * Pointwise applies the cosh function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseCosh$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseCosh), result);
            },
            /**
             * Pointwise applies the floor function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseFloor: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseFloor));
            },
            /**
             * Pointwise applies the floor function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseFloor$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseFloor), result);
            },
            /**
             * Pointwise applies the log10 function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseLog10: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseLog10));
            },
            /**
             * Pointwise applies the log10 function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseLog10$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseLog10), result);
            },
            /**
             * Pointwise applies the round function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseRound: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseRound));
            },
            /**
             * Pointwise applies the round function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseRound$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseRound), result);
            },
            /**
             * Pointwise applies the sign function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseSign: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseSign));
            },
            /**
             * Pointwise applies the sign function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseSign$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseSign), result);
            },
            /**
             * Pointwise applies the sin function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseSin: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseSin));
            },
            /**
             * Pointwise applies the sin function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseSin$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseSin), result);
            },
            /**
             * Pointwise applies the sinh function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseSinh: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseSinh));
            },
            /**
             * Pointwise applies the sinh function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseSinh$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseSinh), result);
            },
            /**
             * Pointwise applies the sqrt function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseSqrt: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseSqrt));
            },
            /**
             * Pointwise applies the sqrt function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseSqrt$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseSqrt), result);
            },
            /**
             * Pointwise applies the tan function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseTan: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseTan));
            },
            /**
             * Pointwise applies the tan function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseTan$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseTan), result);
            },
            /**
             * Pointwise applies the tanh function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseTanh: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseTanh));
            },
            /**
             * Pointwise applies the tanh function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseTanh$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseTanh), result);
            },
            /**
             * Calculates the rank of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {number}        effective numerical rank, obtained from SVD
             */
            Rank: function () {
                return this.Svd(false).Rank;
            },
            /**
             * Calculates the nullity of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {number}        effective numerical nullity, obtained from SVD
             */
            Nullity: function () {
                return ((this.ColumnCount - this.Rank()) | 0);
            },
            /**
             * Calculates the condition number of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {T}        The condition number of the matrix.
             */
            ConditionNumber: function () {
                return this.Svd(false).ConditionNumber;
            },
            /**
             * Computes the determinant of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {T}        The determinant of this matrix.
             */
            Determinant: function () {
                if (this.RowCount !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSquare");
                }

                return this.LU().Determinant;
            },
            /**
             * Computes an orthonormal basis for the null space of this matrix,
             also known as the kernel of the corresponding matrix transformation.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}
             */
            Kernel: function () {
                var $t;
                var svd = this.Svd(true);
                return ($t = MathNet.Numerics.LinearAlgebra.Vector$1(T), System.Linq.Enumerable.from(svd.VT.EnumerateRows$1(svd.Rank, ((this.ColumnCount - svd.Rank) | 0)), $t).ToArray($t));
            },
            /**
             * Computes an orthonormal basis for the column space of this matrix,
             also known as the range or image of the corresponding matrix transformation.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}
             */
            Range: function () {
                var $t;
                var svd = this.Svd(true);
                return ($t = MathNet.Numerics.LinearAlgebra.Vector$1(T), System.Linq.Enumerable.from(svd.U.EnumerateColumns$1(0, svd.Rank), $t).ToArray($t));
            },
            /**
             * Computes the inverse of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The inverse of this matrix.
             */
            Inverse: function () {
                if (this.RowCount !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSquare");
                }

                return this.LU().Inverse();
            },
            /**
             * Computes the Kronecker product of this matrix with the given matrix. The new matrix is M-by-N
             with M = this.Rows * lower.Rows and N = this.Columns * lower.Columns.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The other matrix.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The Kronecker product of the two matrices.
             */
            KroneckerProduct: function (other) {
                var result = this.m_builder.SameAs$1(this, other, Bridge.Int.mul(this.RowCount, other.RowCount), Bridge.Int.mul(this.ColumnCount, other.ColumnCount));
                this.KroneckerProduct$1(other, result);
                return result;
            },
            /**
             * Computes the Kronecker product of this matrix with the given matrix. The new matrix is M-by-N
             with M = this.Rows * lower.Rows and N = this.Columns * lower.Columns.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the result matrix's dimensions are not (this.Rows * lower.rows) x (this.Columns * lower.Columns).
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The other matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The Kronecker product of the two matrices.
             * @return  {void}
             */
            KroneckerProduct$1: function (other, result) {
                if (result.RowCount !== (Bridge.Int.mul(this.RowCount, other.RowCount)) || result.ColumnCount !== (Bridge.Int.mul(this.ColumnCount, other.ColumnCount))) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentOutOfRangeException, this, other, result);
                }

                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        result.SetSubMatrix$1(Bridge.Int.mul(i, other.RowCount), other.RowCount, Bridge.Int.mul(j, other.ColumnCount), other.ColumnCount, MathNet.Numerics.LinearAlgebra.Matrix$1(T).op_Multiply(this.At(i, j), other));
                    }
                }
            },
            /**
             * Pointwise applies the minimum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseMinimum: function (scalar) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoPointwiseMinimum(scalar, result);
                return result;
            },
            /**
             * Pointwise applies the minimum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The vector to store the result.
             * @return  {void}
             */
            PointwiseMinimum$2: function (scalar, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result);
                }

                this.DoPointwiseMinimum(scalar, result);
            },
            /**
             * Pointwise applies the minimum with the values of another matrix to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The matrix with the values to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseMinimum$1: function (other) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoPointwiseMinimum$1(other, result);
                return result;
            },
            /**
             * Pointwise applies the minimum with the values of another matrix to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix with the values to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result.
             * @return  {void}
             */
            PointwiseMinimum$3: function (other, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount || this.ColumnCount !== other.ColumnCount || this.RowCount !== other.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, other, result);
                }

                this.DoPointwiseMinimum$1(other, result);
            },
            /**
             * Pointwise applies the maximum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseMaximum: function (scalar) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoPointwiseMaximum(scalar, result);
                return result;
            },
            /**
             * Pointwise applies the maximum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result.
             * @return  {void}
             */
            PointwiseMaximum$2: function (scalar, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result);
                }

                this.DoPointwiseMaximum(scalar, result);
            },
            /**
             * Pointwise applies the maximum with the values of another matrix to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The matrix with the values to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseMaximum$1: function (other) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoPointwiseMaximum$1(other, result);
                return result;
            },
            /**
             * Pointwise applies the maximum with the values of another matrix to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix with the values to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result.
             * @return  {void}
             */
            PointwiseMaximum$3: function (other, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount || this.ColumnCount !== other.ColumnCount || this.RowCount !== other.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, other, result);
                }

                this.DoPointwiseMaximum$1(other, result);
            },
            /**
             * Pointwise applies the absolute minimum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseAbsoluteMinimum: function (scalar) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoPointwiseAbsoluteMinimum(scalar, result);
                return result;
            },
            /**
             * Pointwise applies the absolute minimum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result.
             * @return  {void}
             */
            PointwiseAbsoluteMinimum$2: function (scalar, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result);
                }

                this.DoPointwiseAbsoluteMinimum(scalar, result);
            },
            /**
             * Pointwise applies the absolute minimum with the values of another matrix to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The matrix with the values to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseAbsoluteMinimum$1: function (other) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoPointwiseAbsoluteMinimum$1(other, result);
                return result;
            },
            /**
             * Pointwise applies the absolute minimum with the values of another matrix to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix with the values to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result.
             * @return  {void}
             */
            PointwiseAbsoluteMinimum$3: function (other, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount || this.ColumnCount !== other.ColumnCount || this.RowCount !== other.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, other, result);
                }

                this.DoPointwiseAbsoluteMinimum$1(other, result);
            },
            /**
             * Pointwise applies the absolute maximum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseAbsoluteMaximum: function (scalar) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoPointwiseAbsoluteMaximum(scalar, result);
                return result;
            },
            /**
             * Pointwise applies the absolute maximum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result.
             * @return  {void}
             */
            PointwiseAbsoluteMaximum$2: function (scalar, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result);
                }

                this.DoPointwiseAbsoluteMaximum(scalar, result);
            },
            /**
             * Pointwise applies the absolute maximum with the values of another matrix to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    The matrix with the values to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PointwiseAbsoluteMaximum$1: function (other) {
                var result = this.m_builder.SameAs$3(T, this);
                this.DoPointwiseAbsoluteMaximum$1(other, result);
                return result;
            },
            /**
             * Pointwise applies the absolute maximum with the values of another matrix to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If this matrix and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix with the values to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result.
             * @return  {void}
             */
            PointwiseAbsoluteMaximum$3: function (other, result) {
                if (this.ColumnCount !== result.ColumnCount || this.RowCount !== result.RowCount || this.ColumnCount !== other.ColumnCount || this.RowCount !== other.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$1(System.ArgumentException, this, other, result);
                }

                this.DoPointwiseAbsoluteMaximum$1(other, result);
            },
            /**
             * Calculates the induced L2 norm of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {number}        The largest singular value of the matrix.
             */
            L2Norm: function () {
                return this.Svd(false).L2Norm;
            },
            /**
             * Indicates whether the current object is equal to another object of the same type.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    An object to compare with this object.
             * @return  {boolean}                                             <pre><code>true</code></pre> if the current object is equal to the <b /> parameter; otherwise, <pre><code>false</code></pre>.
             */
            equalsT: function (other) {
                return other != null && this.Storage.equalsT(other.Storage);
            },
            /**
             * Determines whether the specified {@link } is equal to this instance.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Object}    obj    The {@link } to compare with this instance.
             * @return  {boolean}                 <pre><code>true</code></pre> if the specified {@link } is equal to this instance; otherwise, <pre><code>false</code></pre>.
             */
            equals: function (obj) {
                var other = Bridge.as(obj, MathNet.Numerics.LinearAlgebra.Matrix$1(T));
                return other != null && this.Storage.equalsT(other.Storage);
            },
            /**
             * Returns a hash code for this instance.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {number}        A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
             */
            getHashCode: function () {
                return this.Storage.getHashCode();
            },
            /**
             * Creates a new object that is a copy of the current instance.
             *
             * @instance
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {System.Object}        A new object that is a copy of this instance.
             */
            System$ICloneable$clone: function () {
                return this.Clone();
            },
            /**
             * Creates a clone of this instance.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        A clone of the instance.
             */
            Clone: function () {
                var result = this.m_builder.SameAs$3(T, this);
                this.Storage.CopyToUnchecked(result.Storage, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Returns a string that describes the type, dimensions and shape of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {string}
             */
            ToTypeString: function () {
                return System.String.format("{0} {1}x{2}-{3}", Bridge.Reflection.getTypeName(Bridge.getType(this)), Bridge.box(this.RowCount, System.Int32), Bridge.box(this.ColumnCount, System.Int32), Bridge.Reflection.getTypeName(T));
            },
            /**
             * Returns a string 2D array that summarizes the content of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}            upperRows             
             * @param   {number}            lowerRows             
             * @param   {number}            leftColumns           
             * @param   {number}            rightColumns          
             * @param   {string}            horizontalEllipsis    
             * @param   {string}            verticalEllipsis      
             * @param   {string}            diagonalEllipsis      
             * @param   {System.Func}       formatValue
             * @return  {Array.<string>}
             */
            ToMatrixStringArray$1: function (upperRows, lowerRows, leftColumns, rightColumns, horizontalEllipsis, verticalEllipsis, diagonalEllipsis, formatValue) {
                upperRows = Math.max(upperRows, 1);
                lowerRows = Math.max(lowerRows, 0);
                leftColumns = Math.max(leftColumns, 1);
                rightColumns = Math.max(rightColumns, 0);

                var upper = this.RowCount <= upperRows ? this.RowCount : upperRows;
                var lower = this.RowCount <= upperRows ? 0 : this.RowCount <= ((upperRows + lowerRows) | 0) ? ((this.RowCount - upperRows) | 0) : lowerRows;
                var rowEllipsis = this.RowCount > ((upper + lower) | 0);
                var rows = rowEllipsis ? ((((upper + lower) | 0) + 1) | 0) : ((upper + lower) | 0);

                var left = this.ColumnCount <= leftColumns ? this.ColumnCount : leftColumns;
                var right = this.ColumnCount <= leftColumns ? 0 : this.ColumnCount <= ((leftColumns + rightColumns) | 0) ? ((this.ColumnCount - leftColumns) | 0) : rightColumns;
                var colEllipsis = this.ColumnCount > ((left + right) | 0);
                var cols = colEllipsis ? ((((left + right) | 0) + 1) | 0) : ((left + right) | 0);

                var array = System.Array.create(null, null, System.String, rows, cols);
                for (var i = 0; i < upper; i = (i + 1) | 0) {
                    for (var j = 0; j < left; j = (j + 1) | 0) {
                        array.set([i, j], formatValue(this.At(i, j)));
                    }
                    var colOffset = left;
                    if (colEllipsis) {
                        array.set([i, left], horizontalEllipsis);
                        colOffset = (colOffset + 1) | 0;
                    }
                    for (var j1 = 0; j1 < right; j1 = (j1 + 1) | 0) {
                        array.set([i, ((colOffset + j1) | 0)], formatValue(this.At(i, ((((this.ColumnCount - right) | 0) + j1) | 0))));
                    }
                }
                var rowOffset = upper;
                if (rowEllipsis) {
                    for (var j2 = 0; j2 < left; j2 = (j2 + 1) | 0) {
                        array.set([upper, j2], verticalEllipsis);
                    }
                    var colOffset1 = left;
                    if (colEllipsis) {
                        array.set([upper, left], diagonalEllipsis);
                        colOffset1 = (colOffset1 + 1) | 0;
                    }
                    for (var j3 = 0; j3 < right; j3 = (j3 + 1) | 0) {
                        array.set([upper, ((colOffset1 + j3) | 0)], verticalEllipsis);
                    }
                    rowOffset = (rowOffset + 1) | 0;
                }
                for (var i1 = 0; i1 < lower; i1 = (i1 + 1) | 0) {
                    for (var j4 = 0; j4 < left; j4 = (j4 + 1) | 0) {
                        array.set([((rowOffset + i1) | 0), j4], formatValue(this.At(((((this.RowCount - lower) | 0) + i1) | 0), j4)));
                    }
                    var colOffset2 = left;
                    if (colEllipsis) {
                        array.set([((rowOffset + i1) | 0), left], horizontalEllipsis);
                        colOffset2 = (colOffset2 + 1) | 0;
                    }
                    for (var j5 = 0; j5 < right; j5 = (j5 + 1) | 0) {
                        array.set([((rowOffset + i1) | 0), ((colOffset2 + j5) | 0)], formatValue(this.At(((((this.RowCount - lower) | 0) + i1) | 0), ((((this.ColumnCount - right) | 0) + j5) | 0))));
                    }
                }
                return array;
            },
            /**
             * Returns a string 2D array that summarizes the content of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}            upperRows             
             * @param   {number}            lowerRows             
             * @param   {number}            minLeftColumns        
             * @param   {number}            rightColumns          
             * @param   {number}            maxWidth              
             * @param   {number}            padding               
             * @param   {string}            horizontalEllipsis    
             * @param   {string}            verticalEllipsis      
             * @param   {string}            diagonalEllipsis      
             * @param   {System.Func}       formatValue
             * @return  {Array.<string>}
             */
            ToMatrixStringArray: function (upperRows, lowerRows, minLeftColumns, rightColumns, maxWidth, padding, horizontalEllipsis, verticalEllipsis, diagonalEllipsis, formatValue) {
                var $t, $t1, $t2, $t3;
                upperRows = Math.max(upperRows, 1);
                lowerRows = Math.max(lowerRows, 0);
                minLeftColumns = Math.max(minLeftColumns, 1);
                maxWidth = Math.max(maxWidth, 12);

                var upper = this.RowCount <= upperRows ? this.RowCount : upperRows;
                var lower = this.RowCount <= upperRows ? 0 : this.RowCount <= ((upperRows + lowerRows) | 0) ? ((this.RowCount - upperRows) | 0) : lowerRows;
                var rowEllipsis = this.RowCount > ((upper + lower) | 0);
                var rows = rowEllipsis ? ((((upper + lower) | 0) + 1) | 0) : ((upper + lower) | 0);

                var left = this.ColumnCount <= minLeftColumns ? this.ColumnCount : minLeftColumns;
                var right = this.ColumnCount <= minLeftColumns ? 0 : this.ColumnCount <= ((minLeftColumns + rightColumns) | 0) ? ((this.ColumnCount - minLeftColumns) | 0) : rightColumns;

                var columnsLeft = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Array.type(System.String)))).ctor();
                for (var j = 0; j < left; j = (j + 1) | 0) {
                    columnsLeft.add(this.FormatColumn(j, rows, upper, lower, rowEllipsis, verticalEllipsis, formatValue));
                }

                var columnsRight = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Array.type(System.String)))).ctor();
                for (var j1 = 0; j1 < right; j1 = (j1 + 1) | 0) {
                    columnsRight.add(this.FormatColumn(((((this.ColumnCount - right) | 0) + j1) | 0), rows, upper, lower, rowEllipsis, verticalEllipsis, formatValue));
                }

                var chars = (System.Linq.Enumerable.from(columnsLeft, System.Tuple$2(System.Int32,System.Array.type(System.String))).sum(function (t) {
                        return ((t.Item1 + padding) | 0);
                    }) + System.Linq.Enumerable.from(columnsRight, System.Tuple$2(System.Int32,System.Array.type(System.String))).sum(function (t) {
                        return ((t.Item1 + padding) | 0);
                    })) | 0;
                for (var j2 = left; j2 < ((this.ColumnCount - right) | 0); j2 = (j2 + 1) | 0) {
                    var candidate = this.FormatColumn(j2, rows, upper, lower, rowEllipsis, verticalEllipsis, formatValue);
                    chars = (chars + (((candidate.Item1 + padding) | 0))) | 0;
                    if (chars > maxWidth) {
                        break;
                    }
                    columnsLeft.add(candidate);
                }

                var cols = (columnsLeft.Count + columnsRight.Count) | 0;
                var colEllipsis = this.ColumnCount > cols;
                if (colEllipsis) {
                    cols = (cols + 1) | 0;
                }

                var array = System.Array.create(null, null, System.String, rows, cols);
                var colIndex = 0;
                $t = Bridge.getEnumerator(columnsLeft);
                try {
                    while ($t.moveNext()) {
                        var column = $t.Current;
                        for (var i = 0; i < column.Item2.length; i = (i + 1) | 0) {
                            array.set([i, colIndex], ($t1 = column.Item2)[System.Array.index(i, $t1)]);
                        }
                        colIndex = (colIndex + 1) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (colEllipsis) {
                    var rowIndex = 0;
                    for (var row = 0; row < upper; row = (row + 1) | 0) {
                        array.set([Bridge.identity(rowIndex, ((rowIndex = (rowIndex + 1) | 0))), colIndex], horizontalEllipsis);
                    }
                    if (rowEllipsis) {
                        array.set([Bridge.identity(rowIndex, ((rowIndex = (rowIndex + 1) | 0))), colIndex], diagonalEllipsis);
                    }
                    for (var row1 = (this.RowCount - lower) | 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                        array.set([Bridge.identity(rowIndex, ((rowIndex = (rowIndex + 1) | 0))), colIndex], horizontalEllipsis);
                    }
                    colIndex = (colIndex + 1) | 0;
                }
                $t2 = Bridge.getEnumerator(columnsRight);
                try {
                    while ($t2.moveNext()) {
                        var column1 = $t2.Current;
                        for (var i1 = 0; i1 < column1.Item2.length; i1 = (i1 + 1) | 0) {
                            array.set([i1, colIndex], ($t3 = column1.Item2)[System.Array.index(i1, $t3)]);
                        }
                        colIndex = (colIndex + 1) | 0;
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
                return array;
            },
            FormatColumn: function (column, height, upper, lower, withEllipsis, ellipsis, formatValue) {
                var c = System.Array.init(height, null, System.String);
                var index = 0;
                for (var row = 0; row < upper; row = (row + 1) | 0) {
                    c[System.Array.index(Bridge.identity(index, ((index = (index + 1) | 0))), c)] = formatValue(this.At(row, column));
                }
                if (withEllipsis) {
                    c[System.Array.index(Bridge.identity(index, ((index = (index + 1) | 0))), c)] = "";
                }
                for (var row1 = (this.RowCount - lower) | 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                    c[System.Array.index(Bridge.identity(index, ((index = (index + 1) | 0))), c)] = formatValue(this.At(row1, column));
                }
                var w = System.Linq.Enumerable.from(c, System.String).max(function (x) {
                        return x.length;
                    });
                if (withEllipsis) {
                    c[System.Array.index(upper, c)] = ellipsis;
                }
                return { Item1: w, Item2: c };
            },
            ToMatrixString$1: function (upperRows, lowerRows, leftColumns, rightColumns, horizontalEllipsis, verticalEllipsis, diagonalEllipsis, columnSeparator, rowSeparator, formatValue) {
                return MathNet.Numerics.LinearAlgebra.Matrix$1(T).FormatStringArrayToString(this.ToMatrixStringArray$1(upperRows, lowerRows, leftColumns, rightColumns, horizontalEllipsis, verticalEllipsis, diagonalEllipsis, formatValue), columnSeparator, rowSeparator);
            },
            ToMatrixString: function (upperRows, lowerRows, minLeftColumns, rightColumns, maxWidth, horizontalEllipsis, verticalEllipsis, diagonalEllipsis, columnSeparator, rowSeparator, formatValue) {
                return MathNet.Numerics.LinearAlgebra.Matrix$1(T).FormatStringArrayToString(this.ToMatrixStringArray(upperRows, lowerRows, minLeftColumns, rightColumns, maxWidth, columnSeparator.length, horizontalEllipsis, verticalEllipsis, diagonalEllipsis, formatValue), columnSeparator, rowSeparator);
            },
            /**
             * Returns a string that summarizes the content of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}                    maxRows       
             * @param   {number}                    maxColumns    
             * @param   {string}                    format        
             * @param   {System.IFormatProvider}    provider
             * @return  {string}
             */
            ToMatrixString$2: function (maxRows, maxColumns, format, provider) {
                if (format === void 0) { format = null; }
                if (provider === void 0) { provider = null; }
                if (format == null) {
                    format = "G6";
                }

                var bottom = maxRows > 4 ? 2 : 0;
                var right = maxColumns > 4 ? 2 : 0;
                return this.ToMatrixString$1(((maxRows - bottom) | 0), bottom, ((maxColumns - right) | 0), right, "..", "..", "..", "  ", "\n", function (x) {
                    return Bridge.toString(x);
                });
            },
            /**
             * Returns a string that summarizes the content of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {string}                    format      
             * @param   {System.IFormatProvider}    provider
             * @return  {string}
             */
            ToMatrixString$3: function (format, provider) {
                if (format === void 0) { format = null; }
                if (provider === void 0) { provider = null; }
                if (format == null) {
                    format = "G6";
                }

                return this.ToMatrixString(8, 4, 5, 2, 76, "..", "..", "..", "  ", "\n", function (x) {
                    return Bridge.toString(x);
                });
            },
            /**
             * Returns a string that summarizes this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}                    maxRows           
             * @param   {number}                    maxColumns        
             * @param   {string}                    format            
             * @param   {System.IFormatProvider}    formatProvider
             * @return  {string}
             */
            ToString: function (maxRows, maxColumns, format, formatProvider) {
                if (format === void 0) { format = null; }
                if (formatProvider === void 0) { formatProvider = null; }
                return System.String.concat(this.ToTypeString(), "\n", this.ToMatrixString$2(maxRows, maxColumns, format, formatProvider));
            },
            /**
             * Returns a string that summarizes this matrix.
             The maximum number of cells can be configured in the {@link } class.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {string}
             */
            toString: function () {
                return System.String.concat(this.ToTypeString(), "\n", this.ToMatrixString$3());
            },
            /**
             * Returns a string that summarizes this matrix.
             The maximum number of cells can be configured in the {@link } class.
             The format string is ignored.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {string}                    format            
             * @param   {System.IFormatProvider}    formatProvider
             * @return  {string}
             */
            format: function (format, formatProvider) {
                if (format === void 0) { format = null; }
                if (formatProvider === void 0) { formatProvider = null; }
                return System.String.concat(this.ToTypeString(), "\n", this.ToMatrixString$3(format, formatProvider));
            },
            /**
             * Retrieves the requested element without range checking.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}    row       The row of the element.
             * @param   {number}    column    The column of the element.
             * @return  {T}                   The requested element.
             */
            At: function (row, column) {
                return this.Storage.At(row, column);
            },
            /**
             * Sets the value of the given element without range checking.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}    row       The row of the element.
             * @param   {number}    column    The column of the element.
             * @param   {T}         value     The value to set the element to.
             * @return  {void}
             */
            At$1: function (row, column, value) {
                this.Storage.At$1(row, column, value);
            },
            /**
             * Sets all values to zero.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {void}
             */
            Clear: function () {
                this.Storage.Clear();
            },
            /**
             * Sets all values of a row to zero.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}    rowIndex
             * @return  {void}
             */
            ClearRow: function (rowIndex) {
                if ((rowIndex >>> 0) >= ((this.RowCount) >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowIndex");
                }

                this.Storage.ClearUnchecked(rowIndex, 1, 0, this.ColumnCount);
            },
            /**
             * Sets all values of a column to zero.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}    columnIndex
             * @return  {void}
             */
            ClearColumn: function (columnIndex) {
                if ((columnIndex >>> 0) >= ((this.ColumnCount) >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnIndex");
                }

                this.Storage.ClearUnchecked(0, this.RowCount, columnIndex, 1);
            },
            /**
             * Sets all values for all of the chosen rows to zero.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Array.<number>}    rowIndices
             * @return  {void}
             */
            ClearRows: function (rowIndices) {
                if (rowIndices === void 0) { rowIndices = []; }
                this.Storage.ClearRows(rowIndices);
            },
            /**
             * Sets all values for all of the chosen columns to zero.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Array.<number>}    columnIndices
             * @return  {void}
             */
            ClearColumns: function (columnIndices) {
                if (columnIndices === void 0) { columnIndices = []; }
                this.Storage.ClearColumns(columnIndices);
            },
            /**
             * Sets all values of a sub-matrix to zero.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}    rowIndex       
             * @param   {number}    rowCount       
             * @param   {number}    columnIndex    
             * @param   {number}    columnCount
             * @return  {void}
             */
            ClearSubMatrix: function (rowIndex, rowCount, columnIndex, columnCount) {
                this.Storage.Clear$1(rowIndex, rowCount, columnIndex, columnCount);
            },
            /**
             * Set all values that meet the predicate to zero, in-place.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Func}    zeroPredicate
             * @return  {void}
             */
            CoerceZero$1: function (zeroPredicate) {
                this.MapInplace(function (x) {
                    return zeroPredicate(x) ? MathNet.Numerics.LinearAlgebra.Matrix$1(T).Zero : x;
                }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Copies the elements of this matrix to the given matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If target is {@link ArgumentNullException}.
             * @throws If this and the target matrix do not have the same dimensions..
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    target    The matrix to copy values into.
             * @return  {void}
             */
            CopyTo: function (target) {
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                this.Storage.CopyTo(target.Storage);
            },
            /**
             * Copies a row into an Vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is negative,
             or greater than or equal to the number of rows.
             * @param   {number}                                     index    The row to copy.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}             A Vector containing the copied elements.
             */
            Row: function (index) {
                if ((index >>> 0) >= ((this.RowCount) >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                var ret = this.v_builder.SameAs$3(T, this, this.ColumnCount);
                this.Storage.CopySubRowToUnchecked(ret.Storage, index, 0, 0, this.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return ret;
            },
            /**
             * Copies a row into to the given Vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the result vector is {@link ArgumentNullException}.
             * @throws If <b /> is negative,
             or greater than or equal to the number of rows.
             * @throws If <b>this.Columns != result.Count</b>.
             * @param   {number}                                     index     The row to copy.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The Vector to copy the row into.
             * @return  {void}
             */
            Row$2: function (index, result) {
                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                this.Storage.CopyRowTo(result.Storage, index);
            },
            /**
             * Copies the requested row elements into a new Vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If:
             * @throws If <b /> is not positive.
             * @param   {number}                                     rowIndex       The row to copy elements from.
             * @param   {number}                                     columnIndex    The column to start copying from.
             * @param   {number}                                     length         The number of elements to copy.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                   A Vector containing the requested elements.
             */
            Row$1: function (rowIndex, columnIndex, length) {
                var ret = this.v_builder.SameAs$3(T, this, length);
                this.Storage.CopySubRowTo(ret.Storage, rowIndex, columnIndex, 0, length);
                return ret;
            },
            /**
             * Copies the requested row elements into a new Vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the result Vector is {@link ArgumentNullException}.
             * @throws If <b /> is negative,
             or greater than or equal to the number of columns.
             * @throws If <b /> is negative,
             or greater than or equal to the number of rows.
             * @throws If <b /> + <b />
             is greater than or equal to the number of rows.
             * @throws If <b /> is not positive.
             * @throws If <strong>result.Count &lt; length</strong>.
             * @param   {number}                                     rowIndex       The row to copy elements from.
             * @param   {number}                                     columnIndex    The column to start copying from.
             * @param   {number}                                     length         The number of elements to copy.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result         The Vector to copy the column into.
             * @return  {void}
             */
            Row$3: function (rowIndex, columnIndex, length, result) {
                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                this.Storage.CopySubRowTo(result.Storage, rowIndex, columnIndex, 0, length);
            },
            /**
             * Copies a column into a new Vector&gt;.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is negative,
             or greater than or equal to the number of columns.
             * @param   {number}                                     index    The column to copy.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}             A Vector containing the copied elements.
             */
            Column: function (index) {
                if ((index >>> 0) >= ((this.ColumnCount) >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                var ret = this.v_builder.SameAs$3(T, this, this.RowCount);
                this.Storage.CopySubColumnToUnchecked(ret.Storage, index, 0, 0, this.RowCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return ret;
            },
            /**
             * Copies a column into to the given Vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the result Vector is {@link ArgumentNullException}.
             * @throws If <b /> is negative,
             or greater than or equal to the number of columns.
             * @throws If <b>this.Rows != result.Count</b>.
             * @param   {number}                                     index     The column to copy.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The Vector to copy the column into.
             * @return  {void}
             */
            Column$2: function (index, result) {
                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                this.Storage.CopyColumnTo(result.Storage, index);
            },
            /**
             * Copies the requested column elements into a new Vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If:
             * @throws If <b /> is not positive.
             * @param   {number}                                     columnIndex    The column to copy elements from.
             * @param   {number}                                     rowIndex       The row to start copying from.
             * @param   {number}                                     length         The number of elements to copy.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                   A Vector containing the requested elements.
             */
            Column$1: function (columnIndex, rowIndex, length) {
                var ret = this.v_builder.SameAs$3(T, this, length);
                this.Storage.CopySubColumnTo(ret.Storage, columnIndex, rowIndex, 0, length);
                return ret;
            },
            /**
             * Copies the requested column elements into the given vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If the result Vector is {@link ArgumentNullException}.
             * @throws If <b /> is negative,
             or greater than or equal to the number of columns.
             * @throws If <b /> is negative,
             or greater than or equal to the number of rows.
             * @throws If <b /> + <b />
             is greater than or equal to the number of rows.
             * @throws If <b /> is not positive.
             * @throws If <strong>result.Count &lt; length</strong>.
             * @param   {number}                                     columnIndex    The column to copy elements from.
             * @param   {number}                                     rowIndex       The row to start copying from.
             * @param   {number}                                     length         The number of elements to copy.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result         The Vector to copy the column into.
             * @return  {void}
             */
            Column$3: function (columnIndex, rowIndex, length, result) {
                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                this.Storage.CopySubColumnTo(result.Storage, columnIndex, rowIndex, 0, length);
            },
            /**
             * Returns a new matrix containing the upper triangle of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The upper triangle of this matrix.
             */
            UpperTriangle: function () {
                var result = this.m_builder.SameAs$3(T, this);
                for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                    for (var column = row; column < this.ColumnCount; column = (column + 1) | 0) {
                        result.At$1(row, column, this.At(row, column));
                    }
                }
                return result;
            },
            /**
             * Puts the upper triangle of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            UpperTriangle$1: function (result) {
                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                    for (var column = 0; column < this.ColumnCount; column = (column + 1) | 0) {
                        result.At$1(row, column, row <= column ? this.At(row, column) : MathNet.Numerics.LinearAlgebra.Matrix$1(T).Zero);
                    }
                }
            },
            /**
             * Returns a new matrix containing the lower triangle of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The lower triangle of this matrix.
             */
            LowerTriangle: function () {
                var result = this.m_builder.SameAs$3(T, this);
                for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                    for (var column = 0; column <= row && column < this.ColumnCount; column = (column + 1) | 0) {
                        result.At$1(row, column, this.At(row, column));
                    }
                }
                return result;
            },
            /**
             * Puts the lower triangle of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            LowerTriangle$1: function (result) {
                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                    for (var column = 0; column < this.ColumnCount; column = (column + 1) | 0) {
                        result.At$1(row, column, row >= column ? this.At(row, column) : MathNet.Numerics.LinearAlgebra.Matrix$1(T).Zero);
                    }
                }
            },
            /**
             * Creates a matrix that contains the values from the requested sub-matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If:
             * @throws If <b /> or <b />
             is not positive.
             * @param   {number}                                     rowIndex       The row to start copying from.
             * @param   {number}                                     rowCount       The number of rows to copy. Must be positive.
             * @param   {number}                                     columnIndex    The column to start copying from.
             * @param   {number}                                     columnCount    The number of columns to copy. Must be positive.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                   The requested sub-matrix.
             */
            SubMatrix: function (rowIndex, rowCount, columnIndex, columnCount) {
                var result = this.m_builder.SameAs$4(T, this, rowCount, columnCount);
                this.Storage.CopySubMatrixTo(result.Storage, rowIndex, 0, rowCount, columnIndex, 0, columnCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Returns the elements of the diagonal in a Vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}        The elements of the diagonal.
             */
            Diagonal: function () {
                var min = Math.min(this.RowCount, this.ColumnCount);
                var diagonal = this.v_builder.SameAs$3(T, this, min);

                for (var i = 0; i < min; i = (i + 1) | 0) {
                    diagonal.At$1(i, this.At(i, i));
                }

                return diagonal;
            },
            /**
             * Returns a new matrix containing the lower triangle of this matrix. The new matrix
             does not contain the diagonal elements of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The lower triangle of this matrix.
             */
            StrictlyLowerTriangle: function () {
                var result = this.m_builder.SameAs$3(T, this);
                for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                    var columns = Math.min(row, this.ColumnCount);
                    for (var column = 0; column < columns; column = (column + 1) | 0) {
                        result.At$1(row, column, this.At(row, column));
                    }
                }
                return result;
            },
            /**
             * Puts the strictly lower triangle of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            StrictlyLowerTriangle$1: function (result) {
                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                    for (var column = 0; column < this.ColumnCount; column = (column + 1) | 0) {
                        result.At$1(row, column, row > column ? this.At(row, column) : MathNet.Numerics.LinearAlgebra.Matrix$1(T).Zero);
                    }
                }
            },
            /**
             * Returns a new matrix containing the upper triangle of this matrix. The new matrix
             does not contain the diagonal elements of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The upper triangle of this matrix.
             */
            StrictlyUpperTriangle: function () {
                var result = this.m_builder.SameAs$3(T, this);
                for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                    for (var column = (row + 1) | 0; column < this.ColumnCount; column = (column + 1) | 0) {
                        result.At$1(row, column, this.At(row, column));
                    }
                }
                return result;
            },
            /**
             * Puts the strictly upper triangle of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            StrictlyUpperTriangle$1: function (result) {
                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                    for (var column = 0; column < this.ColumnCount; column = (column + 1) | 0) {
                        result.At$1(row, column, row < column ? this.At(row, column) : MathNet.Numerics.LinearAlgebra.Matrix$1(T).Zero);
                    }
                }
            },
            /**
             * Creates a new matrix and inserts the given column at the given index.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If <b /> is &lt; zero or &gt; the number of columns.
             * @throws If the size of <b /> != the number of rows.
             * @param   {number}                                     columnIndex    The index of where to insert the column.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    column         The column to insert.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                   A new matrix with the inserted column.
             */
            InsertColumn: function (columnIndex, column) {
                if (column == null) {
                    throw new System.ArgumentNullException.$ctor1("column");
                }

                if ((columnIndex >>> 0) > ((this.ColumnCount) >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnIndex");
                }

                if (column.Count !== this.RowCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameRowDimension{0}", "column");
                }

                var result = this.m_builder.SameAs$4(T, this, this.RowCount, ((this.ColumnCount + 1) | 0), true);
                this.Storage.CopySubMatrixTo(result.Storage, 0, 0, this.RowCount, 0, 0, columnIndex, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                result.SetColumn$1(columnIndex, column);
                this.Storage.CopySubMatrixTo(result.Storage, 0, 0, this.RowCount, columnIndex, ((columnIndex + 1) | 0), ((this.ColumnCount - columnIndex) | 0), MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Creates a new matrix with the given column removed.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is &lt; zero or &gt;= the number of columns.
             * @param   {number}                                     columnIndex    The index of the column to remove.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                   A new matrix without the chosen column.
             */
            RemoveColumn: function (columnIndex) {
                if ((columnIndex >>> 0) >= ((this.ColumnCount) >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnIndex");
                }

                var result = this.m_builder.SameAs$4(T, this, this.RowCount, ((this.ColumnCount - 1) | 0), true);
                this.Storage.CopySubMatrixTo(result.Storage, 0, 0, this.RowCount, 0, 0, columnIndex, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                this.Storage.CopySubMatrixTo(result.Storage, 0, 0, this.RowCount, ((columnIndex + 1) | 0), columnIndex, ((((this.ColumnCount - columnIndex) | 0) - 1) | 0), MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Copies the values of the given Vector to the specified column.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If <b /> is less than zero,
             or greater than or equal to the number of columns.
             * @throws If the size of <b /> does not
             equal the number of rows of this <strong>Matrix</strong>.
             * @param   {number}                                     columnIndex    The column to copy the values to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    column         The vector to copy the values from.
             * @return  {void}
             */
            SetColumn$1: function (columnIndex, column) {
                if (column == null) {
                    throw new System.ArgumentNullException.$ctor1("column");
                }

                column.Storage.CopyToColumn(this.Storage, columnIndex);
            },
            /**
             * Copies the values of the given Vector to the specified sub-column.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If <b /> is less than zero,
             or greater than or equal to the number of columns.
             * @throws If the size of <b /> does not
             equal the number of rows of this <strong>Matrix</strong>.
             * @param   {number}                                     columnIndex    The column to copy the values to.
             * @param   {number}                                     rowIndex       The row to start copying to.
             * @param   {number}                                     length         The number of elements to copy.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    column         The vector to copy the values from.
             * @return  {void}
             */
            SetColumn$2: function (columnIndex, rowIndex, length, column) {
                if (column == null) {
                    throw new System.ArgumentNullException.$ctor1("column");
                }

                column.Storage.CopyToSubColumn(this.Storage, columnIndex, 0, rowIndex, length);
            },
            /**
             * Copies the values of the given array to the specified column.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If <b /> is less than zero,
             or greater than or equal to the number of columns.
             * @throws If the size of <b /> does not
             equal the number of rows of this <strong>Matrix</strong>.
             * @throws If the size of <b /> does not
             equal the number of rows of this <strong>Matrix</strong>.
             * @param   {number}       columnIndex    The column to copy the values to.
             * @param   {Array.<T>}    column         The array to copy the values from.
             * @return  {void}
             */
            SetColumn: function (columnIndex, column) {
                if (column == null) {
                    throw new System.ArgumentNullException.$ctor1("column");
                }

                new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).$ctor1(column.length, column).CopyToColumn(this.Storage, columnIndex);
            },
            /**
             * Creates a new matrix and inserts the given row at the given index.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If <b /> is &lt; zero or &gt; the number of rows.
             * @throws If the size of <b /> != the number of columns.
             * @param   {number}                                     rowIndex    The index of where to insert the row.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    row         The row to insert.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                A new matrix with the inserted column.
             */
            InsertRow: function (rowIndex, row) {
                if (row == null) {
                    throw new System.ArgumentNullException.$ctor1("row");
                }

                if ((rowIndex >>> 0) > ((this.RowCount) >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowIndex");
                }

                if (row.Count !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameRowDimension{0}", "row");
                }

                var result = this.m_builder.SameAs$4(T, this, ((this.RowCount + 1) | 0), this.ColumnCount, true);
                this.Storage.CopySubMatrixTo(result.Storage, 0, 0, rowIndex, 0, 0, this.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                result.SetRow$1(rowIndex, row);
                this.Storage.CopySubMatrixTo(result.Storage, rowIndex, ((rowIndex + 1) | 0), ((this.RowCount - rowIndex) | 0), 0, 0, this.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Creates a new matrix with the given row removed.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is &lt; zero or &gt;= the number of rows.
             * @param   {number}                                     rowIndex    The index of the row to remove.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                A new matrix without the chosen row.
             */
            RemoveRow: function (rowIndex) {
                if ((rowIndex >>> 0) >= ((this.RowCount) >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowIndex");
                }

                var result = this.m_builder.SameAs$4(T, this, ((this.RowCount - 1) | 0), this.ColumnCount, true);
                this.Storage.CopySubMatrixTo(result.Storage, 0, 0, rowIndex, 0, 0, this.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                this.Storage.CopySubMatrixTo(result.Storage, ((rowIndex + 1) | 0), rowIndex, ((((this.RowCount - rowIndex) | 0) - 1) | 0), 0, 0, this.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Copies the values of the given Vector to the specified row.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If <b /> is less than zero,
             or greater than or equal to the number of rows.
             * @throws If the size of <b /> does not
             equal the number of columns of this <strong>Matrix</strong>.
             * @param   {number}                                     rowIndex    The row to copy the values to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    row         The vector to copy the values from.
             * @return  {void}
             */
            SetRow$1: function (rowIndex, row) {
                if (row == null) {
                    throw new System.ArgumentNullException.$ctor1("row");
                }

                row.Storage.CopyToRow(this.Storage, rowIndex);
            },
            /**
             * Copies the values of the given Vector to the specified sub-row.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If <b /> is less than zero,
             or greater than or equal to the number of rows.
             * @throws If the size of <b /> does not
             equal the number of columns of this <strong>Matrix</strong>.
             * @param   {number}                                     rowIndex       The row to copy the values to.
             * @param   {number}                                     columnIndex    The column to start copying to.
             * @param   {number}                                     length         The number of elements to copy.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    row            The vector to copy the values from.
             * @return  {void}
             */
            SetRow$2: function (rowIndex, columnIndex, length, row) {
                if (row == null) {
                    throw new System.ArgumentNullException.$ctor1("row");
                }

                row.Storage.CopyToSubRow(this.Storage, rowIndex, 0, columnIndex, length);
            },
            /**
             * Copies the values of the given array to the specified row.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If <b /> is less than zero,
             or greater than or equal to the number of rows.
             * @throws If the size of <b /> does not
             equal the number of columns of this <strong>Matrix</strong>.
             * @param   {number}       rowIndex    The row to copy the values to.
             * @param   {Array.<T>}    row         The array to copy the values from.
             * @return  {void}
             */
            SetRow: function (rowIndex, row) {
                if (row == null) {
                    throw new System.ArgumentNullException.$ctor1("row");
                }

                new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).$ctor1(row.length, row).CopyToRow(this.Storage, rowIndex);
            },
            /**
             * Copies the values of a given matrix into a region in this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If:
             * @param   {number}                                     rowIndex       The row to start copying to.
             * @param   {number}                                     columnIndex    The column to start copying to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    subMatrix      The sub-matrix to copy from.
             * @return  {void}
             */
            SetSubMatrix: function (rowIndex, columnIndex, subMatrix) {
                subMatrix.Storage.CopySubMatrixTo(this.Storage, 0, rowIndex, subMatrix.RowCount, 0, columnIndex, subMatrix.ColumnCount);
            },
            /**
             * Copies the values of a given matrix into a region in this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If:
             * @throws If <b /> or <b />
             is not positive.
             * @param   {number}                                     rowIndex       The row to start copying to.
             * @param   {number}                                     rowCount       The number of rows to copy. Must be positive.
             * @param   {number}                                     columnIndex    The column to start copying to.
             * @param   {number}                                     columnCount    The number of columns to copy. Must be positive.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    subMatrix      The sub-matrix to copy from.
             * @return  {void}
             */
            SetSubMatrix$1: function (rowIndex, rowCount, columnIndex, columnCount, subMatrix) {
                subMatrix.Storage.CopySubMatrixTo(this.Storage, 0, rowIndex, rowCount, 0, columnIndex, columnCount);
            },
            /**
             * Copies the values of a given matrix into a region in this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If:
             * @throws If <b /> or <b />
             is not positive.
             * @param   {number}                                     rowIndex             The row to start copying to.
             * @param   {number}                                     sorceRowIndex        The row of the sub-matrix to start copying from.
             * @param   {number}                                     rowCount             The number of rows to copy. Must be positive.
             * @param   {number}                                     columnIndex          The column to start copying to.
             * @param   {number}                                     sourceColumnIndex    The column of the sub-matrix to start copying from.
             * @param   {number}                                     columnCount          The number of columns to copy. Must be positive.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    subMatrix            The sub-matrix to copy from.
             * @return  {void}
             */
            SetSubMatrix$2: function (rowIndex, sorceRowIndex, rowCount, columnIndex, sourceColumnIndex, columnCount, subMatrix) {
                subMatrix.Storage.CopySubMatrixTo(this.Storage, sorceRowIndex, rowIndex, rowCount, sourceColumnIndex, columnIndex, columnCount);
            },
            /**
             * Copies the values of the given Vector to the diagonal.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If the length of <b /> does not
             equal Min(Rows, Columns).
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    source    The vector to copy the values from. The length of the vector should be
             Min(Rows, Columns).
             * @return  {void}
             */
            SetDiagonal$1: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException.$ctor1("source");
                }

                var min = Math.min(this.RowCount, this.ColumnCount);

                if (source.Count !== min) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength{0}", "source");
                }

                for (var i = 0; i < min; i = (i + 1) | 0) {
                    this.At$1(i, i, source.At(i));
                }
            },
            /**
             * Copies the values of the given array to the diagonal.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If the length of <b /> does not
             equal Min(Rows, Columns).
             * @param   {Array.<T>}    source    The array to copy the values from. The length of the vector should be
             Min(Rows, Columns).
             * @return  {void}
             */
            SetDiagonal: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException.$ctor1("source");
                }

                var min = Math.min(this.RowCount, this.ColumnCount);

                if (source.length !== min) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentArraysSameLength{0}", "source");
                }

                for (var i = 0; i < min; i = (i + 1) | 0) {
                    this.At$1(i, i, source[System.Array.index(i, source)]);
                }
            },
            /**
             * Returns the transpose of this matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The transpose of this matrix.
             */
            Transpose: function () {

                var result = this.m_builder.SameAs$4(T, this, this.ColumnCount, this.RowCount);
                this.Storage.TransposeToUnchecked(result.Storage, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Puts the transpose of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result
             * @return  {void}
             */
            Transpose$1: function (result) {
                this.Storage.TransposeTo(result.Storage, MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
            },
            /**
             * Permute the rows of a matrix according to a permutation.
             * Permute the columns of a matrix according to a permutation.
             * Concatenates this matrix with the given matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    right    The matrix to concatenate.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The combined matrix.
             * @see {@link Stack(Matrix{T})}
             * @see {@link DiagonalStack(Matrix{T})}
             */
            Append: function (right) {
                if (right == null) {
                    throw new System.ArgumentNullException.$ctor1("right");
                }

                if (right.RowCount !== this.RowCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSameRowDimension");
                }

                var result = this.m_builder.SameAs$1(this, right, this.RowCount, ((this.ColumnCount + right.ColumnCount) | 0), true);
                this.Storage.CopySubMatrixToUnchecked(result.Storage, 0, 0, this.RowCount, 0, 0, this.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                right.Storage.CopySubMatrixToUnchecked(result.Storage, 0, 0, right.RowCount, 0, this.ColumnCount, right.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Concatenates this matrix with the given matrix and places the result into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    right     The matrix to concatenate.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The combined matrix.
             * @return  {void}
             * @see {@link Stack(Matrix{T}, Matrix{T})}
             * @see {@link DiagonalStack(Matrix{T}, Matrix{T})}
             */
            Append$1: function (right, result) {
                if (right == null) {
                    throw new System.ArgumentNullException.$ctor1("right");
                }

                if (right.RowCount !== this.RowCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSameRowDimension");
                }

                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (result.ColumnCount !== (((this.ColumnCount + right.ColumnCount) | 0)) || result.RowCount !== this.RowCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSameColumnDimension");
                }

                this.Storage.CopySubMatrixToUnchecked(result.Storage, 0, 0, this.RowCount, 0, 0, this.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
                right.Storage.CopySubMatrixToUnchecked(result.Storage, 0, 0, right.RowCount, 0, this.ColumnCount, right.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
            },
            /**
             * Stacks this matrix on top of the given matrix and places the result into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If lower is {@link ArgumentNullException}.
             * @throws If <strong>upper.Columns != lower.Columns</strong>.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    lower    The matrix to stack this matrix upon.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The combined matrix.
             * @see {@link Append(Matrix{T})}
             * @see {@link DiagonalStack(Matrix{T})}
             */
            Stack: function (lower) {
                if (lower == null) {
                    throw new System.ArgumentNullException.$ctor1("lower");
                }

                if (lower.ColumnCount !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameColumnDimension{0}", "lower");
                }

                var result = this.m_builder.SameAs$1(this, lower, ((this.RowCount + lower.RowCount) | 0), this.ColumnCount, true);
                this.Storage.CopySubMatrixToUnchecked(result.Storage, 0, 0, this.RowCount, 0, 0, this.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                lower.Storage.CopySubMatrixToUnchecked(result.Storage, 0, this.RowCount, lower.RowCount, 0, 0, lower.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Stacks this matrix on top of the given matrix and places the result into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If lower is {@link ArgumentNullException}.
             * @throws If <strong>upper.Columns != lower.Columns</strong>.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    lower     The matrix to stack this matrix upon.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The combined matrix.
             * @return  {void}
             * @see {@link Append(Matrix{T}, Matrix{T})}
             * @see {@link DiagonalStack(Matrix{T}, Matrix{T})}
             */
            Stack$1: function (lower, result) {
                if (lower == null) {
                    throw new System.ArgumentNullException.$ctor1("lower");
                }

                if (lower.ColumnCount !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameColumnDimension{0}", "lower");
                }

                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (result.RowCount !== (((this.RowCount + lower.RowCount) | 0)) || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                this.Storage.CopySubMatrixToUnchecked(result.Storage, 0, 0, this.RowCount, 0, 0, this.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
                lower.Storage.CopySubMatrixToUnchecked(result.Storage, 0, this.RowCount, lower.RowCount, 0, 0, lower.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
            },
            /**
             * Diagonally stacks his matrix on top of the given matrix. The new matrix is a M-by-N matrix,
             where M = this.Rows + lower.Rows and N = this.Columns + lower.Columns.
             The values of off the off diagonal matrices/blocks are set to zero.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If lower is {@link ArgumentNullException}.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    lower    The lower, right matrix.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             the combined matrix
             * @see {@link Stack(Matrix{T})}
             * @see {@link Append(Matrix{T})}
             */
            DiagonalStack: function (lower) {
                if (lower == null) {
                    throw new System.ArgumentNullException.$ctor1("lower");
                }

                var result = this.m_builder.SameAs$1(this, lower, ((this.RowCount + lower.RowCount) | 0), ((this.ColumnCount + lower.ColumnCount) | 0), this.RowCount !== this.ColumnCount);
                this.Storage.CopySubMatrixToUnchecked(result.Storage, 0, 0, this.RowCount, 0, 0, this.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                lower.Storage.CopySubMatrixToUnchecked(result.Storage, 0, this.RowCount, lower.RowCount, 0, this.ColumnCount, lower.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Diagonally stacks his matrix on top of the given matrix and places the combined matrix into the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @throws If lower is {@link ArgumentNullException}.
             * @throws If the result matrix is {@link ArgumentNullException}.
             * @throws If the result matrix's dimensions are not (this.Rows + lower.rows) x (this.Columns + lower.Columns).
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    lower     The lower, right matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The combined matrix
             * @return  {void}
             * @see {@link Stack(Matrix{T}, Matrix{T})}
             * @see {@link Append(Matrix{T}, Matrix{T})}
             */
            DiagonalStack$1: function (lower, result) {
                if (lower == null) {
                    throw new System.ArgumentNullException.$ctor1("lower");
                }

                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (result.RowCount !== ((this.RowCount + lower.RowCount) | 0) || result.ColumnCount !== ((this.ColumnCount + lower.ColumnCount) | 0)) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(T).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                this.Storage.CopySubMatrixToUnchecked(result.Storage, 0, 0, this.RowCount, 0, 0, this.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
                lower.Storage.CopySubMatrixToUnchecked(result.Storage, 0, this.RowCount, lower.RowCount, 0, this.ColumnCount, lower.ColumnCount, MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
            },
            /**
             * Evaluates whether this matrix is symmetric.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {boolean}
             */
            IsSymmetric: function () {
                if (this.RowCount !== this.ColumnCount) {
                    return false;
                }

                for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                    for (var column = (row + 1) | 0; column < this.ColumnCount; column = (column + 1) | 0) {
                        if (!Bridge.equals(this.At(row, column), this.At(column, row))) {
                            return false;
                        }
                    }
                }

                return true;
            },
            /**
             * Returns this matrix as a multidimensional array.
             The returned array will be independent from this matrix.
             A new memory block will be allocated for the array.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {Array.<T>}        A multidimensional containing the values of this matrix.
             */
            ToArray: function () {
                return this.Storage.ToArray();
            },
            /**
             * Returns the matrix's elements as an array with the data laid out column by column (column major).
             The returned array will be independent from this matrix.
             A new memory block will be allocated for the array.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @example <pre>
             1, 2, 3
             4, 5, 6  will be returned as  1, 4, 7, 2, 5, 8, 3, 6, 9
             7, 8, 9
             </pre>
             *
             *
             * @return  {Array.<T>}        An array containing the matrix's elements.
             * @see {@link ToRowMajorArray}
             * @see {@link Enumerate(Zeros)}
             */
            ToColumnMajorArray: function () {
                return this.Storage.ToColumnMajorArray();
            },
            /**
             * Returns the matrix's elements as an array with the data laid row by row (row major).
             The returned array will be independent from this matrix.
             A new memory block will be allocated for the array.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @example <pre>
             1, 2, 3
             4, 5, 6  will be returned as  1, 2, 3, 4, 5, 6, 7, 8, 9
             7, 8, 9
             </pre>
             *
             *
             * @return  {Array.<T>}        An array containing the matrix's elements.
             * @see {@link ToColumnMajorArray}
             * @see {@link Enumerate(Zeros)}
             */
            ToRowMajorArray: function () {
                return this.Storage.ToRowMajorArray();
            },
            /**
             * Returns this matrix as array of row arrays.
             The returned arrays will be independent from this matrix.
             A new memory block will be allocated for the arrays.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {Array.<Array.<T>>}
             */
            ToRowArrays: function () {
                return this.Storage.ToRowArrays();
            },
            /**
             * Returns this matrix as array of column arrays.
             The returned arrays will be independent from this matrix.
             A new memory block will be allocated for the arrays.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {Array.<Array.<T>>}
             */
            ToColumnArrays: function () {
                return this.Storage.ToColumnArrays();
            },
            /**
             * Returns the internal multidimensional array of this matrix if, and only if, this matrix is stored by such an array internally.
             Otherwise returns null. Changes to the returned array and the matrix will affect each other.
             Use ToArray instead if you always need an independent array.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {Array.<T>}
             */
            AsArray: function () {
                return this.Storage.AsArray();
            },
            /**
             * Returns the internal column by column (column major) array of this matrix if, and only if, this matrix is stored by such arrays internally.
             Otherwise returns null. Changes to the returned arrays and the matrix will affect each other.
             Use ToColumnMajorArray instead if you always need an independent array.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @example <pre>
             1, 2, 3
             4, 5, 6  will be returned as  1, 4, 7, 2, 5, 8, 3, 6, 9
             7, 8, 9
             </pre>
             *
             *
             * @return  {Array.<T>}        An array containing the matrix's elements.
             * @see {@link ToRowMajorArray}
             * @see {@link Enumerate(Zeros)}
             */
            AsColumnMajorArray: function () {
                return this.Storage.AsColumnMajorArray();
            },
            /**
             * Returns the internal row by row (row major) array of this matrix if, and only if, this matrix is stored by such arrays internally.
             Otherwise returns null. Changes to the returned arrays and the matrix will affect each other.
             Use ToRowMajorArray instead if you always need an independent array.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @example <pre>
             1, 2, 3
             4, 5, 6  will be returned as  1, 2, 3, 4, 5, 6, 7, 8, 9
             7, 8, 9
             </pre>
             *
             *
             * @return  {Array.<T>}        An array containing the matrix's elements.
             * @see {@link ToColumnMajorArray}
             * @see {@link Enumerate(Zeros)}
             */
            AsRowMajorArray: function () {
                return this.Storage.AsRowMajorArray();
            },
            /**
             * Returns the internal row arrays of this matrix if, and only if, this matrix is stored by such arrays internally.
             Otherwise returns null. Changes to the returned arrays and the matrix will affect each other.
             Use ToRowArrays instead if you always need an independent array.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {Array.<Array.<T>>}
             */
            AsRowArrays: function () {
                return this.Storage.AsRowArrays();
            },
            /**
             * Returns the internal column arrays of this matrix if, and only if, this matrix is stored by such arrays internally.
             Otherwise returns null. Changes to the returned arrays and the matrix will affect each other.
             Use ToColumnArrays instead if you always need an independent array.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {Array.<Array.<T>>}
             */
            AsColumnArrays: function () {
                return this.Storage.AsColumnArrays();
            },
            /**
             * Returns an IEnumerable that can be used to iterate through all values of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            Enumerate: function () {
                return this.Storage.Enumerate();
            },
            /**
             * Returns an IEnumerable that can be used to iterate through all values of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}        zeros
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            Enumerate$1: function (zeros) {
                if (zeros === void 0) { zeros = 1; }
                switch (zeros) {
                    case MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip: 
                        return this.Storage.EnumerateNonZero();
                    default: 
                        return this.Storage.Enumerate();
                }
            },
            /**
             * Returns an IEnumerable that can be used to iterate through all values of the matrix and their index.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            EnumerateIndexed: function () {
                return this.Storage.EnumerateIndexed();
            },
            /**
             * Returns an IEnumerable that can be used to iterate through all values of the matrix and their index.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}        zeros
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            EnumerateIndexed$1: function (zeros) {
                if (zeros === void 0) { zeros = 1; }
                switch (zeros) {
                    case MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip: 
                        return this.Storage.EnumerateNonZeroIndexed();
                    default: 
                        return this.Storage.EnumerateIndexed();
                }
            },
            /**
             * Returns an IEnumerable that can be used to iterate through all columns of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            EnumerateColumns: function () {
                return new (Bridge.GeneratorEnumerable$1(MathNet.Numerics.LinearAlgebra.Vector$1(T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(MathNet.Numerics.LinearAlgebra.Vector$1(T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.ColumnCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = this.Column(i);
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            /**
             * Returns an IEnumerable that can be used to iterate through a subset of all columns of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}                                      index     The column to start enumerating over.
             * @param   {number}                                      length    The number of columns to enumerating over.
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            EnumerateColumns$1: function (index, length) {
                return new (Bridge.GeneratorEnumerable$1(MathNet.Numerics.LinearAlgebra.Vector$1(T)))(Bridge.fn.bind(this, function (index, length) {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        maxIndex,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(MathNet.Numerics.LinearAlgebra.Vector$1(T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        maxIndex = Math.min(((index + length) | 0), this.ColumnCount);
                                            i = Math.max(index, 0);
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < maxIndex ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = this.Column(i);
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }, arguments));
            },
            /**
             * Returns an IEnumerable that can be used to iterate through all columns of the matrix and their index.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            EnumerateColumnsIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$2(System.Int32,MathNet.Numerics.LinearAlgebra.Vector$1(T))))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$2(System.Int32,MathNet.Numerics.LinearAlgebra.Vector$1(T))))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.ColumnCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = { Item1: i, Item2: this.Column(i) };
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            /**
             * Returns an IEnumerable that can be used to iterate through a subset of all columns of the matrix and their index.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}                                      index     The column to start enumerating over.
             * @param   {number}                                      length    The number of columns to enumerating over.
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            EnumerateColumnsIndexed$1: function (index, length) {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$2(System.Int32,MathNet.Numerics.LinearAlgebra.Vector$1(T))))(Bridge.fn.bind(this, function (index, length) {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        maxIndex,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$2(System.Int32,MathNet.Numerics.LinearAlgebra.Vector$1(T))))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        maxIndex = Math.min(((index + length) | 0), this.ColumnCount);
                                            i = Math.max(index, 0);
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < maxIndex ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = { Item1: i, Item2: this.Column(i) };
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }, arguments));
            },
            /**
             * Returns an IEnumerable that can be used to iterate through all rows of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            EnumerateRows: function () {
                return new (Bridge.GeneratorEnumerable$1(MathNet.Numerics.LinearAlgebra.Vector$1(T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(MathNet.Numerics.LinearAlgebra.Vector$1(T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.RowCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = this.Row(i);
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            /**
             * Returns an IEnumerable that can be used to iterate through a subset of all rows of the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}                                      index     The row to start enumerating over.
             * @param   {number}                                      length    The number of rows to enumerating over.
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            EnumerateRows$1: function (index, length) {
                return new (Bridge.GeneratorEnumerable$1(MathNet.Numerics.LinearAlgebra.Vector$1(T)))(Bridge.fn.bind(this, function (index, length) {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        maxIndex,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(MathNet.Numerics.LinearAlgebra.Vector$1(T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        maxIndex = Math.min(((index + length) | 0), this.RowCount);
                                            i = Math.max(index, 0);
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < maxIndex ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = this.Row(i);
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }, arguments));
            },
            /**
             * Returns an IEnumerable that can be used to iterate through all rows of the matrix and their index.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            EnumerateRowsIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$2(System.Int32,MathNet.Numerics.LinearAlgebra.Vector$1(T))))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$2(System.Int32,MathNet.Numerics.LinearAlgebra.Vector$1(T))))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.RowCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = { Item1: i, Item2: this.Row(i) };
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            /**
             * Returns an IEnumerable that can be used to iterate through a subset of all rows of the matrix and their index.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {number}                                      index     The row to start enumerating over.
             * @param   {number}                                      length    The number of rows to enumerating over.
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            EnumerateRowsIndexed$1: function (index, length) {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$2(System.Int32,MathNet.Numerics.LinearAlgebra.Vector$1(T))))(Bridge.fn.bind(this, function (index, length) {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        maxIndex,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$2(System.Int32,MathNet.Numerics.LinearAlgebra.Vector$1(T))))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        maxIndex = Math.min(((index + length) | 0), this.RowCount);
                                            i = Math.max(index, 0);
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < maxIndex ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = { Item1: i, Item2: this.Row(i) };
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }, arguments));
            },
            /**
             * Applies a function to each value of this matrix and replaces the value with its result.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse matrices).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Func}                             f        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {void}
             */
            MapInplace: function (f, zeros) {
                if (zeros === void 0) { zeros = 0; }
                this.Storage.MapInplace(f, zeros);
            },
            /**
             * Applies a function to each value of this matrix and replaces the value with its result.
             The row and column indices of each value (zero-based) are passed as first arguments to the function.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse matrices).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Func}                             f        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {void}
             */
            MapIndexedInplace: function (f, zeros) {
                if (zeros === void 0) { zeros = 0; }
                this.Storage.MapIndexedInplace(f, zeros);
            },
            /**
             * Applies a function to each value of this matrix and replaces the value in the result matrix.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse matrices).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Func}                                f         
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {void}
             */
            Map$1: function (f, result, zeros) {
                if (zeros === void 0) { zeros = 0; }
                if (Bridge.referenceEquals(this, result)) {
                    this.Storage.MapInplace(f, zeros);
                } else {
                    this.Storage.MapTo(T, result.Storage, f, zeros, zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include ? MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros : MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
                }
            },
            /**
             * Applies a function to each value of this matrix and returns the results as a new matrix.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse matrices).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Function}                                   TU       
             * @param   {System.Func}                                f        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Map: function (TU, f, zeros) {
                if (zeros === void 0) { zeros = 0; }
                var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TU).Matrix;
                var result = m_builder.SameAs$4(T, this, this.RowCount, this.ColumnCount, zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include);
                this.Storage.MapToUnchecked(TU, result.Storage, f, zeros, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Applies a function to each value of this matrix and replaces the value in the result matrix.
             The index of each value (zero-based) is passed as first argument to the function.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse matrices).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Func}                                f         
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {void}
             */
            MapIndexed$1: function (f, result, zeros) {
                if (zeros === void 0) { zeros = 0; }
                if (Bridge.referenceEquals(this, result)) {
                    this.Storage.MapIndexedInplace(f, zeros);
                } else {
                    this.Storage.MapIndexedTo(T, result.Storage, f, zeros, zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include ? MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros : MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
                }
            },
            /**
             * Applies a function to each value of this matrix and returns the results as a new matrix.
             The index of each value (zero-based) is passed as first argument to the function.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse matrices).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Function}                                   TU       
             * @param   {System.Func}                                f        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            MapIndexed: function (TU, f, zeros) {
                if (zeros === void 0) { zeros = 0; }
                var m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TU).Matrix;
                var result = m_builder.SameAs$4(T, this, this.RowCount, this.ColumnCount, zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include);
                this.Storage.MapIndexedToUnchecked(TU, result.Storage, f, zeros, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Applies a function to each value of this matrix and replaces the value in the result matrix.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse matrices).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Function}                                   TU        
             * @param   {System.Func}                                f         
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {void}
             */
            MapConvert: function (TU, f, result, zeros) {
                if (zeros === void 0) { zeros = 0; }
                this.Storage.MapTo(TU, result.Storage, f, zeros, zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include ? MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros : MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
            },
            /**
             * Applies a function to each value of this matrix and replaces the value in the result matrix.
             The index of each value (zero-based) is passed as first argument to the function.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse matrices).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Function}                                   TU        
             * @param   {System.Func}                                f         
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {void}
             */
            MapIndexedConvert: function (TU, f, result, zeros) {
                if (zeros === void 0) { zeros = 0; }
                this.Storage.MapIndexedTo(TU, result.Storage, f, zeros, zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include ? MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros : MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
            },
            /**
             * For each row, applies a function f to each element of the row, threading an accumulator argument through the computation.
             Returns an array with the resulting accumulator states for each row.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Function}                                TU       
             * @param   {System.Func}                             f        
             * @param   {TU}                                      state    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {Array.<TU>}
             */
            FoldByRow: function (TU, f, state, zeros) {
                if (zeros === void 0) { zeros = 0; }
                var result = System.Array.init(this.RowCount, function (){
                    return Bridge.getDefaultValue(TU);
                }, TU);
                if (!System.Collections.Generic.EqualityComparer$1(TU).def.equals2(state, Bridge.getDefaultValue(TU))) {

                    for (var i = 0; i < result.length; i = (i + 1) | 0) {
                        result[System.Array.index(i, result)] = state;

                    }
                }
                this.Storage.FoldByRowUnchecked(TU, result, f, function (x, c) {
                    return x;
                }, result, zeros);
                return result;
            },
            /**
             * For each column, applies a function f to each element of the column, threading an accumulator argument through the computation.
             Returns an array with the resulting accumulator states for each column.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Function}                                TU       
             * @param   {System.Func}                             f        
             * @param   {TU}                                      state    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {Array.<TU>}
             */
            FoldByColumn: function (TU, f, state, zeros) {
                if (zeros === void 0) { zeros = 0; }
                var result = System.Array.init(this.ColumnCount, function (){
                    return Bridge.getDefaultValue(TU);
                }, TU);
                if (!System.Collections.Generic.EqualityComparer$1(TU).def.equals2(state, Bridge.getDefaultValue(TU))) {

                    for (var i = 0; i < result.length; i = (i + 1) | 0) {
                        result[System.Array.index(i, result)] = state;
                    }

                }
                this.Storage.FoldByColumnUnchecked(TU, result, f, function (x, c) {
                    return x;
                }, result, zeros);
                return result;
            },
            /**
             * Applies a function f to each row vector, threading an accumulator vector argument through the computation.
             Returns the resulting accumulator vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Function}                                   TU       
             * @param   {System.Func}                                f        
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    state
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            FoldRows: function (TU, f, state) {
                var $t;
                $t = Bridge.getEnumerator(this.EnumerateRows(), MathNet.Numerics.LinearAlgebra.Vector$1(T));
                try {
                    while ($t.moveNext()) {
                        var vector = $t.Current;
                        state = f(state, vector);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return state;
            },
            /**
             * Applies a function f to each column vector, threading an accumulator vector argument through the computation.
             Returns the resulting accumulator vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Function}                                   TU       
             * @param   {System.Func}                                f        
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    state
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            FoldColumns: function (TU, f, state) {
                var $t;
                $t = Bridge.getEnumerator(this.EnumerateColumns(), MathNet.Numerics.LinearAlgebra.Vector$1(T));
                try {
                    while ($t.moveNext()) {
                        var vector = $t.Current;
                        state = f(state, vector);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return state;
            },
            /**
             * Reduces all row vectors by applying a function between two of them, until only a single vector is left.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Func}                                f
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            ReduceRows: function (f) {
                return System.Linq.Enumerable.from(this.EnumerateRows(), MathNet.Numerics.LinearAlgebra.Vector$1(T)).aggregate(f);
            },
            /**
             * Reduces all column vectors by applying a function between two of them, until only a single vector is left.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Func}                                f
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            ReduceColumns: function (f) {
                return System.Linq.Enumerable.from(this.EnumerateColumns(), MathNet.Numerics.LinearAlgebra.Vector$1(T)).aggregate(f);
            },
            /**
             * Applies a function to each value pair of two matrices and replaces the value in the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Func}                                f         
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {void}
             */
            Map2$1: function (f, other, result, zeros) {
                if (zeros === void 0) { zeros = 0; }
                this.Storage.Map2To(result.Storage, other.Storage, f, zeros, MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
            },
            /**
             * Applies a function to each value pair of two matrices and returns the results as a new vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Func}                                f        
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Map2: function (f, other, zeros) {
                if (zeros === void 0) { zeros = 0; }
                var result = this.m_builder.SameAs$3(T, this);
                this.Storage.Map2To(result.Storage, other.Storage, f, zeros, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Applies a function to update the status with each value pair of two matrices and returns the resulting status.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Function}                                   TOther    
             * @param   {Function}                                   TState    
             * @param   {System.Func}                                f         
             * @param   {TState}                                     state     
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {TState}
             */
            Fold2: function (TOther, TState, f, state, other, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Fold2(TOther, TState, other.Storage, f, state, zeros);
            },
            /**
             * Returns a tuple with the index and value of the first element satisfying a predicate, or null if none is found.
             Zero elements may be skipped on sparse data structures if allowed (default).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Func}                             predicate    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {System.Tuple$3}
             */
            Find: function (predicate, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Find(predicate, zeros);
            },
            /**
             * Returns a tuple with the index and values of the first element pair of two matrices of the same size satisfying a predicate, or null if none is found.
             Zero elements may be skipped on sparse data structures if allowed (default).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Function}                                   TOther       
             * @param   {System.Func}                                predicate    
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {System.Tuple$4}
             */
            Find2: function (TOther, predicate, other, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Find2(TOther, other.Storage, predicate, zeros);
            },
            /**
             * Returns true if at least one element satisfies a predicate.
             Zero elements may be skipped on sparse data structures if allowed (default).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Func}                             predicate    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {boolean}
             */
            Exists: function (predicate, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Find(predicate, zeros) != null;
            },
            /**
             * Returns true if at least one element pairs of two matrices of the same size satisfies a predicate.
             Zero elements may be skipped on sparse data structures if allowed (default).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Function}                                   TOther       
             * @param   {System.Func}                                predicate    
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {boolean}
             */
            Exists2: function (TOther, predicate, other, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Find2(TOther, other.Storage, predicate, zeros) != null;
            },
            /**
             * Returns true if all elements satisfy a predicate.
             Zero elements may be skipped on sparse data structures if allowed (default).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {System.Func}                             predicate    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {boolean}
             */
            ForAll: function (predicate, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Find(function (x) {
                    return !predicate(x);
                }, zeros) == null;
            },
            /**
             * Returns true if all element pairs of two matrices of the same size satisfy a predicate.
             Zero elements may be skipped on sparse data structures if allowed (default).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Matrix$1
             * @memberof MathNet.Numerics.LinearAlgebra.Matrix$1
             * @param   {Function}                                   TOther       
             * @param   {System.Func}                                predicate    
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {boolean}
             */
            ForAll2: function (TOther, predicate, other, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Find2(TOther, other.Storage, function (x, y) {
                    return !predicate(x, y);
                }, zeros) == null;
            }
        }
    }; });

    Bridge.define("MathNet.Numerics.LinearAlgebra.Vector$1", function (T) { return {
        inherits: function () { return [System.IFormattable,System.IEquatable$1(MathNet.Numerics.LinearAlgebra.Vector$1(T)),System.Collections.IList,System.Collections.Generic.IList$1(T),System.ICloneable]; },
        statics: {
            fields: {
                /**
                 * The zero value for type T.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @type T
                 */
                Zero: null,
                /**
                 * The value of 1.0 for type T.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @type T
                 */
                One: null
            },
            ctors: {
                init: function () {
                    this.Zero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector.Zero;
                    this.One = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector.One;
                }
            },
            methods: {
                OuterProduct: function (u, v) {
                    return u.OuterProduct(v);
                },
                FormatStringArrayToString: function (array, columnSeparator, rowSeparator) {
                    var rows = System.Array.getLength(array, 0);
                    var cols = System.Array.getLength(array, 1);

                    var widths = System.Array.init(cols, 0, System.Int32);
                    for (var i = 0; i < rows; i = (i + 1) | 0) {
                        for (var j = 0; j < cols; j = (j + 1) | 0) {
                            widths[System.Array.index(j, widths)] = Math.max(widths[System.Array.index(j, widths)], array.get([i, j]).length);
                        }
                    }

                    var sb = new System.Text.StringBuilder();
                    for (var i1 = 0; i1 < rows; i1 = (i1 + 1) | 0) {
                        sb.append(System.String.alignString(array.get([i1, 0]), widths[System.Array.index(0, widths)]));
                        for (var j1 = 1; j1 < cols; j1 = (j1 + 1) | 0) {
                            sb.append(columnSeparator);
                            sb.append(System.String.alignString(array.get([i1, j1]), widths[System.Array.index(j1, widths)]));
                        }
                        sb.append(rowSeparator);
                    }
                    return sb.toString();
                },
                op_DotMultiply: function (x, y) {
                    return x.PointwiseMultiply(y);
                },
                op_DotDivide: function (dividend, divisor) {
                    return dividend.PointwiseDivide(divisor);
                },
                op_DotPercent: function (dividend, divisor) {
                    return dividend.PointwiseRemainder(divisor);
                },
                op_DotHat$1: function (vector, exponent) {
                    return vector.PointwisePower$1(exponent);
                },
                op_DotHat: function (vector, exponent) {
                    return vector.PointwisePower(exponent);
                },
                /**
                 * Computes the sqrt of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Sqrt: function (x) {
                    return x.PointwiseSqrt();
                },
                /**
                 * Computes the exponential of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Exp: function (x) {
                    return x.PointwiseUnary(Bridge.fn.cacheBind(x, x.DoPointwiseExp));
                },
                /**
                 * Computes the log of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Log: function (x) {
                    return x.PointwiseUnary(Bridge.fn.cacheBind(x, x.PointwiseLog$1));
                },
                /**
                 * Computes the log10 of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Log10: function (x) {
                    return x.PointwiseLog10();
                },
                /**
                 * Computes the sin of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Sin: function (x) {
                    return x.PointwiseSin();
                },
                /**
                 * Computes the cos of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Cos: function (x) {
                    return x.PointwiseCos();
                },
                /**
                 * Computes the tan of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Tan: function (x) {
                    return x.PointwiseTan();
                },
                /**
                 * Computes the asin of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Asin: function (x) {
                    return x.PointwiseAsin();
                },
                /**
                 * Computes the acos of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Acos: function (x) {
                    return x.PointwiseAcos();
                },
                /**
                 * Computes the atan of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Atan: function (x) {
                    return x.PointwiseAtan();
                },
                /**
                 * Computes the sinh of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Sinh: function (x) {
                    return x.PointwiseSinh();
                },
                /**
                 * Computes the cosh of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Cosh: function (x) {
                    return x.PointwiseCosh();
                },
                /**
                 * Computes the tanh of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Tanh: function (x) {
                    return x.PointwiseTanh();
                },
                /**
                 * Computes the absolute value of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Abs: function (x) {
                    return x.PointwiseAbs();
                },
                /**
                 * Computes the floor of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Floor: function (x) {
                    return x.PointwiseFloor();
                },
                /**
                 * Computes the ceiling of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Ceiling: function (x) {
                    return x.PointwiseCeiling();
                },
                /**
                 * Computes the rounded value of a vector pointwise
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    x    The input vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Round: function (x) {
                    return x.PointwiseRound();
                }/**
                 * Returns a <strong>Vector</strong> containing the same values of <b />.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to get the values from.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 A vector containing the same values as <b />.
                 */
                ,
                op_UnaryPlus: function (rightSide) {
                    return rightSide.Clone();
                }/**
                 * Returns a <strong>Vector</strong> containing the negated values of <b />.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to get the values from.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 A vector containing the negated values as <b />.
                 */
                ,
                op_UnaryNegation: function (rightSide) {
                    return rightSide.Negate();
                }/**
                 * Adds two <strong>Vectors</strong> together and returns the results.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> and <b /> are not the same size.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    leftSide     One of the vectors to add.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The other vector to add.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 The result of the addition.
                 */
                ,
                op_Addition$2: function (leftSide, rightSide) {
                    return leftSide.Add$1(rightSide);
                }/**
                 * Adds a scalar to each element of a vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    leftSide     The vector to add to.
                 * @param   {T}                                          rightSide    The scalar value to add.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 The result of the addition.
                 */
                ,
                op_Addition$1: function (leftSide, rightSide) {
                    return leftSide.Add(rightSide);
                }/**
                 * Adds a scalar to each element of a vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {T}                                          leftSide     The scalar value to add.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to add to.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 The result of the addition.
                 */
                ,
                op_Addition: function (leftSide, rightSide) {
                    return rightSide.Add(leftSide);
                }/**
                 * Subtracts two <strong>Vectors</strong> and returns the results.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> and <b /> are not the same size.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    leftSide     The vector to subtract from.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to subtract.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 The result of the subtraction.
                 */
                ,
                op_Subtraction$2: function (leftSide, rightSide) {
                    return leftSide.Subtract$1(rightSide);
                }/**
                 * Subtracts a scalar from each element of a vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    leftSide     The vector to subtract from.
                 * @param   {T}                                          rightSide    The scalar value to subtract.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 The result of the subtraction.
                 */
                ,
                op_Subtraction$1: function (leftSide, rightSide) {
                    return leftSide.Subtract(rightSide);
                }/**
                 * Subtracts each element of a vector from a scalar.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {T}                                          leftSide     The scalar value to subtract from.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to subtract.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 The result of the subtraction.
                 */
                ,
                op_Subtraction: function (leftSide, rightSide) {
                    return rightSide.SubtractFrom(leftSide);
                }/**
                 * Multiplies a vector with a scalar.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    leftSide     The vector to scale.
                 * @param   {T}                                          rightSide    The scalar value.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 The result of the multiplication.
                 */
                ,
                op_Multiply$2: function (leftSide, rightSide) {
                    return leftSide.Multiply(rightSide);
                }/**
                 * Multiplies a vector with a scalar.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {T}                                          leftSide     The scalar value.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to scale.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                 The result of the multiplication.
                 */
                ,
                op_Multiply$1: function (leftSide, rightSide) {
                    return rightSide.Multiply(leftSide);
                }/**
                 * Computes the dot product between two <strong>Vectors</strong>.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> and <b /> are not the same size.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    leftSide     The left row vector.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The right column vector.
                 * @return  {T}                                                       The dot product between the two vectors.
                 */
                ,
                op_Multiply: function (leftSide, rightSide) {
                    return leftSide.DotProduct(rightSide);
                }/**
                 * Divides a scalar with a vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {T}                                          dividend    The scalar to divide.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor     The vector.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                The result of the division.
                 */
                ,
                op_Division: function (dividend, divisor) {
                    return divisor.DivideByThis(dividend);
                }/**
                 * Divides a vector with a scalar.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    dividend    The vector to divide.
                 * @param   {T}                                          divisor     The scalar value.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                The result of the division.
                 */
                ,
                op_Division$1: function (dividend, divisor) {
                    return dividend.Divide(divisor);
                }/**
                 * Pointwise divides two <strong>Vectors</strong>.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> and <b /> are not the same size.
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    dividend    The vector to divide.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor     The other vector.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                The result of the division.
                 */
                ,
                op_Division$2: function (dividend, divisor) {
                    return dividend.PointwiseDivide(divisor);
                }/**
                 * Computes the remainder (% operator), where the result has the sign of the dividend,
                 of each element of the vector of the given divisor.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    dividend    The vector whose elements we want to compute the remainder of.
                 * @param   {T}                                          divisor     The divisor to use.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                ,
                op_Modulus$1: function (dividend, divisor) {
                    return dividend.Remainder(divisor);
                }/**
                 * Computes the remainder (% operator), where the result has the sign of the dividend,
                 of the given dividend of each element of the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {T}                                          dividend    The dividend we want to compute the remainder of.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor     The vector whose elements we want to use as divisor.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                ,
                op_Modulus: function (dividend, divisor) {
                    return divisor.RemainderByThis(dividend);
                }/**
                 * Computes the pointwise remainder (% operator), where the result has the sign of the dividend,
                 of each element of two vectors.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Vector$1
                 * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
                 * @throws If <b /> and <b /> are not the same size.
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    dividend    The vector whose elements we want to compute the remainder of.
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor     The divisor to use.
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                ,
                op_Modulus$2: function (dividend, divisor) {
                    return dividend.PointwiseRemainder(divisor);
                }
            }
        },
        fields: {
            v_builder: null,
            m_builder: null,
            /**
             * Gets the raw vector data storage.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @function Storage
             * @type MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1
             */
            Storage: null,
            /**
             * Gets the length or number of dimensions of this vector.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @function Count
             * @type number
             */
            Count: 0
        },
        props: {
            System$Collections$Generic$ICollection$1$IsReadOnly: {
                get: function () {
                    return false;
                }
            },
            System$Collections$IList$IsReadOnly: {
                get: function () {
                    return false;
                }
            },
            System$Collections$IList$IsFixedSize: {
                get: function () {
                    return true;
                }
            },
            System$Collections$ICollection$IsSynchronized: {
                get: function () {
                    return false;
                }
            },
            System$Collections$ICollection$SyncRoot: {
                get: function () {
                    return this.Storage;
                }
            }
        },
        alias: [
            "equalsT", "System$IEquatable$1$MathNet$Numerics$LinearAlgebra$Vector$1$" + Bridge.getTypeAlias(T) + "$equalsT",
            "System$Collections$Generic$IList$1$indexOf", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$indexOf",
            "System$Collections$Generic$IList$1$insert", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$insert",
            "System$Collections$Generic$IList$1$removeAt", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$removeAt",
            "System$Collections$Generic$ICollection$1$IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$IsReadOnly",
            "System$Collections$Generic$ICollection$1$add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$add",
            "System$Collections$Generic$ICollection$1$remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$remove",
            "System$Collections$Generic$ICollection$1$contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$contains",
            "System$Collections$Generic$ICollection$1$copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$copyTo",
            "System$Collections$Generic$IEnumerable$1$GetEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator",
            "format", "System$IFormattable$format",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$Count",
            "Count", "System$Collections$ICollection$Count",
            "getItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$getItem",
            "setItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$setItem",
            "clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$clear",
            "clear", "System$Collections$IList$clear"
        ],
        ctors: {
            init: function () {
                this.v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;
                this.m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
            },
            /**
             * Initializes a new instance of the Vector class.
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1}    storage
             * @return  {void}
             */
            ctor: function (storage) {
                this.$initialize();
                this.Storage = storage;
                this.Count = storage.Length;
            }
        },
        methods: {
            System$Collections$IList$getItem: function (index) {
                return this.Storage.getItem(index);
            },
            System$Collections$IList$setItem: function (index, value) {
                this.Storage.setItem(index, Bridge.cast(Bridge.unbox(value, T), T));
            },
            /**
             * Gets or sets the value at the given <b />.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If <b /> is negative or
             greater than the size of the vector.
             * @param   {number}    index    The index of the value to get or set.
             * @return  {T}                  The value of the vector at the given <b />.
             */
            getItem: function (index) {
                return this.Storage.getItem(index);
            },
            /**
             * Gets or sets the value at the given <b />.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If <b /> is negative or
             greater than the size of the vector.
             * @param   {number}    index    The index of the value to get or set.
             * @param   {T}         value
             * @return  {void}               The value of the vector at the given <b />.
             */
            setItem: function (index, value) {
                this.Storage.setItem(index, value);
            },
            /**
             * Subtracts each element of the vector from a scalar and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          scalar    The scalar to subtract from.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the subtraction.
             * @return  {void}
             */
            DoSubtractFrom: function (scalar, result) {
                this.DoNegate(result);
                result.DoAdd(scalar, result);
            },
            /**
             * Computes the outer product M[i,j] = u[i]*v[j] of this and another vector and stores the result in the result matrix.
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The other vector
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the product.
             * @return  {void}
             */
            DoOuterProduct: function (other, result) {
                var work = this.v_builder.Dense$2(this.Count);
                for (var i = 0; i < other.Count; i = (i + 1) | 0) {
                    this.DoMultiply(other.At(i), work);
                    result.SetColumn$1(i, work);
                }
            },
            /**
             * Adds a scalar to each element of the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          scalar    The scalar to add.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}              A copy of the vector with the scalar added.
             */
            Add: function (scalar) {
                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Vector$1(T).Zero)) {
                    return this.Clone();
                }

                var result = this.v_builder.SameAs$4(T, this);
                this.DoAdd(scalar, result);
                return result;
            },
            /**
             * Adds a scalar to each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar to add.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the addition.
             * @return  {void}
             */
            Add$2: function (scalar, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Vector$1(T).Zero)) {
                    this.CopyTo(result);
                    return;
                }

                this.DoAdd(scalar, result);
            },
            /**
             * Adds another vector to this vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The vector to add to this one.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}             A new vector containing the sum of both vectors.
             */
            Add$1: function (other) {
                if (this.Count !== other.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "other");
                }

                var result = this.v_builder.SameAs$1(this, other);
                this.DoAdd$1(other, result);
                return result;
            },
            /**
             * Adds another vector to this vector and stores the result into the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector to add to this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the addition.
             * @return  {void}
             */
            Add$3: function (other, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoAdd$1(other, result);
            },
            System$Collections$Generic$ICollection$1$add: function (item) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$IList$add: function (value) {
                throw new System.NotSupportedException.ctor();
            },
            /**
             * Subtracts a scalar from each element of the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          scalar    The scalar to subtract.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}              A new vector containing the subtraction of this vector and the scalar.
             */
            Subtract: function (scalar) {
                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Vector$1(T).Zero)) {
                    return this.Clone();
                }

                var result = this.v_builder.SameAs$4(T, this);
                this.DoSubtract(scalar, result);
                return result;
            },
            /**
             * Subtracts a scalar from each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar to subtract.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the subtraction.
             * @return  {void}
             */
            Subtract$2: function (scalar, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Vector$1(T).Zero)) {
                    this.CopyTo(result);
                    return;
                }

                this.DoSubtract(scalar, result);
            },
            /**
             * Subtracts another vector from this vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The vector to subtract from this one.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}             A new vector containing the subtraction of the two vectors.
             */
            Subtract$1: function (other) {
                if (this.Count !== other.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "other");
                }

                var result = this.v_builder.SameAs$1(this, other);
                this.DoSubtract$1(other, result);
                return result;
            },
            /**
             * Subtracts another vector to this vector and stores the result into the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector to subtract from this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the subtraction.
             * @return  {void}
             */
            Subtract$3: function (other, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoSubtract$1(other, result);
            },
            /**
             * Subtracts each element of the vector from a scalar.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          scalar    The scalar to subtract from.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}              A new vector containing the subtraction of the scalar and this vector.
             */
            SubtractFrom: function (scalar) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoSubtractFrom(scalar, result);
                return result;
            },
            /**
             * Subtracts each element of the vector from a scalar and stores the result in the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar to subtract from.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the subtraction.
             * @return  {void}
             */
            SubtractFrom$1: function (scalar, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoSubtractFrom(scalar, result);
            },
            /**
             * Returns a negated vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}        The negated vector.
             */
            Negate: function () {
                var retrunVector = this.v_builder.SameAs$4(T, this);
                this.DoNegate(retrunVector);
                return retrunVector;
            },
            /**
             * Negates vector and save result to <b />
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    Target vector
             * @return  {void}
             */
            Negate$1: function (result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoNegate(result);
            },
            /**
             * Return vector with complex conjugate values of the source vector
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}        Conjugated vector
             */
            Conjugate: function () {
                var retrunVector = this.v_builder.SameAs$4(T, this);
                this.DoConjugate(retrunVector);
                return retrunVector;
            },
            /**
             * Complex conjugates vector and save result to <b />
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    Target vector
             * @return  {void}
             */
            Conjugate$1: function (result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoConjugate(result);
            },
            /**
             * Multiplies a scalar to each element of the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          scalar    The scalar to multiply.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}              A new vector that is the multiplication of the vector and the scalar.
             */
            Multiply: function (scalar) {
                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Vector$1(T).One)) {
                    return this.Clone();
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Vector$1(T).Zero)) {
                    return this.v_builder.SameAs$4(T, this);
                }

                var result = this.v_builder.SameAs$4(T, this);
                this.DoMultiply(scalar, result);
                return result;
            },
            /**
             * Multiplies a scalar to each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar to multiply.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the multiplication.
             * @return  {void}
             */
            Multiply$1: function (scalar, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Vector$1(T).One)) {
                    this.CopyTo(result);
                    return;
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Vector$1(T).Zero)) {
                    result.clear();
                    return;
                }

                this.DoMultiply(scalar, result);
            },
            /**
             * Computes the dot product between this vector and another vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If <b /> is not of the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The other vector.
             * @return  {T}                                                   The sum of a[i]*b[i] for all i.
             * @see {@link ConjugateDotProduct}
             */
            DotProduct: function (other) {
                if (this.Count !== other.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "other");
                }

                return this.DoDotProduct(other);
            },
            /**
             * Computes the dot product between the conjugate of this vector and another vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If <b /> is not of the same size.
             * @throws If <b /> is {@link ArgumentNullException}.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The other vector.
             * @return  {T}                                                   The sum of conj(a[i])*b[i] for all i.
             * @see {@link DotProduct}
             */
            ConjugateDotProduct: function (other) {
                if (this.Count !== other.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "other");
                }

                return this.DoConjugateDotProduct(other);
            },
            /**
             * Divides each element of the vector by a scalar.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          scalar    The scalar to divide with.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}              A new vector that is the division of the vector and the scalar.
             */
            Divide: function (scalar) {
                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Vector$1(T).One)) {
                    return this.Clone();
                }

                var result = this.v_builder.SameAs$4(T, this);
                this.DoDivide(scalar, result);
                return result;
            },
            /**
             * Divides each element of the vector by a scalar and stores the result in the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar to divide with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the division.
             * @return  {void}
             */
            Divide$1: function (scalar, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                if (Bridge.equals(scalar, MathNet.Numerics.LinearAlgebra.Vector$1(T).One)) {
                    this.CopyTo(result);
                    return;
                }

                this.DoDivide(scalar, result);
            },
            /**
             * Divides a scalar by each element of the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          scalar    The scalar to divide.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}              A new vector that is the division of the vector and the scalar.
             */
            DivideByThis: function (scalar) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoDivideByThis(scalar, result);
                return result;
            },
            /**
             * Divides a scalar by each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar to divide.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the division.
             * @return  {void}
             */
            DivideByThis$1: function (scalar, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoDivideByThis(scalar, result);
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for each element of the vector for the given divisor.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          divisor    The scalar denominator to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}               A vector containing the result.
             */
            Modulus: function (divisor) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoModulus(divisor, result);
                return result;
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for each element of the vector for the given divisor.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     A vector to store the results in.
             * @return  {void}
             */
            Modulus$1: function (divisor, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoModulus(divisor, result);
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for the given dividend for each element of the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          dividend    The scalar numerator to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                A vector containing the result.
             */
            ModulusByThis: function (dividend) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoModulusByThis(dividend, result);
                return result;
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for the given dividend for each element of the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          dividend    The scalar numerator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result      A vector to store the results in.
             * @return  {void}
             */
            ModulusByThis$1: function (dividend, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoModulusByThis(dividend, result);
            },
            /**
             * Computes the remainder (vector % divisor), where the result has the sign of the dividend,
             for each element of the vector for the given divisor.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          divisor    The scalar denominator to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}               A vector containing the result.
             */
            Remainder: function (divisor) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoRemainder(divisor, result);
                return result;
            },
            /**
             * Computes the remainder (vector % divisor), where the result has the sign of the dividend,
             for each element of the vector for the given divisor.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     A vector to store the results in.
             * @return  {void}
             */
            Remainder$1: function (divisor, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoRemainder(divisor, result);
            },
            /**
             * Computes the remainder (dividend % vector), where the result has the sign of the dividend,
             for the given dividend for each element of the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          dividend    The scalar numerator to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}                A vector containing the result.
             */
            RemainderByThis: function (dividend) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoRemainderByThis(dividend, result);
                return result;
            },
            /**
             * Computes the remainder (dividend % vector), where the result has the sign of the dividend,
             for the given dividend for each element of the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          dividend    The scalar numerator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result      A vector to store the results in.
             * @return  {void}
             */
            RemainderByThis$1: function (dividend, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoRemainderByThis(dividend, result);
            },
            /**
             * Pointwise multiplies this vector with another vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The vector to pointwise multiply with this one.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}             A new vector which is the pointwise multiplication of the two vectors.
             */
            PointwiseMultiply: function (other) {
                if (this.Count !== other.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "other");
                }

                var result = this.v_builder.SameAs$1(this, other);
                this.DoPointwiseMultiply(other, result);
                return result;
            },
            /**
             * Pointwise multiplies this vector with another vector and stores the result into the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector to pointwise multiply with this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the pointwise multiplication.
             * @return  {void}
             */
            PointwiseMultiply$1: function (other, result) {
                if (this.Count !== other.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "other");
                }

                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwiseMultiply(other, result);
            },
            /**
             * Pointwise divide this vector with another vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor    The pointwise denominator vector to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}               A new vector which is the pointwise division of the two vectors.
             */
            PointwiseDivide: function (divisor) {
                if (this.Count !== divisor.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "divisor");
                }

                var result = this.v_builder.SameAs$1(this, divisor);
                this.DoPointwiseDivide(divisor, result);
                return result;
            },
            /**
             * Pointwise divide this vector with another vector and stores the result into the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor    The pointwise denominator vector to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     The vector to store the result of the pointwise division.
             * @return  {void}
             */
            PointwiseDivide$1: function (divisor, result) {
                if (this.Count !== divisor.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "divisor");
                }

                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwiseDivide(divisor, result);
            },
            /**
             * Pointwise raise this vector to an exponent.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          exponent    The exponent to raise this vector values to.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwisePower: function (exponent) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoPointwisePower(exponent, result);
                return result;
            },
            /**
             * Pointwise raise this vector to an exponent and store the result into the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {T}                                          exponent    The exponent to raise this vector values to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result      The matrix to store the result into.
             * @return  {void}
             */
            PointwisePower$2: function (exponent, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwisePower(exponent, result);
            },
            /**
             * Pointwise raise this vector to an exponent and store the result into the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    exponent    The exponent to raise this vector values to.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwisePower$1: function (exponent) {
                if (this.Count !== exponent.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "exponent");
                }

                var result = this.v_builder.SameAs$4(T, this);
                this.DoPointwisePower$1(exponent, result);
                return result;
            },
            /**
             * Pointwise raise this vector to an exponent.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    exponent    The exponent to raise this vector values to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result      The vector to store the result into.
             * @return  {void}
             */
            PointwisePower$3: function (exponent, result) {
                if (this.Count !== exponent.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "exponent");
                }

                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwisePower$1(exponent, result);
            },
            /**
             * Pointwise canonical modulus, where the result has the sign of the divisor,
             of this vector with another vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor    The pointwise denominator vector to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseModulus: function (divisor) {
                if (this.Count !== divisor.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "divisor");
                }

                var result = this.v_builder.SameAs$1(this, divisor);
                this.DoPointwiseModulus(divisor, result);
                return result;
            },
            /**
             * Pointwise canonical modulus, where the result has the sign of the divisor,
             of this vector with another vector and stores the result into the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor    The pointwise denominator vector to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     The vector to store the result of the pointwise modulus.
             * @return  {void}
             */
            PointwiseModulus$1: function (divisor, result) {
                if (this.Count !== divisor.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "divisor");
                }

                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwiseModulus(divisor, result);
            },
            /**
             * Pointwise remainder (% operator), where the result has the sign of the dividend,
             of this vector with another vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor    The pointwise denominator vector to use.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseRemainder: function (divisor) {
                if (this.Count !== divisor.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "divisor");
                }

                var result = this.v_builder.SameAs$1(this, divisor);
                this.DoPointwiseRemainder(divisor, result);
                return result;
            },
            /**
             * Pointwise remainder (% operator), where the result has the sign of the dividend,
             this vector with another vector and stores the result into the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor    The pointwise denominator vector to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     The vector to store the result of the pointwise remainder.
             * @return  {void}
             */
            PointwiseRemainder$1: function (divisor, result) {
                if (this.Count !== divisor.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "divisor");
                }

                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwiseRemainder(divisor, result);
            },
            /**
             * Helper function to apply a unary function to a vector. The function
             f modifies the vector given to it in place.  Before its
             called, a copy of the 'this' vector with the same dimension is
             first created, then passed to f.  The copy is returned as the result
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {System.Action}                              f    Function which takes a vector, modifies it in place and returns void
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}         New instance of vector which is the result
             */
            PointwiseUnary: function (f) {
                var result = this.v_builder.SameAs$4(T, this);
                f(result);
                return result;
            },
            /**
             * Helper function to apply a unary function which modifies a vector
             in place.
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {System.Action}                              f         Function which takes a vector, modifies it in place and returns void
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector where the result is to be stored
             * @return  {void}
             */
            PointwiseUnary$1: function (f, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                f(result);
            },
            /**
             * Helper function to apply a binary function which takes a scalar and
             a vector and modifies the latter in place. A copy of the "this"
             vector is therefore first made and then passed to f together with
             the scalar argument.  The copy is then returned as the result
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {System.Action}                              f        Function which takes a scalar and a vector, modifies the vector in place and returns void
             * @param   {T}                                          other    The scalar to be passed to the function
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}             The resulting vector
             */
            PointwiseBinary: function (f, other) {
                var result = this.v_builder.SameAs$4(T, this);
                f(other, result);
                return result;
            },
            /**
             * Helper function to apply a binary function which takes a scalar and
             a vector, modifies the latter in place and returns void.
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {System.Action}                              f         Function which takes a scalar and a vector, modifies the vector in place and returns void
             * @param   {T}                                          x         The scalar to be passed to the function
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector where the result will be placed
             * @return  {void}
             */
            PointwiseBinary$2: function (f, x, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }
                f(x, result);
            },
            /**
             * Helper function to apply a binary function which takes two vectors
             and modifies the latter in place.  A copy of the "this" vector is
             first made and then passed to f together with the other vector. The
             copy is then returned as the result
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {System.Action}                              f        Function which takes two vectors, modifies the second in place and returns void
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The other vector to be passed to the function as argument. It is not modified
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}             The resulting vector
             */
            PointwiseBinary$1: function (f, other) {
                if (this.Count !== other.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "other");
                }

                var result = this.v_builder.SameAs$1(this, other);
                f(other, result);
                return result;
            },
            /**
             * Helper function to apply a binary function which takes two vectors
             and modifies the second one in place
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {System.Action}                              f         Function which takes two vectors, modifies the second in place and returns void
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The other vector to be passed to the function as argument. It is not modified
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The resulting vector
             * @return  {void}
             */
            PointwiseBinary$3: function (f, other, result) {
                if (this.Count !== other.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "other");
                }

                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }
                f(other, result);
            },
            /**
             * Pointwise applies the exponent function to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseExp: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseExp));
            },
            /**
             * Pointwise applies the exponent function to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result.
             * @return  {void}
             */
            PointwiseExp$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseExp), result);
            },
            /**
             * Pointwise applies the natural logarithm function to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseLog: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseLog));
            },
            /**
             * Pointwise applies the natural logarithm function to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result.
             * @return  {void}
             */
            PointwiseLog$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseLog), result);
            },
            /**
             * Pointwise applies the abs function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseAbs: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseAbs));
            },
            /**
             * Pointwise applies the abs function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseAbs$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseAbs), result);
            },
            /**
             * Pointwise applies the acos function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseAcos: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseAcos));
            },
            /**
             * Pointwise applies the acos function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseAcos$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseAcos), result);
            },
            /**
             * Pointwise applies the asin function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseAsin: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseAsin));
            },
            /**
             * Pointwise applies the asin function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseAsin$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseAsin), result);
            },
            /**
             * Pointwise applies the atan function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseAtan: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseAtan));
            },
            /**
             * Pointwise applies the atan function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseAtan$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseAtan), result);
            },
            /**
             * Pointwise applies the atan2 function to each value of the current
             vector and a given other vector being the 'x' of atan2 and the
             'this' vector being the 'y'
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseAtan2: function (other) {
                return this.PointwiseBinary$1(Bridge.fn.cacheBind(this, this.DoPointwiseAtan2$1), other);
            },
            /**
             * Pointwise applies the atan2 function to each value of the current
             vector and a given other vector being the 'x' of atan2 and the
             'this' vector being the 'y'
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseAtan2$1: function (other, result) {
                this.PointwiseBinary$3(Bridge.fn.cacheBind(this, this.DoPointwiseAtan2$1), other, result);
            },
            /**
             * Pointwise applies the ceiling function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseCeiling: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseCeiling));
            },
            /**
             * Pointwise applies the ceiling function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseCeiling$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseCeiling), result);
            },
            /**
             * Pointwise applies the cos function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseCos: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseCos));
            },
            /**
             * Pointwise applies the cos function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseCos$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseCos), result);
            },
            /**
             * Pointwise applies the cosh function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseCosh: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseCosh));
            },
            /**
             * Pointwise applies the cosh function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseCosh$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseCosh), result);
            },
            /**
             * Pointwise applies the floor function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseFloor: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseFloor));
            },
            /**
             * Pointwise applies the floor function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseFloor$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseFloor), result);
            },
            /**
             * Pointwise applies the log10 function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseLog10: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseLog10));
            },
            /**
             * Pointwise applies the log10 function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseLog10$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseLog10), result);
            },
            /**
             * Pointwise applies the round function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseRound: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseRound));
            },
            /**
             * Pointwise applies the round function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseRound$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseRound), result);
            },
            /**
             * Pointwise applies the sign function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseSign: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseSign));
            },
            /**
             * Pointwise applies the sign function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseSign$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseSign), result);
            },
            /**
             * Pointwise applies the sin function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseSin: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseSin));
            },
            /**
             * Pointwise applies the sin function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseSin$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseSin), result);
            },
            /**
             * Pointwise applies the sinh function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseSinh: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseSinh));
            },
            /**
             * Pointwise applies the sinh function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseSinh$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseSinh), result);
            },
            /**
             * Pointwise applies the sqrt function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseSqrt: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseSqrt));
            },
            /**
             * Pointwise applies the sqrt function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseSqrt$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseSqrt), result);
            },
            /**
             * Pointwise applies the tan function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseTan: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseTan));
            },
            /**
             * Pointwise applies the tan function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseTan$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseTan), result);
            },
            /**
             * Pointwise applies the tanh function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseTanh: function () {
                return this.PointwiseUnary(Bridge.fn.cacheBind(this, this.DoPointwiseTanh));
            },
            /**
             * Pointwise applies the tanh function to each value
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result
             * @return  {void}
             */
            PointwiseTanh$1: function (result) {
                this.PointwiseUnary$1(Bridge.fn.cacheBind(this, this.DoPointwiseTanh), result);
            },
            /**
             * Computes the outer product M[i,j] = u[i]*v[j] of this and another vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The other vector
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            OuterProduct: function (other) {
                var matrix = this.m_builder.SameAs$2(this, this.Count, other.Count);
                this.DoOuterProduct(other, matrix);
                return matrix;
            },
            /**
             * Computes the outer product M[i,j] = u[i]*v[j] of this and another vector and stores the result in the result matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The other vector
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the product.
             * @return  {void}
             */
            OuterProduct$1: function (other, result) {
                if (this.Count !== result.RowCount || other.Count !== result.ColumnCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixDimensions", "result");
                }

                this.DoOuterProduct(other, result);
            },
            /**
             * Pointwise applies the minimum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseMinimum: function (scalar) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoPointwiseMinimum(scalar, result);
                return result;
            },
            /**
             * Pointwise applies the minimum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result.
             * @return  {void}
             */
            PointwiseMinimum$2: function (scalar, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwiseMinimum(scalar, result);
            },
            /**
             * Pointwise applies the minimum with the values of another vector to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The vector with the values to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseMinimum$1: function (other) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoPointwiseMinimum$1(other, result);
                return result;
            },
            /**
             * Pointwise applies the minimum with the values of another vector to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector with the values to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result.
             * @return  {void}
             */
            PointwiseMinimum$3: function (other, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwiseMinimum$1(other, result);
            },
            /**
             * Pointwise applies the maximum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseMaximum: function (scalar) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoPointwiseMaximum(scalar, result);
                return result;
            },
            /**
             * Pointwise applies the maximum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result.
             * @return  {void}
             */
            PointwiseMaximum$2: function (scalar, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwiseMaximum(scalar, result);
            },
            /**
             * Pointwise applies the maximum with the values of another vector to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The vector with the values to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseMaximum$1: function (other) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoPointwiseMaximum$1(other, result);
                return result;
            },
            /**
             * Pointwise applies the maximum with the values of another vector to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector with the values to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result.
             * @return  {void}
             */
            PointwiseMaximum$3: function (other, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwiseMaximum$1(other, result);
            },
            /**
             * Pointwise applies the absolute minimum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseAbsoluteMinimum: function (scalar) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoPointwiseAbsoluteMinimum(scalar, result);
                return result;
            },
            /**
             * Pointwise applies the absolute minimum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result.
             * @return  {void}
             */
            PointwiseAbsoluteMinimum$2: function (scalar, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwiseAbsoluteMinimum(scalar, result);
            },
            /**
             * Pointwise applies the absolute minimum with the values of another vector to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The vector with the values to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseAbsoluteMinimum$1: function (other) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoPointwiseAbsoluteMinimum$1(other, result);
                return result;
            },
            /**
             * Pointwise applies the absolute minimum with the values of another vector to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector with the values to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result.
             * @return  {void}
             */
            PointwiseAbsoluteMinimum$3: function (other, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwiseAbsoluteMinimum$1(other, result);
            },
            /**
             * Pointwise applies the absolute maximum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseAbsoluteMaximum: function (scalar) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoPointwiseAbsoluteMaximum(scalar, result);
                return result;
            },
            /**
             * Pointwise applies the absolute maximum with a scalar to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {T}                                          scalar    The scalar value to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result.
             * @return  {void}
             */
            PointwiseAbsoluteMaximum$2: function (scalar, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwiseAbsoluteMaximum(scalar, result);
            },
            /**
             * Pointwise applies the absolute maximum with the values of another vector to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The vector with the values to compare to.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            PointwiseAbsoluteMaximum$1: function (other) {
                var result = this.v_builder.SameAs$4(T, this);
                this.DoPointwiseAbsoluteMaximum$1(other, result);
                return result;
            },
            /**
             * Pointwise applies the absolute maximum with the values of another vector to each value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If this vector and <b /> are not the same size.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector with the values to compare to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result.
             * @return  {void}
             */
            PointwiseAbsoluteMaximum$3: function (other, result) {
                if (this.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "result");
                }

                this.DoPointwiseAbsoluteMaximum$1(other, result);
            },
            /**
             * Returns the value of maximum element.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {T}        The value of maximum element.
             */
            Maximum: function () {
                return this.At(this.MaximumIndex());
            },
            /**
             * Returns the value of the minimum element.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {T}        The value of the minimum element.
             */
            Minimum: function () {
                return this.At(this.MinimumIndex());
            },
            /**
             * Computes the sum of the absolute value of the vector's elements.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {number}        The sum of the absolute value of the vector's elements.
             */
            SumMagnitudes: function () {
                return this.L1Norm();
            },
            /**
             * Indicates whether the current object is equal to another object of the same type.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    An object to compare with this object.
             * @return  {boolean}                                             <pre><code>true</code></pre> if the current object is equal to the <b /> parameter; otherwise, <pre><code>false</code></pre>.
             */
            equalsT: function (other) {
                return other != null && this.Storage.equalsT(other.Storage);
            },
            /**
             * Determines whether the specified {@link } is equal to this instance.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {System.Object}    obj    The {@link } to compare with this instance.
             * @return  {boolean}                 <pre><code>true</code></pre> if the specified {@link } is equal to this instance; otherwise, <pre><code>false</code></pre>.
             */
            equals: function (obj) {
                var other = Bridge.as(obj, MathNet.Numerics.LinearAlgebra.Vector$1(T));
                return other != null && this.Storage.equalsT(other.Storage);
            },
            /**
             * Returns a hash code for this instance.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {number}        A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
             */
            getHashCode: function () {
                return this.Storage.getHashCode();
            },
            /**
             * Creates a new object that is a copy of the current instance.
             *
             * @instance
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {System.Object}        A new object that is a copy of this instance.
             */
            System$ICloneable$clone: function () {
                return this.Clone();
            },
            /**
             * Returns a deep-copy clone of the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}        A deep-copy clone of the vector.
             */
            Clone: function () {
                var result = this.v_builder.SameAs$4(T, this);
                this.Storage.CopyToUnchecked(result.Storage, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            System$Collections$Generic$IList$1$indexOf: function (item) {
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (Bridge.equals(this.At(i), item)) {
                        return i;
                    }
                }
                return -1;
            },
            System$Collections$IList$indexOf: function (value) {
                if (!(Bridge.is(value, T))) {
                    return -1;
                }

                return System.Array.indexOf(Bridge.cast(this, System.Collections.Generic.IList$1(T)), Bridge.cast(Bridge.unbox(value, T), T), 0, null, T);
            },
            System$Collections$Generic$IList$1$insert: function (index, item) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$IList$insert: function (index, value) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$Generic$IList$1$removeAt: function (index) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$IList$removeAt: function (index) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$Generic$ICollection$1$remove: function (item) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$IList$remove: function (value) {
                throw new System.NotSupportedException.ctor();
            },
            System$Collections$Generic$ICollection$1$contains: function (item) {
                var $t;
                $t = Bridge.getEnumerator(this, T);
                try {
                    while ($t.moveNext()) {
                        var x = $t.Current;
                        if (Bridge.equals(x, item)) {
                            return true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return false;
            },
            System$Collections$IList$contains: function (value) {
                if (!(Bridge.is(value, T))) {
                    return false;
                }

                return System.Array.contains(Bridge.cast(this, System.Collections.Generic.ICollection$1(T)), Bridge.cast(Bridge.unbox(value, T), T), T);
            },
            System$Collections$Generic$ICollection$1$copyTo: function (array, arrayIndex) {
                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }

                this.Storage.CopySubVectorTo(new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).$ctor1(array.length, array), 0, arrayIndex, this.Count);
            },
            System$Collections$ICollection$copyTo: function (array, index) {
                if (array == null) {
                    throw new System.ArgumentNullException.$ctor1("array");
                }
                if (System.Array.getRank(array) !== 1) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentSingleDimensionArray", "array");

                }

                this.Storage.CopySubVectorTo(new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).$ctor1(array.length, Bridge.cast(array, System.Array.type(T))), 0, index, this.Count);
            },
            /**
             * Copies the values of this vector into the target vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If <b /> is not the same size as this vector.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    target    The vector to copy elements into.
             * @return  {void}
             */
            CopyTo: function (target) {
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                this.Storage.CopyTo(target.Storage);
            },
            /**
             * Returns an enumerator that iterates through the collection.
             *
             * @instance
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {System.Collections.Generic.IEnumerator$1}        A {@link } that can be used to iterate through the collection.
             */
            System$Collections$Generic$IEnumerable$1$GetEnumerator: function () {
                return Bridge.getEnumerator(this.Enumerate(), T);
            },
            /**
             * Returns an enumerator that iterates through a collection.
             *
             * @instance
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {System.Collections.IEnumerator}        An {@link } object that can be used to iterate through the collection.
             */
            System$Collections$IEnumerable$GetEnumerator: function () {
                return Bridge.getEnumerator(this.Enumerate(), T);
            },
            /**
             * Returns a string that describes the type, dimensions and shape of this vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {string}
             */
            ToTypeString: function () {
                return System.String.format("{0} {1}-{2}", Bridge.Reflection.getTypeName(Bridge.getType(this)), Bridge.box(this.Count, System.Int32), Bridge.Reflection.getTypeName(T));
            },
            ToVectorStringArray: function (maxPerColumn, maxCharactersWidth, padding, ellipsis, formatValue) {
                var $t, $t1;
                maxPerColumn = Math.max(maxPerColumn, 3);
                maxCharactersWidth = Math.max(maxCharactersWidth, 16);

                var columns = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,System.Array.type(System.String)))).ctor();
                var chars = 0;
                var offset = 0;
                while (offset < this.Count) {
                    var height = Math.min(maxPerColumn, ((this.Count - offset) | 0));
                    var candidate = this.FormatCompleteColumn(offset, height, formatValue);
                    chars = (chars + (((candidate.Item1 + padding) | 0))) | 0;
                    if (chars > maxCharactersWidth && offset > 0) {
                        break;
                    }
                    columns.add(candidate);
                    offset = (offset + height) | 0;
                }
                if (offset < this.Count) {
                    var last = columns.getItem(((columns.Count - 1) | 0));
                    var c = last.Item2;
                    c[System.Array.index(((c.length - 2) | 0), c)] = ellipsis;
                    c[System.Array.index(((c.length - 1) | 0), c)] = formatValue(this.At(((this.Count - 1) | 0)));
                }

                var rows = columns.getItem(0).Item2.length;
                var cols = columns.Count;
                var array = System.Array.create(null, null, System.String, rows, cols);
                var colIndex = 0;
                $t = Bridge.getEnumerator(columns);
                try {
                    while ($t.moveNext()) {
                        var column = $t.Current;
                        for (var k = 0; k < column.Item2.length; k = (k + 1) | 0) {
                            array.set([k, colIndex], ($t1 = column.Item2)[System.Array.index(k, $t1)]);
                        }
                        for (var k1 = column.Item2.length; k1 < rows; k1 = (k1 + 1) | 0) {
                            array.set([k1, colIndex], "");
                        }
                        colIndex = (colIndex + 1) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return array;
            },
            FormatCompleteColumn: function (offset, height, formatValue) {
                var c = System.Array.init(height, null, System.String);
                var index = 0;
                for (var k = 0; k < height; k = (k + 1) | 0) {
                    c[System.Array.index(Bridge.identity(index, ((index = (index + 1) | 0))), c)] = formatValue(this.At(((offset + k) | 0)));
                }
                var w = System.Linq.Enumerable.from(c, System.String).max(function (x) {
                        return x.length;
                    });
                return { Item1: w, Item2: c };
            },
            /**
             * Returns a string that represents the content of this vector, column by column.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {number}         maxPerColumn          Maximum number of entries and thus lines per column. Typical value: 12; Minimum: 3.
             * @param   {number}         maxCharactersWidth    Maximum number of characters per line over all columns. Typical value: 80; Minimum: 16.
             * @param   {string}         ellipsis              Character to use to print if there is not enough space to print all entries. Typical value: "..".
             * @param   {string}         columnSeparator       Character to use to separate two columns on a line. Typical value: "  " (2 spaces).
             * @param   {string}         rowSeparator          Character to use to separate two rows/lines. Typical value: Environment.NewLine.
             * @param   {System.Func}    formatValue           Function to provide a string for any given entry value.
             * @return  {string}
             */
            ToVectorString$1: function (maxPerColumn, maxCharactersWidth, ellipsis, columnSeparator, rowSeparator, formatValue) {
                return MathNet.Numerics.LinearAlgebra.Vector$1(T).FormatStringArrayToString(this.ToVectorStringArray(maxPerColumn, maxCharactersWidth, columnSeparator.length, ellipsis, formatValue), columnSeparator, rowSeparator);
            },
            /**
             * Returns a string that represents the content of this vector, column by column.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {number}                    maxPerColumn          Maximum number of entries and thus lines per column. Typical value: 12; Minimum: 3.
             * @param   {number}                    maxCharactersWidth    Maximum number of characters per line over all columns. Typical value: 80; Minimum: 16.
             * @param   {string}                    format                Floating point format string. Can be null. Default value: G6.
             * @param   {System.IFormatProvider}    provider              Format provider or culture. Can be null.
             * @return  {string}
             */
            ToVectorString: function (maxPerColumn, maxCharactersWidth, format, provider) {
                if (format === void 0) { format = null; }
                if (provider === void 0) { provider = null; }
                if (format == null) {
                    format = "G6";
                }

                return this.ToVectorString$1(maxPerColumn, maxCharactersWidth, "..", "  ", "\n", function (x) {
                    return Bridge.toString(x);
                });
            },
            /**
             * Returns a string that represents the content of this vector, column by column.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {string}                    format      Floating point format string. Can be null. Default value: G6.
             * @param   {System.IFormatProvider}    provider    Format provider or culture. Can be null.
             * @return  {string}
             */
            ToVectorString$2: function (format, provider) {
                if (format === void 0) { format = null; }
                if (provider === void 0) { provider = null; }
                if (format == null) {
                    format = "G6";
                }

                return this.ToVectorString$1(12, 80, "..", "  ", "\n", function (x) {
                    return Bridge.toString(x);
                });
            },
            /**
             * Returns a string that summarizes this vector, column by column and with a type header.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {number}                    maxPerColumn          Maximum number of entries and thus lines per column. Typical value: 12; Minimum: 3.
             * @param   {number}                    maxCharactersWidth    Maximum number of characters per line over all columns. Typical value: 80; Minimum: 16.
             * @param   {string}                    format                Floating point format string. Can be null. Default value: G6.
             * @param   {System.IFormatProvider}    provider              Format provider or culture. Can be null.
             * @return  {string}
             */
            ToString: function (maxPerColumn, maxCharactersWidth, format, provider) {
                if (format === void 0) { format = null; }
                if (provider === void 0) { provider = null; }
                return System.String.concat(this.ToTypeString(), "\n", this.ToVectorString(maxPerColumn, maxCharactersWidth, format, provider));
            },
            /**
             * Returns a string that summarizes this vector.
             The maximum number of cells can be configured in the {@link } class.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {string}
             */
            toString: function () {
                return System.String.concat(this.ToTypeString(), "\n", this.ToVectorString$2());
            },
            /**
             * Returns a string that summarizes this vector.
             The maximum number of cells can be configured in the {@link } class.
             The format string is ignored.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {string}                    format            
             * @param   {System.IFormatProvider}    formatProvider
             * @return  {string}
             */
            format: function (format, formatProvider) {
                if (format === void 0) { format = null; }
                if (formatProvider === void 0) { formatProvider = null; }
                return System.String.concat(this.ToTypeString(), "\n", this.ToVectorString$2(format, formatProvider));
            },
            /**
             * Gets the value at the given <b /> without range checking..
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {number}    index    The index of the value to get or set.
             * @return  {T}                  The value of the vector at the given <b />.
             */
            At: function (index) {
                return this.Storage.At(index);
            },
            /**
             * Sets the <b /> at the given <b /> without range checking..
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {number}    index    The index of the value to get or set.
             * @param   {T}         value    The value to set.
             * @return  {void}
             */
            At$1: function (index, value) {
                this.Storage.At$1(index, value);
            },
            /**
             * Resets all values to zero.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {void}
             */
            clear: function () {
                this.Storage.Clear();
            },
            /**
             * Sets all values of a subvector to zero.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {number}    index    
             * @param   {number}    count
             * @return  {void}
             */
            ClearSubVector: function (index, count) {
                if (count < 1) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "Resources.ArgumentMustBePositive");
                }

                if (((index + count) | 0) > this.Count || index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }

                this.Storage.Clear$1(index, count);
            },
            /**
             * Set all values that meet the predicate to zero, in-place.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {System.Func}    zeroPredicate
             * @return  {void}
             */
            CoerceZero$1: function (zeroPredicate) {
                this.MapInplace(function (x) {
                    return zeroPredicate(x) ? MathNet.Numerics.LinearAlgebra.Vector$1(T).Zero : x;
                }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Set the values of this vector to the given values.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If <b /> is not the same size as this vector.
             * @param   {Array.<T>}    values    The array containing the values to use.
             * @return  {void}
             */
            SetValues: function (values) {
                var source = new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).$ctor1(this.Count, values);
                source.CopyTo(this.Storage);
            },
            /**
             * Creates a vector containing specified elements.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws 
             * @throws If <b /> is not positive.
             * @param   {number}                                     index    The first element to begin copying from.
             * @param   {number}                                     count    The number of elements to copy.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}             A vector containing a copy of the specified elements.
             */
            SubVector: function (index, count) {
                var target = this.v_builder.SameAs$5(T, this, count);
                this.Storage.CopySubVectorTo(target.Storage, index, 0, count, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return target;
            },
            /**
             * Copies the values of a given vector into a region in this vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @throws If <b /> is {@link ArgumentNullException}
             * @param   {number}                                     index        The field to start copying to
             * @param   {number}                                     count        The number of fields to copy. Must be positive.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    subVector    The sub-vector to copy from.
             * @return  {void}
             */
            SetSubVector: function (index, count, subVector) {
                if (subVector == null) {
                    throw new System.ArgumentNullException.$ctor1("subVector");
                }

                subVector.Storage.CopySubVectorTo(this.Storage, 0, index, count);
            },
            /**
             * Copies the requested elements from this vector to another.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    destination    The vector to copy the elements to.
             * @param   {number}                                     sourceIndex    The element to start copying from.
             * @param   {number}                                     targetIndex    The element to start copying to.
             * @param   {number}                                     count          The number of elements to copy.
             * @return  {void}
             */
            CopySubVectorTo: function (destination, sourceIndex, targetIndex, count) {
                if (destination == null) {
                    throw new System.ArgumentNullException.$ctor1("destination");
                }

                this.Storage.CopySubVectorTo(destination.Storage, sourceIndex, targetIndex, count);
            },
            /**
             * Returns the data contained in the vector as an array.
             The returned array will be independent from this vector.
             A new memory block will be allocated for the array.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {Array.<T>}        The vector's data as an array.
             */
            ToArray: function () {
                return this.Storage.ToArray();
            },
            /**
             * Returns the internal array of this vector if, and only if, this vector is stored by such an array internally.
             Otherwise returns null. Changes to the returned array and the vector will affect each other.
             Use ToArray instead if you always need an independent array.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {Array.<T>}
             */
            AsArray: function () {
                return this.Storage.AsArray();
            },
            /**
             * Create a matrix based on this vector in column form (one single column).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        This vector as a column matrix.
             */
            ToColumnMatrix: function () {
                var result = this.m_builder.SameAs$2(this, this.Count, 1);
                this.Storage.CopyToColumnUnchecked(result.Storage, 0, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Create a matrix based on this vector in row form (one single row).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        This vector as a row matrix.
             */
            ToRowMatrix: function () {
                var result = this.m_builder.SameAs$2(this, 1, this.Count);
                this.Storage.CopyToRowUnchecked(result.Storage, 0, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Returns an IEnumerable that can be used to iterate through all values of the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            Enumerate: function () {
                return this.Storage.Enumerate();
            },
            /**
             * Returns an IEnumerable that can be used to iterate through all values of the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}        zeros
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            Enumerate$1: function (zeros) {
                if (zeros === void 0) { zeros = 1; }
                switch (zeros) {
                    case MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip: 
                        return this.Storage.EnumerateNonZero();
                    default: 
                        return this.Storage.Enumerate();
                }
            },
            /**
             * Returns an IEnumerable that can be used to iterate through all values of the vector and their index.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            EnumerateIndexed: function () {
                return this.Storage.EnumerateIndexed();
            },
            /**
             * Returns an IEnumerable that can be used to iterate through all values of the vector and their index.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}        zeros
             * @return  {System.Collections.Generic.IEnumerable$1}
             */
            EnumerateIndexed$1: function (zeros) {
                if (zeros === void 0) { zeros = 1; }
                switch (zeros) {
                    case MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip: 
                        return this.Storage.EnumerateNonZeroIndexed();
                    default: 
                        return this.Storage.EnumerateIndexed();
                }
            },
            /**
             * Applies a function to each value of this vector and replaces the value with its result.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse vectors).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {System.Func}                             f        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {void}
             */
            MapInplace: function (f, zeros) {
                if (zeros === void 0) { zeros = 0; }
                this.Storage.MapInplace(f, zeros);
            },
            /**
             * Applies a function to each value of this vector and replaces the value with its result.
             The index of each value (zero-based) is passed as first argument to the function.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse vectors).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {System.Func}                             f        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {void}
             */
            MapIndexedInplace: function (f, zeros) {
                if (zeros === void 0) { zeros = 0; }
                this.Storage.MapIndexedInplace(f, zeros);
            },
            /**
             * Applies a function to each value of this vector and replaces the value in the result vector.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse vectors).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {System.Func}                                f         
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {void}
             */
            Map$1: function (f, result, zeros) {
                if (zeros === void 0) { zeros = 0; }
                if (Bridge.referenceEquals(this, result)) {
                    this.Storage.MapInplace(f, zeros);
                } else {
                    this.Storage.MapTo(T, result.Storage, f, zeros, zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include ? MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros : MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
                }
            },
            /**
             * Applies a function to each value of this vector and returns the results as a new vector.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse vectors).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {Function}                                   TU       
             * @param   {System.Func}                                f        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            Map: function (TU, f, zeros) {
                if (zeros === void 0) { zeros = 0; }
                var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TU).Vector;
                var result = v_builder.SameAs$4(T, this);
                this.Storage.MapToUnchecked(TU, result.Storage, f, zeros, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Applies a function to each value of this vector and replaces the value in the result vector.
             The index of each value (zero-based) is passed as first argument to the function.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse vectors).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {System.Func}                                f         
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {void}
             */
            MapIndexed$1: function (f, result, zeros) {
                if (zeros === void 0) { zeros = 0; }
                if (Bridge.referenceEquals(this, result)) {
                    this.Storage.MapIndexedInplace(f, zeros);
                } else {
                    this.Storage.MapIndexedTo(T, result.Storage, f, zeros, zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include ? MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros : MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
                }
            },
            /**
             * Applies a function to each value of this vector and returns the results as a new vector.
             The index of each value (zero-based) is passed as first argument to the function.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse vectors).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {Function}                                   TU       
             * @param   {System.Func}                                f        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            MapIndexed: function (TU, f, zeros) {
                if (zeros === void 0) { zeros = 0; }
                var v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TU).Vector;
                var result = v_builder.SameAs$4(T, this);
                this.Storage.MapIndexedToUnchecked(TU, result.Storage, f, zeros, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Applies a function to each value of this vector and replaces the value in the result vector.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse vectors).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {Function}                                   TU        
             * @param   {System.Func}                                f         
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {void}
             */
            MapConvert: function (TU, f, result, zeros) {
                if (zeros === void 0) { zeros = 0; }
                this.Storage.MapTo(TU, result.Storage, f, zeros, zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include ? MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros : MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
            },
            /**
             * Applies a function to each value of this vector and replaces the value in the result vector.
             The index of each value (zero-based) is passed as first argument to the function.
             If forceMapZero is not set to true, zero values may or may not be skipped depending
             on the actual data storage implementation (relevant mostly for sparse vectors).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {Function}                                   TU        
             * @param   {System.Func}                                f         
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {void}
             */
            MapIndexedConvert: function (TU, f, result, zeros) {
                if (zeros === void 0) { zeros = 0; }
                this.Storage.MapIndexedTo(TU, result.Storage, f, zeros, zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include ? MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros : MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
            },
            /**
             * Applies a function to each value pair of two vectors and replaces the value in the result vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {System.Func}                                f         
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {void}
             */
            Map2$1: function (f, other, result, zeros) {
                if (zeros === void 0) { zeros = 0; }
                this.Storage.Map2To(result.Storage, other.Storage, f, zeros, MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
            },
            /**
             * Applies a function to each value pair of two vectors and returns the results as a new vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {System.Func}                                f        
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            Map2: function (f, other, zeros) {
                if (zeros === void 0) { zeros = 0; }
                var result = this.v_builder.SameAs$4(T, this);
                this.Storage.Map2To(result.Storage, other.Storage, f, zeros, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Applies a function to update the status with each value pair of two vectors and returns the resulting status.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {Function}                                   TOther    
             * @param   {Function}                                   TState    
             * @param   {System.Func}                                f         
             * @param   {TState}                                     state     
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {TState}
             */
            Fold2: function (TOther, TState, f, state, other, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Fold2(TOther, TState, other.Storage, f, state, zeros);
            },
            /**
             * Returns a tuple with the index and value of the first element satisfying a predicate, or null if none is found.
             Zero elements may be skipped on sparse data structures if allowed (default).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {System.Func}                             predicate    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {System.Tuple$2}
             */
            Find: function (predicate, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Find(predicate, zeros);
            },
            /**
             * Returns a tuple with the index and values of the first element pair of two vectors of the same size satisfying a predicate, or null if none is found.
             Zero elements may be skipped on sparse data structures if allowed (default).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {Function}                                   TOther       
             * @param   {System.Func}                                predicate    
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {System.Tuple$3}
             */
            Find2: function (TOther, predicate, other, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Find2(TOther, other.Storage, predicate, zeros);
            },
            /**
             * Returns true if at least one element satisfies a predicate.
             Zero elements may be skipped on sparse data structures if allowed (default).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {System.Func}                             predicate    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {boolean}
             */
            Exists: function (predicate, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Find(predicate, zeros) != null;
            },
            /**
             * Returns true if at least one element pairs of two vectors of the same size satisfies a predicate.
             Zero elements may be skipped on sparse data structures if allowed (default).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {Function}                                   TOther       
             * @param   {System.Func}                                predicate    
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {boolean}
             */
            Exists2: function (TOther, predicate, other, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Find2(TOther, other.Storage, predicate, zeros) != null;
            },
            /**
             * Returns true if all elements satisfy a predicate.
             Zero elements may be skipped on sparse data structures if allowed (default).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {System.Func}                             predicate    
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {boolean}
             */
            ForAll: function (predicate, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Find(function (x) {
                    return !predicate(x);
                }, zeros) == null;
            },
            /**
             * Returns true if all element pairs of two vectors of the same size satisfy a predicate.
             Zero elements may be skipped on sparse data structures if allowed (default).
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Vector$1
             * @memberof MathNet.Numerics.LinearAlgebra.Vector$1
             * @param   {Function}                                   TOther       
             * @param   {System.Func}                                predicate    
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other        
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}       zeros
             * @return  {boolean}
             */
            ForAll2: function (TOther, predicate, other, zeros) {
                if (zeros === void 0) { zeros = 0; }
                return this.Storage.Find2(TOther, other.Storage, function (x, y) {
                    return !predicate(x, y);
                }, zeros) == null;
            }
        }
    }; });

    /** @namespace MathNet.Numerics.LinearAlgebra.Factorization */

    /**
     * Classes that solves a system of linear equations, <pre><code>AX = B</code></pre>.
     *
     * @abstract
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Factorization.ISolver$1
     * @param   {Function}    [name]    Supported data types are double, single, {@link }, and {@link }.
     */
    Bridge.definei("MathNet.Numerics.LinearAlgebra.Factorization.ISolver$1", function (T) { return {
        $kind: "interface"
    }; });

    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1", function (T) { return {
        statics: {
            fields: {
                _singleton: null
            },
            props: {
                Matrix: {
                    get: function () {
                        return MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T)._singleton.Item1;
                    }
                },
                Vector: {
                    get: function () {
                        return MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T)._singleton.Item2;
                    }
                }
            },
            ctors: {
                init: function () {
                    this._singleton = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Create();
                }
            },
            methods: {
                Create: function () {


                    if (Bridge.referenceEquals(T, System.Double)) {
                        return { Item1: Bridge.cast(new MathNet.Numerics.LinearAlgebra.Double.MatrixBuilder(), MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1(T)), Item2: Bridge.cast(new MathNet.Numerics.LinearAlgebra.Double.VectorBuilder(), MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1(T)) };
                    }



                    throw new System.NotSupportedException.$ctor1(System.String.format("Matrices and vectors of type '{0}' are not supported. Only Double, Single, Complex or Complex32 are supported at this point.", [Bridge.Reflection.getTypeName(T)]));
                },
                Register: function (matrixBuilder, vectorBuilder) {
                    MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T)._singleton = { Item1: matrixBuilder, Item2: vectorBuilder };
                }
            }
        }
    }; });

    /** @namespace MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra */

    /**
     * Generic linear algebra type builder, for situations where a matrix or vector
     must be created in a generic way. Usage of generic builders should not be
     required in normal user code.
     *
     * @abstract
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1", function (T) { return {
        methods: {
            /**
             * Create a new matrix straight from an initialized matrix storage instance.
             If you have an instance of a discrete storage type instead, use their direct methods instead.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1}    storage
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            OfStorage: function (storage) {
                if (storage == null) {
                    throw new System.ArgumentNullException.$ctor1("storage");
                }

                var dense = Bridge.as(storage, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T));
                if (dense != null) {
                    return this.Dense(dense);
                }

                var sparse = Bridge.as(storage, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T));
                if (sparse != null) {
                    return this.Sparse(sparse);
                }

                var diagonal = Bridge.as(storage, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T));
                if (diagonal != null) {
                    return this.Diagonal$1(diagonal);
                }

                throw new System.NotSupportedException.$ctor1(System.String.format("Matrix storage type '{0}' is not supported. Only DenseColumnMajorMatrixStorage, SparseCompressedRowMatrixStorage and DiagonalMatrixStorage are supported as this point.", [Bridge.Reflection.getTypeName(Bridge.getType(storage))]));
            },
            /**
             * Create a new matrix with the same kind of the provided example.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Function}                                   TU              
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    example         
             * @param   {number}                                     rows            
             * @param   {number}                                     columns         
             * @param   {boolean}                                    fullyMutable
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SameAs$4: function (TU, example, rows, columns, fullyMutable) {
                if (fullyMutable === void 0) { fullyMutable = false; }
                var storage = example.Storage;
                if (Bridge.is(storage, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T))) {
                    return this.Dense$1(rows, columns);
                }
                if (Bridge.is(storage, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T))) {
                    return fullyMutable ? this.Sparse$1(rows, columns) : this.Diagonal$2(rows, columns);
                }
                if (Bridge.is(storage, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))) {
                    return this.Sparse$1(rows, columns);
                }
                return this.Dense$1(rows, columns);
            },
            /**
             * Create a new matrix with the same kind and dimensions of the provided example.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Function}                                   TU         
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    example
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SameAs$3: function (TU, example) {
                return this.SameAs$4(TU, example, example.RowCount, example.ColumnCount);
            },
            /**
             * Create a new matrix with the same kind of the provided example.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    example    
             * @param   {number}                                     rows       
             * @param   {number}                                     columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SameAs$2: function (example, rows, columns) {
                return example.Storage.IsDense ? this.Dense$1(rows, columns) : this.Sparse$1(rows, columns);
            },
            /**
             * Create a new matrix with a type that can represent and is closest to both provided samples.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    example         
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    otherExample    
             * @param   {number}                                     rows            
             * @param   {number}                                     columns         
             * @param   {boolean}                                    fullyMutable
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SameAs$1: function (example, otherExample, rows, columns, fullyMutable) {
                if (fullyMutable === void 0) { fullyMutable = false; }
                var storage1 = example.Storage;
                var storage2 = otherExample.Storage;
                if (Bridge.is(storage1, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)) || Bridge.is(storage2, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T))) {
                    return this.Dense$1(rows, columns);
                }
                if (Bridge.is(storage1, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T)) && Bridge.is(storage2, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T))) {
                    return fullyMutable ? this.Sparse$1(rows, columns) : this.Diagonal$2(rows, columns);
                }
                if (Bridge.is(storage1, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T)) || Bridge.is(storage2, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))) {
                    return this.Sparse$1(rows, columns);
                }
                return this.Dense$1(rows, columns);
            },
            /**
             * Create a new matrix with a type that can represent and is closest to both provided samples and the dimensions of example.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    example         
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    otherExample
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SameAs: function (example, otherExample) {
                return this.SameAs$1(example, otherExample, example.RowCount, example.ColumnCount);
            },
            /**
             * Create a new dense matrix with the given number of rows and columns.
             All cells of the matrix will be initialized to zero.
             Zero-length matrices are not supported.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Dense$1: function (rows, columns) {
                return this.Dense(new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).ctor(rows, columns));
            },
            /**
             * Create a new dense matrix with the given number of rows and columns directly binding to a raw array.
             The array is assumed to be in column-major order (column by column) and is used directly without copying.
             Very efficient, but changes to the array and the matrix will affect each other.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns    
             * @param   {Array.<T>}                                  storage
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             * @see {@link }
             */
            Dense$3: function (rows, columns, storage) {
                return this.Dense(new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).$ctor1(rows, columns, storage));
            },
            /**
             * Create a new dense matrix and initialize each value to the same provided value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns    
             * @param   {T}                                          value
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Dense$2: function (rows, columns, value) {
                if (Bridge.equalsT(this.Zero, value, T)) {
                    return this.Dense$1(rows, columns);
                }
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfValue(rows, columns, value));
            },
            /**
             * Create a new dense matrix and initialize each value using the provided init function.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns    
             * @param   {System.Func}                                init
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Dense$4: function (rows, columns, init) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfInit(rows, columns, init));
            },
            /**
             * Create a new diagonal dense matrix and initialize each diagonal value to the same provided value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns    
             * @param   {T}                                          value
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseDiagonal$1: function (rows, columns, value) {
                if (Bridge.equalsT(this.Zero, value, T)) {
                    return this.Dense$1(rows, columns);
                }
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfDiagonalInit(rows, columns, function (i) {
                    return value;
                }));
            },
            /**
             * Create a new diagonal dense matrix and initialize each diagonal value to the same provided value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     order    
             * @param   {T}                                          value
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseDiagonal: function (order, value) {
                if (Bridge.equalsT(this.Zero, value, T)) {
                    return this.Dense$1(order, order);
                }
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfDiagonalInit(order, order, function (i) {
                    return value;
                }));
            },
            /**
             * Create a new diagonal dense matrix and initialize each diagonal value using the provided init function.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns    
             * @param   {System.Func}                                init
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseDiagonal$2: function (rows, columns, init) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfDiagonalInit(rows, columns, init));
            },
            /**
             * Create a new diagonal dense identity matrix with a one-diagonal.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseIdentity$1: function (rows, columns) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfDiagonalInit(rows, columns, Bridge.fn.bind(this, function (i) {
                    return this.One;
                })));
            },
            /**
             * Create a new diagonal dense identity matrix with a one-diagonal.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     order
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseIdentity: function (order) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfDiagonalInit(order, order, Bridge.fn.bind(this, function (i) {
                    return this.One;
                })));
            },
            /**
             * Create a new dense matrix as a copy of the given other matrix.
             This new matrix will be independent from the other matrix.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfMatrix: function (matrix) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfMatrix(matrix.Storage));
            },
            /**
             * Create a new dense matrix as a copy of the given two-dimensional array.
             This new matrix will be independent from the provided array.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<T>}                                  array
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfArray: function (array) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfArray(array));
            },
            /**
             * Create a new dense matrix as a copy of the given indexed enumerable.
             Keys must be provided at most once, zero is assumed if a key is omitted.
             This new matrix will be independent from the enumerable.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                      rows          
             * @param   {number}                                      columns       
             * @param   {System.Collections.Generic.IEnumerable$1}    enumerable
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfIndexed: function (rows, columns, enumerable) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfIndexedEnumerable(rows, columns, enumerable));
            },
            /**
             * Create a new dense matrix as a copy of the given enumerable.
             The enumerable is assumed to be in column-major order (column by column).
             This new matrix will be independent from the enumerable.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                      rows           
             * @param   {number}                                      columns        
             * @param   {System.Collections.Generic.IEnumerable$1}    columnMajor
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfColumnMajor: function (rows, columns, columnMajor) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfColumnMajorEnumerable(rows, columns, columnMajor));
            },
            /**
             * Create a new dense matrix as a copy of the given enumerable of enumerable columns.
             Each enumerable in the master enumerable specifies a column.
             This new matrix will be independent from the enumerables.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    data
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfColumns: function (data) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfColumnArrays(System.Linq.Enumerable.from(data, System.Collections.Generic.IEnumerable$1(T)).select(function (v) {
                        var $t;
                        return (Bridge.as(v, System.Array.type(T))) || ($t = T, System.Linq.Enumerable.from(v, $t).ToArray($t));
                    }).ToArray(System.Array.type(T))));
            },
            /**
             * Create a new dense matrix as a copy of the given enumerable of enumerable columns.
             Each enumerable in the master enumerable specifies a column.
             This new matrix will be independent from the enumerables.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                      rows       
             * @param   {number}                                      columns    
             * @param   {System.Collections.Generic.IEnumerable$1}    data
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfColumns$1: function (rows, columns, data) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfColumnEnumerables(rows, columns, data));
            },
            /**
             * Create a new dense matrix of T as a copy of the given column arrays.
             This new matrix will be independent from the arrays.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<Array.<T>>}                          columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfColumnArrays: function (columns) {
                if (columns === void 0) { columns = []; }
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfColumnArrays(columns));
            },
            /**
             * Create a new dense matrix of T as a copy of the given column arrays.
             This new matrix will be independent from the arrays.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfColumnArrays$1: function (columns) {
                var $t;
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfColumnArrays((Bridge.as(columns, System.Array.type(System.Array.type(T)))) || ($t = System.Array.type(T), System.Linq.Enumerable.from(columns, $t).ToArray($t))));
            },
            /**
             * Create a new dense matrix as a copy of the given column vectors.
             This new matrix will be independent from the vectors.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}    columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfColumnVectors: function (columns) {
                if (columns === void 0) { columns = []; }
                var storage = System.Array.init(columns.length, null, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T));
                for (var i = 0; i < columns.length; i = (i + 1) | 0) {
                    storage[System.Array.index(i, storage)] = columns[System.Array.index(i, columns)].Storage;
                }
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfColumnVectors(storage));
            },
            /**
             * Create a new dense matrix as a copy of the given column vectors.
             This new matrix will be independent from the vectors.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfColumnVectors$1: function (columns) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfColumnVectors(System.Linq.Enumerable.from(columns, MathNet.Numerics.LinearAlgebra.Vector$1(T)).select(function (c) {
                        return c.Storage;
                    }).ToArray(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T))));
            },
            /**
             * Create a new dense matrix as a copy of the given enumerable.
             The enumerable is assumed to be in row-major order (row by row).
             This new matrix will be independent from the enumerable.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                      rows           
             * @param   {number}                                      columns        
             * @param   {System.Collections.Generic.IEnumerable$1}    columnMajor
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfRowMajor: function (rows, columns, columnMajor) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfRowMajorEnumerable(rows, columns, columnMajor));
            },
            /**
             * Create a new dense matrix as a copy of the given enumerable of enumerable rows.
             Each enumerable in the master enumerable specifies a row.
             This new matrix will be independent from the enumerables.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    data
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfRows: function (data) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfRowArrays(System.Linq.Enumerable.from(data, System.Collections.Generic.IEnumerable$1(T)).select(function (v) {
                        var $t;
                        return (Bridge.as(v, System.Array.type(T))) || ($t = T, System.Linq.Enumerable.from(v, $t).ToArray($t));
                    }).ToArray(System.Array.type(T))));
            },
            /**
             * Create a new dense matrix as a copy of the given enumerable of enumerable rows.
             Each enumerable in the master enumerable specifies a row.
             This new matrix will be independent from the enumerables.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                      rows       
             * @param   {number}                                      columns    
             * @param   {System.Collections.Generic.IEnumerable$1}    data
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfRows$1: function (rows, columns, data) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfRowEnumerables(rows, columns, data));
            },
            /**
             * Create a new dense matrix of T as a copy of the given row arrays.
             This new matrix will be independent from the arrays.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<Array.<T>>}                          rows
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfRowArrays: function (rows) {
                if (rows === void 0) { rows = []; }
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfRowArrays(rows));
            },
            /**
             * Create a new dense matrix of T as a copy of the given row arrays.
             This new matrix will be independent from the arrays.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    rows
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfRowArrays$1: function (rows) {
                var $t;
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfRowArrays((Bridge.as(rows, System.Array.type(System.Array.type(T)))) || ($t = System.Array.type(T), System.Linq.Enumerable.from(rows, $t).ToArray($t))));
            },
            /**
             * Create a new dense matrix as a copy of the given row vectors.
             This new matrix will be independent from the vectors.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}    rows
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfRowVectors: function (rows) {
                if (rows === void 0) { rows = []; }
                var storage = System.Array.init(rows.length, null, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T));
                for (var i = 0; i < rows.length; i = (i + 1) | 0) {
                    storage[System.Array.index(i, storage)] = rows[System.Array.index(i, rows)].Storage;
                }
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfRowVectors(storage));
            },
            /**
             * Create a new dense matrix as a copy of the given row vectors.
             This new matrix will be independent from the vectors.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    rows
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfRowVectors$1: function (rows) {
                return this.Dense(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfRowVectors(System.Linq.Enumerable.from(rows, MathNet.Numerics.LinearAlgebra.Vector$1(T)).select(function (r) {
                        return r.Storage;
                    }).ToArray(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T))));
            },
            /**
             * Create a new dense matrix with the diagonal as a copy of the given vector.
             This new matrix will be independent from the vector.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    diagonal
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfDiagonalVector: function (diagonal) {
                var m = this.Dense$1(diagonal.Count, diagonal.Count);
                m.SetDiagonal$1(diagonal);
                return m;
            },
            /**
             * Create a new dense matrix with the diagonal as a copy of the given vector.
             This new matrix will be independent from the vector.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows        
             * @param   {number}                                     columns     
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    diagonal
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfDiagonalVector$1: function (rows, columns, diagonal) {
                var m = this.Dense$1(rows, columns);
                m.SetDiagonal$1(diagonal);
                return m;
            },
            /**
             * Create a new dense matrix with the diagonal as a copy of the given array.
             This new matrix will be independent from the array.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<T>}                                  diagonal
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfDiagonalArray: function (diagonal) {
                var m = this.Dense$1(diagonal.length, diagonal.length);
                m.SetDiagonal(diagonal);
                return m;
            },
            /**
             * Create a new dense matrix with the diagonal as a copy of the given array.
             This new matrix will be independent from the array.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows        
             * @param   {number}                                     columns     
             * @param   {Array.<T>}                                  diagonal
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfDiagonalArray$1: function (rows, columns, diagonal) {
                var m = this.Dense$1(rows, columns);
                m.SetDiagonal(diagonal);
                return m;
            },
            /**
             * Create a new dense matrix from a 2D array of existing matrices.
             The matrices in the array are not required to be dense already.
             If the matrices do not align properly, they are placed on the top left
             corner of their cell with the remaining fields left zero.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<MathNet.Numerics.LinearAlgebra.Matrix$1>}    matrices
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DenseOfMatrixArray: function (matrices) {
                var rowspans = System.Array.init(System.Array.getLength(matrices, 0), 0, System.Int32);
                var colspans = System.Array.init(System.Array.getLength(matrices, 1), 0, System.Int32);
                for (var i = 0; i < rowspans.length; i = (i + 1) | 0) {
                    for (var j = 0; j < colspans.length; j = (j + 1) | 0) {
                        rowspans[System.Array.index(i, rowspans)] = Math.max(rowspans[System.Array.index(i, rowspans)], matrices.get([i, j]).RowCount);
                        colspans[System.Array.index(j, colspans)] = Math.max(colspans[System.Array.index(j, colspans)], matrices.get([i, j]).ColumnCount);
                    }
                }
                var m = this.Dense$1(System.Linq.Enumerable.from(rowspans, System.Int32).sum(), System.Linq.Enumerable.from(colspans, System.Int32).sum());
                var rowoffset = 0;
                for (var i1 = 0; i1 < rowspans.length; i1 = (i1 + 1) | 0) {
                    var coloffset = 0;
                    for (var j1 = 0; j1 < colspans.length; j1 = (j1 + 1) | 0) {
                        m.SetSubMatrix(rowoffset, coloffset, matrices.get([i1, j1]));
                        coloffset = (coloffset + colspans[System.Array.index(j1, colspans)]) | 0;
                    }
                    rowoffset = (rowoffset + rowspans[System.Array.index(i1, rowspans)]) | 0;
                }
                return m;
            },
            /**
             * Create a sparse matrix of T with the given number of rows and columns.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       The number of rows.
             * @param   {number}                                     columns    The number of columns.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Sparse$1: function (rows, columns) {
                return this.Sparse(new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(rows, columns));
            },
            /**
             * Create a new sparse matrix and initialize each value to the same provided value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns    
             * @param   {T}                                          value
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Sparse$2: function (rows, columns, value) {
                if (Bridge.equalsT(this.Zero, value, T)) {
                    return this.Sparse$1(rows, columns);
                }
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfValue(rows, columns, value));
            },
            /**
             * Create a new sparse matrix and initialize each value using the provided init function.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns    
             * @param   {System.Func}                                init
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Sparse$3: function (rows, columns, init) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfInit(rows, columns, init));
            },
            /**
             * Create a new diagonal sparse matrix and initialize each diagonal value to the same provided value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns    
             * @param   {T}                                          value
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseDiagonal$1: function (rows, columns, value) {
                if (Bridge.equalsT(this.Zero, value, T)) {
                    return this.Sparse$1(rows, columns);
                }
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfDiagonalInit(rows, columns, function (i) {
                    return value;
                }));
            },
            /**
             * Create a new diagonal sparse matrix and initialize each diagonal value to the same provided value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     order    
             * @param   {T}                                          value
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseDiagonal: function (order, value) {
                if (Bridge.equalsT(this.Zero, value, T)) {
                    return this.Sparse$1(order, order);
                }
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfDiagonalInit(order, order, function (i) {
                    return value;
                }));
            },
            /**
             * Create a new diagonal sparse matrix and initialize each diagonal value using the provided init function.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns    
             * @param   {System.Func}                                init
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseDiagonal$2: function (rows, columns, init) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfDiagonalInit(rows, columns, init));
            },
            /**
             * Create a new diagonal dense identity matrix with a one-diagonal.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseIdentity$1: function (rows, columns) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfDiagonalInit(rows, columns, Bridge.fn.bind(this, function (i) {
                    return this.One;
                })));
            },
            /**
             * Create a new diagonal dense identity matrix with a one-diagonal.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     order
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseIdentity: function (order) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfDiagonalInit(order, order, Bridge.fn.bind(this, function (i) {
                    return this.One;
                })));
            },
            /**
             * Create a new sparse matrix as a copy of the given other matrix.
             This new matrix will be independent from the other matrix.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfMatrix: function (matrix) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfMatrix(matrix.Storage));
            },
            /**
             * Create a new sparse matrix as a copy of the given two-dimensional array.
             This new matrix will be independent from the provided array.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<T>}                                  array
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfArray: function (array) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfArray(array));
            },
            /**
             * Create a new sparse matrix as a copy of the given indexed enumerable.
             Keys must be provided at most once, zero is assumed if a key is omitted.
             This new matrix will be independent from the enumerable.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                      rows          
             * @param   {number}                                      columns       
             * @param   {System.Collections.Generic.IEnumerable$1}    enumerable
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfIndexed: function (rows, columns, enumerable) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfIndexedEnumerable(rows, columns, enumerable));
            },
            /**
             * Create a new sparse matrix as a copy of the given enumerable.
             The enumerable is assumed to be in row-major order (row by row).
             This new matrix will be independent from the enumerable.
             A new memory block will be allocated for storing the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                      rows        
             * @param   {number}                                      columns     
             * @param   {System.Collections.Generic.IEnumerable$1}    rowMajor
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             * @see {@link }
             */
            SparseOfRowMajor: function (rows, columns, rowMajor) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfRowMajorEnumerable(rows, columns, rowMajor));
            },
            /**
             * Create a new sparse matrix with the given number of rows and columns as a copy of the given array.
             The array is assumed to be in column-major order (column by column).
             This new matrix will be independent from the provided array.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows           
             * @param   {number}                                     columns        
             * @param   {System.Collections.Generic.IList$1}         columnMajor
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             * @see {@link }
             */
            SparseOfColumnMajor: function (rows, columns, columnMajor) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfColumnMajorList(rows, columns, columnMajor));
            },
            /**
             * Create a new sparse matrix as a copy of the given enumerable of enumerable columns.
             Each enumerable in the master enumerable specifies a column.
             This new matrix will be independent from the enumerables.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    data
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfColumns: function (data) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfColumnArrays(System.Linq.Enumerable.from(data, System.Collections.Generic.IEnumerable$1(T)).select(function (v) {
                        var $t;
                        return (Bridge.as(v, System.Array.type(T))) || ($t = T, System.Linq.Enumerable.from(v, $t).ToArray($t));
                    }).ToArray(System.Array.type(T))));
            },
            /**
             * Create a new sparse matrix as a copy of the given enumerable of enumerable columns.
             Each enumerable in the master enumerable specifies a column.
             This new matrix will be independent from the enumerables.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                      rows       
             * @param   {number}                                      columns    
             * @param   {System.Collections.Generic.IEnumerable$1}    data
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfColumns$1: function (rows, columns, data) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfColumnEnumerables(rows, columns, data));
            },
            /**
             * Create a new sparse matrix as a copy of the given column arrays.
             This new matrix will be independent from the arrays.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<Array.<T>>}                          columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfColumnArrays: function (columns) {
                if (columns === void 0) { columns = []; }
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfColumnArrays(columns));
            },
            /**
             * Create a new sparse matrix as a copy of the given column arrays.
             This new matrix will be independent from the arrays.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfColumnArrays$1: function (columns) {
                var $t;
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfColumnArrays((Bridge.as(columns, System.Array.type(System.Array.type(T)))) || ($t = System.Array.type(T), System.Linq.Enumerable.from(columns, $t).ToArray($t))));
            },
            /**
             * Create a new sparse matrix as a copy of the given column vectors.
             This new matrix will be independent from the vectors.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}    columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfColumnVectors: function (columns) {
                if (columns === void 0) { columns = []; }
                var storage = System.Array.init(columns.length, null, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T));
                for (var i = 0; i < columns.length; i = (i + 1) | 0) {
                    storage[System.Array.index(i, storage)] = columns[System.Array.index(i, columns)].Storage;
                }
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfColumnVectors(storage));
            },
            /**
             * Create a new sparse matrix as a copy of the given column vectors.
             This new matrix will be independent from the vectors.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfColumnVectors$1: function (columns) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfColumnVectors(System.Linq.Enumerable.from(columns, MathNet.Numerics.LinearAlgebra.Vector$1(T)).select(function (c) {
                        return c.Storage;
                    }).ToArray(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T))));
            },
            /**
             * Create a new sparse matrix as a copy of the given enumerable of enumerable rows.
             Each enumerable in the master enumerable specifies a row.
             This new matrix will be independent from the enumerables.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    data
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfRows: function (data) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfRowArrays(System.Linq.Enumerable.from(data, System.Collections.Generic.IEnumerable$1(T)).select(function (v) {
                        var $t;
                        return (Bridge.as(v, System.Array.type(T))) || ($t = T, System.Linq.Enumerable.from(v, $t).ToArray($t));
                    }).ToArray(System.Array.type(T))));
            },
            /**
             * Create a new sparse matrix as a copy of the given enumerable of enumerable rows.
             Each enumerable in the master enumerable specifies a row.
             This new matrix will be independent from the enumerables.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                      rows       
             * @param   {number}                                      columns    
             * @param   {System.Collections.Generic.IEnumerable$1}    data
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfRows$1: function (rows, columns, data) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfRowEnumerables(rows, columns, data));
            },
            /**
             * Create a new sparse matrix as a copy of the given row arrays.
             This new matrix will be independent from the arrays.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<Array.<T>>}                          rows
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfRowArrays: function (rows) {
                if (rows === void 0) { rows = []; }
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfRowArrays(rows));
            },
            /**
             * Create a new sparse matrix as a copy of the given row arrays.
             This new matrix will be independent from the arrays.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    rows
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfRowArrays$1: function (rows) {
                var $t;
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfRowArrays((Bridge.as(rows, System.Array.type(System.Array.type(T)))) || ($t = System.Array.type(T), System.Linq.Enumerable.from(rows, $t).ToArray($t))));
            },
            /**
             * Create a new sparse matrix as a copy of the given row vectors.
             This new matrix will be independent from the vectors.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}    rows
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfRowVectors: function (rows) {
                if (rows === void 0) { rows = []; }
                var storage = System.Array.init(rows.length, null, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T));
                for (var i = 0; i < rows.length; i = (i + 1) | 0) {
                    storage[System.Array.index(i, storage)] = rows[System.Array.index(i, rows)].Storage;
                }
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfRowVectors(storage));
            },
            /**
             * Create a new sparse matrix as a copy of the given row vectors.
             This new matrix will be independent from the vectors.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    rows
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfRowVectors$1: function (rows) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T).OfRowVectors(System.Linq.Enumerable.from(rows, MathNet.Numerics.LinearAlgebra.Vector$1(T)).select(function (r) {
                        return r.Storage;
                    }).ToArray(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T))));
            },
            /**
             * Create a new sparse matrix with the diagonal as a copy of the given vector.
             This new matrix will be independent from the vector.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    diagonal
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfDiagonalVector: function (diagonal) {
                var m = this.Sparse$1(diagonal.Count, diagonal.Count);
                m.SetDiagonal$1(diagonal);
                return m;
            },
            /**
             * Create a new sparse matrix with the diagonal as a copy of the given vector.
             This new matrix will be independent from the vector.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows        
             * @param   {number}                                     columns     
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    diagonal
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfDiagonalVector$1: function (rows, columns, diagonal) {
                var m = this.Sparse$1(rows, columns);
                m.SetDiagonal$1(diagonal);
                return m;
            },
            /**
             * Create a new sparse matrix with the diagonal as a copy of the given array.
             This new matrix will be independent from the array.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<T>}                                  diagonal
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfDiagonalArray: function (diagonal) {
                var m = this.Sparse$1(diagonal.length, diagonal.length);
                m.SetDiagonal(diagonal);
                return m;
            },
            /**
             * Create a new sparse matrix with the diagonal as a copy of the given array.
             This new matrix will be independent from the array.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows        
             * @param   {number}                                     columns     
             * @param   {Array.<T>}                                  diagonal
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfDiagonalArray$1: function (rows, columns, diagonal) {
                var m = this.Sparse$1(rows, columns);
                m.SetDiagonal(diagonal);
                return m;
            },
            /**
             * Create a new sparse matrix from a 2D array of existing matrices.
             The matrices in the array are not required to be sparse already.
             If the matrices do not align properly, they are placed on the top left
             corner of their cell with the remaining fields left zero.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<MathNet.Numerics.LinearAlgebra.Matrix$1>}    matrices
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            SparseOfMatrixArray: function (matrices) {
                var rowspans = System.Array.init(System.Array.getLength(matrices, 0), 0, System.Int32);
                var colspans = System.Array.init(System.Array.getLength(matrices, 1), 0, System.Int32);
                for (var i = 0; i < rowspans.length; i = (i + 1) | 0) {
                    for (var j = 0; j < colspans.length; j = (j + 1) | 0) {
                        rowspans[System.Array.index(i, rowspans)] = Math.max(rowspans[System.Array.index(i, rowspans)], matrices.get([i, j]).RowCount);
                        colspans[System.Array.index(j, colspans)] = Math.max(colspans[System.Array.index(j, colspans)], matrices.get([i, j]).ColumnCount);
                    }
                }
                var m = this.Sparse$1(System.Linq.Enumerable.from(rowspans, System.Int32).sum(), System.Linq.Enumerable.from(colspans, System.Int32).sum());
                var rowoffset = 0;
                for (var i1 = 0; i1 < rowspans.length; i1 = (i1 + 1) | 0) {
                    var coloffset = 0;
                    for (var j1 = 0; j1 < colspans.length; j1 = (j1 + 1) | 0) {
                        m.SetSubMatrix(rowoffset, coloffset, matrices.get([i1, j1]));
                        coloffset = (coloffset + colspans[System.Array.index(j1, colspans)]) | 0;
                    }
                    rowoffset = (rowoffset + rowspans[System.Array.index(i1, rowspans)]) | 0;
                }
                return m;
            },
            /**
             * Create a new diagonal matrix with the given number of rows and columns.
             All cells of the matrix will be initialized to zero.
             Zero-length matrices are not supported.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Diagonal$2: function (rows, columns) {
                return this.Diagonal$1(new (MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T)).ctor(rows, columns));
            },
            /**
             * Create a new diagonal matrix with the given number of rows and columns directly binding to a raw array.
             The array is assumed to represent the diagonal values and is used directly without copying.
             Very efficient, but changes to the array and the matrix will affect each other.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns    
             * @param   {Array.<T>}                                  storage
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Diagonal$4: function (rows, columns, storage) {
                return this.Diagonal$1(new (MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T)).$ctor1(rows, columns, storage));
            },
            /**
             * Create a new square diagonal matrix directly binding to a raw array.
             The array is assumed to represent the diagonal values and is used directly without copying.
             Very efficient, but changes to the array and the matrix will affect each other.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<T>}                                  storage
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Diagonal: function (storage) {
                return this.Diagonal$1(new (MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T)).$ctor1(storage.length, storage.length, storage));
            },
            /**
             * Create a new diagonal matrix and initialize each diagonal value to the same provided value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns    
             * @param   {T}                                          value
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Diagonal$3: function (rows, columns, value) {
                if (Bridge.equalsT(this.Zero, value, T)) {
                    return this.Diagonal$2(rows, columns);
                }
                return this.Diagonal$1(MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T).OfValue(rows, columns, value));
            },
            /**
             * Create a new diagonal matrix and initialize each diagonal value using the provided init function.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns    
             * @param   {System.Func}                                init
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            Diagonal$5: function (rows, columns, init) {
                return this.Diagonal$1(MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T).OfInit(rows, columns, init));
            },
            /**
             * Create a new diagonal identity matrix with a one-diagonal.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows       
             * @param   {number}                                     columns
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DiagonalIdentity$1: function (rows, columns) {
                return this.Diagonal$1(MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T).OfValue(rows, columns, this.One));
            },
            /**
             * Create a new diagonal identity matrix with a one-diagonal.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     order
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DiagonalIdentity: function (order) {
                return this.Diagonal$1(MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T).OfValue(order, order, this.One));
            },
            /**
             * Create a new diagonal matrix with the diagonal as a copy of the given vector.
             This new matrix will be independent from the vector.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    diagonal
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DiagonalOfDiagonalVector: function (diagonal) {
                var m = this.Diagonal$2(diagonal.Count, diagonal.Count);
                m.SetDiagonal$1(diagonal);
                return m;
            },
            /**
             * Create a new diagonal matrix with the diagonal as a copy of the given vector.
             This new matrix will be independent from the vector.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows        
             * @param   {number}                                     columns     
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    diagonal
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DiagonalOfDiagonalVector$1: function (rows, columns, diagonal) {
                var m = this.Diagonal$2(rows, columns);
                m.SetDiagonal$1(diagonal);
                return m;
            },
            /**
             * Create a new diagonal matrix with the diagonal as a copy of the given array.
             This new matrix will be independent from the array.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {Array.<T>}                                  diagonal
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DiagonalOfDiagonalArray: function (diagonal) {
                var m = this.Diagonal$2(diagonal.length, diagonal.length);
                m.SetDiagonal(diagonal);
                return m;
            },
            /**
             * Create a new diagonal matrix with the diagonal as a copy of the given array.
             This new matrix will be independent from the array.
             A new memory block will be allocated for storing the matrix.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1
             * @param   {number}                                     rows        
             * @param   {number}                                     columns     
             * @param   {Array.<T>}                                  diagonal
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            DiagonalOfDiagonalArray$1: function (rows, columns, diagonal) {
                var m = this.Diagonal$2(rows, columns);
                m.SetDiagonal(diagonal);
                return m;
            }
        }
    }; });

    /**
     * Generic linear algebra type builder, for situations where a matrix or vector
     must be created in a generic way. Usage of generic builders should not be
     required in normal user code.
     *
     * @abstract
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1", function (T) { return {
        methods: {
            /**
             * Create a new vector straight from an initialized matrix storage instance.
             If you have an instance of a discrete storage type instead, use their direct methods instead.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1}    storage
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            OfStorage: function (storage) {
                if (storage == null) {
                    throw new System.ArgumentNullException.$ctor1("storage");
                }

                var dense = Bridge.as(storage, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T));
                if (dense != null) {
                    return this.Dense$1(dense);
                }

                var sparse = Bridge.as(storage, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T));
                if (sparse != null) {
                    return this.Sparse(sparse);
                }

                throw new System.NotSupportedException.$ctor1(System.String.format("Vector storage type '{0}' is not supported. Only DenseVectorStorage and SparseVectorStorage are supported as this point.", [Bridge.Reflection.getTypeName(Bridge.getType(storage))]));
            },
            /**
             * Create a new vector with the same kind of the provided example.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {Function}                                   TU         
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    example    
             * @param   {number}                                     length
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            SameAs$5: function (TU, example, length) {
                return example.Storage.IsDense ? this.Dense$2(length) : this.Sparse$1(length);
            },
            /**
             * Create a new vector with the same kind and dimension of the provided example.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {Function}                                   TU         
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    example
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            SameAs$4: function (TU, example) {
                return example.Storage.IsDense ? this.Dense$2(example.Count) : this.Sparse$1(example.Count);
            },
            /**
             * Create a new vector with the same kind of the provided example.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {Function}                                   TU         
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    example    
             * @param   {number}                                     length
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            SameAs$3: function (TU, example, length) {
                return example.Storage.IsDense ? this.Dense$2(length) : this.Sparse$1(length);
            },
            /**
             * Create a new vector with a type that can represent and is closest to both provided samples.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    example         
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    otherExample    
             * @param   {number}                                     length
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            SameAs$2: function (example, otherExample, length) {
                return example.Storage.IsDense || otherExample.Storage.IsDense ? this.Dense$2(length) : this.Sparse$1(length);
            },
            /**
             * Create a new vector with a type that can represent and is closest to both provided samples and the dimensions of example.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    example         
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    otherExample
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            SameAs$1: function (example, otherExample) {
                return example.Storage.IsDense || otherExample.Storage.IsDense ? this.Dense$2(example.Count) : this.Sparse$1(example.Count);
            },
            /**
             * Create a new vector with a type that can represent and is closest to both provided samples.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix    
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector    
             * @param   {number}                                     length
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            SameAs: function (matrix, vector, length) {
                return matrix.Storage.IsDense || vector.Storage.IsDense ? this.Dense$2(length) : this.Sparse$1(length);
            },
            /**
             * Create a dense vector of T with the given size.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {number}                                     size    The size of the vector.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            Dense$2: function (size) {
                return this.Dense$1(new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).ctor(size));
            },
            /**
             * Create a dense vector of T that is directly bound to the specified array.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {Array.<T>}                                  array
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            Dense: function (array) {
                return this.Dense$1(new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).$ctor1(array.length, array));
            },
            /**
             * Create a new dense vector and initialize each value using the provided value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {number}                                     length    
             * @param   {T}                                          value
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            Dense$3: function (length, value) {
                if (Bridge.equalsT(this.Zero, value, T)) {
                    return this.Dense$2(length);
                }
                return this.Dense$1(MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T).OfValue(length, value));
            },
            /**
             * Create a new dense vector and initialize each value using the provided init function.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {number}                                     length    
             * @param   {System.Func}                                init
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            Dense$4: function (length, init) {
                return this.Dense$1(MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T).OfInit(length, init));
            },
            /**
             * Create a new dense vector as a copy of the given other vector.
             This new vector will be independent from the other vector.
             A new memory block will be allocated for storing the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            DenseOfVector: function (vector) {
                return this.Dense$1(MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T).OfVector(vector.Storage));
            },
            /**
             * Create a new dense vector as a copy of the given array.
             This new vector will be independent from the array.
             A new memory block will be allocated for storing the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {Array.<T>}                                  array
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            DenseOfArray: function (array) {
                return this.Dense$1(MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T).OfVector(new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).$ctor1(array.length, array)));
            },
            /**
             * Create a new dense vector as a copy of the given enumerable.
             This new vector will be independent from the enumerable.
             A new memory block will be allocated for storing the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    enumerable
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            DenseOfEnumerable: function (enumerable) {
                return this.Dense$1(MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T).OfEnumerable(enumerable));
            },
            /**
             * Create a new dense vector as a copy of the given indexed enumerable.
             Keys must be provided at most once, zero is assumed if a key is omitted.
             This new vector will be independent from the enumerable.
             A new memory block will be allocated for storing the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {number}                                      length        
             * @param   {System.Collections.Generic.IEnumerable$1}    enumerable
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            DenseOfIndexed: function (length, enumerable) {
                return this.Dense$1(MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T).OfIndexedEnumerable(length, enumerable));
            },
            /**
             * Create a sparse vector of T with the given size.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {number}                                     size    The size of the vector.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            Sparse$1: function (size) {
                return this.Sparse(new (MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T))(size));
            },
            /**
             * Create a new sparse vector and initialize each value using the provided value.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {number}                                     length    
             * @param   {T}                                          value
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            Sparse$2: function (length, value) {
                if (Bridge.equalsT(this.Zero, value, T)) {
                    return this.Sparse$1(length);
                }
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T).OfValue(length, value));
            },
            /**
             * Create a new sparse vector and initialize each value using the provided init function.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {number}                                     length    
             * @param   {System.Func}                                init
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            Sparse$3: function (length, init) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T).OfInit(length, init));
            },
            /**
             * Create a new sparse vector as a copy of the given other vector.
             This new vector will be independent from the other vector.
             A new memory block will be allocated for storing the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            SparseOfVector: function (vector) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T).OfVector(vector.Storage));
            },
            /**
             * Create a new sparse vector as a copy of the given array.
             This new vector will be independent from the array.
             A new memory block will be allocated for storing the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {Array.<T>}                                  array
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            SparseOfArray: function (array) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T).OfEnumerable(array));
            },
            /**
             * Create a new sparse vector as a copy of the given enumerable.
             This new vector will be independent from the enumerable.
             A new memory block will be allocated for storing the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {System.Collections.Generic.IEnumerable$1}    enumerable
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            SparseOfEnumerable: function (enumerable) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T).OfEnumerable(enumerable));
            },
            /**
             * Create a new sparse vector as a copy of the given indexed enumerable.
             Keys must be provided at most once, zero is assumed if a key is omitted.
             This new vector will be independent from the enumerable.
             A new memory block will be allocated for storing the vector.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @memberof MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
             * @param   {number}                                      length        
             * @param   {System.Collections.Generic.IEnumerable$1}    enumerable
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            SparseOfIndexed: function (length, enumerable) {
                return this.Sparse(MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T).OfIndexedEnumerable(length, enumerable));
            }
        }
    }; });

    Bridge.define("MathNet.Numerics.LinearAlgebra.ExistingData", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Existing data may not be all zeros, so clearing may be necessary
                 if not all of it will be overwritten anyway.
                 *
                 * @static
                 * @public
                 * @memberof MathNet.Numerics.LinearAlgebra.ExistingData
                 * @constant
                 * @default 0
                 * @type MathNet.Numerics.LinearAlgebra.ExistingData
                 */
                Clear: 0,
                /**
                 * If existing data is assumed to be all zeros already,
                 clearing it may be skipped if applicable.
                 *
                 * @static
                 * @public
                 * @memberof MathNet.Numerics.LinearAlgebra.ExistingData
                 * @constant
                 * @default 1
                 * @type MathNet.Numerics.LinearAlgebra.ExistingData
                 */
                AssumeZeros: 1
            }
        }
    });

    Bridge.define("MathNet.Numerics.LinearAlgebra.MatrixExtensions", {
        statics: {
            methods: {
                /**
                 * Converts a matrix to single precision.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                ToSingle: function (matrix) {
                    return matrix.Map(System.Single, function (x) {
                        return x;
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Converts a matrix to double precision.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                ToDouble: function (matrix) {
                    return matrix.Map(System.Double, function (x) {
                        return x;
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Converts a matrix to single precision complex numbers.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                ToComplex32: function (matrix) {
                    return matrix.Map(mathnetnumericsbridge.Complex32, function (x) {
                        return new mathnetnumericsbridge.Complex32.$ctor1(x.Real, x.Imaginary);
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Gets a single precision complex matrix with the real parts from the given matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                ToComplex32$1: function (matrix) {
                    return matrix.Map(mathnetnumericsbridge.Complex32, function (x) {
                        return new mathnetnumericsbridge.Complex32.$ctor1(x, 0.0);
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Converts a matrix to double precision complex numbers.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                ToComplex: function (matrix) {
                    return matrix.Map(mathnetnumericsbridge.Complex, function (x) {
                        return new mathnetnumericsbridge.Complex.$ctor1(x.Real, x.Imaginary);
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Gets a double precision complex matrix with the real parts from the given matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                ToComplex$1: function (matrix) {
                    return matrix.Map(mathnetnumericsbridge.Complex, function (x) {
                        return new mathnetnumericsbridge.Complex.$ctor1(x, 0.0);
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Gets a real matrix representing the real parts of a complex matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Real: function (matrix) {
                    return matrix.Map(System.Double, function (x) {
                        return x.Real;
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Gets a real matrix representing the real parts of a complex matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Real$1: function (matrix) {
                    return matrix.Map(System.Single, function (x) {
                        return x.Real;
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Gets a real matrix representing the imaginary parts of a complex matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Imaginary: function (matrix) {
                    return matrix.Map(System.Double, function (x) {
                        return x.Imaginary;
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Gets a real matrix representing the imaginary parts of a complex matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.MatrixExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
                 */
                Imaginary$1: function (matrix) {
                    return matrix.Map(System.Single, function (x) {
                        return x.Imaginary;
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                }
            }
        }
    });

    Bridge.define("MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1", function (T) { return {
        inherits: function () { return [System.IEquatable$1(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T))]; },
        statics: {
            fields: {
                Zero: null
            },
            ctors: {
                init: function () {
                    this.Zero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix.Zero;
                }
            }
        },
        fields: {
            RowCount: 0,
            ColumnCount: 0
        },
        alias: ["equalsT", "System$IEquatable$1$MathNet$Numerics$LinearAlgebra$Storage$MatrixStorage$1$" + Bridge.getTypeAlias(T) + "$equalsT"],
        ctors: {
            ctor: function (rowCount, columnCount) {
                this.$initialize();
                if (rowCount <= 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("rowCount", "Resources.MatrixRowsMustBePositive");
                }

                if (columnCount <= 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("columnCount", "Resources.MatrixColumnsMustBePositive");
                }

                this.RowCount = rowCount;
                this.ColumnCount = columnCount;
            }
        },
        methods: {
            /**
             * Gets or sets the value at the given row and column, with range checking.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @param   {number}    row       The row of the element.
             * @param   {number}    column    The column of the element.
             * @return  {T}
             */
            getItem: function (row, column) {
                this.ValidateRange(row, column);
                return this.At(row, column);
            },
            /**
             * Gets or sets the value at the given row and column, with range checking.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @param   {number}    row       The row of the element.
             * @param   {number}    column    The column of the element.
             * @param   {T}         value     The value to get or set.
             * @return  {void}
             */
            setItem: function (row, column, value) {
                this.ValidateRange(row, column);
                this.At$1(row, column, value);
            },
            /**
             * Indicates whether the current object is equal to another object of the same type.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @param   {MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1}    other    An object to compare with this object.
             * @return  {boolean}                                                            <pre><code>true</code></pre> if the current object is equal to the <b /> parameter; otherwise, <pre><code>false</code></pre>.
             */
            equalsT: function (other) {
                if (other == null) {
                    return false;
                }
                if (this.ColumnCount !== other.ColumnCount || this.RowCount !== other.RowCount) {
                    return false;
                }

                if (Bridge.referenceEquals(this, other)) {
                    return true;
                }

                return this.Find2Unchecked(T, other, function (a, b) {
                    return !Bridge.equalsT(a, b, T);
                }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip) == null;
            },
            /**
             * Determines whether the specified {@link } is equal to the current {@link }.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @param   {System.Object}    obj    The {@link } to compare with the current {@link }.
             * @return  {boolean}                 true if the specified {@link } is equal to the current {@link }; otherwise, false.
             */
            equals: function (obj) {
                return this.equalsT(Bridge.as(obj, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T)));
            },
            /**
             * Serves as a hash function for a particular type.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @return  {number}        A hash code for the current {@link }.
             */
            getHashCode: function () {
                var hashNum = Math.min(Bridge.Int.mul(this.RowCount, this.ColumnCount), 25);
                var hash = 17;
                for (var i = 0; i < hashNum; i = (i + 1) | 0) {
                    var col = { };
                    var row = Bridge.Math.divRem(i, this.ColumnCount, col);
                    hash = (Bridge.Int.mul(hash, 31) + Bridge.getHashCode(this.At(row, col.v))) | 0;
                }
                return hash;
            },
            Clear: function () {
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        this.At$1(i, j, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                    }
                }
            },
            Clear$1: function (rowIndex, rowCount, columnIndex, columnCount) {
                if (rowCount < 1 || columnCount < 1) {
                    return;
                }

                if (((rowIndex + rowCount) | 0) > this.RowCount || rowIndex < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowIndex");
                }

                if (((columnIndex + columnCount) | 0) > this.ColumnCount || columnIndex < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnIndex");
                }

                this.ClearUnchecked(rowIndex, rowCount, columnIndex, columnCount);
            },
            ClearUnchecked: function (rowIndex, rowCount, columnIndex, columnCount) {
                for (var i = rowIndex; i < ((rowIndex + rowCount) | 0); i = (i + 1) | 0) {
                    for (var j = columnIndex; j < ((columnIndex + columnCount) | 0); j = (j + 1) | 0) {
                        this.At$1(i, j, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                    }
                }
            },
            ClearRows: function (rowIndices) {
                if (rowIndices.length === 0) {
                    return;
                }

                for (var k = 0; k < rowIndices.length; k = (k + 1) | 0) {
                    if (rowIndices[System.Array.index(k, rowIndices)] < 0 || rowIndices[System.Array.index(k, rowIndices)] >= this.RowCount) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("rowIndices");
                    }
                }

                this.ClearRowsUnchecked(rowIndices);
            },
            ClearColumns: function (columnIndices) {
                if (columnIndices.length === 0) {
                    return;
                }

                for (var k = 0; k < columnIndices.length; k = (k + 1) | 0) {
                    if (((columnIndices[System.Array.index(k, columnIndices)]) >>> 0) >= (this.ColumnCount >>> 0)) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("columnIndices");
                    }
                }

                this.ClearColumnsUnchecked(columnIndices);
            },
            ClearRowsUnchecked: function (rowIndices) {
                for (var k = 0; k < rowIndices.length; k = (k + 1) | 0) {
                    var row = rowIndices[System.Array.index(k, rowIndices)];
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        this.At$1(row, j, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                    }
                }
            },
            ClearColumnsUnchecked: function (columnIndices) {
                for (var k = 0; k < columnIndices.length; k = (k + 1) | 0) {
                    var column = columnIndices[System.Array.index(k, columnIndices)];
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        this.At$1(i, column, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                    }
                }
            },
            CopyTo: function (target, existingData) {
                if (existingData === void 0) { existingData = 0; }
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (Bridge.referenceEquals(this, target)) {
                    return;
                }

                if (this.RowCount !== target.RowCount || this.ColumnCount !== target.ColumnCount) {
                    var message = System.String.format("Resources.ArgumentMatrixDimensions2, RowCount + x + ColumnCount, target.RowCount + x + target.ColumnCount", null);
                    throw new System.ArgumentException.$ctor3(message, "target");
                }

                this.CopyToUnchecked(target, existingData);
            },
            CopyToUnchecked: function (target, existingData) {
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        target.At$1(i, j, this.At(i, j));
                    }
                }
            },
            CopySubMatrixTo: function (target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                if (existingData === void 0) { existingData = 0; }
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (rowCount === 0 || columnCount === 0) {
                    return;
                }

                if (Bridge.referenceEquals(this, target)) {
                    throw new System.NotSupportedException.ctor();
                }

                this.ValidateSubMatrixRange(T, target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount);

                this.CopySubMatrixToUnchecked(target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, existingData);
            },
            CopySubMatrixToUnchecked: function (target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                for (var j = sourceColumnIndex, jj = targetColumnIndex; j < ((sourceColumnIndex + columnCount) | 0); j = (j + 1) | 0, jj = (jj + 1) | 0) {
                    for (var i = sourceRowIndex, ii = targetRowIndex; i < ((sourceRowIndex + rowCount) | 0); i = (i + 1) | 0, ii = (ii + 1) | 0) {
                        target.At$1(ii, jj, this.At(i, j));
                    }
                }
            },
            CopyRowTo: function (target, rowIndex, existingData) {
                if (existingData === void 0) { existingData = 0; }
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                this.ValidateRowRange(T, target, rowIndex);
                this.CopySubRowToUnchecked(target, rowIndex, 0, 0, this.ColumnCount, existingData);
            },
            CopySubRowTo: function (target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                if (existingData === void 0) { existingData = 0; }
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (columnCount === 0) {
                    return;
                }

                this.ValidateSubRowRange(T, target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount);
                this.CopySubRowToUnchecked(target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount, existingData);
            },
            CopySubRowToUnchecked: function (target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                for (var j = sourceColumnIndex, jj = targetColumnIndex; j < ((sourceColumnIndex + columnCount) | 0); j = (j + 1) | 0, jj = (jj + 1) | 0) {
                    target.At$1(jj, this.At(rowIndex, j));
                }
            },
            CopyColumnTo: function (target, columnIndex, existingData) {
                if (existingData === void 0) { existingData = 0; }
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                this.ValidateColumnRange(T, target, columnIndex);
                this.CopySubColumnToUnchecked(target, columnIndex, 0, 0, this.RowCount, existingData);
            },
            CopySubColumnTo: function (target, columnIndex, sourceRowIndex, targetRowIndex, rowCount, existingData) {
                if (existingData === void 0) { existingData = 0; }
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (rowCount === 0) {
                    return;
                }

                this.ValidateSubColumnRange(T, target, columnIndex, sourceRowIndex, targetRowIndex, rowCount);
                this.CopySubColumnToUnchecked(target, columnIndex, sourceRowIndex, targetRowIndex, rowCount, existingData);
            },
            CopySubColumnToUnchecked: function (target, columnIndex, sourceRowIndex, targetRowIndex, rowCount, existingData) {
                for (var i = sourceRowIndex, ii = targetRowIndex; i < ((sourceRowIndex + rowCount) | 0); i = (i + 1) | 0, ii = (ii + 1) | 0) {
                    target.At$1(ii, this.At(i, columnIndex));
                }
            },
            TransposeTo: function (target, existingData) {
                if (existingData === void 0) { existingData = 0; }
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (this.RowCount !== target.ColumnCount || this.ColumnCount !== target.RowCount) {
                    var message = System.String.format("Resources.ArgumentMatrixDimensions2, RowCount + x + ColumnCount, target.RowCount + x + target.ColumnCount", null);
                    throw new System.ArgumentException.$ctor3(message, "target");
                }

                if (Bridge.referenceEquals(this, target)) {
                    this.TransposeSquareInplaceUnchecked();
                    return;
                }

                this.TransposeToUnchecked(target, existingData);
            },
            TransposeToUnchecked: function (target, existingData) {
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        target.At$1(j, i, this.At(i, j));
                    }
                }
            },
            TransposeSquareInplaceUnchecked: function () {
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    for (var i = 0; i < j; i = (i + 1) | 0) {
                        var swap = this.At(i, j);
                        this.At$1(i, j, this.At(j, i));
                        this.At$1(j, i, swap);
                    }
                }
            },
            ToRowMajorArray: function () {
                var ret = System.Array.init(Bridge.Int.mul(this.RowCount, this.ColumnCount), function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var offset = Bridge.Int.mul(i, this.ColumnCount);
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        ret[System.Array.index(((offset + j) | 0), ret)] = this.At(i, j);
                    }
                }
                return ret;
            },
            ToColumnMajorArray: function () {
                var ret = System.Array.init(Bridge.Int.mul(this.RowCount, this.ColumnCount), function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    var offset = Bridge.Int.mul(j, this.RowCount);
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        ret[System.Array.index(((offset + i) | 0), ret)] = this.At(i, j);
                    }
                }
                return ret;
            },
            ToRowArrays: function () {
                var ret = System.Array.init(this.RowCount, null, System.Array.type(T));
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var row = System.Array.init(this.ColumnCount, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        row[System.Array.index(j, row)] = this.At(i, j);
                    }
                    ret[System.Array.index(i, ret)] = row;
                }
                return ret;
            },
            ToColumnArrays: function () {
                var ret = System.Array.init(this.ColumnCount, null, System.Array.type(T));
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    var column = System.Array.init(this.RowCount, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        column[System.Array.index(i, column)] = this.At(i, j);
                    }
                    ret[System.Array.index(j, ret)] = column;
                }
                return ret;
            },
            ToArray: function () {
                var ret = System.Array.create(function (){
                    return Bridge.getDefaultValue(T);
                }, null, T, this.RowCount, this.ColumnCount);
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        ret.set([i, j], this.At(i, j));
                    }
                }
                return ret;
            },
            AsRowMajorArray: function () {
                return null;
            },
            AsColumnMajorArray: function () {
                return null;
            },
            AsRowArrays: function () {
                return null;
            },
            AsColumnArrays: function () {
                return null;
            },
            AsArray: function () {
                return null;
            },
            Enumerate: function () {
                return new (Bridge.GeneratorEnumerable$1(T))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        j,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.RowCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 9;
                                        continue;
                                    }
                                    case 2: {
                                        j = 0;
                                            $step = 3;
                                            continue;
                                    }
                                    case 3: {
                                        if ( j < this.ColumnCount ) {
                                                $step = 4;
                                                continue;
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 4: {
                                        $enumerator.current = this.At(i, j);
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {
                                        j = (j + 1) | 0;
                                        $step = 3;
                                        continue;
                                    }
                                    case 7: {
                                        $step = 8;
                                        continue;
                                    }
                                    case 8: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 9: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            EnumerateIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        j,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.RowCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 9;
                                        continue;
                                    }
                                    case 2: {
                                        j = 0;
                                            $step = 3;
                                            continue;
                                    }
                                    case 3: {
                                        if ( j < this.ColumnCount ) {
                                                $step = 4;
                                                continue;
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 4: {
                                        $enumerator.current = { Item1: i, Item2: j, Item3: this.At(i, j) };
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {
                                        j = (j + 1) | 0;
                                        $step = 3;
                                        continue;
                                    }
                                    case 7: {
                                        $step = 8;
                                        continue;
                                    }
                                    case 8: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 9: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            EnumerateNonZero: function () {
                return new (Bridge.GeneratorEnumerable$1(T))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        j,
                        x,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.RowCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 11;
                                        continue;
                                    }
                                    case 2: {
                                        j = 0;
                                            $step = 3;
                                            continue;
                                    }
                                    case 3: {
                                        if ( j < this.ColumnCount ) {
                                                $step = 4;
                                                continue;
                                            }
                                        $step = 9;
                                        continue;
                                    }
                                    case 4: {
                                        x = this.At(i, j);
                                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, x, T)) {
                                                $step = 5;
                                                continue;
                                            } 
                                            $step = 7;
                                            continue;
                                    }
                                    case 5: {
                                        $enumerator.current = x;
                                            $step = 6;
                                            return true;
                                    }
                                    case 6: {
                                        $step = 7;
                                        continue;
                                    }
                                    case 7: {
                                        $step = 8;
                                        continue;
                                    }
                                    case 8: {
                                        j = (j + 1) | 0;
                                        $step = 3;
                                        continue;
                                    }
                                    case 9: {
                                        $step = 10;
                                        continue;
                                    }
                                    case 10: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 11: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            EnumerateNonZeroIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        j,
                        x,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.RowCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 11;
                                        continue;
                                    }
                                    case 2: {
                                        j = 0;
                                            $step = 3;
                                            continue;
                                    }
                                    case 3: {
                                        if ( j < this.ColumnCount ) {
                                                $step = 4;
                                                continue;
                                            }
                                        $step = 9;
                                        continue;
                                    }
                                    case 4: {
                                        x = this.At(i, j);
                                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, x, T)) {
                                                $step = 5;
                                                continue;
                                            } 
                                            $step = 7;
                                            continue;
                                    }
                                    case 5: {
                                        $enumerator.current = { Item1: i, Item2: j, Item3: x };
                                            $step = 6;
                                            return true;
                                    }
                                    case 6: {
                                        $step = 7;
                                        continue;
                                    }
                                    case 7: {
                                        $step = 8;
                                        continue;
                                    }
                                    case 8: {
                                        j = (j + 1) | 0;
                                        $step = 3;
                                        continue;
                                    }
                                    case 9: {
                                        $step = 10;
                                        continue;
                                    }
                                    case 10: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 11: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            Find: function (predicate, zeros) {
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        var item = this.At(i, j);
                        if (predicate(item)) {
                            return { Item1: i, Item2: j, Item3: item };
                        }
                    }
                }
                return null;
            },
            Find2: function (TOther, other, predicate, zeros) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if (this.RowCount !== other.RowCount || this.ColumnCount !== other.ColumnCount) {
                    var message = System.String.format("Resources.ArgumentMatrixDimensions2, RowCount + x + ColumnCount, other.RowCount + x + other.ColumnCount", null);
                    throw new System.ArgumentException.$ctor3(message, "other");
                }

                return this.Find2Unchecked(TOther, other, predicate, zeros);
            },
            Find2Unchecked: function (TOther, other, predicate, zeros) {
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        var item = this.At(i, j);
                        var otherItem = other.At(i, j);
                        if (predicate(item, otherItem)) {
                            return { Item1: i, Item2: j, Item3: item, Item4: otherItem };
                        }
                    }
                }
                return null;
            },
            MapInplace: function (f, zeros) {
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        this.At$1(i, j, f(this.At(i, j)));
                    }
                }
            },
            MapIndexedInplace: function (f, zeros) {
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        this.At$1(i, j, f(i, j, this.At(i, j)));
                    }
                }
            },
            MapTo: function (TU, target, f, zeros, existingData) {
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (this.RowCount !== target.RowCount || this.ColumnCount !== target.ColumnCount) {
                    var message = System.String.format("Resources.ArgumentMatrixDimensions2, RowCount + x + ColumnCount, target.RowCount + x + target.ColumnCount", null);
                    throw new System.ArgumentException.$ctor3(message, "target");
                }

                this.MapToUnchecked(TU, target, f, zeros, existingData);
            },
            MapToUnchecked: function (TU, target, f, zeros, existingData) {
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        target.At$1(i, j, f(this.At(i, j)));
                    }
                }
            },
            MapIndexedTo: function (TU, target, f, zeros, existingData) {
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (this.RowCount !== target.RowCount || this.ColumnCount !== target.ColumnCount) {
                    var message = System.String.format("Resources.ArgumentMatrixDimensions2, RowCount + x + ColumnCount, target.RowCount + x + target.ColumnCount", null);
                    throw new System.ArgumentException.$ctor3(message, "target");
                }

                this.MapIndexedToUnchecked(TU, target, f, zeros, existingData);
            },
            MapIndexedToUnchecked: function (TU, target, f, zeros, existingData) {
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        target.At$1(i, j, f(i, j, this.At(i, j)));
                    }
                }
            },
            MapSubMatrixIndexedTo: function (TU, target, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros, existingData) {
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (rowCount === 0 || columnCount === 0) {
                    return;
                }

                if (Bridge.referenceEquals(this, target)) {
                    throw new System.NotSupportedException.ctor();
                }

                this.ValidateSubMatrixRange(TU, target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount);

                this.MapSubMatrixIndexedToUnchecked(TU, target, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros, existingData);
            },
            MapSubMatrixIndexedToUnchecked: function (TU, target, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros, existingData) {
                for (var j = sourceColumnIndex, jj = targetColumnIndex; j < ((sourceColumnIndex + columnCount) | 0); j = (j + 1) | 0, jj = (jj + 1) | 0) {
                    for (var i = sourceRowIndex, ii = targetRowIndex; i < ((sourceRowIndex + rowCount) | 0); i = (i + 1) | 0, ii = (ii + 1) | 0) {
                        target.At$1(ii, jj, f(ii, jj, this.At(i, j)));
                    }
                }
            },
            Map2To: function (target, other, f, zeros, existingData) {
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if (this.RowCount !== target.RowCount || this.ColumnCount !== target.ColumnCount) {
                    var message = System.String.format("Resources.ArgumentMatrixDimensions2, RowCount + x + ColumnCount, target.RowCount + x + target.ColumnCount", null);
                    throw new System.ArgumentException.$ctor3(message, "target");
                }

                if (this.RowCount !== other.RowCount || this.ColumnCount !== other.ColumnCount) {
                    var message1 = System.String.format("Resources.ArgumentMatrixDimensions2, RowCount + x + ColumnCount, other.RowCount + x + other.ColumnCount", null);
                    throw new System.ArgumentException.$ctor3(message1, "other");
                }

                this.Map2ToUnchecked(target, other, f, zeros, existingData);
            },
            Map2ToUnchecked: function (target, other, f, zeros, existingData) {
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        target.At$1(i, j, f(this.At(i, j), other.At(i, j)));
                    }
                }
            },
            /**
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @param   {Function}                                TU          
             * @param   {Array.<TU>}                              target      
             * @param   {System.Func}                             f           
             * @param   {System.Func}                             finalize    
             * @param   {Array.<TU>}                              state       
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {void}
             */
            FoldByRow: function (TU, target, f, finalize, state, zeros) {
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }
                if (target.length !== this.RowCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "target");
                }

                if (state == null) {
                    throw new System.ArgumentNullException.$ctor1("state");
                }
                if (state.length !== this.RowCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "state");
                }

                this.FoldByRowUnchecked(TU, target, f, finalize, state, zeros);
            },
            /**
             * @instance
             * @this MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @param   {Function}                                TU          
             * @param   {Array.<TU>}                              target      
             * @param   {System.Func}                             f           
             * @param   {System.Func}                             finalize    
             * @param   {Array.<TU>}                              state       
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {void}
             */
            FoldByRowUnchecked: function (TU, target, f, finalize, state, zeros) {
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var s = state[System.Array.index(i, state)];
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        s = f(s, this.At(i, j));
                    }
                    target[System.Array.index(i, target)] = finalize(s, this.ColumnCount);
                }
            },
            /**
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @param   {Function}                                TU          
             * @param   {Array.<TU>}                              target      
             * @param   {System.Func}                             f           
             * @param   {System.Func}                             finalize    
             * @param   {Array.<TU>}                              state       
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {void}
             */
            FoldByColumn: function (TU, target, f, finalize, state, zeros) {
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }
                if (target.length !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "target");
                }

                if (state == null) {
                    throw new System.ArgumentNullException.$ctor1("state");
                }
                if (state.length !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "state");
                }

                this.FoldByColumnUnchecked(TU, target, f, finalize, state, zeros);
            },
            /**
             * @instance
             * @this MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1
             * @param   {Function}                                TU          
             * @param   {Array.<TU>}                              target      
             * @param   {System.Func}                             f           
             * @param   {System.Func}                             finalize    
             * @param   {Array.<TU>}                              state       
             * @param   {MathNet.Numerics.LinearAlgebra.Zeros}    zeros
             * @return  {void}
             */
            FoldByColumnUnchecked: function (TU, target, f, finalize, state, zeros) {
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    var s = state[System.Array.index(j, state)];
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        s = f(s, this.At(i, j));
                    }
                    target[System.Array.index(j, target)] = finalize(s, this.RowCount);
                }
            },
            Fold2: function (TOther, TState, other, f, state, zeros) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if (this.RowCount !== other.RowCount || this.ColumnCount !== other.ColumnCount) {
                    var message = System.String.format("Resources.ArgumentMatrixDimensions2, RowCount + x + ColumnCount, other.RowCount + x + other.ColumnCount", null);
                    throw new System.ArgumentException.$ctor3(message, "other");
                }

                return this.Fold2Unchecked(TOther, TState, other, f, state, zeros);
            },
            Fold2Unchecked: function (TOther, TState, other, f, state, zeros) {
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        state = f(state, this.At(i, j), other.At(i, j));
                    }
                }

                return state;
            },
            ValidateRange: function (row, column) {
                if ((row >>> 0) >= (this.RowCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("row");
                }

                if ((column >>> 0) >= (this.ColumnCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("column");
                }
            },
            ValidateSubMatrixRange: function (TU, target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount) {
                if (rowCount < 1) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("rowCount", "Resources.ArgumentMustBePositive");
                }

                if (columnCount < 1) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("columnCount", "Resources.ArgumentMustBePositive");
                }


                if ((sourceRowIndex >>> 0) >= (this.RowCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("sourceRowIndex");
                }

                if ((sourceColumnIndex >>> 0) >= (this.ColumnCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("sourceColumnIndex");
                }

                var sourceRowMax = (sourceRowIndex + rowCount) | 0;
                var sourceColumnMax = (sourceColumnIndex + columnCount) | 0;

                if (sourceRowMax > this.RowCount) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowCount");
                }

                if (sourceColumnMax > this.ColumnCount) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnCount");
                }


                if ((targetRowIndex >>> 0) >= (target.RowCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("targetRowIndex");
                }

                if ((targetColumnIndex >>> 0) >= (target.ColumnCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("targetColumnIndex");
                }

                var targetRowMax = (targetRowIndex + rowCount) | 0;
                var targetColumnMax = (targetColumnIndex + columnCount) | 0;

                if (targetRowMax > target.RowCount) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowCount");
                }

                if (targetColumnMax > target.ColumnCount) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnCount");
                }
            },
            ValidateRowRange: function (TU, target, rowIndex) {
                if ((rowIndex >>> 0) >= (this.RowCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowIndex");
                }

                if (this.ColumnCount !== target.Length) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameRowDimension", "target");
                }
            },
            ValidateColumnRange: function (TU, target, columnIndex) {
                if ((columnIndex >>> 0) >= (this.ColumnCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnIndex");
                }

                if (this.RowCount !== target.Length) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameColumnDimension", "target");
                }
            },
            ValidateSubRowRange: function (TU, target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount) {
                if (columnCount < 1) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("columnCount", "Resources.ArgumentMustBePositive");
                }


                if ((rowIndex >>> 0) >= (this.RowCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowIndex");
                }

                if ((sourceColumnIndex >>> 0) >= (this.ColumnCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("sourceColumnIndex");
                }

                if (((sourceColumnIndex + columnCount) | 0) > this.ColumnCount) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnCount");
                }


                if ((targetColumnIndex >>> 0) >= (target.Length >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("targetColumnIndex");
                }

                if (((targetColumnIndex + columnCount) | 0) > target.Length) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnCount");
                }
            },
            ValidateSubColumnRange: function (TU, target, columnIndex, sourceRowIndex, targetRowIndex, rowCount) {
                if (rowCount < 1) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("rowCount", "Resources.ArgumentMustBePositive");
                }


                if ((columnIndex >>> 0) >= (this.ColumnCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnIndex");
                }

                if ((sourceRowIndex >>> 0) >= (this.RowCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("sourceRowIndex");
                }

                if (((sourceRowIndex + rowCount) | 0) > this.RowCount) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowCount");
                }


                if ((targetRowIndex >>> 0) >= (target.Length >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("targetRowIndex");
                }

                if (((targetRowIndex + rowCount) | 0) > target.Length) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowCount");
                }
            }
        }
    }; });

    Bridge.define("MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1", function (T) { return {
        inherits: function () { return [System.IEquatable$1(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T))]; },
        statics: {
            fields: {
                Zero: null
            },
            ctors: {
                init: function () {
                    this.Zero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector.Zero;
                }
            }
        },
        fields: {
            Length: 0
        },
        alias: ["equalsT", "System$IEquatable$1$MathNet$Numerics$LinearAlgebra$Storage$VectorStorage$1$" + Bridge.getTypeAlias(T) + "$equalsT"],
        ctors: {
            ctor: function (length) {
                this.$initialize();
                if (length <= 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("length", "Resources.ArgumentMustBePositive");
                }

                this.Length = length;
            }
        },
        methods: {
            /**
             * Gets or sets the value at the given index, with range checking.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1
             * @param   {number}    index    The index of the element.
             * @return  {T}
             */
            getItem: function (index) {
                this.ValidateRange(index);
                return this.At(index);
            },
            /**
             * Gets or sets the value at the given index, with range checking.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1
             * @param   {number}    index    The index of the element.
             * @param   {T}         value    The value to get or set.
             * @return  {void}
             */
            setItem: function (index, value) {
                this.ValidateRange(index);
                this.At$1(index, value);
            },
            /**
             * Indicates whether the current object is equal to another object of the same type.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1
             * @param   {MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1}    other    An object to compare with this object.
             * @return  {boolean}                                                            <pre><code>true</code></pre> if the current object is equal to the <b /> parameter; otherwise, <pre><code>false</code></pre>.
             */
            equalsT: function (other) {
                if (other == null) {
                    return false;
                }
                if (this.Length !== other.Length) {
                    return false;
                }

                if (Bridge.referenceEquals(this, other)) {
                    return true;
                }

                for (var index = 0; index < this.Length; index = (index + 1) | 0) {
                    if (!Bridge.equalsT(this.At(index), other.At(index), T)) {
                        return false;
                    }
                }

                return true;
            },
            /**
             * Determines whether the specified {@link } is equal to the current {@link }.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1
             * @param   {System.Object}    obj    The {@link } to compare with the current {@link }.
             * @return  {boolean}                 true if the specified {@link } is equal to the current {@link }; otherwise, false.
             */
            equals: function (obj) {
                return this.equalsT(Bridge.as(obj, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T)));
            },
            /**
             * Serves as a hash function for a particular type.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1
             * @return  {number}        A hash code for the current {@link }.
             */
            getHashCode: function () {
                var hashNum = Math.min(this.Length, 25);
                var hash = 17;
                for (var i = 0; i < hashNum; i = (i + 1) | 0) {
                    hash = (Bridge.Int.mul(hash, 31) + Bridge.getHashCode(this.At(i))) | 0;
                }
                return hash;
            },
            Clear: function () {
                for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                    this.At$1(i, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero);
                }
            },
            Clear$1: function (index, count) {
                for (var i = index; i < ((index + count) | 0); i = (i + 1) | 0) {
                    this.At$1(i, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero);
                }
            },
            CopyTo: function (target, existingData) {
                if (existingData === void 0) { existingData = 0; }
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (Bridge.referenceEquals(this, target)) {
                    return;
                }

                if (this.Length !== target.Length) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "target");
                }

                this.CopyToUnchecked(target, existingData);
            },
            CopyToUnchecked: function (target, existingData) {
                for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                    target.At$1(i, this.At(i));
                }
            },
            CopyToRow: function (target, rowIndex, existingData) {
                if (existingData === void 0) { existingData = 0; }
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (this.Length !== target.ColumnCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "target");
                }

                this.ValidateRowRange(target, rowIndex);
                this.CopyToRowUnchecked(target, rowIndex, existingData);
            },
            CopyToRowUnchecked: function (target, rowIndex, existingData) {
                for (var j = 0; j < this.Length; j = (j + 1) | 0) {
                    target.At$1(rowIndex, j, this.At(j));
                }
            },
            CopyToColumn: function (target, columnIndex, existingData) {
                if (existingData === void 0) { existingData = 0; }
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (this.Length !== target.RowCount) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "target");
                }

                this.ValidateColumnRange(target, columnIndex);
                this.CopyToColumnUnchecked(target, columnIndex, existingData);
            },
            CopyToColumnUnchecked: function (target, columnIndex, existingData) {
                for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                    target.At$1(i, columnIndex, this.At(i));
                }
            },
            CopySubVectorTo: function (target, sourceIndex, targetIndex, count, existingData) {
                if (existingData === void 0) { existingData = 0; }
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (count === 0) {
                    return;
                }

                this.ValidateSubVectorRange(target, sourceIndex, targetIndex, count);
                this.CopySubVectorToUnchecked(target, sourceIndex, targetIndex, count, existingData);
            },
            CopySubVectorToUnchecked: function (target, sourceIndex, targetIndex, count, existingData) {
                if (Bridge.referenceEquals(this, target)) {
                    var tmp = System.Array.init(count, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    for (var i = 0; i < tmp.length; i = (i + 1) | 0) {
                        tmp[System.Array.index(i, tmp)] = this.At(((i + sourceIndex) | 0));
                    }
                    for (var i1 = 0; i1 < tmp.length; i1 = (i1 + 1) | 0) {
                        this.At$1(((i1 + targetIndex) | 0), tmp[System.Array.index(i1, tmp)]);
                    }

                    return;
                }

                for (var i2 = sourceIndex, ii = targetIndex; i2 < ((sourceIndex + count) | 0); i2 = (i2 + 1) | 0, ii = (ii + 1) | 0) {
                    target.At$1(ii, this.At(i2));
                }
            },
            CopyToSubRow: function (target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                if (existingData === void 0) { existingData = 0; }
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (columnCount === 0) {
                    return;
                }

                this.ValidateSubRowRange(target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount);
                this.CopyToSubRowUnchecked(target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount, existingData);
            },
            CopyToSubRowUnchecked: function (target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                for (var j = sourceColumnIndex, jj = targetColumnIndex; j < ((sourceColumnIndex + columnCount) | 0); j = (j + 1) | 0, jj = (jj + 1) | 0) {
                    target.At$1(rowIndex, jj, this.At(j));
                }
            },
            CopyToSubColumn: function (target, columnIndex, sourceRowIndex, targetRowIndex, rowCount, existingData) {
                if (existingData === void 0) { existingData = 0; }
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (rowCount === 0) {
                    return;
                }

                this.ValidateSubColumnRange(target, columnIndex, sourceRowIndex, targetRowIndex, rowCount);
                this.CopyToSubColumnUnchecked(target, columnIndex, sourceRowIndex, targetRowIndex, rowCount, existingData);
            },
            CopyToSubColumnUnchecked: function (target, columnIndex, sourceRowIndex, targetRowIndex, rowCount, existingData) {
                for (var i = sourceRowIndex, ii = targetRowIndex; i < ((sourceRowIndex + rowCount) | 0); i = (i + 1) | 0, ii = (ii + 1) | 0) {
                    target.At$1(ii, columnIndex, this.At(i));
                }
            },
            ToArray: function () {
                var ret = System.Array.init(this.Length, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                for (var i = 0; i < ret.length; i = (i + 1) | 0) {
                    ret[System.Array.index(i, ret)] = this.At(i);
                }
                return ret;
            },
            AsArray: function () {
                return null;
            },
            Enumerate: function () {
                return new (Bridge.GeneratorEnumerable$1(T))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.Length ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = this.At(i);
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            EnumerateIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$2(System.Int32,T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$2(System.Int32,T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.Length ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = { Item1: i, Item2: this.At(i) };
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            EnumerateNonZero: function () {
                return new (Bridge.GeneratorEnumerable$1(T))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        x,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.Length ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 2: {
                                        x = this.At(i);
                                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, x, T)) {
                                                $step = 3;
                                                continue;
                                            } 
                                            $step = 5;
                                            continue;
                                    }
                                    case 3: {
                                        $enumerator.current = x;
                                            $step = 4;
                                            return true;
                                    }
                                    case 4: {
                                        $step = 5;
                                        continue;
                                    }
                                    case 5: {
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 7: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            EnumerateNonZeroIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$2(System.Int32,T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        x,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$2(System.Int32,T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.Length ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 2: {
                                        x = this.At(i);
                                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, x, T)) {
                                                $step = 3;
                                                continue;
                                            } 
                                            $step = 5;
                                            continue;
                                    }
                                    case 3: {
                                        $enumerator.current = { Item1: i, Item2: x };
                                            $step = 4;
                                            return true;
                                    }
                                    case 4: {
                                        $step = 5;
                                        continue;
                                    }
                                    case 5: {
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 7: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            Find: function (predicate, zeros) {
                for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                    var item = this.At(i);
                    if (predicate(item)) {
                        return { Item1: i, Item2: item };
                    }
                }
                return null;
            },
            Find2: function (TOther, other, predicate, zeros) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if (this.Length !== other.Length) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "other");
                }

                return this.Find2Unchecked(TOther, other, predicate, zeros);
            },
            Find2Unchecked: function (TOther, other, predicate, zeros) {
                for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                    var item = this.At(i);
                    var otherItem = other.At(i);
                    if (predicate(item, otherItem)) {
                        return { Item1: i, Item2: item, Item3: otherItem };
                    }
                }
                return null;
            },
            MapInplace: function (f, zeros) {
                for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                    this.At$1(i, f(this.At(i)));
                }
            },
            MapIndexedInplace: function (f, zeros) {
                for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                    this.At$1(i, f(i, this.At(i)));
                }
            },
            MapTo: function (TU, target, f, zeros, existingData) {
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (this.Length !== target.Length) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "target");
                }

                this.MapToUnchecked(TU, target, f, zeros, existingData);
            },
            MapToUnchecked: function (TU, target, f, zeros, existingData) {
                for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                    target.At$1(i, f(this.At(i)));
                }
            },
            MapIndexedTo: function (TU, target, f, zeros, existingData) {
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (this.Length !== target.Length) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "target");
                }

                this.MapIndexedToUnchecked(TU, target, f, zeros, existingData);
            },
            MapIndexedToUnchecked: function (TU, target, f, zeros, existingData) {
                for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                    target.At$1(i, f(i, this.At(i)));
                }
            },
            Map2To: function (target, other, f, zeros, existingData) {
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if (this.Length !== target.Length) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "target");
                }

                if (this.Length !== other.Length) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "other");
                }

                this.Map2ToUnchecked(target, other, f, zeros, existingData);
            },
            Map2ToUnchecked: function (target, other, f, zeros, existingData) {
                for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                    target.At$1(i, f(this.At(i), other.At(i)));
                }
            },
            Fold2: function (TOther, TState, other, f, state, zeros) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if (this.Length !== other.Length) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "other");
                }

                return this.Fold2Unchecked(TOther, TState, other, f, state, zeros);
            },
            Fold2Unchecked: function (TOther, TState, other, f, state, zeros) {
                for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                    state = f(state, this.At(i), other.At(i));
                }

                return state;
            },
            ValidateRange: function (index) {
                if ((index >>> 0) >= (this.Length >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
            },
            ValidateSubVectorRange: function (target, sourceIndex, targetIndex, count) {
                if (count < 1) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("count", "Resources.ArgumentMustBePositive");
                }


                if ((sourceIndex >>> 0) >= (this.Length >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("sourceIndex");
                }

                var sourceMax = (sourceIndex + count) | 0;

                if (sourceMax > this.Length) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }


                if ((targetIndex >>> 0) >= (target.Length >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("targetIndex");
                }

                var targetMax = (targetIndex + count) | 0;

                if (targetMax > target.Length) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }
            },
            ValidateRowRange: function (target, rowIndex) {
                if ((rowIndex >>> 0) >= (target.RowCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowIndex");
                }

                if (target.ColumnCount !== this.Length) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameRowDimension", "target");
                }
            },
            ValidateColumnRange: function (target, columnIndex) {
                if ((columnIndex >>> 0) >= (target.ColumnCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnIndex");
                }

                if (target.RowCount !== this.Length) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentMatrixSameColumnDimension", "target");
                }
            },
            ValidateSubRowRange: function (target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount) {
                if (columnCount < 1) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("columnCount", "Resources.ArgumentMustBePositive");
                }


                if ((sourceColumnIndex >>> 0) >= (this.Length >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("sourceColumnIndex");
                }

                if (((sourceColumnIndex + columnCount) | 0) > this.Length) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnCount");
                }


                if ((rowIndex >>> 0) >= (target.RowCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowIndex");
                }

                if ((targetColumnIndex >>> 0) >= (target.ColumnCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("targetColumnIndex");
                }

                if (((targetColumnIndex + columnCount) | 0) > target.ColumnCount) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnCount");
                }
            },
            ValidateSubColumnRange: function (target, columnIndex, sourceRowIndex, targetRowIndex, rowCount) {
                if (rowCount < 1) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("rowCount", "Resources.ArgumentMustBePositive");
                }


                if ((sourceRowIndex >>> 0) >= (this.Length >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("sourceRowIndex");
                }

                if (((sourceRowIndex + rowCount) | 0) > this.Length) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowCount");
                }


                if ((columnIndex >>> 0) >= (target.ColumnCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("columnIndex");
                }

                if ((targetRowIndex >>> 0) >= (target.RowCount >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("targetRowIndex");
                }

                if (((targetRowIndex + rowCount) | 0) > target.RowCount) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("rowCount");
                }
            }
        }
    }; });

    Bridge.define("MathNet.Numerics.LinearAlgebra.Symmetricity", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * It is not known yet whether a matrix is symmetric or not.
                 *
                 * @static
                 * @public
                 * @memberof MathNet.Numerics.LinearAlgebra.Symmetricity
                 * @constant
                 * @default 0
                 * @type MathNet.Numerics.LinearAlgebra.Symmetricity
                 */
                Unknown: 0,
                /**
                 * A matrix is symmetric
                 *
                 * @static
                 * @public
                 * @memberof MathNet.Numerics.LinearAlgebra.Symmetricity
                 * @constant
                 * @default 1
                 * @type MathNet.Numerics.LinearAlgebra.Symmetricity
                 */
                Symmetric: 1,
                /**
                 * A matrix is Hermitian (conjugate symmetric).
                 *
                 * @static
                 * @public
                 * @memberof MathNet.Numerics.LinearAlgebra.Symmetricity
                 * @constant
                 * @default 2
                 * @type MathNet.Numerics.LinearAlgebra.Symmetricity
                 */
                Hermitian: 2,
                /**
                 * A matrix is not symmetric
                 *
                 * @static
                 * @public
                 * @memberof MathNet.Numerics.LinearAlgebra.Symmetricity
                 * @constant
                 * @default 3
                 * @type MathNet.Numerics.LinearAlgebra.Symmetricity
                 */
                Asymmetric: 3
            }
        }
    });

    Bridge.define("MathNet.Numerics.LinearAlgebra.VectorExtensions", {
        statics: {
            methods: {
                /**
                 * Converts a vector to single precision.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                ToSingle: function (vector) {
                    return vector.Map(System.Single, function (x) {
                        return x;
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Converts a vector to double precision.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                ToDouble: function (vector) {
                    return vector.Map(System.Double, function (x) {
                        return x;
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Converts a vector to single precision complex numbers.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                ToComplex32: function (vector) {
                    return vector.Map(mathnetnumericsbridge.Complex32, function (x) {
                        return new mathnetnumericsbridge.Complex32.$ctor1(x.Real, x.Imaginary);
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Gets a single precision complex vector with the real parts from the given vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                ToComplex32$1: function (vector) {
                    return vector.Map(mathnetnumericsbridge.Complex32, function (x) {
                        return new mathnetnumericsbridge.Complex32.$ctor1(x, 0.0);
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Converts a vector to double precision complex numbers.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                ToComplex: function (vector) {
                    return vector.Map(mathnetnumericsbridge.Complex, function (x) {
                        return new mathnetnumericsbridge.Complex.$ctor1(x.Real, x.Imaginary);
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Gets a double precision complex vector with the real parts from the given vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                ToComplex$1: function (vector) {
                    return vector.Map(mathnetnumericsbridge.Complex, function (x) {
                        return new mathnetnumericsbridge.Complex.$ctor1(x, 0.0);
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Gets a real vector representing the real parts of a complex vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Real: function (vector) {
                    return vector.Map(System.Double, function (x) {
                        return x.Real;
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Gets a real vector representing the real parts of a complex vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Real$1: function (vector) {
                    return vector.Map(System.Single, function (x) {
                        return x.Real;
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Gets a real vector representing the imaginary parts of a complex vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Imaginary: function (vector) {
                    return vector.Map(System.Double, function (x) {
                        return x.Imaginary;
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                },
                /**
                 * Gets a real vector representing the imaginary parts of a complex vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @memberof MathNet.Numerics.LinearAlgebra.VectorExtensions
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
                 */
                Imaginary$1: function (vector) {
                    return vector.Map(System.Single, function (x) {
                        return x.Imaginary;
                    }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                }
            }
        }
    });

    Bridge.define("MathNet.Numerics.LinearAlgebra.Zeros", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Allow skipping zero entries (without enforcing skipping them).
                 When enumerating sparse matrices this can significantly speed up operations.
                 *
                 * @static
                 * @public
                 * @memberof MathNet.Numerics.LinearAlgebra.Zeros
                 * @constant
                 * @default 0
                 * @type MathNet.Numerics.LinearAlgebra.Zeros
                 */
                AllowSkip: 0,
                /**
                 * Force applying the operation to all fields even if they are zero.
                 *
                 * @static
                 * @public
                 * @memberof MathNet.Numerics.LinearAlgebra.Zeros
                 * @constant
                 * @default 1
                 * @type MathNet.Numerics.LinearAlgebra.Zeros
                 */
                Include: 1
            }
        }
    });

    /**
     * Class to represent a permutation for a subset of the natural numbers.
     *
     * @public
     * @class MathNet.Numerics.Permutation
     */
    Bridge.define("MathNet.Numerics.Permutation", {
        statics: {
            methods: {
                /**
                 * Construct an array from a sequence of inversions.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Permutation
                 * @memberof MathNet.Numerics.Permutation
                 * @example From wikipedia: the permutation 12043 has the inversions (0,2), (1,2) and (3,4). This would be
                 encoded using the array [22244].
                 *
                 *
                 * @param   {Array.<number>}                  inv    The set of inversions to construct the permutation from.
                 * @return  {MathNet.Numerics.Permutation}           A permutation generated from a sequence of inversions.
                 */
                FromInversions: function (inv) {
                    var idx = System.Array.init(inv.length, 0, System.Int32);
                    for (var i = 0; i < inv.length; i = (i + 1) | 0) {
                        idx[System.Array.index(i, idx)] = i;
                    }

                    for (var i1 = (inv.length - 1) | 0; i1 >= 0; i1 = (i1 - 1) | 0) {
                        if (idx[System.Array.index(i1, idx)] !== inv[System.Array.index(i1, inv)]) {
                            var t = idx[System.Array.index(i1, idx)];
                            idx[System.Array.index(i1, idx)] = idx[System.Array.index(inv[System.Array.index(i1, inv)], idx)];
                            idx[System.Array.index(inv[System.Array.index(i1, inv)], idx)] = t;
                        }
                    }

                    return new MathNet.Numerics.Permutation(idx);
                },
                /**
                 * Checks whether the <b /> array represents a proper permutation.
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.Permutation
                 * @memberof MathNet.Numerics.Permutation
                 * @param   {Array.<number>}    indices    An array which represents where each integer is permuted too: indices[i] represents that integer i
                 is permuted to location indices[i].
                 * @return  {boolean}                      True if <b /> represents a proper permutation, <pre><code>false</code></pre> otherwise.
                 */
                CheckForProperPermutation: function (indices) {
                    var idxCheck = System.Array.init(indices.length, false, System.Boolean);

                    for (var i = 0; i < indices.length; i = (i + 1) | 0) {
                        if (indices[System.Array.index(i, indices)] >= indices.length || indices[System.Array.index(i, indices)] < 0) {
                            return false;
                        }

                        idxCheck[System.Array.index(indices[System.Array.index(i, indices)], idxCheck)] = true;
                    }

                    for (var i1 = 0; i1 < indices.length; i1 = (i1 + 1) | 0) {
                        if (idxCheck[System.Array.index(i1, idxCheck)] === false) {
                            return false;
                        }
                    }

                    return true;
                }
            }
        },
        fields: {
            /**
             * Entry _indices[i] represents the location to which i is permuted to.
             *
             * @instance
             * @private
             * @readonly
             * @memberof MathNet.Numerics.Permutation
             * @type Array.<number>
             */
            _indices: null
        },
        props: {
            /**
             * Gets the number of elements this permutation is over.
             *
             * @instance
             * @public
             * @readonly
             * @memberof MathNet.Numerics.Permutation
             * @function Dimension
             * @type number
             */
            Dimension: {
                get: function () {
                    return this._indices.length;
                }
            }
        },
        ctors: {
            /**
             * Initializes a new instance of the Permutation class.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.Permutation
             * @memberof MathNet.Numerics.Permutation
             * @param   {Array.<number>}    indices    An array which represents where each integer is permuted too: indices[i] represents that integer i
             is permuted to location indices[i].
             * @return  {void}
             */
            ctor: function (indices) {
                this.$initialize();
                if (!MathNet.Numerics.Permutation.CheckForProperPermutation(indices)) {
                    throw new System.ArgumentException.$ctor3("Resources.PermutationAsIntArrayInvalid", "indices");
                }

                this._indices = Bridge.cast(System.Array.clone(indices), System.Array.type(System.Int32));
            }
        },
        methods: {
            /**
             * Computes where <b /> permutes too.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.Permutation
             * @memberof MathNet.Numerics.Permutation
             * @param   {number}    idx    The index to permute from.
             * @return  {number}           The index which is permuted to.
             */
            getItem: function (idx) {
                return this._indices[System.Array.index(idx, this._indices)];
            },
            /**
             * Computes the inverse of the permutation.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.Permutation
             * @memberof MathNet.Numerics.Permutation
             * @return  {MathNet.Numerics.Permutation}        The inverse of the permutation.
             */
            Inverse: function () {
                var invIdx = System.Array.init(this.Dimension, 0, System.Int32);
                for (var i = 0; i < invIdx.length; i = (i + 1) | 0) {
                    invIdx[System.Array.index(this._indices[System.Array.index(i, this._indices)], invIdx)] = i;
                }

                return new MathNet.Numerics.Permutation(invIdx);
            },
            /**
             * Construct a sequence of inversions from the permutation.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.Permutation
             * @memberof MathNet.Numerics.Permutation
             * @example From wikipedia: the permutation 12043 has the inversions (0,2), (1,2) and (3,4). This would be
             encoded using the array [22244].
             *
             *
             * @return  {Array.<number>}        A sequence of inversions.
             */
            ToInversions: function () {
                var idx = Bridge.cast(System.Array.clone(this._indices), System.Array.type(System.Int32));

                for (var i = 0; i < idx.length; i = (i + 1) | 0) {
                    if (idx[System.Array.index(i, idx)] !== i) {
                        var q = System.Array.findIndex(idx, ((i + 1) | 0), function (x) {
                                return x === i;
                            });
                        var t = idx[System.Array.index(i, idx)];
                        idx[System.Array.index(i, idx)] = q;
                        idx[System.Array.index(q, idx)] = t;
                    }
                }

                return idx;
            }
        }
    });

    /**
     * Sorting algorithms for single, tuple and triple lists.
     *
     * @static
     * @abstract
     * @public
     * @class MathNet.Numerics.Sorting
     */
    Bridge.define("MathNet.Numerics.Sorting", {
        statics: {
            methods: {
                /**
                 * Sort a list of keys, in place using the quick sort algorithm using the quick sort algorithm.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Sorting
                 * @memberof MathNet.Numerics.Sorting
                 * @param   {Function}                                  T           The type of elements in the key list.
                 * @param   {System.Collections.Generic.IList$1}        keys        List to sort.
                 * @param   {System.Collections.Generic.IComparer$1}    comparer    Comparison, defining the sort order.
                 * @return  {void}
                 */
                Sort: function (T, keys, comparer) {
                    if (comparer === void 0) { comparer = null; }
                    var count = System.Array.getCount(keys, T);
                    if (count <= 1) {
                        return;
                    }

                    if (null == comparer) {
                        comparer = new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn);
                    }

                    if (count === 2) {
                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, 0, T), System.Array.getItem(keys, 1, T)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T, keys, 0, 1);
                        }
                        return;
                    }

                    if (count <= 10) {
                        for (var i = 1; i < count; i = (i + 1) | 0) {
                            var key = System.Array.getItem(keys, i, T);
                            var j = (i - 1) | 0;
                            while (j >= 0 && comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, j, T), key) > 0) {
                                System.Array.setItem(keys, ((j + 1) | 0), System.Array.getItem(keys, j, T), T);
                                j = (j - 1) | 0;
                            }
                            System.Array.setItem(keys, ((j + 1) | 0), key, T);
                        }
                        return;
                    }

                    var keysArray = Bridge.as(keys, System.Array.type(T));
                    if (null != keysArray) {
                        System.Array.sort(keysArray, comparer);
                        return;
                    }

                    var keysList = Bridge.as(keys, System.Collections.Generic.List$1(T));
                    if (null != keysList) {
                        keysList.Sort$1(comparer);
                        return;
                    }

                    MathNet.Numerics.Sorting.QuickSort(T, keys, comparer, 0, ((count - 1) | 0));
                },
                /**
                 * Sort a list of keys and items with respect to the keys, in place using the quick sort algorithm.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Sorting
                 * @memberof MathNet.Numerics.Sorting
                 * @param   {Function}                                  TKey        The type of elements in the key list.
                 * @param   {Function}                                  TItem       The type of elements in the item list.
                 * @param   {System.Collections.Generic.IList$1}        keys        List to sort.
                 * @param   {System.Collections.Generic.IList$1}        items       List to permute the same way as the key list.
                 * @param   {System.Collections.Generic.IComparer$1}    comparer    Comparison, defining the sort order.
                 * @return  {void}
                 */
                Sort$2: function (TKey, TItem, keys, items, comparer) {
                    if (comparer === void 0) { comparer = null; }
                    var count = System.Array.getCount(keys, TKey);
                    if (count <= 1) {
                        return;
                    }

                    if (null == comparer) {
                        comparer = new (System.Collections.Generic.Comparer$1(TKey))(System.Collections.Generic.Comparer$1.$default.fn);
                    }

                    if (count === 2) {
                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TKey) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, 0, TKey), System.Array.getItem(keys, 1, TKey)) > 0) {
                            MathNet.Numerics.Sorting.Swap(TKey, keys, 0, 1);
                            MathNet.Numerics.Sorting.Swap(TItem, items, 0, 1);
                        }
                        return;
                    }

                    if (count <= 10) {
                        for (var i = 1; i < count; i = (i + 1) | 0) {
                            var key = System.Array.getItem(keys, i, TKey);
                            var item = System.Array.getItem(items, i, TItem);
                            var j = (i - 1) | 0;
                            while (j >= 0 && comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TKey) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, j, TKey), key) > 0) {
                                System.Array.setItem(keys, ((j + 1) | 0), System.Array.getItem(keys, j, TKey), TKey);
                                System.Array.setItem(items, ((j + 1) | 0), System.Array.getItem(items, j, TItem), TItem);
                                j = (j - 1) | 0;
                            }
                            System.Array.setItem(keys, ((j + 1) | 0), key, TKey);
                            System.Array.setItem(items, ((j + 1) | 0), item, TItem);
                        }
                        return;
                    }

                    var keysArray = Bridge.as(keys, System.Array.type(TKey));
                    var itemsArray = Bridge.as(items, System.Array.type(TItem));
                    if ((null != keysArray) && (null != itemsArray)) {
                        System.Array.sortDict(keysArray, itemsArray, 0, null, comparer);
                        return;
                    }

                    MathNet.Numerics.Sorting.QuickSort$1(TKey, TItem, keys, items, comparer, 0, ((count - 1) | 0));
                },
                /**
                 * Sort a list of keys, items1 and items2 with respect to the keys, in place using the quick sort algorithm.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Sorting
                 * @memberof MathNet.Numerics.Sorting
                 * @param   {Function}                                  TKey        The type of elements in the key list.
                 * @param   {Function}                                  TItem1      The type of elements in the first item list.
                 * @param   {Function}                                  TItem2      The type of elements in the second item list.
                 * @param   {System.Collections.Generic.IList$1}        keys        List to sort.
                 * @param   {System.Collections.Generic.IList$1}        items1      First list to permute the same way as the key list.
                 * @param   {System.Collections.Generic.IList$1}        items2      Second list to permute the same way as the key list.
                 * @param   {System.Collections.Generic.IComparer$1}    comparer    Comparison, defining the sort order.
                 * @return  {void}
                 */
                Sort$4: function (TKey, TItem1, TItem2, keys, items1, items2, comparer) {
                    if (comparer === void 0) { comparer = null; }
                    var count = System.Array.getCount(keys, TKey);
                    if (count <= 1) {
                        return;
                    }

                    if (null == comparer) {
                        comparer = new (System.Collections.Generic.Comparer$1(TKey))(System.Collections.Generic.Comparer$1.$default.fn);
                    }

                    if (count === 2) {
                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TKey) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, 0, TKey), System.Array.getItem(keys, 1, TKey)) > 0) {
                            MathNet.Numerics.Sorting.Swap(TKey, keys, 0, 1);
                            MathNet.Numerics.Sorting.Swap(TItem1, items1, 0, 1);
                            MathNet.Numerics.Sorting.Swap(TItem2, items2, 0, 1);
                        }
                        return;
                    }

                    if (count <= 10) {
                        for (var i = 1; i < count; i = (i + 1) | 0) {
                            var key = System.Array.getItem(keys, i, TKey);
                            var item1 = System.Array.getItem(items1, i, TItem1);
                            var item2 = System.Array.getItem(items2, i, TItem2);
                            var j = (i - 1) | 0;
                            while (j >= 0 && comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TKey) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, j, TKey), key) > 0) {
                                System.Array.setItem(keys, ((j + 1) | 0), System.Array.getItem(keys, j, TKey), TKey);
                                System.Array.setItem(items1, ((j + 1) | 0), System.Array.getItem(items1, j, TItem1), TItem1);
                                System.Array.setItem(items2, ((j + 1) | 0), System.Array.getItem(items2, j, TItem2), TItem2);
                                j = (j - 1) | 0;
                            }
                            System.Array.setItem(keys, ((j + 1) | 0), key, TKey);
                            System.Array.setItem(items1, ((j + 1) | 0), item1, TItem1);
                            System.Array.setItem(items2, ((j + 1) | 0), item2, TItem2);
                        }
                        return;
                    }

                    MathNet.Numerics.Sorting.QuickSort$2(TKey, TItem1, TItem2, keys, items1, items2, comparer, 0, ((count - 1) | 0));
                },
                /**
                 * Sort a range of a list of keys, in place using the quick sort algorithm.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Sorting
                 * @memberof MathNet.Numerics.Sorting
                 * @param   {Function}                                  T           The type of element in the list.
                 * @param   {System.Collections.Generic.IList$1}        keys        List to sort.
                 * @param   {number}                                    index       The zero-based starting index of the range to sort.
                 * @param   {number}                                    count       The length of the range to sort.
                 * @param   {System.Collections.Generic.IComparer$1}    comparer    Comparison, defining the sort order.
                 * @return  {void}
                 */
                Sort$1: function (T, keys, index, count, comparer) {
                    if (comparer === void 0) { comparer = null; }
                    if (index < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index");
                    }

                    if (count < 0 || ((index + count) | 0) > System.Array.getCount(keys, T)) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("count");
                    }

                    if (count <= 1) {
                        return;
                    }

                    if (null == comparer) {
                        comparer = new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn);
                    }

                    if (count === 2) {
                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, index, T), System.Array.getItem(keys, ((index + 1) | 0), T)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T, keys, index, ((index + 1) | 0));
                        }
                        return;
                    }

                    if (count <= 10) {
                        var to = (index + count) | 0;
                        for (var i = (index + 1) | 0; i < to; i = (i + 1) | 0) {
                            var key = System.Array.getItem(keys, i, T);
                            var j = (i - 1) | 0;
                            while (j >= index && comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, j, T), key) > 0) {
                                System.Array.setItem(keys, ((j + 1) | 0), System.Array.getItem(keys, j, T), T);
                                j = (j - 1) | 0;
                            }
                            System.Array.setItem(keys, ((j + 1) | 0), key, T);
                        }
                        return;
                    }

                    var keysArray = Bridge.as(keys, System.Array.type(T));
                    if (null != keysArray) {
                        System.Array.sort(keysArray, index, count, comparer);
                        return;
                    }

                    var keysList = Bridge.as(keys, System.Collections.Generic.List$1(T));
                    if (null != keysList) {
                        keysList.Sort$3(index, count, comparer);
                        return;
                    }

                    MathNet.Numerics.Sorting.QuickSort(T, keys, comparer, index, ((count - 1) | 0));
                },
                /**
                 * Sort a list of keys and items with respect to the keys, in place using the quick sort algorithm.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Sorting
                 * @memberof MathNet.Numerics.Sorting
                 * @param   {Function}                                  TKey        The type of elements in the key list.
                 * @param   {Function}                                  TItem       The type of elements in the item list.
                 * @param   {System.Collections.Generic.IList$1}        keys        List to sort.
                 * @param   {System.Collections.Generic.IList$1}        items       List to permute the same way as the key list.
                 * @param   {number}                                    index       The zero-based starting index of the range to sort.
                 * @param   {number}                                    count       The length of the range to sort.
                 * @param   {System.Collections.Generic.IComparer$1}    comparer    Comparison, defining the sort order.
                 * @return  {void}
                 */
                Sort$3: function (TKey, TItem, keys, items, index, count, comparer) {
                    if (comparer === void 0) { comparer = null; }
                    if (index < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index");
                    }

                    if (count < 0 || ((index + count) | 0) > System.Array.getCount(keys, TKey)) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("count");
                    }

                    if (count <= 1) {
                        return;
                    }

                    if (null == comparer) {
                        comparer = new (System.Collections.Generic.Comparer$1(TKey))(System.Collections.Generic.Comparer$1.$default.fn);
                    }

                    if (count === 2) {
                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TKey) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, index, TKey), System.Array.getItem(keys, ((index + 1) | 0), TKey)) > 0) {
                            MathNet.Numerics.Sorting.Swap(TKey, keys, index, ((index + 1) | 0));
                            MathNet.Numerics.Sorting.Swap(TItem, items, index, ((index + 1) | 0));
                        }
                        return;
                    }

                    if (count <= 10) {
                        var to = (index + count) | 0;
                        for (var i = (index + 1) | 0; i < to; i = (i + 1) | 0) {
                            var key = System.Array.getItem(keys, i, TKey);
                            var item = System.Array.getItem(items, i, TItem);
                            var j = (i - 1) | 0;
                            while (j >= index && comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TKey) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, j, TKey), key) > 0) {
                                System.Array.setItem(keys, ((j + 1) | 0), System.Array.getItem(keys, j, TKey), TKey);
                                System.Array.setItem(items, ((j + 1) | 0), System.Array.getItem(items, j, TItem), TItem);
                                j = (j - 1) | 0;
                            }
                            System.Array.setItem(keys, ((j + 1) | 0), key, TKey);
                            System.Array.setItem(items, ((j + 1) | 0), item, TItem);
                        }
                        return;
                    }

                    var keysArray = Bridge.as(keys, System.Array.type(TKey));
                    var itemsArray = Bridge.as(items, System.Array.type(TItem));
                    if ((null != keysArray) && (null != itemsArray)) {
                        System.Array.sortDict(keysArray, itemsArray, index, count, comparer);
                        return;
                    }

                    MathNet.Numerics.Sorting.QuickSort$1(TKey, TItem, keys, items, comparer, index, ((count - 1) | 0));
                },
                /**
                 * Sort a list of keys, items1 and items2 with respect to the keys, in place using the quick sort algorithm.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Sorting
                 * @memberof MathNet.Numerics.Sorting
                 * @param   {Function}                                  TKey        The type of elements in the key list.
                 * @param   {Function}                                  TItem1      The type of elements in the first item list.
                 * @param   {Function}                                  TItem2      The type of elements in the second item list.
                 * @param   {System.Collections.Generic.IList$1}        keys        List to sort.
                 * @param   {System.Collections.Generic.IList$1}        items1      First list to permute the same way as the key list.
                 * @param   {System.Collections.Generic.IList$1}        items2      Second list to permute the same way as the key list.
                 * @param   {number}                                    index       The zero-based starting index of the range to sort.
                 * @param   {number}                                    count       The length of the range to sort.
                 * @param   {System.Collections.Generic.IComparer$1}    comparer    Comparison, defining the sort order.
                 * @return  {void}
                 */
                Sort$5: function (TKey, TItem1, TItem2, keys, items1, items2, index, count, comparer) {
                    if (comparer === void 0) { comparer = null; }
                    if (index < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("index");
                    }

                    if (count < 0 || ((index + count) | 0) > System.Array.getCount(keys, TKey)) {
                        throw new System.ArgumentOutOfRangeException.$ctor1("count");
                    }

                    if (count <= 1) {
                        return;
                    }

                    if (null == comparer) {
                        comparer = new (System.Collections.Generic.Comparer$1(TKey))(System.Collections.Generic.Comparer$1.$default.fn);
                    }

                    if (count === 2) {
                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TKey) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, index, TKey), System.Array.getItem(keys, ((index + 1) | 0), TKey)) > 0) {
                            MathNet.Numerics.Sorting.Swap(TKey, keys, index, ((index + 1) | 0));
                            MathNet.Numerics.Sorting.Swap(TItem1, items1, index, ((index + 1) | 0));
                            MathNet.Numerics.Sorting.Swap(TItem2, items2, index, ((index + 1) | 0));
                        }
                        return;
                    }

                    if (count <= 10) {
                        var to = (index + count) | 0;
                        for (var i = (index + 1) | 0; i < to; i = (i + 1) | 0) {
                            var key = System.Array.getItem(keys, i, TKey);
                            var item1 = System.Array.getItem(items1, i, TItem1);
                            var item2 = System.Array.getItem(items2, i, TItem2);
                            var j = (i - 1) | 0;
                            while (j >= index && comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TKey) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, j, TKey), key) > 0) {
                                System.Array.setItem(keys, ((j + 1) | 0), System.Array.getItem(keys, j, TKey), TKey);
                                System.Array.setItem(items1, ((j + 1) | 0), System.Array.getItem(items1, j, TItem1), TItem1);
                                System.Array.setItem(items2, ((j + 1) | 0), System.Array.getItem(items2, j, TItem2), TItem2);
                                j = (j - 1) | 0;
                            }
                            System.Array.setItem(keys, ((j + 1) | 0), key, TKey);
                            System.Array.setItem(items1, ((j + 1) | 0), item1, TItem1);
                            System.Array.setItem(items2, ((j + 1) | 0), item2, TItem2);
                        }
                        return;
                    }

                    MathNet.Numerics.Sorting.QuickSort$2(TKey, TItem1, TItem2, keys, items1, items2, comparer, index, ((count - 1) | 0));
                },
                /**
                 * Sort a list of keys and items with respect to the keys, in place using the quick sort algorithm.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.Sorting
                 * @memberof MathNet.Numerics.Sorting
                 * @param   {Function}                                  T1                   The type of elements in the primary list.
                 * @param   {Function}                                  T2                   The type of elements in the secondary list.
                 * @param   {System.Collections.Generic.IList$1}        primary              List to sort.
                 * @param   {System.Collections.Generic.IList$1}        secondary            List to sort on duplicate primary items, and permute the same way as the key list.
                 * @param   {System.Collections.Generic.IComparer$1}    primaryComparer      Comparison, defining the primary sort order.
                 * @param   {System.Collections.Generic.IComparer$1}    secondaryComparer    Comparison, defining the secondary sort order.
                 * @return  {void}
                 */
                SortAll: function (T1, T2, primary, secondary, primaryComparer, secondaryComparer) {
                    if (primaryComparer === void 0) { primaryComparer = null; }
                    if (secondaryComparer === void 0) { secondaryComparer = null; }
                    if (null == primaryComparer) {
                        primaryComparer = new (System.Collections.Generic.Comparer$1(T1))(System.Collections.Generic.Comparer$1.$default.fn);
                    }

                    if (null == secondaryComparer) {
                        secondaryComparer = new (System.Collections.Generic.Comparer$1(T2))(System.Collections.Generic.Comparer$1.$default.fn);
                    }

                    MathNet.Numerics.Sorting.QuickSortAll(T1, T2, primary, secondary, primaryComparer, secondaryComparer, 0, ((System.Array.getCount(primary, T1) - 1) | 0));
                },
                /**
                 * Recursive implementation for an in place quick sort on a list.
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.Sorting
                 * @memberof MathNet.Numerics.Sorting
                 * @param   {Function}                                  T           The type of the list on which the quick sort is performed.
                 * @param   {System.Collections.Generic.IList$1}        keys        The list which is sorted using quick sort.
                 * @param   {System.Collections.Generic.IComparer$1}    comparer    The method with which to compare two elements of the quick sort.
                 * @param   {number}                                    left        The left boundary of the quick sort.
                 * @param   {number}                                    right       The right boundary of the quick sort.
                 * @return  {void}
                 */
                QuickSort: function (T, keys, comparer, left, right) {
                    do {
                        var a = left;
                        var b = right;
                        var p = (a + ((((b - a) | 0)) >> 1)) | 0;

                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, a, T), System.Array.getItem(keys, p, T)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T, keys, a, p);
                        }

                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, a, T), System.Array.getItem(keys, b, T)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T, keys, a, b);
                        }

                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, p, T), System.Array.getItem(keys, b, T)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T, keys, p, b);
                        }

                        var pivot = System.Array.getItem(keys, p, T);

                        do {
                            while (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, a, T), pivot) < 0) {
                                a = (a + 1) | 0;
                            }

                            while (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](pivot, System.Array.getItem(keys, b, T)) < 0) {
                                b = (b - 1) | 0;
                            }

                            if (a > b) {
                                break;
                            }

                            if (a < b) {
                                MathNet.Numerics.Sorting.Swap(T, keys, a, b);
                            }

                            a = (a + 1) | 0;
                            b = (b - 1) | 0;
                        } while (a <= b);

                        if ((((b - left) | 0)) <= (((right - a) | 0))) {
                            if (left < b) {
                                MathNet.Numerics.Sorting.QuickSort(T, keys, comparer, left, b);
                            }

                            left = a;
                        } else {
                            if (a < right) {
                                MathNet.Numerics.Sorting.QuickSort(T, keys, comparer, a, right);
                            }

                            right = b;
                        }
                    } while (left < right);
                },
                /**
                 * Recursive implementation for an in place quick sort on a list while reordering one other list accordingly.
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.Sorting
                 * @memberof MathNet.Numerics.Sorting
                 * @param   {Function}                                  T           The type of the list on which the quick sort is performed.
                 * @param   {Function}                                  TItems      The type of the list which is automatically reordered accordingly.
                 * @param   {System.Collections.Generic.IList$1}        keys        The list which is sorted using quick sort.
                 * @param   {System.Collections.Generic.IList$1}        items       The list which is automatically reordered accordingly.
                 * @param   {System.Collections.Generic.IComparer$1}    comparer    The method with which to compare two elements of the quick sort.
                 * @param   {number}                                    left        The left boundary of the quick sort.
                 * @param   {number}                                    right       The right boundary of the quick sort.
                 * @return  {void}
                 */
                QuickSort$1: function (T, TItems, keys, items, comparer, left, right) {
                    do {
                        var a = left;
                        var b = right;
                        var p = (a + ((((b - a) | 0)) >> 1)) | 0;

                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, a, T), System.Array.getItem(keys, p, T)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T, keys, a, p);
                            MathNet.Numerics.Sorting.Swap(TItems, items, a, p);
                        }

                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, a, T), System.Array.getItem(keys, b, T)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T, keys, a, b);
                            MathNet.Numerics.Sorting.Swap(TItems, items, a, b);
                        }

                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, p, T), System.Array.getItem(keys, b, T)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T, keys, p, b);
                            MathNet.Numerics.Sorting.Swap(TItems, items, p, b);
                        }

                        var pivot = System.Array.getItem(keys, p, T);

                        do {
                            while (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, a, T), pivot) < 0) {
                                a = (a + 1) | 0;
                            }

                            while (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](pivot, System.Array.getItem(keys, b, T)) < 0) {
                                b = (b - 1) | 0;
                            }

                            if (a > b) {
                                break;
                            }

                            if (a < b) {
                                MathNet.Numerics.Sorting.Swap(T, keys, a, b);
                                MathNet.Numerics.Sorting.Swap(TItems, items, a, b);
                            }

                            a = (a + 1) | 0;
                            b = (b - 1) | 0;
                        } while (a <= b);

                        if ((((b - left) | 0)) <= (((right - a) | 0))) {
                            if (left < b) {
                                MathNet.Numerics.Sorting.QuickSort$1(T, TItems, keys, items, comparer, left, b);
                            }

                            left = a;
                        } else {
                            if (a < right) {
                                MathNet.Numerics.Sorting.QuickSort$1(T, TItems, keys, items, comparer, a, right);
                            }

                            right = b;
                        }
                    } while (left < right);
                },
                /**
                 * Recursive implementation for an in place quick sort on one list while reordering two other lists accordingly.
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.Sorting
                 * @memberof MathNet.Numerics.Sorting
                 * @param   {Function}                                  T           The type of the list on which the quick sort is performed.
                 * @param   {Function}                                  TItems1     The type of the first list which is automatically reordered accordingly.
                 * @param   {Function}                                  TItems2     The type of the second list which is automatically reordered accordingly.
                 * @param   {System.Collections.Generic.IList$1}        keys        The list which is sorted using quick sort.
                 * @param   {System.Collections.Generic.IList$1}        items1      The first list which is automatically reordered accordingly.
                 * @param   {System.Collections.Generic.IList$1}        items2      The second list which is automatically reordered accordingly.
                 * @param   {System.Collections.Generic.IComparer$1}    comparer    The method with which to compare two elements of the quick sort.
                 * @param   {number}                                    left        The left boundary of the quick sort.
                 * @param   {number}                                    right       The right boundary of the quick sort.
                 * @return  {void}
                 */
                QuickSort$2: function (T, TItems1, TItems2, keys, items1, items2, comparer, left, right) {
                    do {
                        var a = left;
                        var b = right;
                        var p = (a + ((((b - a) | 0)) >> 1)) | 0;

                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, a, T), System.Array.getItem(keys, p, T)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T, keys, a, p);
                            MathNet.Numerics.Sorting.Swap(TItems1, items1, a, p);
                            MathNet.Numerics.Sorting.Swap(TItems2, items2, a, p);
                        }

                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, a, T), System.Array.getItem(keys, b, T)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T, keys, a, b);
                            MathNet.Numerics.Sorting.Swap(TItems1, items1, a, b);
                            MathNet.Numerics.Sorting.Swap(TItems2, items2, a, b);
                        }

                        if (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, p, T), System.Array.getItem(keys, b, T)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T, keys, p, b);
                            MathNet.Numerics.Sorting.Swap(TItems1, items1, p, b);
                            MathNet.Numerics.Sorting.Swap(TItems2, items2, p, b);
                        }

                        var pivot = System.Array.getItem(keys, p, T);

                        do {
                            while (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(keys, a, T), pivot) < 0) {
                                a = (a + 1) | 0;
                            }

                            while (comparer[Bridge.geti(comparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare", "System$Collections$Generic$IComparer$1$compare")](pivot, System.Array.getItem(keys, b, T)) < 0) {
                                b = (b - 1) | 0;
                            }

                            if (a > b) {
                                break;
                            }

                            if (a < b) {
                                MathNet.Numerics.Sorting.Swap(T, keys, a, b);
                                MathNet.Numerics.Sorting.Swap(TItems1, items1, a, b);
                                MathNet.Numerics.Sorting.Swap(TItems2, items2, a, b);
                            }

                            a = (a + 1) | 0;
                            b = (b - 1) | 0;
                        } while (a <= b);

                        if ((((b - left) | 0)) <= (((right - a) | 0))) {
                            if (left < b) {
                                MathNet.Numerics.Sorting.QuickSort$2(T, TItems1, TItems2, keys, items1, items2, comparer, left, b);
                            }

                            left = a;
                        } else {
                            if (a < right) {
                                MathNet.Numerics.Sorting.QuickSort$2(T, TItems1, TItems2, keys, items1, items2, comparer, a, right);
                            }

                            right = b;
                        }
                    } while (left < right);
                },
                /**
                 * Recursive implementation for an in place quick sort on the primary and then by the secondary list while reordering one secondary list accordingly.
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.Sorting
                 * @memberof MathNet.Numerics.Sorting
                 * @param   {Function}                                  T1                   The type of the primary list.
                 * @param   {Function}                                  T2                   The type of the secondary list.
                 * @param   {System.Collections.Generic.IList$1}        primary              The list which is sorted using quick sort.
                 * @param   {System.Collections.Generic.IList$1}        secondary            The list which is sorted secondarily (on primary duplicates) and automatically reordered accordingly.
                 * @param   {System.Collections.Generic.IComparer$1}    primaryComparer      The method with which to compare two elements of the primary list.
                 * @param   {System.Collections.Generic.IComparer$1}    secondaryComparer    The method with which to compare two elements of the secondary list.
                 * @param   {number}                                    left                 The left boundary of the quick sort.
                 * @param   {number}                                    right                The right boundary of the quick sort.
                 * @return  {void}
                 */
                QuickSortAll: function (T1, T2, primary, secondary, primaryComparer, secondaryComparer, left, right) {
                    do {
                        var a = left;
                        var b = right;
                        var p = (a + ((((b - a) | 0)) >> 1)) | 0;

                        var ap = primaryComparer[Bridge.geti(primaryComparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T1) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(primary, a, T1), System.Array.getItem(primary, p, T1));
                        if (ap > 0 || ap === 0 && secondaryComparer[Bridge.geti(secondaryComparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T2) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(secondary, a, T2), System.Array.getItem(secondary, p, T2)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T1, primary, a, p);
                            MathNet.Numerics.Sorting.Swap(T2, secondary, a, p);
                        }

                        var ab = primaryComparer[Bridge.geti(primaryComparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T1) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(primary, a, T1), System.Array.getItem(primary, b, T1));
                        if (ab > 0 || ab === 0 && secondaryComparer[Bridge.geti(secondaryComparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T2) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(secondary, a, T2), System.Array.getItem(secondary, b, T2)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T1, primary, a, b);
                            MathNet.Numerics.Sorting.Swap(T2, secondary, a, b);
                        }

                        var pb = primaryComparer[Bridge.geti(primaryComparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T1) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(primary, p, T1), System.Array.getItem(primary, b, T1));
                        if (pb > 0 || pb === 0 && secondaryComparer[Bridge.geti(secondaryComparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T2) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(secondary, p, T2), System.Array.getItem(secondary, b, T2)) > 0) {
                            MathNet.Numerics.Sorting.Swap(T1, primary, p, b);
                            MathNet.Numerics.Sorting.Swap(T2, secondary, p, b);
                        }

                        var pivot1 = System.Array.getItem(primary, p, T1);
                        var pivot2 = System.Array.getItem(secondary, p, T2);

                        do {
                            var ax;
                            while (((ax = primaryComparer[Bridge.geti(primaryComparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T1) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(primary, a, T1), pivot1))) < 0 || ax === 0 && secondaryComparer[Bridge.geti(secondaryComparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T2) + "$compare", "System$Collections$Generic$IComparer$1$compare")](System.Array.getItem(secondary, a, T2), pivot2) < 0) {
                                a = (a + 1) | 0;
                            }

                            var xb;
                            while (((xb = primaryComparer[Bridge.geti(primaryComparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T1) + "$compare", "System$Collections$Generic$IComparer$1$compare")](pivot1, System.Array.getItem(primary, b, T1)))) < 0 || xb === 0 && secondaryComparer[Bridge.geti(secondaryComparer, "System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T2) + "$compare", "System$Collections$Generic$IComparer$1$compare")](pivot2, System.Array.getItem(secondary, b, T2)) < 0) {
                                b = (b - 1) | 0;
                            }

                            if (a > b) {
                                break;
                            }

                            if (a < b) {
                                MathNet.Numerics.Sorting.Swap(T1, primary, a, b);
                                MathNet.Numerics.Sorting.Swap(T2, secondary, a, b);
                            }

                            a = (a + 1) | 0;
                            b = (b - 1) | 0;
                        } while (a <= b);

                        if ((((b - left) | 0)) <= (((right - a) | 0))) {
                            if (left < b) {
                                MathNet.Numerics.Sorting.QuickSortAll(T1, T2, primary, secondary, primaryComparer, secondaryComparer, left, b);
                            }

                            left = a;
                        } else {
                            if (a < right) {
                                MathNet.Numerics.Sorting.QuickSortAll(T1, T2, primary, secondary, primaryComparer, secondaryComparer, a, right);
                            }

                            right = b;
                        }
                    } while (left < right);
                },
                /**
                 * Performs an in place swap of two elements in a list.
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.Sorting
                 * @memberof MathNet.Numerics.Sorting
                 * @param   {Function}                              T       The type of elements stored in the list.
                 * @param   {System.Collections.Generic.IList$1}    keys    The list in which the elements are stored.
                 * @param   {number}                                a       The index of the first element of the swap.
                 * @param   {number}                                b       The index of the second element of the swap.
                 * @return  {void}
                 */
                Swap: function (T, keys, a, b) {
                    if (a === b) {
                        return;
                    }

                    var local = System.Array.getItem(keys, a, T);
                    System.Array.setItem(keys, a, System.Array.getItem(keys, b, T), T);
                    System.Array.setItem(keys, b, local, T);
                }
            }
        }
    });

    Bridge.define("MathNetNumerics.App", {
        main: function Main () {
            System.Console.WriteLine("Welcome to Bridge.NET");

            var k = MathNetNumerics.App.v_builder.DenseOfArray(System.Array.init([1.0, 0.0, 0.0], System.Double));
            var I = MathNetNumerics.App.m_builder.DenseIdentity(3);
            var khat = MathNetNumerics.App.Hat(k);
            var khat2 = khat.Multiply$1(khat);
            System.Console.WriteLine(MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).op_Addition$2(MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).op_Addition$2(I, khat), khat2));




        },
        statics: {
            fields: {
                v_builder: null,
                m_builder: null
            },
            ctors: {
                init: function () {
                    this.v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(System.Double).Vector;
                    this.m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(System.Double).Matrix;
                }
            },
            methods: {
                Hat: function (k) {
                    var khat = MathNetNumerics.App.m_builder.Dense$1(3, 3);
                    khat.setItem(0, 1, -k.getItem(2));
                    khat.setItem(0, 2, k.getItem(1));
                    khat.setItem(1, 0, k.getItem(2));
                    khat.setItem(1, 2, -k.getItem(0));
                    khat.setItem(2, 0, -k.getItem(1));
                    khat.setItem(2, 1, k.getItem(0));
                    return khat;
                }
            }
        }
    });

    Bridge.define("MathNetNumerics.Buffer", {
        statics: {
            methods: {
                BlockCopy$2: function (recbuf, v1, newbuf, v2, v3) {
                    System.Array.copy(recbuf, v1, newbuf, v2, v3);
                },
                BlockCopy: function (a, v, membuf, position, bl) {
                    var b = new System.IO.BinaryWriter.$ctor1(new System.IO.MemoryStream.$ctor3(membuf, position, bl));
                    var t = System.Type.getTypeCode((Bridge.getType(a).$elementType || null));
                    switch (t) {
                        case System.TypeCode.Double: 
                            {
                                var a1 = Bridge.cast(a, System.Array.type(System.Double));
                                for (var i = 0; i < ((Bridge.Int.div(bl, 8)) | 0); i = (i + 1) | 0) {
                                    b.Write$8(a1[System.Array.index(((i + v) | 0), a1)]);
                                }
                                break;
                            }
                        case System.TypeCode.Single: 
                            {
                                var a11 = Bridge.cast(a, System.Array.type(System.Single));
                                for (var i1 = 0; i1 < ((Bridge.Int.div(bl, 4)) | 0); i1 = (i1 + 1) | 0) {
                                    b.Write$13(a11[System.Array.index(((i1 + v) | 0), a11)]);
                                }
                                break;
                            }
                        case System.TypeCode.Byte: 
                            {
                                var a12 = Bridge.cast(a, System.Array.type(System.Byte));
                                for (var i2 = 0; i2 < bl; i2 = (i2 + 1) | 0) {
                                    b.Write$1(a12[System.Array.index(((i2 + v) | 0), a12)]);
                                }
                                break;
                            }
                        case System.TypeCode.SByte: 
                            {
                                var a13 = Bridge.cast(a, System.Array.type(System.SByte));
                                for (var i3 = 0; i3 < bl; i3 = (i3 + 1) | 0) {
                                    b.Write$12(a13[System.Array.index(((i3 + v) | 0), a13)]);
                                }
                                break;
                            }
                        case System.TypeCode.UInt16: 
                            {
                                var a14 = Bridge.cast(a, System.Array.type(System.UInt16));
                                for (var i4 = 0; i4 < ((Bridge.Int.div(bl, 2)) | 0); i4 = (i4 + 1) | 0) {
                                    b.Write$15(a14[System.Array.index(((i4 + v) | 0), a14)]);
                                }
                                break;
                            }
                        case System.TypeCode.Int16: 
                            {
                                var a15 = Bridge.cast(a, System.Array.type(System.Int16));
                                for (var i5 = 0; i5 < ((Bridge.Int.div(bl, 2)) | 0); i5 = (i5 + 1) | 0) {
                                    b.Write$9(a15[System.Array.index(((i5 + v) | 0), a15)]);
                                }
                                break;
                            }
                        case System.TypeCode.UInt32: 
                            {
                                var a16 = Bridge.cast(a, System.Array.type(System.UInt32));
                                for (var i6 = 0; i6 < ((Bridge.Int.div(bl, 4)) | 0); i6 = (i6 + 1) | 0) {
                                    b.Write$16(a16[System.Array.index(((i6 + v) | 0), a16)]);
                                }
                                break;
                            }
                        case System.TypeCode.Int32: 
                            {
                                var a17 = Bridge.cast(a, System.Array.type(System.Int32));
                                for (var i7 = 0; i7 < ((Bridge.Int.div(bl, 4)) | 0); i7 = (i7 + 1) | 0) {
                                    b.Write$10(a17[System.Array.index(((i7 + v) | 0), a17)]);
                                }
                                break;
                            }
                        case System.TypeCode.UInt64: 
                            {
                                var a18 = Bridge.cast(a, System.Array.type(System.UInt64));
                                for (var i8 = 0; i8 < ((Bridge.Int.div(bl, 8)) | 0); i8 = (i8 + 1) | 0) {
                                    b.Write$17(a18[System.Array.index(((i8 + v) | 0), a18)]);
                                }
                                break;
                            }
                        case System.TypeCode.Int64: 
                            {
                                var a19 = Bridge.cast(a, System.Array.type(System.Int64));
                                for (var i9 = 0; i9 < ((Bridge.Int.div(bl, 8)) | 0); i9 = (i9 + 1) | 0) {
                                    b.Write$11(a19[System.Array.index(((i9 + v) | 0), a19)]);
                                }
                                break;
                            }
                        case System.TypeCode.Boolean: 
                            {
                                var a110 = Bridge.cast(a, System.Array.type(System.Boolean));
                                for (var i10 = 0; i10 < bl; i10 = (i10 + 1) | 0) {
                                    b.Write(a110[System.Array.index(((i10 + v) | 0), a110)]);
                                }
                                break;
                            }
                        default: 
                            throw new System.ArgumentException.$ctor1("Invalid array type");
                    }
                },
                BlockCopy$1: function (membuf, position, a, v, bl) {
                    var b = new System.IO.BinaryReader.ctor(new System.IO.MemoryStream.$ctor3(membuf, position, bl));
                    var t = System.Type.getTypeCode((Bridge.getType(a).$elementType || null));
                    switch (t) {
                        case System.TypeCode.Double: 
                            {
                                var a1 = Bridge.cast(a, System.Array.type(System.Double));
                                for (var i = 0; i < ((Bridge.Int.div(bl, 8)) | 0); i = (i + 1) | 0) {
                                    a1[System.Array.index(((i + v) | 0), a1)] = b.ReadDouble();
                                }
                                break;
                            }
                        case System.TypeCode.Single: 
                            {
                                var a11 = Bridge.cast(a, System.Array.type(System.Single));
                                for (var i1 = 0; i1 < ((Bridge.Int.div(bl, 4)) | 0); i1 = (i1 + 1) | 0) {
                                    a11[System.Array.index(((i1 + v) | 0), a11)] = b.ReadSingle();
                                }
                                break;
                            }
                        case System.TypeCode.Byte: 
                            {
                                var a12 = Bridge.cast(a, System.Array.type(System.Byte));
                                for (var i2 = 0; i2 < bl; i2 = (i2 + 1) | 0) {
                                    a12[System.Array.index(((i2 + v) | 0), a12)] = b.ReadByte();
                                }
                                break;
                            }
                        case System.TypeCode.SByte: 
                            {
                                var a13 = Bridge.cast(a, System.Array.type(System.SByte));
                                for (var i3 = 0; i3 < bl; i3 = (i3 + 1) | 0) {
                                    a13[System.Array.index(((i3 + v) | 0), a13)] = b.ReadSByte();
                                }
                                break;
                            }
                        case System.TypeCode.UInt16: 
                            {
                                var a14 = Bridge.cast(a, System.Array.type(System.UInt16));
                                for (var i4 = 0; i4 < ((Bridge.Int.div(bl, 2)) | 0); i4 = (i4 + 1) | 0) {
                                    a14[System.Array.index(((i4 + v) | 0), a14)] = b.ReadUInt16();
                                }
                                break;
                            }
                        case System.TypeCode.Int16: 
                            {
                                var a15 = Bridge.cast(a, System.Array.type(System.Int16));
                                for (var i5 = 0; i5 < ((Bridge.Int.div(bl, 2)) | 0); i5 = (i5 + 1) | 0) {
                                    a15[System.Array.index(((i5 + v) | 0), a15)] = b.ReadInt16();
                                }
                                break;
                            }
                        case System.TypeCode.UInt32: 
                            {
                                var a16 = Bridge.cast(a, System.Array.type(System.UInt32));
                                for (var i6 = 0; i6 < ((Bridge.Int.div(bl, 4)) | 0); i6 = (i6 + 1) | 0) {
                                    a16[System.Array.index(((i6 + v) | 0), a16)] = b.ReadUInt32();
                                }
                                break;
                            }
                        case System.TypeCode.Int32: 
                            {
                                var a17 = Bridge.cast(a, System.Array.type(System.Int32));
                                for (var i7 = 0; i7 < ((Bridge.Int.div(bl, 4)) | 0); i7 = (i7 + 1) | 0) {
                                    a17[System.Array.index(((i7 + v) | 0), a17)] = b.ReadInt32();
                                }
                                break;
                            }
                        case System.TypeCode.UInt64: 
                            {
                                var a18 = Bridge.cast(a, System.Array.type(System.UInt64));
                                for (var i8 = 0; i8 < ((Bridge.Int.div(bl, 8)) | 0); i8 = (i8 + 1) | 0) {
                                    a18[System.Array.index(((i8 + v) | 0), a18)] = b.ReadUInt64();
                                }
                                break;
                            }
                        case System.TypeCode.Int64: 
                            {
                                var a19 = Bridge.cast(a, System.Array.type(System.Int64));
                                for (var i9 = 0; i9 < ((Bridge.Int.div(bl, 8)) | 0); i9 = (i9 + 1) | 0) {
                                    a19[System.Array.index(((i9 + v) | 0), a19)] = b.ReadInt64();
                                }
                                break;
                            }
                        case System.TypeCode.Boolean: 
                            {
                                var a110 = Bridge.cast(a, System.Array.type(System.Boolean));
                                for (var i10 = 0; i10 < bl; i10 = (i10 + 1) | 0) {
                                    a110[System.Array.index(((i10 + v) | 0), a110)] = b.ReadBoolean();
                                }
                                break;
                            }
                        default: 
                            throw new System.ArgumentException.$ctor1("Invalid array type");
                    }
                },
                ByteLength: function (a) {
                    var t = System.Type.getTypeCode((Bridge.getType(a).$elementType || null));
                    switch (t) {
                        case System.TypeCode.Double: 
                            return Bridge.Int.mul(8, a.length);
                        case System.TypeCode.Single: 
                            return Bridge.Int.mul(4, a.length);
                        case System.TypeCode.Byte: 
                        case System.TypeCode.SByte: 
                            return a.length;
                        case System.TypeCode.UInt16: 
                        case System.TypeCode.Int16: 
                            return Bridge.Int.mul(2, a.length);
                        case System.TypeCode.UInt32: 
                        case System.TypeCode.Int32: 
                            return Bridge.Int.mul(4, a.length);
                        case System.TypeCode.UInt64: 
                        case System.TypeCode.Int64: 
                            return Bridge.Int.mul(8, a.length);
                        case System.TypeCode.Boolean: 
                            return a.length;
                        default: 
                            throw new System.ArgumentException.$ctor1("Invalid array type");
                    }
                }
            }
        }
    });

    Bridge.define("MathNetNumerics.ManagedLinearAlgebraProvider", {
        statics: {
            methods: {
                Drotg: function (da, db, c, s) {
                    var r, z;

                    var roe = db.v;
                    var absda = Math.abs(da.v);
                    var absdb = Math.abs(db.v);
                    if (absda > absdb) {
                        roe = da.v;
                    }

                    var scale = absda + absdb;
                    if (scale === 0.0) {
                        c.v = 1.0;
                        s.v = 0.0;
                        r = 0.0;
                        z = 0.0;
                    } else {
                        var sda = da.v / scale;
                        var sdb = db.v / scale;
                        r = scale * Math.sqrt((sda * sda) + (sdb * sdb));
                        if (roe < 0.0) {
                            r = -r;
                        }

                        c.v = da.v / r;
                        s.v = db.v / r;
                        z = 1.0;
                        if (absda > absdb) {
                            z = s.v;
                        }

                        if (absdb >= absda && c.v !== 0.0) {
                            z = 1.0 / c.v;
                        }
                    }

                    da.v = r;
                    db.v = z;
                }
            }
        },
        methods: {
            SvdSolveFactored: function (rowsA, columnsA, s, u, vt, b, columnsB, x) {
                if (s == null) {
                    throw new System.ArgumentNullException.$ctor1("s");
                }

                if (u == null) {
                    throw new System.ArgumentNullException.$ctor1("u");
                }

                if (vt == null) {
                    throw new System.ArgumentNullException.$ctor1("vt");
                }

                if (b == null) {
                    throw new System.ArgumentNullException.$ctor1("b");
                }

                if (x == null) {
                    throw new System.ArgumentNullException.$ctor1("x");
                }

                if (u.length !== Bridge.Int.mul(rowsA, rowsA)) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentArraysSameLength", "u");
                }

                if (vt.length !== Bridge.Int.mul(columnsA, columnsA)) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentArraysSameLength", "vt");
                }

                if (s.length !== Math.min(rowsA, columnsA)) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentArraysSameLength", "s");
                }

                if (b.length !== Bridge.Int.mul(rowsA, columnsB)) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentArraysSameLength", "b");
                }

                if (x.length !== Bridge.Int.mul(columnsA, columnsB)) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentArraysSameLength", "b");
                }

                var mn = Math.min(rowsA, columnsA);
                var tmp = System.Array.init(columnsA, 0, System.Double);

                for (var k = 0; k < columnsB; k = (k + 1) | 0) {
                    for (var j = 0; j < columnsA; j = (j + 1) | 0) {
                        var value = 0;
                        if (j < mn) {
                            for (var i = 0; i < rowsA; i = (i + 1) | 0) {
                                value += u[System.Array.index((((Bridge.Int.mul(j, rowsA)) + i) | 0), u)] * b[System.Array.index((((Bridge.Int.mul(k, rowsA)) + i) | 0), b)];
                            }

                            value /= s[System.Array.index(j, s)];
                        }

                        tmp[System.Array.index(j, tmp)] = value;
                    }

                    for (var j1 = 0; j1 < columnsA; j1 = (j1 + 1) | 0) {
                        var value1 = 0;
                        for (var i1 = 0; i1 < columnsA; i1 = (i1 + 1) | 0) {
                            value1 += vt[System.Array.index((((Bridge.Int.mul(j1, columnsA)) + i1) | 0), vt)] * tmp[System.Array.index(i1, tmp)];
                        }

                        x[System.Array.index((((Bridge.Int.mul(k, columnsA)) + j1) | 0), x)] = value1;
                    }
                }
            },
            SingularValueDecomposition: function (computeVectors, a, rowsA, columnsA, s, u, vt) {
                if (a == null) {
                    throw new System.ArgumentNullException.$ctor1("a");
                }

                if (s == null) {
                    throw new System.ArgumentNullException.$ctor1("s");
                }

                if (u == null) {
                    throw new System.ArgumentNullException.$ctor1("u");
                }

                if (vt == null) {
                    throw new System.ArgumentNullException.$ctor1("vt");
                }

                if (u.length !== Bridge.Int.mul(rowsA, rowsA)) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentArraysSameLength", "u");
                }

                if (vt.length !== Bridge.Int.mul(columnsA, columnsA)) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentArraysSameLength", "vt");
                }

                if (s.length !== Math.min(rowsA, columnsA)) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentArraysSameLength", "s");
                }

                var work = System.Array.init(rowsA, 0, System.Double);

                var maxiter = 1000;

                var e = System.Array.init(columnsA, 0, System.Double);
                var v = System.Array.init(vt.length, 0, System.Double);
                var stemp = System.Array.init(Math.min(((rowsA + 1) | 0), columnsA), 0, System.Double);

                var i, j, l, lp1;

                var t;

                var ncu = rowsA;

                var nct = Math.min(((rowsA - 1) | 0), columnsA);
                var nrt = Math.max(0, Math.min(((columnsA - 2) | 0), rowsA));
                var lu = Math.max(nct, nrt);

                for (l = 0; l < lu; l = (l + 1) | 0) {
                    lp1 = (l + 1) | 0;
                    if (l < nct) {
                        var sum = 0.0;
                        for (var i1 = l; i1 < rowsA; i1 = (i1 + 1) | 0) {
                            sum += a[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i1) | 0), a)] * a[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i1) | 0), a)];
                        }

                        stemp[System.Array.index(l, stemp)] = Math.sqrt(sum);

                        if (stemp[System.Array.index(l, stemp)] !== 0.0) {
                            if (a[System.Array.index((((Bridge.Int.mul(l, rowsA)) + l) | 0), a)] !== 0.0) {
                                stemp[System.Array.index(l, stemp)] = Math.abs(stemp[System.Array.index(l, stemp)]) * (a[System.Array.index((((Bridge.Int.mul(l, rowsA)) + l) | 0), a)] / Math.abs(a[System.Array.index((((Bridge.Int.mul(l, rowsA)) + l) | 0), a)]));
                            }

                            for (i = l; i < rowsA; i = (i + 1) | 0) {
                                a[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i) | 0), a)] = a[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i) | 0), a)] * (1.0 / stemp[System.Array.index(l, stemp)]);
                            }

                            a[System.Array.index((((Bridge.Int.mul(l, rowsA)) + l) | 0), a)] = 1.0 + a[System.Array.index((((Bridge.Int.mul(l, rowsA)) + l) | 0), a)];
                        }

                        stemp[System.Array.index(l, stemp)] = -stemp[System.Array.index(l, stemp)];
                    }

                    for (j = lp1; j < columnsA; j = (j + 1) | 0) {
                        if (l < nct) {
                            if (stemp[System.Array.index(l, stemp)] !== 0.0) {
                                t = 0.0;
                                for (i = l; i < rowsA; i = (i + 1) | 0) {
                                    t += a[System.Array.index((((Bridge.Int.mul(j, rowsA)) + i) | 0), a)] * a[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i) | 0), a)];
                                }

                                t = -t / a[System.Array.index((((Bridge.Int.mul(l, rowsA)) + l) | 0), a)];

                                for (var ii = l; ii < rowsA; ii = (ii + 1) | 0) {
                                    a[System.Array.index((((Bridge.Int.mul(j, rowsA)) + ii) | 0), a)] += t * a[System.Array.index((((Bridge.Int.mul(l, rowsA)) + ii) | 0), a)];
                                }
                            }
                        }

                        e[System.Array.index(j, e)] = a[System.Array.index((((Bridge.Int.mul(j, rowsA)) + l) | 0), a)];
                    }

                    if (computeVectors && l < nct) {
                        for (i = l; i < rowsA; i = (i + 1) | 0) {
                            u[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i) | 0), u)] = a[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i) | 0), a)];
                        }
                    }

                    if (l >= nrt) {
                        continue;
                    }

                    var enorm = 0.0;
                    for (i = lp1; i < e.length; i = (i + 1) | 0) {
                        enorm += e[System.Array.index(i, e)] * e[System.Array.index(i, e)];
                    }

                    e[System.Array.index(l, e)] = Math.sqrt(enorm);
                    if (e[System.Array.index(l, e)] !== 0.0) {
                        if (e[System.Array.index(lp1, e)] !== 0.0) {
                            e[System.Array.index(l, e)] = Math.abs(e[System.Array.index(l, e)]) * (e[System.Array.index(lp1, e)] / Math.abs(e[System.Array.index(lp1, e)]));
                        }

                        for (i = lp1; i < e.length; i = (i + 1) | 0) {
                            e[System.Array.index(i, e)] = e[System.Array.index(i, e)] * (1.0 / e[System.Array.index(l, e)]);
                        }

                        e[System.Array.index(lp1, e)] = 1.0 + e[System.Array.index(lp1, e)];
                    }

                    e[System.Array.index(l, e)] = -e[System.Array.index(l, e)];

                    if (lp1 < rowsA && e[System.Array.index(l, e)] !== 0.0) {
                        for (i = lp1; i < rowsA; i = (i + 1) | 0) {
                            work[System.Array.index(i, work)] = 0.0;
                        }

                        for (j = lp1; j < columnsA; j = (j + 1) | 0) {
                            for (var ii1 = lp1; ii1 < rowsA; ii1 = (ii1 + 1) | 0) {
                                work[System.Array.index(ii1, work)] += e[System.Array.index(j, e)] * a[System.Array.index((((Bridge.Int.mul(j, rowsA)) + ii1) | 0), a)];
                            }
                        }

                        for (j = lp1; j < columnsA; j = (j + 1) | 0) {
                            var ww = -e[System.Array.index(j, e)] / e[System.Array.index(lp1, e)];
                            for (var ii2 = lp1; ii2 < rowsA; ii2 = (ii2 + 1) | 0) {
                                a[System.Array.index((((Bridge.Int.mul(j, rowsA)) + ii2) | 0), a)] += ww * work[System.Array.index(ii2, work)];
                            }
                        }
                    }

                    if (!computeVectors) {
                        continue;
                    }

                    for (i = lp1; i < columnsA; i = (i + 1) | 0) {
                        v[System.Array.index((((Bridge.Int.mul(l, columnsA)) + i) | 0), v)] = e[System.Array.index(i, e)];
                    }
                }

                var m = Math.min(columnsA, ((rowsA + 1) | 0));
                var nctp1 = (nct + 1) | 0;
                var nrtp1 = (nrt + 1) | 0;
                if (nct < columnsA) {
                    stemp[System.Array.index(((nctp1 - 1) | 0), stemp)] = a[System.Array.index((((Bridge.Int.mul((((nctp1 - 1) | 0)), rowsA)) + (((nctp1 - 1) | 0))) | 0), a)];
                }

                if (rowsA < m) {
                    stemp[System.Array.index(((m - 1) | 0), stemp)] = 0.0;
                }

                if (nrtp1 < m) {
                    e[System.Array.index(((nrtp1 - 1) | 0), e)] = a[System.Array.index((((Bridge.Int.mul((((m - 1) | 0)), rowsA)) + (((nrtp1 - 1) | 0))) | 0), a)];
                }

                e[System.Array.index(((m - 1) | 0), e)] = 0.0;

                if (computeVectors) {
                    for (j = (nctp1 - 1) | 0; j < ncu; j = (j + 1) | 0) {
                        for (i = 0; i < rowsA; i = (i + 1) | 0) {
                            u[System.Array.index((((Bridge.Int.mul(j, rowsA)) + i) | 0), u)] = 0.0;
                        }

                        u[System.Array.index((((Bridge.Int.mul(j, rowsA)) + j) | 0), u)] = 1.0;
                    }

                    for (l = (nct - 1) | 0; l >= 0; l = (l - 1) | 0) {
                        if (stemp[System.Array.index(l, stemp)] !== 0.0) {
                            for (j = (l + 1) | 0; j < ncu; j = (j + 1) | 0) {
                                t = 0.0;
                                for (i = l; i < rowsA; i = (i + 1) | 0) {
                                    t += u[System.Array.index((((Bridge.Int.mul(j, rowsA)) + i) | 0), u)] * u[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i) | 0), u)];
                                }

                                t = -t / u[System.Array.index((((Bridge.Int.mul(l, rowsA)) + l) | 0), u)];

                                for (var ii3 = l; ii3 < rowsA; ii3 = (ii3 + 1) | 0) {
                                    u[System.Array.index((((Bridge.Int.mul(j, rowsA)) + ii3) | 0), u)] += t * u[System.Array.index((((Bridge.Int.mul(l, rowsA)) + ii3) | 0), u)];
                                }
                            }

                            for (i = l; i < rowsA; i = (i + 1) | 0) {
                                u[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i) | 0), u)] = u[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i) | 0), u)] * -1.0;
                            }

                            u[System.Array.index((((Bridge.Int.mul(l, rowsA)) + l) | 0), u)] = 1.0 + u[System.Array.index((((Bridge.Int.mul(l, rowsA)) + l) | 0), u)];
                            for (i = 0; i < l; i = (i + 1) | 0) {
                                u[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i) | 0), u)] = 0.0;
                            }
                        } else {
                            for (i = 0; i < rowsA; i = (i + 1) | 0) {
                                u[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i) | 0), u)] = 0.0;
                            }

                            u[System.Array.index((((Bridge.Int.mul(l, rowsA)) + l) | 0), u)] = 1.0;
                        }
                    }
                }

                if (computeVectors) {
                    for (l = (columnsA - 1) | 0; l >= 0; l = (l - 1) | 0) {
                        lp1 = (l + 1) | 0;
                        if (l < nrt) {
                            if (e[System.Array.index(l, e)] !== 0.0) {
                                for (j = lp1; j < columnsA; j = (j + 1) | 0) {
                                    t = 0.0;
                                    for (i = lp1; i < columnsA; i = (i + 1) | 0) {
                                        t += v[System.Array.index((((Bridge.Int.mul(j, columnsA)) + i) | 0), v)] * v[System.Array.index((((Bridge.Int.mul(l, columnsA)) + i) | 0), v)];
                                    }

                                    t = -t / v[System.Array.index((((Bridge.Int.mul(l, columnsA)) + lp1) | 0), v)];
                                    for (var ii4 = l; ii4 < columnsA; ii4 = (ii4 + 1) | 0) {
                                        v[System.Array.index((((Bridge.Int.mul(j, columnsA)) + ii4) | 0), v)] += t * v[System.Array.index((((Bridge.Int.mul(l, columnsA)) + ii4) | 0), v)];
                                    }
                                }
                            }
                        }

                        for (i = 0; i < columnsA; i = (i + 1) | 0) {
                            v[System.Array.index((((Bridge.Int.mul(l, columnsA)) + i) | 0), v)] = 0.0;
                        }

                        v[System.Array.index((((Bridge.Int.mul(l, columnsA)) + l) | 0), v)] = 1.0;
                    }
                }

                for (i = 0; i < m; i = (i + 1) | 0) {
                    var r;
                    if (stemp[System.Array.index(i, stemp)] !== 0.0) {
                        t = stemp[System.Array.index(i, stemp)];
                        r = stemp[System.Array.index(i, stemp)] / t;
                        stemp[System.Array.index(i, stemp)] = t;
                        if (i < ((m - 1) | 0)) {
                            e[System.Array.index(i, e)] = e[System.Array.index(i, e)] / r;
                        }

                        if (computeVectors) {
                            for (j = 0; j < rowsA; j = (j + 1) | 0) {
                                u[System.Array.index((((Bridge.Int.mul(i, rowsA)) + j) | 0), u)] = u[System.Array.index((((Bridge.Int.mul(i, rowsA)) + j) | 0), u)] * r;
                            }
                        }
                    }

                    if (i === ((m - 1) | 0)) {
                        break;
                    }

                    if (e[System.Array.index(i, e)] === 0.0) {
                        continue;
                    }

                    t = e[System.Array.index(i, e)];
                    r = t / e[System.Array.index(i, e)];
                    e[System.Array.index(i, e)] = t;
                    stemp[System.Array.index(((i + 1) | 0), stemp)] = stemp[System.Array.index(((i + 1) | 0), stemp)] * r;
                    if (!computeVectors) {
                        continue;
                    }

                    for (j = 0; j < columnsA; j = (j + 1) | 0) {
                        v[System.Array.index((((Bridge.Int.mul((((i + 1) | 0)), columnsA)) + j) | 0), v)] = v[System.Array.index((((Bridge.Int.mul((((i + 1) | 0)), columnsA)) + j) | 0), v)] * r;
                    }
                }

                var mn = m;
                var iter = 0;

                while (m > 0) {
                    if (iter >= maxiter) {
                        throw new System.ArgumentException.$ctor1("NonConvergenceException");
                    }

                    var ztest;
                    var test;
                    for (l = (m - 2) | 0; l >= 0; l = (l - 1) | 0) {
                        test = Math.abs(stemp[System.Array.index(l, stemp)]) + Math.abs(stemp[System.Array.index(((l + 1) | 0), stemp)]);
                        ztest = test + Math.abs(e[System.Array.index(l, e)]);
                        if (this.AlmostEquals(ztest, test)) {
                            e[System.Array.index(l, e)] = 0.0;
                            break;
                        }
                    }

                    var kase;
                    if (l === ((m - 2) | 0)) {
                        kase = 4;
                    } else {
                        var ls;
                        for (ls = (m - 1) | 0; ls > l; ls = (ls - 1) | 0) {
                            test = 0.0;
                            if (ls !== ((m - 1) | 0)) {
                                test = test + Math.abs(e[System.Array.index(ls, e)]);
                            }

                            if (ls !== ((l + 1) | 0)) {
                                test = test + Math.abs(e[System.Array.index(((ls - 1) | 0), e)]);
                            }

                            ztest = test + Math.abs(stemp[System.Array.index(ls, stemp)]);
                            if (this.AlmostEquals(ztest, test)) {
                                stemp[System.Array.index(ls, stemp)] = 0.0;
                                break;
                            }
                        }

                        if (ls === l) {
                            kase = 3;
                        } else if (ls === ((m - 1) | 0)) {
                            kase = 1;
                        } else {
                            kase = 2;
                            l = ls;
                        }
                    }

                    l = (l + 1) | 0;

                    var k;
                    var f = { };
                    var cs = { };
                    var sn = { };
                    switch (kase) {
                        case 1: 
                            f.v = e[System.Array.index(((m - 2) | 0), e)];
                            e[System.Array.index(((m - 2) | 0), e)] = 0.0;
                            var t1 = { };
                            for (var kk = l; kk < ((m - 1) | 0); kk = (kk + 1) | 0) {
                                k = (((((m - 2) | 0) - kk) | 0) + l) | 0;
                                t1.v = stemp[System.Array.index(k, stemp)];

                                MathNetNumerics.ManagedLinearAlgebraProvider.Drotg(t1, f, cs, sn);
                                stemp[System.Array.index(k, stemp)] = t1.v;
                                if (k !== l) {
                                    f.v = -sn.v * e[System.Array.index(((k - 1) | 0), e)];
                                    e[System.Array.index(((k - 1) | 0), e)] = cs.v * e[System.Array.index(((k - 1) | 0), e)];
                                }

                                if (computeVectors) {
                                    for (i = 0; i < columnsA; i = (i + 1) | 0) {
                                        var z = (cs.v * v[System.Array.index((((Bridge.Int.mul(k, columnsA)) + i) | 0), v)]) + (sn.v * v[System.Array.index((((Bridge.Int.mul((((m - 1) | 0)), columnsA)) + i) | 0), v)]);
                                        v[System.Array.index((((Bridge.Int.mul((((m - 1) | 0)), columnsA)) + i) | 0), v)] = (cs.v * v[System.Array.index((((Bridge.Int.mul((((m - 1) | 0)), columnsA)) + i) | 0), v)]) - (sn.v * v[System.Array.index((((Bridge.Int.mul(k, columnsA)) + i) | 0), v)]);
                                        v[System.Array.index((((Bridge.Int.mul(k, columnsA)) + i) | 0), v)] = z;
                                    }
                                }
                            }
                            break;
                        case 2: 
                            f.v = e[System.Array.index(((l - 1) | 0), e)];
                            e[System.Array.index(((l - 1) | 0), e)] = 0.0;
                            for (k = l; k < m; k = (k + 1) | 0) {
                                t1 = stemp[System.Array.index(k, stemp)];
                                MathNetNumerics.ManagedLinearAlgebraProvider.Drotg(t1, f, cs, sn);
                                stemp[System.Array.index(k, stemp)] = t1;
                                f.v = -sn.v * e[System.Array.index(k, e)];
                                e[System.Array.index(k, e)] = cs.v * e[System.Array.index(k, e)];
                                if (computeVectors) {
                                    for (i = 0; i < rowsA; i = (i + 1) | 0) {
                                        var z1 = (cs.v * u[System.Array.index((((Bridge.Int.mul(k, rowsA)) + i) | 0), u)]) + (sn.v * u[System.Array.index((((Bridge.Int.mul((((l - 1) | 0)), rowsA)) + i) | 0), u)]);
                                        u[System.Array.index((((Bridge.Int.mul((((l - 1) | 0)), rowsA)) + i) | 0), u)] = (cs.v * u[System.Array.index((((Bridge.Int.mul((((l - 1) | 0)), rowsA)) + i) | 0), u)]) - (sn.v * u[System.Array.index((((Bridge.Int.mul(k, rowsA)) + i) | 0), u)]);
                                        u[System.Array.index((((Bridge.Int.mul(k, rowsA)) + i) | 0), u)] = z1;
                                    }
                                }
                            }
                            break;
                        case 3: 
                            var scale = 0.0;
                            scale = Math.max(scale, Math.abs(stemp[System.Array.index(((m - 1) | 0), stemp)]));
                            scale = Math.max(scale, Math.abs(stemp[System.Array.index(((m - 2) | 0), stemp)]));
                            scale = Math.max(scale, Math.abs(e[System.Array.index(((m - 2) | 0), e)]));
                            scale = Math.max(scale, Math.abs(stemp[System.Array.index(l, stemp)]));
                            scale = Math.max(scale, Math.abs(e[System.Array.index(l, e)]));
                            var sm = stemp[System.Array.index(((m - 1) | 0), stemp)] / scale;
                            var smm1 = stemp[System.Array.index(((m - 2) | 0), stemp)] / scale;
                            var emm1 = e[System.Array.index(((m - 2) | 0), e)] / scale;
                            var sl = stemp[System.Array.index(l, stemp)] / scale;
                            var el = e[System.Array.index(l, e)] / scale;
                            var b = (((smm1 + sm) * (smm1 - sm)) + (emm1 * emm1)) / 2.0;
                            var c = (sm * emm1) * (sm * emm1);
                            var shift = 0.0;
                            if (b !== 0.0 || c !== 0.0) {
                                shift = Math.sqrt((b * b) + c);
                                if (b < 0.0) {
                                    shift = -shift;
                                }

                                shift = c / (b + shift);
                            }
                            f.v = ((sl + sm) * (sl - sm)) + shift;
                            var g = { v : sl * el };
                            for (k = l; k < ((m - 1) | 0); k = (k + 1) | 0) {
                                MathNetNumerics.ManagedLinearAlgebraProvider.Drotg(f, g, cs, sn);
                                if (k !== l) {
                                    e[System.Array.index(((k - 1) | 0), e)] = f.v;
                                }

                                f.v = (cs.v * stemp[System.Array.index(k, stemp)]) + (sn.v * e[System.Array.index(k, e)]);
                                e[System.Array.index(k, e)] = (cs.v * e[System.Array.index(k, e)]) - (sn.v * stemp[System.Array.index(k, stemp)]);
                                g.v = sn.v * stemp[System.Array.index(((k + 1) | 0), stemp)];
                                stemp[System.Array.index(((k + 1) | 0), stemp)] = cs.v * stemp[System.Array.index(((k + 1) | 0), stemp)];
                                if (computeVectors) {
                                    for (i = 0; i < columnsA; i = (i + 1) | 0) {
                                        var z2 = (cs.v * v[System.Array.index((((Bridge.Int.mul(k, columnsA)) + i) | 0), v)]) + (sn.v * v[System.Array.index((((Bridge.Int.mul((((k + 1) | 0)), columnsA)) + i) | 0), v)]);
                                        v[System.Array.index((((Bridge.Int.mul((((k + 1) | 0)), columnsA)) + i) | 0), v)] = (cs.v * v[System.Array.index((((Bridge.Int.mul((((k + 1) | 0)), columnsA)) + i) | 0), v)]) - (sn.v * v[System.Array.index((((Bridge.Int.mul(k, columnsA)) + i) | 0), v)]);
                                        v[System.Array.index((((Bridge.Int.mul(k, columnsA)) + i) | 0), v)] = z2;
                                    }
                                }

                                MathNetNumerics.ManagedLinearAlgebraProvider.Drotg(f, g, cs, sn);
                                stemp[System.Array.index(k, stemp)] = f.v;
                                f.v = (cs.v * e[System.Array.index(k, e)]) + (sn.v * stemp[System.Array.index(((k + 1) | 0), stemp)]);
                                stemp[System.Array.index(((k + 1) | 0), stemp)] = -(sn.v * e[System.Array.index(k, e)]) + (cs.v * stemp[System.Array.index(((k + 1) | 0), stemp)]);
                                g.v = sn.v * e[System.Array.index(((k + 1) | 0), e)];
                                e[System.Array.index(((k + 1) | 0), e)] = cs.v * e[System.Array.index(((k + 1) | 0), e)];
                                if (computeVectors && k < rowsA) {
                                    for (i = 0; i < rowsA; i = (i + 1) | 0) {
                                        var z3 = (cs.v * u[System.Array.index((((Bridge.Int.mul(k, rowsA)) + i) | 0), u)]) + (sn.v * u[System.Array.index((((Bridge.Int.mul((((k + 1) | 0)), rowsA)) + i) | 0), u)]);
                                        u[System.Array.index((((Bridge.Int.mul((((k + 1) | 0)), rowsA)) + i) | 0), u)] = (cs.v * u[System.Array.index((((Bridge.Int.mul((((k + 1) | 0)), rowsA)) + i) | 0), u)]) - (sn.v * u[System.Array.index((((Bridge.Int.mul(k, rowsA)) + i) | 0), u)]);
                                        u[System.Array.index((((Bridge.Int.mul(k, rowsA)) + i) | 0), u)] = z3;
                                    }
                                }
                            }
                            e[System.Array.index(((m - 2) | 0), e)] = f.v;
                            iter = (iter + 1) | 0;
                            break;
                        case 4: 
                            if (stemp[System.Array.index(l, stemp)] < 0.0) {
                                stemp[System.Array.index(l, stemp)] = -stemp[System.Array.index(l, stemp)];
                                if (computeVectors) {
                                    for (i = 0; i < columnsA; i = (i + 1) | 0) {
                                        v[System.Array.index((((Bridge.Int.mul(l, columnsA)) + i) | 0), v)] = v[System.Array.index((((Bridge.Int.mul(l, columnsA)) + i) | 0), v)] * -1.0;
                                    }
                                }
                            }
                            while (l !== ((mn - 1) | 0)) {
                                if (stemp[System.Array.index(l, stemp)] >= stemp[System.Array.index(((l + 1) | 0), stemp)]) {
                                    break;
                                }

                                t = stemp[System.Array.index(l, stemp)];
                                stemp[System.Array.index(l, stemp)] = stemp[System.Array.index(((l + 1) | 0), stemp)];
                                stemp[System.Array.index(((l + 1) | 0), stemp)] = t;
                                if (computeVectors && l < columnsA) {
                                    for (i = 0; i < columnsA; i = (i + 1) | 0) {
                                        var z4 = v[System.Array.index((((Bridge.Int.mul(l, columnsA)) + i) | 0), v)];
                                        v[System.Array.index((((Bridge.Int.mul(l, columnsA)) + i) | 0), v)] = v[System.Array.index((((Bridge.Int.mul((((l + 1) | 0)), columnsA)) + i) | 0), v)];
                                        v[System.Array.index((((Bridge.Int.mul((((l + 1) | 0)), columnsA)) + i) | 0), v)] = z4;
                                    }
                                }

                                if (computeVectors && l < rowsA) {
                                    for (i = 0; i < rowsA; i = (i + 1) | 0) {
                                        var z5 = u[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i) | 0), u)];
                                        u[System.Array.index((((Bridge.Int.mul(l, rowsA)) + i) | 0), u)] = u[System.Array.index((((Bridge.Int.mul((((l + 1) | 0)), rowsA)) + i) | 0), u)];
                                        u[System.Array.index((((Bridge.Int.mul((((l + 1) | 0)), rowsA)) + i) | 0), u)] = z5;
                                    }
                                }

                                l = (l + 1) | 0;
                            }
                            iter = 0;
                            m = (m - 1) | 0;
                            break;
                    }
                }

                if (computeVectors) {
                    for (i = 0; i < columnsA; i = (i + 1) | 0) {
                        for (j = 0; j < columnsA; j = (j + 1) | 0) {
                            vt[System.Array.index((((Bridge.Int.mul(j, columnsA)) + i) | 0), vt)] = v[System.Array.index((((Bridge.Int.mul(i, columnsA)) + j) | 0), v)];
                        }
                    }
                }


                System.Array.copy(stemp, 0, s, 0, Math.min(rowsA, columnsA));
            },
            AlmostEquals: function (val1, val2) {
                if (Math.abs(val1 - val2) < (Math.pow(10, -8))) {
                    return true;
                }
                return false;
            }
        }
    });

    Bridge.define("mathnetnumericsbridge.Complex", {
        inherits: function () { return [System.IEquatable$1(mathnetnumericsbridge.Complex),System.IFormattable]; },
        $kind: "struct",
        statics: {
            fields: {
                InverseOfLog10: 0,
                Zero: null,
                One: null,
                ImaginaryOne: null,
                NaN: null,
                Infinity: null,
                s_sqrtRescaleThreshold: 0,
                s_asinOverflowThreshold: 0,
                s_log2: 0
            },
            ctors: {
                init: function () {
                    this.Zero = new mathnetnumericsbridge.Complex();
                    this.One = new mathnetnumericsbridge.Complex();
                    this.ImaginaryOne = new mathnetnumericsbridge.Complex();
                    this.NaN = new mathnetnumericsbridge.Complex();
                    this.Infinity = new mathnetnumericsbridge.Complex();
                    this.InverseOfLog10 = 0.43429448190325;
                    this.Zero = new mathnetnumericsbridge.Complex.$ctor1(0.0, 0.0);
                    this.One = new mathnetnumericsbridge.Complex.$ctor1(1.0, 0.0);
                    this.ImaginaryOne = new mathnetnumericsbridge.Complex.$ctor1(0.0, 1.0);
                    this.NaN = new mathnetnumericsbridge.Complex.$ctor1(Number.NaN, Number.NaN);
                    this.Infinity = new mathnetnumericsbridge.Complex.$ctor1(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
                    this.s_sqrtRescaleThreshold = System.Double.max / (Math.sqrt(2.0) + 1.0);
                    this.s_asinOverflowThreshold = Math.sqrt(System.Double.max) / 2.0;
                    this.s_log2 = Bridge.Math.log(2.0);
                }
            },
            methods: {
                FromPolarCoordinates: function (magnitude, phase) {
                    return new mathnetnumericsbridge.Complex.$ctor1(magnitude * Math.cos(phase), magnitude * Math.sin(phase));
                },
                Negate: function (value) {
                    return mathnetnumericsbridge.Complex.op_UnaryNegation(value.$clone());
                },
                Add: function (left, right) {
                    return mathnetnumericsbridge.Complex.op_Addition(left.$clone(), right.$clone());
                },
                Add$1: function (left, right) {
                    return mathnetnumericsbridge.Complex.op_Addition$1(left.$clone(), right);
                },
                Add$2: function (left, right) {
                    return mathnetnumericsbridge.Complex.op_Addition$2(left, right.$clone());
                },
                Subtract: function (left, right) {
                    return mathnetnumericsbridge.Complex.op_Subtraction(left.$clone(), right.$clone());
                },
                Subtract$1: function (left, right) {
                    return mathnetnumericsbridge.Complex.op_Subtraction$1(left.$clone(), right);
                },
                Subtract$2: function (left, right) {
                    return mathnetnumericsbridge.Complex.op_Subtraction$2(left, right.$clone());
                },
                Multiply: function (left, right) {
                    return mathnetnumericsbridge.Complex.op_Multiply(left.$clone(), right.$clone());
                },
                Multiply$1: function (left, right) {
                    return mathnetnumericsbridge.Complex.op_Multiply$1(left.$clone(), right);
                },
                Multiply$2: function (left, right) {
                    return mathnetnumericsbridge.Complex.op_Multiply$2(left, right.$clone());
                },
                Divide: function (dividend, divisor) {
                    return mathnetnumericsbridge.Complex.op_Division(dividend.$clone(), divisor.$clone());
                },
                Divide$1: function (dividend, divisor) {
                    return mathnetnumericsbridge.Complex.op_Division$1(dividend.$clone(), divisor);
                },
                Divide$2: function (dividend, divisor) {
                    return mathnetnumericsbridge.Complex.op_Division$2(dividend, divisor.$clone());
                },
                Abs: function (value) {
                    return mathnetnumericsbridge.Complex.Hypot(value.m_real, value.m_imaginary);
                },
                Hypot: function (a, b) {

                    a = Math.abs(a);
                    b = Math.abs(b);

                    var small, large;
                    if (a < b) {
                        small = a;
                        large = b;
                    } else {
                        small = b;
                        large = a;
                    }

                    if (small === 0.0) {
                        return (large);
                    } else if ((large === Number.POSITIVE_INFINITY) && !isNaN(small)) {
                        return (Number.POSITIVE_INFINITY);
                    } else {
                        var ratio = small / large;
                        return (large * Math.sqrt(1.0 + ratio * ratio));
                    }

                },
                Log1P: function (x) {



                    var xp1 = 1.0 + x;
                    if (xp1 === 1.0) {
                        return x;
                    } else if (x < 0.75) {
                        return x * Bridge.Math.log(xp1) / (xp1 - 1.0);
                    } else {
                        return Bridge.Math.log(xp1);
                    }

                },
                Conjugate: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(value.m_real, -value.m_imaginary);
                },
                Reciprocal: function (value) {
                    if (value.m_real === 0 && value.m_imaginary === 0) {
                        return mathnetnumericsbridge.Complex.Zero.$clone();
                    }
                    return mathnetnumericsbridge.Complex.op_Division(mathnetnumericsbridge.Complex.One.$clone(), value.$clone());
                },
                Sin: function (value) {
                    var p = Math.exp(value.m_imaginary);
                    var q = 1.0 / p;
                    var sinh = (p - q) * 0.5;
                    var cosh = (p + q) * 0.5;
                    return new mathnetnumericsbridge.Complex.$ctor1(Math.sin(value.m_real) * cosh, Math.cos(value.m_real) * sinh);
                },
                Sinh: function (value) {
                    var sin = mathnetnumericsbridge.Complex.Sin(new mathnetnumericsbridge.Complex.$ctor1(-value.m_imaginary, value.m_real));
                    return new mathnetnumericsbridge.Complex.$ctor1(sin.m_imaginary, -sin.m_real);
                },
                Asin: function (value) {
                    var b = { }, bPrime = { }, v = { };
                    mathnetnumericsbridge.Complex.Asin_Internal(Math.abs(value.Real), Math.abs(value.Imaginary), b, bPrime, v);

                    var u;
                    if (bPrime.v < 0.0) {
                        u = Math.asin(b.v);
                    } else {
                        u = Math.atan(bPrime.v);
                    }

                    if (value.Real < 0.0) {
                        u = -u;
                    }
                    if (value.Imaginary < 0.0) {
                        v.v = -v.v;
                    }

                    return new mathnetnumericsbridge.Complex.$ctor1(u, v.v);
                },
                Cos: function (value) {
                    var p = Math.exp(value.m_imaginary);
                    var q = 1.0 / p;
                    var sinh = (p - q) * 0.5;
                    var cosh = (p + q) * 0.5;
                    return new mathnetnumericsbridge.Complex.$ctor1(Math.cos(value.m_real) * cosh, -Math.sin(value.m_real) * sinh);
                },
                Cosh: function (value) {
                    return mathnetnumericsbridge.Complex.Cos(new mathnetnumericsbridge.Complex.$ctor1(-value.m_imaginary, value.m_real));
                },
                Acos: function (value) {
                    var b = { }, bPrime = { }, v = { };
                    mathnetnumericsbridge.Complex.Asin_Internal(Math.abs(value.Real), Math.abs(value.Imaginary), b, bPrime, v);

                    var u;
                    if (bPrime.v < 0.0) {
                        u = Math.acos(b.v);
                    } else {
                        u = Math.atan(1.0 / bPrime.v);
                    }

                    if (value.Real < 0.0) {
                        u = Math.PI - u;
                    }
                    if (value.Imaginary > 0.0) {
                        v.v = -v.v;
                    }

                    return new mathnetnumericsbridge.Complex.$ctor1(u, v.v);
                },
                Tan: function (value) {


                    var x2 = 2.0 * value.m_real;
                    var y2 = 2.0 * value.m_imaginary;
                    var p = Math.exp(y2);
                    var q = 1.0 / p;
                    var cosh = (p + q) * 0.5;
                    if (Math.abs(value.m_imaginary) <= 4.0) {
                        var sinh = (p - q) * 0.5;
                        var D = Math.cos(x2) + cosh;
                        return new mathnetnumericsbridge.Complex.$ctor1(Math.sin(x2) / D, sinh / D);
                    } else {
                        var D1 = 1.0 + Math.cos(x2) / cosh;
                        return new mathnetnumericsbridge.Complex.$ctor1(Math.sin(x2) / cosh / D1, Bridge.Math.tanh(y2) / D1);
                    }
                },
                Tanh: function (value) {
                    var tan = mathnetnumericsbridge.Complex.Tan(new mathnetnumericsbridge.Complex.$ctor1(-value.m_imaginary, value.m_real));
                    return new mathnetnumericsbridge.Complex.$ctor1(tan.m_imaginary, -tan.m_real);
                },
                Atan: function (value) {
                    var two = new mathnetnumericsbridge.Complex.$ctor1(2.0, 0.0);
                    return mathnetnumericsbridge.Complex.op_Multiply((mathnetnumericsbridge.Complex.op_Division(mathnetnumericsbridge.Complex.ImaginaryOne.$clone(), two.$clone())), (mathnetnumericsbridge.Complex.op_Subtraction(mathnetnumericsbridge.Complex.Log(mathnetnumericsbridge.Complex.op_Subtraction(mathnetnumericsbridge.Complex.One.$clone(), mathnetnumericsbridge.Complex.op_Multiply(mathnetnumericsbridge.Complex.ImaginaryOne.$clone(), value.$clone()))), mathnetnumericsbridge.Complex.Log(mathnetnumericsbridge.Complex.op_Addition(mathnetnumericsbridge.Complex.One.$clone(), mathnetnumericsbridge.Complex.op_Multiply(mathnetnumericsbridge.Complex.ImaginaryOne.$clone(), value.$clone()))))));
                },
                Asin_Internal: function (x, y, b, bPrime, v) {








                    if ((x > mathnetnumericsbridge.Complex.s_asinOverflowThreshold) || (y > mathnetnumericsbridge.Complex.s_asinOverflowThreshold)) {
                        b.v = -1.0;
                        bPrime.v = x / y;

                        var small, big;
                        if (x < y) {
                            small = x;
                            big = y;
                        } else {
                            small = y;
                            big = x;
                        }
                        var ratio = small / big;
                        v.v = mathnetnumericsbridge.Complex.s_log2 + Bridge.Math.log(big) + 0.5 * mathnetnumericsbridge.Complex.Log1P(ratio * ratio);
                    } else {
                        var r = mathnetnumericsbridge.Complex.Hypot((x + 1.0), y);
                        var s = mathnetnumericsbridge.Complex.Hypot((x - 1.0), y);

                        var a = (r + s) * 0.5;
                        b.v = x / a;

                        if (b.v > 0.75) {
                            if (x <= 1.0) {
                                var amx = (y * y / (r + (x + 1.0)) + (s + (1.0 - x))) * 0.5;
                                bPrime.v = x / Math.sqrt((a + x) * amx);
                            } else {
                                var t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (x - 1.0))) * 0.5;
                                bPrime.v = x / y / Math.sqrt((a + x) * t);
                            }
                        } else {
                            bPrime.v = -1.0;
                        }

                        if (a < 1.5) {
                            if (x < 1.0) {
                                var t1 = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (1.0 - x))) * 0.5;
                                var am1 = y * y * t1;
                                v.v = mathnetnumericsbridge.Complex.Log1P(am1 + y * Math.sqrt(t1 * (a + 1.0)));
                            } else {
                                var am11 = (y * y / (r + (x + 1.0)) + (s + (x - 1.0))) * 0.5;
                                v.v = mathnetnumericsbridge.Complex.Log1P(am11 + Math.sqrt(am11 * (a + 1.0)));
                            }
                        } else {
                            v.v = Bridge.Math.log(a + Math.sqrt((a - 1.0) * (a + 1.0)));
                        }
                    }
                },
                IsFinite: function (value) {
                    return isFinite(value.m_real) && isFinite(value.m_imaginary);
                },
                IsInfinity: function (value) {
                    return (Math.abs(value.m_real) === Number.POSITIVE_INFINITY) || (Math.abs(value.m_imaginary) === Number.POSITIVE_INFINITY);
                },
                IsNaN: function (value) {
                    return !mathnetnumericsbridge.Complex.IsInfinity(value.$clone()) && !mathnetnumericsbridge.Complex.IsFinite(value.$clone());
                },
                Log: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(Bridge.Math.log(mathnetnumericsbridge.Complex.Abs(value.$clone())), Math.atan2(value.m_imaginary, value.m_real));
                },
                Log$1: function (value, baseValue) {
                    return mathnetnumericsbridge.Complex.op_Division(mathnetnumericsbridge.Complex.Log(value.$clone()), mathnetnumericsbridge.Complex.Log(mathnetnumericsbridge.Complex.op_Implicit$1(baseValue)));
                },
                Log10: function (value) {
                    var tempLog = mathnetnumericsbridge.Complex.Log(value.$clone());
                    return mathnetnumericsbridge.Complex.Scale(tempLog.$clone(), mathnetnumericsbridge.Complex.InverseOfLog10);
                },
                Exp: function (value) {
                    var expReal = Math.exp(value.m_real);
                    var cosImaginary = expReal * Math.cos(value.m_imaginary);
                    var sinImaginary = expReal * Math.sin(value.m_imaginary);
                    return new mathnetnumericsbridge.Complex.$ctor1(cosImaginary, sinImaginary);
                },
                Sqrt: function (value) {

                    if (value.m_imaginary === 0.0) {
                        if (value.m_real < 0.0) {
                            return new mathnetnumericsbridge.Complex.$ctor1(0.0, Math.sqrt(-value.m_real));
                        } else {
                            return new mathnetnumericsbridge.Complex.$ctor1(Math.sqrt(value.m_real), 0.0);
                        }
                    } else {





                        var rescale = false;
                        if ((Math.abs(value.m_real) >= mathnetnumericsbridge.Complex.s_sqrtRescaleThreshold) || (Math.abs(value.m_imaginary) >= mathnetnumericsbridge.Complex.s_sqrtRescaleThreshold)) {
                            if ((Math.abs(value.m_imaginary) === Number.POSITIVE_INFINITY) && !isNaN(value.m_real)) {
                                return (new mathnetnumericsbridge.Complex.$ctor1(Number.POSITIVE_INFINITY, value.m_imaginary));
                            } else {
                                value.m_real *= 0.25;
                                value.m_imaginary *= 0.25;
                                rescale = true;
                            }
                        }

                        var x, y;
                        if (value.m_real >= 0.0) {
                            x = Math.sqrt((mathnetnumericsbridge.Complex.Hypot(value.m_real, value.m_imaginary) + value.m_real) * 0.5);
                            y = value.m_imaginary / (2.0 * x);
                        } else {
                            y = Math.sqrt((mathnetnumericsbridge.Complex.Hypot(value.m_real, value.m_imaginary) - value.m_real) * 0.5);
                            if (value.m_imaginary < 0.0) {
                                y = -y;
                            }
                            x = value.m_imaginary / (2.0 * y);
                        }

                        if (rescale) {
                            x *= 2.0;
                            y *= 2.0;
                        }

                        return new mathnetnumericsbridge.Complex.$ctor1(x, y);

                    }

                },
                Pow: function (value, power) {
                    if (mathnetnumericsbridge.Complex.op_Equality(power.$clone(), mathnetnumericsbridge.Complex.Zero.$clone())) {
                        return mathnetnumericsbridge.Complex.One.$clone();
                    }

                    if (mathnetnumericsbridge.Complex.op_Equality(value.$clone(), mathnetnumericsbridge.Complex.Zero.$clone())) {
                        return mathnetnumericsbridge.Complex.Zero.$clone();
                    }

                    var valueReal = value.m_real;
                    var valueImaginary = value.m_imaginary;
                    var powerReal = power.m_real;
                    var powerImaginary = power.m_imaginary;

                    var rho = mathnetnumericsbridge.Complex.Abs(value.$clone());
                    var theta = Math.atan2(valueImaginary, valueReal);
                    var newRho = powerReal * theta + powerImaginary * Bridge.Math.log(rho);

                    var t = Math.pow(rho, powerReal) * Math.pow(Math.E, -powerImaginary * theta);

                    return new mathnetnumericsbridge.Complex.$ctor1(t * Math.cos(newRho), t * Math.sin(newRho));
                },
                Pow$1: function (value, power) {
                    return mathnetnumericsbridge.Complex.Pow(value.$clone(), new mathnetnumericsbridge.Complex.$ctor1(power, 0));
                },
                Scale: function (value, factor) {
                    var realResult = factor * value.m_real;
                    var imaginaryResuilt = factor * value.m_imaginary;
                    return new mathnetnumericsbridge.Complex.$ctor1(realResult, imaginaryResuilt);
                },
                op_UnaryNegation: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(-value.m_real, -value.m_imaginary);
                },
                op_Addition: function (left, right) {
                    return new mathnetnumericsbridge.Complex.$ctor1(left.m_real + right.m_real, left.m_imaginary + right.m_imaginary);
                },
                op_Addition$1: function (left, right) {
                    return new mathnetnumericsbridge.Complex.$ctor1(left.m_real + right, left.m_imaginary);
                },
                op_Addition$2: function (left, right) {
                    return new mathnetnumericsbridge.Complex.$ctor1(left + right.m_real, right.m_imaginary);
                },
                op_Subtraction: function (left, right) {
                    return new mathnetnumericsbridge.Complex.$ctor1(left.m_real - right.m_real, left.m_imaginary - right.m_imaginary);
                },
                op_Subtraction$1: function (left, right) {
                    return new mathnetnumericsbridge.Complex.$ctor1(left.m_real - right, left.m_imaginary);
                },
                op_Subtraction$2: function (left, right) {
                    return new mathnetnumericsbridge.Complex.$ctor1(left - right.m_real, -right.m_imaginary);
                },
                op_Multiply: function (left, right) {
                    var result_realpart = (left.m_real * right.m_real) - (left.m_imaginary * right.m_imaginary);
                    var result_imaginarypart = (left.m_imaginary * right.m_real) + (left.m_real * right.m_imaginary);
                    return new mathnetnumericsbridge.Complex.$ctor1(result_realpart, result_imaginarypart);
                },
                op_Multiply$1: function (left, right) {
                    if (!isFinite(left.m_real)) {
                        if (!isFinite(left.m_imaginary)) {
                            return new mathnetnumericsbridge.Complex.$ctor1(Number.NaN, Number.NaN);
                        }

                        return new mathnetnumericsbridge.Complex.$ctor1(left.m_real * right, Number.NaN);
                    }

                    if (!isFinite(left.m_imaginary)) {
                        return new mathnetnumericsbridge.Complex.$ctor1(Number.NaN, left.m_imaginary * right);
                    }

                    return new mathnetnumericsbridge.Complex.$ctor1(left.m_real * right, left.m_imaginary * right);
                },
                op_Multiply$2: function (left, right) {
                    if (!isFinite(right.m_real)) {
                        if (!isFinite(right.m_imaginary)) {
                            return new mathnetnumericsbridge.Complex.$ctor1(Number.NaN, Number.NaN);
                        }

                        return new mathnetnumericsbridge.Complex.$ctor1(left * right.m_real, Number.NaN);
                    }

                    if (!isFinite(right.m_imaginary)) {
                        return new mathnetnumericsbridge.Complex.$ctor1(Number.NaN, left * right.m_imaginary);
                    }

                    return new mathnetnumericsbridge.Complex.$ctor1(left * right.m_real, left * right.m_imaginary);
                },
                op_Division: function (left, right) {
                    var a = left.m_real;
                    var b = left.m_imaginary;
                    var c = right.m_real;
                    var d = right.m_imaginary;

                    if (Math.abs(d) < Math.abs(c)) {
                        var doc = d / c;
                        return new mathnetnumericsbridge.Complex.$ctor1((a + b * doc) / (c + d * doc), (b - a * doc) / (c + d * doc));
                    } else {
                        var cod = c / d;
                        return new mathnetnumericsbridge.Complex.$ctor1((b + a * cod) / (d + c * cod), (-a + b * cod) / (d + c * cod));
                    }
                },
                op_Division$1: function (left, right) {
                    if (right === 0) {
                        return new mathnetnumericsbridge.Complex.$ctor1(Number.NaN, Number.NaN);
                    }

                    if (!isFinite(left.m_real)) {
                        if (!isFinite(left.m_imaginary)) {
                            return new mathnetnumericsbridge.Complex.$ctor1(Number.NaN, Number.NaN);
                        }

                        return new mathnetnumericsbridge.Complex.$ctor1(left.m_real / right, Number.NaN);
                    }

                    if (!isFinite(left.m_imaginary)) {
                        return new mathnetnumericsbridge.Complex.$ctor1(Number.NaN, left.m_imaginary / right);
                    }

                    return new mathnetnumericsbridge.Complex.$ctor1(left.m_real / right, left.m_imaginary / right);
                },
                op_Division$2: function (left, right) {
                    var a = left;
                    var c = right.m_real;
                    var d = right.m_imaginary;

                    if (Math.abs(d) < Math.abs(c)) {
                        var doc = d / c;
                        return new mathnetnumericsbridge.Complex.$ctor1(a / (c + d * doc), (-a * doc) / (c + d * doc));
                    } else {
                        var cod = c / d;
                        return new mathnetnumericsbridge.Complex.$ctor1(a * cod / (d + c * cod), -a / (d + c * cod));
                    }
                },
                op_Equality: function (left, right) {
                    return left.m_real === right.m_real && left.m_imaginary === right.m_imaginary;
                },
                op_Inequality: function (left, right) {
                    return left.m_real !== right.m_real || left.m_imaginary !== right.m_imaginary;
                },
                op_Implicit$2: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(value, 0.0);
                },
                op_Implicit$3: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(value, 0.0);
                },
                op_Implicit$4: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(System.Int64.toNumber(value), 0.0);
                },
                op_Implicit$7: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(value, 0.0);
                },
                op_Implicit$8: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(value, 0.0);
                },
                op_Implicit$9: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(System.Int64.toNumber(value), 0.0);
                },
                op_Implicit$5: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(value, 0.0);
                },
                op_Implicit: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(value, 0.0);
                },
                op_Implicit$6: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(value, 0.0);
                },
                op_Implicit$1: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(value, 0.0);
                },
                op_Explicit: function (value) {
                    return new mathnetnumericsbridge.Complex.$ctor1(System.Decimal.toFloat(value), 0.0);
                },
                getDefaultValue: function () { return new mathnetnumericsbridge.Complex(); }
            }
        },
        fields: {
            m_real: 0,
            m_imaginary: 0
        },
        props: {
            Real: {
                get: function () {
                    return this.m_real;
                }
            },
            Imaginary: {
                get: function () {
                    return this.m_imaginary;
                }
            },
            Magnitude: {
                get: function () {
                    return mathnetnumericsbridge.Complex.Abs(this);
                }
            },
            Phase: {
                get: function () {
                    return Math.atan2(this.m_imaginary, this.m_real);
                }
            }
        },
        alias: [
            "equalsT", "System$IEquatable$1$mathnetnumericsbridge$Complex$equalsT",
            "format", "System$IFormattable$format"
        ],
        ctors: {
            $ctor1: function (real, imaginary) {
                this.$initialize();
                this.m_real = real;
                this.m_imaginary = imaginary;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            equalsT: function (value) {
                return this.m_real === value.m_real && this.m_imaginary === value.m_imaginary;
            },
            getHashCode: function () {
                var n1 = 99999997;
                var realHash = System.Double.getHashCode(this.m_real) % n1;
                var imaginaryHash = System.Double.getHashCode(this.m_imaginary);
                var finalHash = Bridge.Int.clip32(Math.pow(realHash, imaginaryHash));
                return finalHash;
            },
            toString: function () {
                return System.String.format("({0}, {1})", Bridge.box(this.m_real, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.m_imaginary, System.Double, System.Double.format, System.Double.getHashCode));
            },
            format: function (stringin, provider) {
                return System.String.formatProvider(provider, "({0}, {1})", Bridge.box(this.m_real, System.Double, System.Double.format, System.Double.getHashCode), Bridge.box(this.m_imaginary, System.Double, System.Double.format, System.Double.getHashCode));
            },
            $clone: function (to) {
                var s = to || new mathnetnumericsbridge.Complex();
                s.m_real = this.m_real;
                s.m_imaginary = this.m_imaginary;
                return s;
            }
        }
    });

    Bridge.define("mathnetnumericsbridge.Complex32", {
        inherits: function () { return [System.IEquatable$1(mathnetnumericsbridge.Complex32),System.IFormattable]; },
        $kind: "struct",
        statics: {
            fields: {
                InverseOfLog10: 0,
                Zero: null,
                One: null,
                ImaginaryOne: null,
                NaN: null,
                Infinity: null,
                s_sqrtRescaleThreshold: 0,
                s_asinOverflowThreshold: 0,
                s_log2: 0
            },
            ctors: {
                init: function () {
                    this.Zero = new mathnetnumericsbridge.Complex32();
                    this.One = new mathnetnumericsbridge.Complex32();
                    this.ImaginaryOne = new mathnetnumericsbridge.Complex32();
                    this.NaN = new mathnetnumericsbridge.Complex32();
                    this.Infinity = new mathnetnumericsbridge.Complex32();
                    this.InverseOfLog10 = 0.4342945;
                    this.Zero = new mathnetnumericsbridge.Complex32.$ctor1(0.0, 0.0);
                    this.One = new mathnetnumericsbridge.Complex32.$ctor1(1.0, 0.0);
                    this.ImaginaryOne = new mathnetnumericsbridge.Complex32.$ctor1(0.0, 1.0);
                    this.NaN = new mathnetnumericsbridge.Complex32.$ctor1(Number.NaN, Number.NaN);
                    this.Infinity = new mathnetnumericsbridge.Complex32.$ctor1(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
                    this.s_sqrtRescaleThreshold = 3.40282347E+38 / (Math.sqrt(2.0) + 1.0);
                    this.s_asinOverflowThreshold = Math.sqrt(3.40282347E+38) / 2.0;
                    this.s_log2 = Bridge.Math.log(2.0);
                }
            },
            methods: {
                FromPolarCoordinates: function (magnitude, phase) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(magnitude * Math.cos(phase), magnitude * Math.sin(phase));
                },
                Negate: function (value) {
                    return mathnetnumericsbridge.Complex32.op_UnaryNegation(value.$clone());
                },
                Add: function (left, right) {
                    return mathnetnumericsbridge.Complex32.op_Addition(left.$clone(), right.$clone());
                },
                Add$1: function (left, right) {
                    return mathnetnumericsbridge.Complex32.op_Addition$1(left.$clone(), right);
                },
                Add$2: function (left, right) {
                    return mathnetnumericsbridge.Complex32.op_Addition$2(left, right.$clone());
                },
                Subtract: function (left, right) {
                    return mathnetnumericsbridge.Complex32.op_Subtraction(left.$clone(), right.$clone());
                },
                Subtract$1: function (left, right) {
                    return mathnetnumericsbridge.Complex32.op_Subtraction$1(left.$clone(), right);
                },
                Subtract$2: function (left, right) {
                    return mathnetnumericsbridge.Complex32.op_Subtraction$2(left, right.$clone());
                },
                Multiply: function (left, right) {
                    return mathnetnumericsbridge.Complex32.op_Multiply(left.$clone(), right.$clone());
                },
                Multiply$1: function (left, right) {
                    return mathnetnumericsbridge.Complex32.op_Multiply$1(left.$clone(), right);
                },
                Multiply$2: function (left, right) {
                    return mathnetnumericsbridge.Complex32.op_Multiply$2(left, right.$clone());
                },
                Divide: function (dividend, divisor) {
                    return mathnetnumericsbridge.Complex32.op_Division(dividend.$clone(), divisor.$clone());
                },
                Divide$1: function (dividend, divisor) {
                    return mathnetnumericsbridge.Complex32.op_Division$1(dividend.$clone(), divisor);
                },
                Divide$2: function (dividend, divisor) {
                    return mathnetnumericsbridge.Complex32.op_Division$2(dividend, divisor.$clone());
                },
                Abs: function (value) {
                    return mathnetnumericsbridge.Complex32.Hypot(value.m_real, value.m_imaginary);
                },
                Hypot: function (a, b) {

                    a = Math.abs(a);
                    b = Math.abs(b);

                    var small, large;
                    if (a < b) {
                        small = a;
                        large = b;
                    } else {
                        small = b;
                        large = a;
                    }

                    if (small === 0.0) {
                        return (large);
                    } else if ((large === Number.POSITIVE_INFINITY) && !isNaN(small)) {
                        return (Number.POSITIVE_INFINITY);
                    } else {
                        var ratio = small / large;
                        return large * Math.sqrt(1.0 + ratio * ratio);
                    }

                },
                Log1P: function (x) {



                    var xp1 = 1.0 + x;
                    if (xp1 === 1.0) {
                        return x;
                    } else if (x < 0.75) {
                        return x * Bridge.Math.log(xp1) / (xp1 - 1.0);
                    } else {
                        return Bridge.Math.log(xp1);
                    }

                },
                Conjugate: function (value) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(value.m_real, -value.m_imaginary);
                },
                Reciprocal: function (value) {
                    if (value.m_real === 0 && value.m_imaginary === 0) {
                        return mathnetnumericsbridge.Complex32.Zero.$clone();
                    }
                    return mathnetnumericsbridge.Complex32.op_Division(mathnetnumericsbridge.Complex32.One.$clone(), value.$clone());
                },
                Sin: function (value) {
                    var p = Math.exp(value.m_imaginary);
                    var q = 1.0 / p;
                    var sinh = (p - q) * 0.5;
                    var cosh = (p + q) * 0.5;
                    return new mathnetnumericsbridge.Complex32.$ctor1(Math.sin(value.m_real) * cosh, Math.cos(value.m_real) * sinh);
                },
                Sinh: function (value) {
                    var sin = mathnetnumericsbridge.Complex32.Sin(new mathnetnumericsbridge.Complex32.$ctor1(-value.m_imaginary, value.m_real));
                    return new mathnetnumericsbridge.Complex32.$ctor1(sin.m_imaginary, -sin.m_real);
                },
                Asin: function (value) {
                    var b = { }, bPrime = { }, v = { };
                    mathnetnumericsbridge.Complex32.Asin_Internal(Math.abs(value.Real), Math.abs(value.Imaginary), b, bPrime, v);

                    var u;
                    if (bPrime.v < 0.0) {
                        u = Math.asin(b.v);
                    } else {
                        u = Math.atan(bPrime.v);
                    }

                    if (value.Real < 0.0) {
                        u = -u;
                    }
                    if (value.Imaginary < 0.0) {
                        v.v = -v.v;
                    }

                    return new mathnetnumericsbridge.Complex32.$ctor1(u, v.v);
                },
                Cos: function (value) {
                    var p = Math.exp(value.m_imaginary);
                    var q = 1.0 / p;
                    var sinh = (p - q) * 0.5;
                    var cosh = (p + q) * 0.5;
                    return new mathnetnumericsbridge.Complex32.$ctor1(Math.cos(value.m_real) * cosh, -Math.sin(value.m_real) * sinh);
                },
                Cosh: function (value) {
                    return mathnetnumericsbridge.Complex32.Cos(new mathnetnumericsbridge.Complex32.$ctor1(-value.m_imaginary, value.m_real));
                },
                Acos: function (value) {
                    var b = { }, bPrime = { }, v = { };
                    mathnetnumericsbridge.Complex32.Asin_Internal(Math.abs(value.Real), Math.abs(value.Imaginary), b, bPrime, v);

                    var u;
                    if (bPrime.v < 0.0) {
                        u = Math.acos(b.v);
                    } else {
                        u = Math.atan(1.0 / bPrime.v);
                    }

                    if (value.Real < 0.0) {
                        u = 3.14159274 - u;
                    }
                    if (value.Imaginary > 0.0) {
                        v.v = -v.v;
                    }

                    return new mathnetnumericsbridge.Complex32.$ctor1(u, v.v);
                },
                Tan: function (value) {


                    var x2 = 2.0 * value.m_real;
                    var y2 = 2.0 * value.m_imaginary;
                    var p = Math.exp(y2);
                    var q = 1.0 / p;
                    var cosh = (p + q) * 0.5;
                    if (Math.abs(value.m_imaginary) <= 4.0) {
                        var sinh = (p - q) * 0.5;
                        var D = Math.cos(x2) + cosh;
                        return new mathnetnumericsbridge.Complex32.$ctor1(Math.sin(x2) / D, sinh / D);
                    } else {
                        var D1 = 1.0 + Math.cos(x2) / cosh;
                        return new mathnetnumericsbridge.Complex32.$ctor1(Math.sin(x2) / cosh / D1, Bridge.Math.tanh(y2) / D1);
                    }
                },
                Tanh: function (value) {
                    var tan = mathnetnumericsbridge.Complex32.Tan(new mathnetnumericsbridge.Complex32.$ctor1(-value.m_imaginary, value.m_real));
                    return new mathnetnumericsbridge.Complex32.$ctor1(tan.m_imaginary, -tan.m_real);
                },
                Atan: function (value) {
                    var two = new mathnetnumericsbridge.Complex32.$ctor1(2.0, 0.0);
                    return mathnetnumericsbridge.Complex32.op_Multiply((mathnetnumericsbridge.Complex32.op_Division(mathnetnumericsbridge.Complex32.ImaginaryOne.$clone(), two.$clone())), (mathnetnumericsbridge.Complex32.op_Subtraction(mathnetnumericsbridge.Complex32.Log(mathnetnumericsbridge.Complex32.op_Subtraction(mathnetnumericsbridge.Complex32.One.$clone(), mathnetnumericsbridge.Complex32.op_Multiply(mathnetnumericsbridge.Complex32.ImaginaryOne.$clone(), value.$clone()))), mathnetnumericsbridge.Complex32.Log(mathnetnumericsbridge.Complex32.op_Addition(mathnetnumericsbridge.Complex32.One.$clone(), mathnetnumericsbridge.Complex32.op_Multiply(mathnetnumericsbridge.Complex32.ImaginaryOne.$clone(), value.$clone()))))));
                },
                Asin_Internal: function (x, y, b, bPrime, v) {








                    if ((x > mathnetnumericsbridge.Complex32.s_asinOverflowThreshold) || (y > mathnetnumericsbridge.Complex32.s_asinOverflowThreshold)) {
                        b.v = -1.0;
                        bPrime.v = x / y;

                        var small, big;
                        if (x < y) {
                            small = x;
                            big = y;
                        } else {
                            small = y;
                            big = x;
                        }
                        var ratio = small / big;
                        v.v = mathnetnumericsbridge.Complex32.s_log2 + Bridge.Math.log(big) + 0.5 * mathnetnumericsbridge.Complex32.Log1P(ratio * ratio);
                    } else {
                        var r = mathnetnumericsbridge.Complex32.Hypot((x + 1.0), y);
                        var s = mathnetnumericsbridge.Complex32.Hypot((x - 1.0), y);

                        var a = (r + s) * 0.5;
                        b.v = x / a;

                        if (b.v > 0.75) {
                            if (x <= 1.0) {
                                var amx = (y * y / (r + (x + 1.0)) + (s + (1.0 - x))) * 0.5;
                                bPrime.v = x / Math.sqrt((a + x) * amx);
                            } else {
                                var t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (x - 1.0))) * 0.5;
                                bPrime.v = x / y / Math.sqrt((a + x) * t);
                            }
                        } else {
                            bPrime.v = -1.0;
                        }

                        if (a < 1.5) {
                            if (x < 1.0) {
                                var t1 = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (1.0 - x))) * 0.5;
                                var am1 = y * y * t1;
                                v.v = mathnetnumericsbridge.Complex32.Log1P(am1 + y * Math.sqrt(t1 * (a + 1.0)));
                            } else {
                                var am11 = (y * y / (r + (x + 1.0)) + (s + (x - 1.0))) * 0.5;
                                v.v = mathnetnumericsbridge.Complex32.Log1P(am11 + Math.sqrt(am11 * (a + 1.0)));
                            }
                        } else {
                            v.v = Bridge.Math.log(a + Math.sqrt((a - 1.0) * (a + 1.0)));
                        }
                    }
                },
                IsFinite: function (value) {
                    return isFinite(value.m_real) && isFinite(value.m_imaginary);
                },
                IsInfinity: function (value) {
                    return (Math.abs(value.m_real) === Number.POSITIVE_INFINITY) || (Math.abs(value.m_imaginary) === Number.POSITIVE_INFINITY);
                },
                IsNaN: function (value) {
                    return !mathnetnumericsbridge.Complex32.IsInfinity(value.$clone()) && !mathnetnumericsbridge.Complex32.IsFinite(value.$clone());
                },
                Log: function (value) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(Bridge.Math.log(mathnetnumericsbridge.Complex32.Abs(value.$clone())), Math.atan2(value.m_imaginary, value.m_real));
                },
                Log$1: function (value, baseValue) {
                    return mathnetnumericsbridge.Complex32.op_Division(mathnetnumericsbridge.Complex32.Log(value.$clone()), mathnetnumericsbridge.Complex32.Log(mathnetnumericsbridge.Complex32.op_Implicit$5(baseValue)));
                },
                Log10: function (value) {
                    var tempLog = mathnetnumericsbridge.Complex32.Log(value.$clone());
                    return mathnetnumericsbridge.Complex32.Scale(tempLog.$clone(), mathnetnumericsbridge.Complex32.InverseOfLog10);
                },
                Exp: function (value) {
                    var expReal = Math.exp(value.m_real);
                    var cosImaginary = expReal * Math.cos(value.m_imaginary);
                    var sinImaginary = expReal * Math.sin(value.m_imaginary);
                    return new mathnetnumericsbridge.Complex32.$ctor1(cosImaginary, sinImaginary);
                },
                Sqrt: function (value) {

                    if (value.m_imaginary === 0.0) {
                        if (value.m_real < 0.0) {
                            return new mathnetnumericsbridge.Complex32.$ctor1(0.0, Math.sqrt(-value.m_real));
                        } else {
                            return new mathnetnumericsbridge.Complex32.$ctor1(Math.sqrt(value.m_real), 0.0);
                        }
                    } else {





                        var rescale = false;
                        if ((Math.abs(value.m_real) >= mathnetnumericsbridge.Complex32.s_sqrtRescaleThreshold) || (Math.abs(value.m_imaginary) >= mathnetnumericsbridge.Complex32.s_sqrtRescaleThreshold)) {
                            if ((Math.abs(value.m_imaginary) === Number.POSITIVE_INFINITY) && !isNaN(value.m_real)) {
                                return (new mathnetnumericsbridge.Complex32.$ctor1(Number.POSITIVE_INFINITY, value.m_imaginary));
                            } else {
                                value.m_real *= 0.25;
                                value.m_imaginary *= 0.25;
                                rescale = true;
                            }
                        }

                        var x, y;
                        if (value.m_real >= 0.0) {
                            x = Math.sqrt((mathnetnumericsbridge.Complex32.Hypot(value.m_real, value.m_imaginary) + value.m_real) * 0.5);
                            y = value.m_imaginary / (2.0 * x);
                        } else {
                            y = Math.sqrt((mathnetnumericsbridge.Complex32.Hypot(value.m_real, value.m_imaginary) - value.m_real) * 0.5);
                            if (value.m_imaginary < 0.0) {
                                y = -y;
                            }
                            x = value.m_imaginary / (2.0 * y);
                        }

                        if (rescale) {
                            x *= 2.0;
                            y *= 2.0;
                        }

                        return new mathnetnumericsbridge.Complex32.$ctor1(x, y);

                    }

                },
                Pow: function (value, power) {
                    if (mathnetnumericsbridge.Complex32.op_Equality(power.$clone(), mathnetnumericsbridge.Complex32.Zero.$clone())) {
                        return mathnetnumericsbridge.Complex32.One.$clone();
                    }

                    if (mathnetnumericsbridge.Complex32.op_Equality(value.$clone(), mathnetnumericsbridge.Complex32.Zero.$clone())) {
                        return mathnetnumericsbridge.Complex32.Zero.$clone();
                    }

                    var valueReal = value.m_real;
                    var valueImaginary = value.m_imaginary;
                    var powerReal = power.m_real;
                    var powerImaginary = power.m_imaginary;

                    var rho = mathnetnumericsbridge.Complex32.Abs(value.$clone());
                    var theta = Math.atan2(valueImaginary, valueReal);
                    var newRho = powerReal * theta + powerImaginary * Bridge.Math.log(rho);

                    var t = Math.pow(rho, powerReal) * Math.pow(Math.E, -powerImaginary * theta);

                    return new mathnetnumericsbridge.Complex32.$ctor1(t * Math.cos(newRho), t * Math.sin(newRho));
                },
                Pow$1: function (value, power) {
                    return mathnetnumericsbridge.Complex32.Pow(value.$clone(), new mathnetnumericsbridge.Complex32.$ctor1(power, 0));
                },
                Scale: function (value, factor) {
                    var realResult = factor * value.m_real;
                    var imaginaryResuilt = factor * value.m_imaginary;
                    return new mathnetnumericsbridge.Complex32.$ctor1(realResult, imaginaryResuilt);
                },
                op_UnaryNegation: function (value) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(-value.m_real, -value.m_imaginary);
                },
                op_Addition: function (left, right) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(left.m_real + right.m_real, left.m_imaginary + right.m_imaginary);
                },
                op_Addition$1: function (left, right) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(left.m_real + right, left.m_imaginary);
                },
                op_Addition$2: function (left, right) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(left + right.m_real, right.m_imaginary);
                },
                op_Subtraction: function (left, right) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(left.m_real - right.m_real, left.m_imaginary - right.m_imaginary);
                },
                op_Subtraction$1: function (left, right) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(left.m_real - right, left.m_imaginary);
                },
                op_Subtraction$2: function (left, right) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(left - right.m_real, -right.m_imaginary);
                },
                op_Multiply: function (left, right) {
                    var result_realpart = (left.m_real * right.m_real) - (left.m_imaginary * right.m_imaginary);
                    var result_imaginarypart = (left.m_imaginary * right.m_real) + (left.m_real * right.m_imaginary);
                    return new mathnetnumericsbridge.Complex32.$ctor1(result_realpart, result_imaginarypart);
                },
                op_Multiply$1: function (left, right) {
                    if (!isFinite(left.m_real)) {
                        if (!isFinite(left.m_imaginary)) {
                            return new mathnetnumericsbridge.Complex32.$ctor1(Number.NaN, Number.NaN);
                        }

                        return new mathnetnumericsbridge.Complex32.$ctor1(left.m_real * right, Number.NaN);
                    }

                    if (!isFinite(left.m_imaginary)) {
                        return new mathnetnumericsbridge.Complex32.$ctor1(Number.NaN, left.m_imaginary * right);
                    }

                    return new mathnetnumericsbridge.Complex32.$ctor1(left.m_real * right, left.m_imaginary * right);
                },
                op_Multiply$2: function (left, right) {
                    if (!isFinite(right.m_real)) {
                        if (!isFinite(right.m_imaginary)) {
                            return new mathnetnumericsbridge.Complex32.$ctor1(Number.NaN, Number.NaN);
                        }

                        return new mathnetnumericsbridge.Complex32.$ctor1(left * right.m_real, Number.NaN);
                    }

                    if (!isFinite(right.m_imaginary)) {
                        return new mathnetnumericsbridge.Complex32.$ctor1(Number.NaN, left * right.m_imaginary);
                    }

                    return new mathnetnumericsbridge.Complex32.$ctor1(left * right.m_real, left * right.m_imaginary);
                },
                op_Division: function (left, right) {
                    var a = left.m_real;
                    var b = left.m_imaginary;
                    var c = right.m_real;
                    var d = right.m_imaginary;

                    if (Math.abs(d) < Math.abs(c)) {
                        var doc = d / c;
                        return new mathnetnumericsbridge.Complex32.$ctor1((a + b * doc) / (c + d * doc), (b - a * doc) / (c + d * doc));
                    } else {
                        var cod = c / d;
                        return new mathnetnumericsbridge.Complex32.$ctor1((b + a * cod) / (d + c * cod), (-a + b * cod) / (d + c * cod));
                    }
                },
                op_Division$1: function (left, right) {
                    if (right === 0) {
                        return new mathnetnumericsbridge.Complex32.$ctor1(Number.NaN, Number.NaN);
                    }

                    if (!isFinite(left.m_real)) {
                        if (!isFinite(left.m_imaginary)) {
                            return new mathnetnumericsbridge.Complex32.$ctor1(Number.NaN, Number.NaN);
                        }

                        return new mathnetnumericsbridge.Complex32.$ctor1(left.m_real / right, Number.NaN);
                    }

                    if (!isFinite(left.m_imaginary)) {
                        return new mathnetnumericsbridge.Complex32.$ctor1(Number.NaN, left.m_imaginary / right);
                    }

                    return new mathnetnumericsbridge.Complex32.$ctor1(left.m_real / right, left.m_imaginary / right);
                },
                op_Division$2: function (left, right) {
                    var a = left;
                    var c = right.m_real;
                    var d = right.m_imaginary;

                    if (Math.abs(d) < Math.abs(c)) {
                        var doc = d / c;
                        return new mathnetnumericsbridge.Complex32.$ctor1(a / (c + d * doc), (-a * doc) / (c + d * doc));
                    } else {
                        var cod = c / d;
                        return new mathnetnumericsbridge.Complex32.$ctor1(a * cod / (d + c * cod), -a / (d + c * cod));
                    }
                },
                op_Equality: function (left, right) {
                    return left.m_real === right.m_real && left.m_imaginary === right.m_imaginary;
                },
                op_Inequality: function (left, right) {
                    return left.m_real !== right.m_real || left.m_imaginary !== right.m_imaginary;
                },
                op_Implicit$1: function (value) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(value, 0.0);
                },
                op_Implicit$2: function (value) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(value, 0.0);
                },
                op_Implicit$3: function (value) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(System.Int64.toNumber(value), 0.0);
                },
                op_Implicit$6: function (value) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(value, 0.0);
                },
                op_Implicit$7: function (value) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(value, 0.0);
                },
                op_Implicit$8: function (value) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(System.Int64.toNumber(value), 0.0);
                },
                op_Implicit$4: function (value) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(value, 0.0);
                },
                op_Implicit: function (value) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(value, 0.0);
                },
                op_Implicit$5: function (value) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(value, 0.0);
                },
                op_Explicit: function (value) {
                    return new mathnetnumericsbridge.Complex32.$ctor1(System.Decimal.toFloat(value), 0.0);
                },
                getDefaultValue: function () { return new mathnetnumericsbridge.Complex32(); }
            }
        },
        fields: {
            m_real: 0,
            m_imaginary: 0
        },
        props: {
            Real: {
                get: function () {
                    return this.m_real;
                }
            },
            Imaginary: {
                get: function () {
                    return this.m_imaginary;
                }
            },
            Magnitude: {
                get: function () {
                    return mathnetnumericsbridge.Complex32.Abs(this);
                }
            },
            Phase: {
                get: function () {
                    return Math.atan2(this.m_imaginary, this.m_real);
                }
            }
        },
        alias: [
            "equalsT", "System$IEquatable$1$mathnetnumericsbridge$Complex32$equalsT",
            "format", "System$IFormattable$format"
        ],
        ctors: {
            $ctor1: function (real, imaginary) {
                this.$initialize();
                this.m_real = real;
                this.m_imaginary = imaginary;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            IsZero: function (value) {
                if (value.Real === 0.0 && value.Imaginary === 0.0) {
                    return true;
                }
                return false;
            },
            equalsT: function (value) {
                return this.m_real === value.m_real && this.m_imaginary === value.m_imaginary;
            },
            getHashCode: function () {
                var n1 = 99999997;
                var realHash = System.Single.getHashCode(this.m_real) % n1;
                var imaginaryHash = System.Single.getHashCode(this.m_imaginary);
                var finalHash = realHash ^ imaginaryHash;
                return finalHash;
            },
            toString: function () {
                return System.String.format("({0}, {1})", Bridge.box(this.m_real, System.Single, System.Single.format, System.Single.getHashCode), Bridge.box(this.m_imaginary, System.Single, System.Single.format, System.Single.getHashCode));
            },
            format: function (stringin, provider) {
                return System.String.formatProvider(provider, "({0}, {1})", Bridge.box(this.m_real, System.Single, System.Single.format, System.Single.getHashCode), Bridge.box(this.m_imaginary, System.Single, System.Single.format, System.Single.getHashCode));
            },
            $clone: function (to) {
                var s = to || new mathnetnumericsbridge.Complex32();
                s.m_real = this.m_real;
                s.m_imaginary = this.m_imaginary;
                return s;
            }
        }
    });

    /** @namespace MathNet.Numerics.LinearAlgebra.Double */

    /**
     * <pre><code>double</code></pre> version of the {@link } class.
     *
     * @abstract
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Double.Matrix
     * @augments MathNet.Numerics.LinearAlgebra.Matrix$1
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.Matrix", {
        inherits: [MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double)],
        fields: {
            v_builder$1: null,
            m_builder$1: null
        },
        ctors: {
            init: function () {
                this.v_builder$1 = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(System.Double).Vector;
                this.m_builder$1 = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(System.Double).Matrix;
            },
            /**
             * Initializes a new instance of the Matrix class.
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1}    storage
             * @return  {void}
             */
            ctor: function (storage) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).ctor.call(this, storage);
            }
        },
        methods: {
            /**
             * Set all values whose absolute value is smaller than the threshold to zero.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}    threshold
             * @return  {void}
             */
            CoerceZero: function (threshold) {
                this.MapInplace(function (x) {
                    return Math.abs(x) < threshold ? 0.0 : x;
                }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Returns the conjugate transpose of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The conjugate transpose of this matrix.
             */
            ConjugateTranspose: function () {
                return this.Transpose();
            },
            /**
             * Puts the conjugate transpose of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result
             * @return  {void}
             */
            ConjugateTranspose$1: function (result) {
                this.Transpose$1(result);
            },
            /**
             * Complex conjugates each element of this matrix and place the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the conjugation.
             * @return  {void}
             */
            DoConjugate: function (result) {
                if (Bridge.referenceEquals(this, result)) {
                    return;
                }

                this.CopyTo(result);
            },
            /**
             * Negate each element of this matrix and place the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the negation.
             * @return  {void}
             */
            DoNegate: function (result) {
                this.Map$1(function (x) {
                    return -x;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Add a scalar to each element of the matrix and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     scalar    The scalar to add.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the addition.
             * @return  {void}
             */
            DoAdd: function (scalar, result) {
                this.Map$1(function (x) {
                    return x + scalar;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Adds another matrix to this matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @throws If the other matrix is {@link ArgumentNullException}.
             * @throws If the two matrices don't have the same dimensions.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to add to this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the addition.
             * @return  {void}
             */
            DoAdd$1: function (other, result) {
                this.Map2$1(function (x, y) {
                    return x + y;
                }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Subtracts a scalar from each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     scalar    The scalar to subtract.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the subtraction.
             * @return  {void}
             */
            DoSubtract: function (scalar, result) {
                this.Map$1(function (x) {
                    return x - scalar;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Subtracts another matrix from this matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @throws If the other matrix is {@link ArgumentNullException}.
             * @throws If the two matrices don't have the same dimensions.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to subtract to this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of subtraction.
             * @return  {void}
             */
            DoSubtract$1: function (other, result) {
                this.Map2$1(function (x, y) {
                    return x - y;
                }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Multiplies each element of the matrix by a scalar and places results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     scalar    The scalar to multiply the matrix with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the multiplication.
             * @return  {void}
             */
            DoMultiply: function (scalar, result) {
                this.Map$1(function (x) {
                    return x * scalar;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Multiplies this matrix with a vector and places the results into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result       The result of the multiplication.
             * @return  {void}
             */
            DoMultiply$2: function (rightSide, result) {
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var s = 0.0;
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        s += this.At(i, j) * rightSide.getItem(j);
                    }
                    result.setItem(i, s);
                }
            },
            /**
             * Multiplies this matrix with another matrix and places the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            DoMultiply$1: function (other, result) {
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    for (var j = 0; j < other.ColumnCount; j = (j + 1) | 0) {
                        var s = 0.0;
                        for (var k = 0; k < this.ColumnCount; k = (k + 1) | 0) {
                            s += this.At(i, k) * other.At(k, j);
                        }
                        result.At$1(i, j, s);
                    }
                }
            },
            /**
             * Divides each element of the matrix by a scalar and places results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     divisor    The scalar to divide the matrix with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     The matrix to store the result of the division.
             * @return  {void}
             */
            DoDivide: function (divisor, result) {
                this.Map$1(function (x) {
                    return x / divisor;
                }, result, divisor === 0.0 ? MathNet.Numerics.LinearAlgebra.Zeros.Include : MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Divides a scalar by each element of the matrix and stores the result in the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     dividend    The scalar to divide by each element of the matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      The matrix to store the result of the division.
             * @return  {void}
             */
            DoDivideByThis: function (dividend, result) {
                this.Map$1(function (x) {
                    return dividend / x;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Multiplies this matrix with transpose of another matrix and places the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            DoTransposeAndMultiply: function (other, result) {
                for (var j = 0; j < other.RowCount; j = (j + 1) | 0) {
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        var s = 0.0;
                        for (var k = 0; k < this.ColumnCount; k = (k + 1) | 0) {
                            s += this.At(i, k) * other.At(j, k);
                        }
                        result.At$1(i, j, s);
                    }
                }
            },
            /**
             * Multiplies this matrix with the conjugate transpose of another matrix and places the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            DoConjugateTransposeAndMultiply: function (other, result) {
                this.DoTransposeAndMultiply(other, result);
            },
            /**
             * Multiplies the transpose of this matrix with another matrix and places the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            DoTransposeThisAndMultiply: function (other, result) {
                for (var j = 0; j < other.ColumnCount; j = (j + 1) | 0) {
                    for (var i = 0; i < this.ColumnCount; i = (i + 1) | 0) {
                        var s = 0.0;
                        for (var k = 0; k < this.RowCount; k = (k + 1) | 0) {
                            s += this.At(k, i) * other.At(k, j);
                        }
                        result.At$1(i, j, s);
                    }
                }
            },
            /**
             * Multiplies the transpose of this matrix with a vector and places the results into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result       The result of the multiplication.
             * @return  {void}
             */
            DoTransposeThisAndMultiply$1: function (rightSide, result) {
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    var s = 0.0;
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        s += this.At(i, j) * rightSide.getItem(i);
                    }
                    result.setItem(j, s);
                }
            },
            /**
             * Multiplies the transpose of this matrix with another matrix and places the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            DoConjugateTransposeThisAndMultiply: function (other, result) {
                this.DoTransposeThisAndMultiply(other, result);
            },
            /**
             * Multiplies the conjugate transpose of this matrix with a vector and places the results into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result       The result of the multiplication.
             * @return  {void}
             */
            DoConjugateTransposeThisAndMultiply$1: function (rightSide, result) {
                this.DoTransposeThisAndMultiply$1(rightSide, result);
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for the given divisor each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     Matrix to store the results in.
             * @return  {void}
             */
            DoModulus: function (divisor, result) {
                this.Map$1(function (x) {
                    return MathNet.Numerics.Euclid.Modulus(x, divisor);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for the given dividend for each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     dividend    The scalar numerator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      A vector to store the results in.
             * @return  {void}
             */
            DoModulusByThis: function (dividend, result) {
                this.Map$1(function (x) {
                    return MathNet.Numerics.Euclid.Modulus(dividend, x);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Computes the remainder (% operator), where the result has the sign of the dividend,
             for the given divisor each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     Matrix to store the results in.
             * @return  {void}
             */
            DoRemainder: function (divisor, result) {
                this.Map$1(function (x) {
                    return MathNet.Numerics.Euclid.Remainder(x, divisor);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Computes the remainder (% operator), where the result has the sign of the dividend,
             for the given dividend for each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     dividend    The scalar numerator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      A vector to store the results in.
             * @return  {void}
             */
            DoRemainderByThis: function (dividend, result) {
                this.Map$1(function (x) {
                    return MathNet.Numerics.Euclid.Remainder(dividend, x);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise multiplies this matrix with another matrix and stores the result into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to pointwise multiply with this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the pointwise multiplication.
             * @return  {void}
             */
            DoPointwiseMultiply: function (other, result) {
                this.Map2$1(function (x, y) {
                    return x * y;
                }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Pointwise divide this matrix by another matrix and stores the result into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor    The matrix to pointwise divide this one by.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     The matrix to store the result of the pointwise division.
             * @return  {void}
             */
            DoPointwiseDivide: function (divisor, result) {
                this.Map2$1(function (x, y) {
                    return x / y;
                }, divisor, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise raise this matrix to an exponent and store the result into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     exponent    The exponent to raise this matrix values to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      The matrix to store the result of the pointwise power.
             * @return  {void}
             */
            DoPointwisePower: function (exponent, result) {
                this.Map$1(function (x) {
                    return Math.pow(x, exponent);
                }, result, exponent > 0.0 ? MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip : MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise raise this matrix to an exponent and store the result into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    exponent    The exponent to raise this matrix values to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      The vector to store the result of the pointwise power.
             * @return  {void}
             */
            DoPointwisePower$1: function (exponent, result) {
                this.Map2(Math.pow, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise canonical modulus, where the result has the sign of the divisor,
             of this matrix with another matrix and stores the result into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor    The pointwise denominator matrix to use
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     The result of the modulus.
             * @return  {void}
             */
            DoPointwiseModulus: function (divisor, result) {
                this.Map2$1(MathNet.Numerics.Euclid.Modulus, divisor, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise remainder (% operator), where the result has the sign of the dividend,
             of this matrix with another matrix and stores the result into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor    The pointwise denominator matrix to use
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     The result of the modulus.
             * @return  {void}
             */
            DoPointwiseRemainder: function (divisor, result) {
                this.Map2$1(MathNet.Numerics.Euclid.Remainder, divisor, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise applies the exponential function to each value and stores the result into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result.
             * @return  {void}
             */
            DoPointwiseExp: function (result) {
                this.Map$1(Math.exp, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise applies the natural logarithm function to each value and stores the result into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result.
             * @return  {void}
             */
            DoPointwiseLog: function (result) {
                this.Map$1(function (x) { return Bridge.Math.log(x); }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseAbs: function (result) {
                this.Map$1(Math.abs, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseAcos: function (result) {
                this.Map$1(Math.acos, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseAsin: function (result) {
                this.Map$1(Math.asin, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseAtan: function (result) {
                this.Map$1(Math.atan, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseAtan2: function (other, result) {
                this.Map2$1(Math.atan2, other, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseCeiling: function (result) {
                this.Map$1(Math.ceil, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseCos: function (result) {
                this.Map$1(Math.cos, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseCosh: function (result) {
                this.Map$1(function (value) { return Bridge.Math.cosh(value); }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseFloor: function (result) {
                this.Map$1(Math.floor, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseLog10: function (result) {
                this.Map$1(function (x) { return Bridge.Math.logWithBase(x, 10.0); }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseRound: function (result) {
                this.Map$1(function (d) { return Bridge.Math.round(d, 0, 6); }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseSign: function (result) {
                this.Map$1(function (x) {
                    return Bridge.Int.sign(x);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseSin: function (result) {
                this.Map$1(Math.sin, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseSinh: function (result) {
                this.Map$1(function (value) { return Bridge.Math.sinh(value); }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseSqrt: function (result) {
                this.Map$1(Math.sqrt, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseTan: function (result) {
                this.Map$1(Math.tan, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseTanh: function (result) {
                this.Map$1(function (value) { return Bridge.Math.tanh(value); }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Computes the Moore-Penrose Pseudo-Inverse of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            PseudoInverse: function () {
                var svd = this.Svd(true);
                var w = svd.W;
                var s = svd.S;
                var tolerance = Math.max(this.RowCount, this.ColumnCount) * svd.L2Norm * 4.94065645841247E-324;

                for (var i = 0; i < s.Count; i = (i + 1) | 0) {
                    s.setItem(i, s.getItem(i) < tolerance ? 0 : 1 / s.getItem(i));
                }

                w.SetDiagonal$1(s);
                return (MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).op_Multiply$2(MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).op_Multiply$2(svd.U, w), svd.VT)).Transpose();
            },
            /**
             * Computes the trace of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @throws If the matrix is not square
             * @return  {number}        The trace of this matrix
             */
            Trace: function () {
                if (this.RowCount !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSquare");
                }

                var sum = 0.0;
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    sum += this.At(i, i);
                }

                return sum;
            },
            DoPointwiseMinimum: function (scalar, result) {
                this.Map$1(function (x) {
                    return Math.min(scalar, x);
                }, result, scalar >= 0.0 ? MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip : MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseMinimum$1: function (other, result) {
                this.Map2$1(Math.min, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseMaximum: function (scalar, result) {
                this.Map$1(function (x) {
                    return Math.max(scalar, x);
                }, result, scalar <= 0.0 ? MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip : MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseMaximum$1: function (other, result) {
                this.Map2$1(Math.max, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseAbsoluteMinimum: function (scalar, result) {
                var absolute = Math.abs(scalar);
                this.Map$1(function (x) {
                    return Math.min(absolute, Math.abs(x));
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseAbsoluteMinimum$1: function (other, result) {
                this.Map2$1(function (x, y) {
                    return Math.min(Math.abs(x), Math.abs(y));
                }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseAbsoluteMaximum: function (scalar, result) {
                var absolute = Math.abs(scalar);
                this.Map$1(function (x) {
                    return Math.max(absolute, Math.abs(x));
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseAbsoluteMaximum$1: function (other, result) {
                this.Map2$1(function (x, y) {
                    return Math.max(Math.abs(x), Math.abs(y));
                }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Calculates the induced L1 norm of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @return  {number}        The maximum absolute column sum of the matrix.
             */
            L1Norm: function () {
                var norm = 0.0;
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    var s = 0.0;
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        s += Math.abs(this.At(i, j));
                    }
                    norm = Math.max(norm, s);
                }
                return norm;
            },
            /**
             * Calculates the induced infinity norm of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @return  {number}        The maximum absolute row sum of the matrix.
             */
            InfinityNorm: function () {
                var norm = 0.0;
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var s = 0.0;
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        s += Math.abs(this.At(i, j));
                    }
                    norm = Math.max(norm, s);
                }
                return norm;
            },
            /**
             * Calculates the entry-wise Frobenius norm of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @return  {number}        The square root of the sum of the squared values.
             */
            FrobeniusNorm: function () {
                var transpose = this.Transpose();
                var aat = MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).op_Multiply$2(this, transpose);
                var norm = 0.0;
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    norm += aat.At(i, i);
                }
                return Math.sqrt(norm);
            },
            /**
             * Calculates the p-norms of all row vectors.
             Typical values for p are 1.0 (L1, Manhattan norm), 2.0 (L2, Euclidean norm) and positive infinity (infinity norm)
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     norm
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            RowNorms: function (norm) {
                if (norm <= 0.0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("norm", "Resources.ArgumentMustBePositive");
                }

                var ret = System.Array.init(this.RowCount, 0, System.Double);
                if (norm === 2.0) {
                    this.Storage.FoldByRowUnchecked(System.Double, ret, function (s, x) {
                        return s + x * x;
                    }, function (x, c) {
                        return Math.sqrt(x);
                    }, ret, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                } else if (norm === 1.0) {
                    this.Storage.FoldByRowUnchecked(System.Double, ret, function (s, x) {
                        return s + Math.abs(x);
                    }, function (x, c) {
                        return x;
                    }, ret, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                } else if ((norm === Number.POSITIVE_INFINITY)) {
                    this.Storage.FoldByRowUnchecked(System.Double, ret, function (s, x) {
                        return Math.max(s, Math.abs(x));
                    }, function (x, c) {
                        return x;
                    }, ret, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                } else {
                    var invnorm = 1.0 / norm;
                    this.Storage.FoldByRowUnchecked(System.Double, ret, function (s, x) {
                        return s + Math.pow(Math.abs(x), norm);
                    }, function (x, c) {
                        return Math.pow(x, invnorm);
                    }, ret, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                }
                return this.v_builder$1.Dense(ret);
            },
            /**
             * Calculates the p-norms of all column vectors.
             Typical values for p are 1.0 (L1, Manhattan norm), 2.0 (L2, Euclidean norm) and positive infinity (infinity norm)
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     norm
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            ColumnNorms: function (norm) {
                if (norm <= 0.0) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("norm", "Resources.ArgumentMustBePositive");
                }

                var ret = System.Array.init(this.ColumnCount, 0, System.Double);
                if (norm === 2.0) {
                    this.Storage.FoldByColumnUnchecked(System.Double, ret, function (s, x) {
                        return s + x * x;
                    }, function (x, c) {
                        return Math.sqrt(x);
                    }, ret, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                } else if (norm === 1.0) {
                    this.Storage.FoldByColumnUnchecked(System.Double, ret, function (s, x) {
                        return s + Math.abs(x);
                    }, function (x, c) {
                        return x;
                    }, ret, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                } else if ((norm === Number.POSITIVE_INFINITY)) {
                    this.Storage.FoldByColumnUnchecked(System.Double, ret, function (s, x) {
                        return Math.max(s, Math.abs(x));
                    }, function (x, c) {
                        return x;
                    }, ret, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                } else {
                    var invnorm = 1.0 / norm;
                    this.Storage.FoldByColumnUnchecked(System.Double, ret, function (s, x) {
                        return s + Math.pow(Math.abs(x), norm);
                    }, function (x, c) {
                        return Math.pow(x, invnorm);
                    }, ret, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                }
                return this.v_builder$1.Dense(ret);
            },
            /**
             * Normalizes all row vectors to a unit p-norm.
             Typical values for p are 1.0 (L1, Manhattan norm), 2.0 (L2, Euclidean norm) and positive infinity (infinity norm)
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     norm
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            NormalizeRows: function (norm) {
                var norminv = Bridge.cast(this.RowNorms(norm).Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double)).Data;
                for (var i = 0; i < norminv.length; i = (i + 1) | 0) {
                    norminv[System.Array.index(i, norminv)] = norminv[System.Array.index(i, norminv)] === 0.0 ? 1.0 : 1.0 / norminv[System.Array.index(i, norminv)];
                }

                var result = this.m_builder$1.SameAs$4(System.Double, this, this.RowCount, this.ColumnCount);
                this.Storage.MapIndexedTo(System.Double, result.Storage, function (i1, j, x) {
                    return norminv[System.Array.index(i1, norminv)] * x;
                }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Normalizes all column vectors to a unit p-norm.
             Typical values for p are 1.0 (L1, Manhattan norm), 2.0 (L2, Euclidean norm) and positive infinity (infinity norm)
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @param   {number}                                     norm
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}
             */
            NormalizeColumns: function (norm) {
                var norminv = Bridge.cast(this.ColumnNorms(norm).Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double)).Data;
                for (var i = 0; i < norminv.length; i = (i + 1) | 0) {
                    norminv[System.Array.index(i, norminv)] = norminv[System.Array.index(i, norminv)] === 0.0 ? 1.0 : 1.0 / norminv[System.Array.index(i, norminv)];
                }

                var result = this.m_builder$1.SameAs$4(System.Double, this, this.RowCount, this.ColumnCount);
                this.Storage.MapIndexedTo(System.Double, result.Storage, function (i1, j, x) {
                    return norminv[System.Array.index(j, norminv)] * x;
                }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return result;
            },
            /**
             * Calculates the value sum of each row vector.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            RowSums: function () {
                var ret = System.Array.init(this.RowCount, 0, System.Double);
                this.Storage.FoldByRowUnchecked(System.Double, ret, function (s, x) {
                    return s + x;
                }, function (x, c) {
                    return x;
                }, ret, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                return this.v_builder$1.Dense(ret);
            },
            /**
             * Calculates the absolute value sum of each row vector.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            RowAbsoluteSums: function () {
                var ret = System.Array.init(this.RowCount, 0, System.Double);
                this.Storage.FoldByRowUnchecked(System.Double, ret, function (s, x) {
                    return s + Math.abs(x);
                }, function (x, c) {
                    return x;
                }, ret, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                return this.v_builder$1.Dense(ret);
            },
            /**
             * Calculates the value sum of each column vector.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            ColumnSums: function () {
                var ret = System.Array.init(this.ColumnCount, 0, System.Double);
                this.Storage.FoldByColumnUnchecked(System.Double, ret, function (s, x) {
                    return s + x;
                }, function (x, c) {
                    return x;
                }, ret, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                return this.v_builder$1.Dense(ret);
            },
            /**
             * Calculates the absolute value sum of each column vector.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}
             */
            ColumnAbsoluteSums: function () {
                var ret = System.Array.init(this.ColumnCount, 0, System.Double);
                this.Storage.FoldByColumnUnchecked(System.Double, ret, function (s, x) {
                    return s + Math.abs(x);
                }, function (x, c) {
                    return x;
                }, ret, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                return this.v_builder$1.Dense(ret);
            },
            /**
             * Evaluates whether this matrix is Hermitian (conjugate symmetric).
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Matrix
             * @return  {boolean}
             */
            IsHermitian: function () {
                return this.IsSymmetric();
            },
            Svd: function (computeVectors) {
                if (computeVectors === void 0) { computeVectors = true; }
                return MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Create(this, computeVectors);
            }
        }
    });

    /**
     * <pre><code>double</code></pre> version of the {@link } class.
     *
     * @abstract
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Double.Vector
     * @augments MathNet.Numerics.LinearAlgebra.Vector$1
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.Vector", {
        inherits: [MathNet.Numerics.LinearAlgebra.Vector$1(System.Double)],
        ctors: {
            /**
             * Initializes a new instance of the Vector class.
             *
             * @instance
             * @protected
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1}    storage
             * @return  {void}
             */
            ctor: function (storage) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Vector$1(System.Double).ctor.call(this, storage);
            }
        },
        methods: {
            /**
             * Set all values whose absolute value is smaller than the threshold to zero.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {number}    threshold
             * @return  {void}
             */
            CoerceZero: function (threshold) {
                this.MapInplace(function (x) {
                    return Math.abs(x) < threshold ? 0.0 : x;
                }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Conjugates vector and save result to <b />
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    Target vector
             * @return  {void}
             */
            DoConjugate: function (result) {
                if (Bridge.referenceEquals(this, result)) {
                    return;
                }

                this.CopyTo(result);
            },
            /**
             * Negates vector and saves result to <b />
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    Target vector
             * @return  {void}
             */
            DoNegate: function (result) {
                this.Map$1(function (x) {
                    return -x;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Adds a scalar to each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {number}                                     scalar    The scalar to add.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the addition.
             * @return  {void}
             */
            DoAdd: function (scalar, result) {
                this.Map$1(function (x) {
                    return x + scalar;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Adds another vector to this vector and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector to add to this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the addition.
             * @return  {void}
             */
            DoAdd$1: function (other, result) {
                this.Map2$1(function (x, y) {
                    return x + y;
                }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Subtracts a scalar from each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {number}                                     scalar    The scalar to subtract.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the subtraction.
             * @return  {void}
             */
            DoSubtract: function (scalar, result) {
                this.Map$1(function (x) {
                    return x - scalar;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Subtracts another vector to this vector and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector to subtract from this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the subtraction.
             * @return  {void}
             */
            DoSubtract$1: function (other, result) {
                this.Map2$1(function (x, y) {
                    return x - y;
                }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Multiplies a scalar to each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {number}                                     scalar    The scalar to multiply.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the multiplication.
             * @return  {void}
             */
            DoMultiply: function (scalar, result) {
                this.Map$1(function (x) {
                    return x * scalar;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Divides each element of the vector by a scalar and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {number}                                     divisor    The scalar to divide with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     The vector to store the result of the division.
             * @return  {void}
             */
            DoDivide: function (divisor, result) {
                this.Map$1(function (x) {
                    return x / divisor;
                }, result, divisor === 0.0 ? MathNet.Numerics.LinearAlgebra.Zeros.Include : MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Divides a scalar by each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {number}                                     dividend    The scalar to divide.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result      The vector to store the result of the division.
             * @return  {void}
             */
            DoDivideByThis: function (dividend, result) {
                this.Map$1(function (x) {
                    return dividend / x;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise multiplies this vector with another vector and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector to pointwise multiply with this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the pointwise multiplication.
             * @return  {void}
             */
            DoPointwiseMultiply: function (other, result) {
                this.Map2$1(function (x, y) {
                    return x * y;
                }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Pointwise divide this vector with another vector and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor    The vector to pointwise divide this one by.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     The vector to store the result of the pointwise division.
             * @return  {void}
             */
            DoPointwiseDivide: function (divisor, result) {
                this.Map2$1(function (x, y) {
                    return x / y;
                }, divisor, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise raise this vector to an exponent and store the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {number}                                     exponent    The exponent to raise this vector values to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result      The vector to store the result of the pointwise power.
             * @return  {void}
             */
            DoPointwisePower: function (exponent, result) {
                this.Map$1(function (x) {
                    return Math.pow(x, exponent);
                }, result, exponent > 0.0 ? MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip : MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise raise this vector to an exponent vector and store the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    exponent    The exponent vector to raise this vector values to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result      The vector to store the result of the pointwise power.
             * @return  {void}
             */
            DoPointwisePower$1: function (exponent, result) {
                this.Map2$1(Math.pow, exponent, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise canonical modulus, where the result has the sign of the divisor,
             of this vector with another vector and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor    The pointwise denominator vector to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     The result of the modulus.
             * @return  {void}
             */
            DoPointwiseModulus: function (divisor, result) {
                this.Map2$1(MathNet.Numerics.Euclid.Modulus, divisor, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise remainder (% operator), where the result has the sign of the dividend,
             of this vector with another vector and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor    The pointwise denominator vector to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     The result of the modulus.
             * @return  {void}
             */
            DoPointwiseRemainder: function (divisor, result) {
                this.Map2$1(MathNet.Numerics.Euclid.Remainder, divisor, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise applies the exponential function to each value and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result.
             * @return  {void}
             */
            DoPointwiseExp: function (result) {
                this.Map$1(Math.exp, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Pointwise applies the natural logarithm function to each value and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result.
             * @return  {void}
             */
            DoPointwiseLog: function (result) {
                this.Map$1(function (x) { return Bridge.Math.log(x); }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseAbs: function (result) {
                this.Map$1(Math.abs, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseAcos: function (result) {
                this.Map$1(Math.acos, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseAsin: function (result) {
                this.Map$1(Math.asin, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseAtan: function (result) {
                this.Map$1(Math.atan, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseAtan2$1: function (other, result) {
                this.Map2$1(Math.atan2, other, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseAtan2: function (scalar, result) {
                this.Map$1(function (x) {
                    return Math.atan2(x, scalar);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseCeiling: function (result) {
                this.Map$1(Math.ceil, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseCos: function (result) {
                this.Map$1(Math.cos, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseCosh: function (result) {
                this.Map$1(function (value) { return Bridge.Math.cosh(value); }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseFloor: function (result) {
                this.Map$1(Math.floor, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseLog10: function (result) {
                this.Map$1(function (x) { return Bridge.Math.logWithBase(x, 10.0); }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseRound: function (result) {
                this.Map$1(function (d) { return Bridge.Math.round(d, 0, 6); }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseSign: function (result) {
                this.Map$1(function (x) {
                    return Bridge.Int.sign(x);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseSin: function (result) {
                this.Map$1(Math.sin, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseSinh: function (result) {
                this.Map$1(function (value) { return Bridge.Math.sinh(value); }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseSqrt: function (result) {
                this.Map$1(Math.sqrt, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseTan: function (result) {
                this.Map$1(Math.tan, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseTanh: function (result) {
                this.Map$1(function (value) { return Bridge.Math.tanh(value); }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Computes the dot product between this vector and another vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The other vector.
             * @return  {number}                                              The sum of a[i]*b[i] for all i.
             */
            DoDotProduct: function (other) {
                var dot = 0.0;
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    dot += this.At(i) * other.At(i);
                }
                return dot;
            },
            /**
             * Computes the dot product between the conjugate of this vector and another vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The other vector.
             * @return  {number}                                              The sum of conj(a[i])*b[i] for all i.
             */
            DoConjugateDotProduct: function (other) {
                return this.DoDotProduct(other);
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for each element of the vector for the given divisor.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {number}                                     divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     A vector to store the results in.
             * @return  {void}
             */
            DoModulus: function (divisor, result) {
                this.Map$1(function (x) {
                    return MathNet.Numerics.Euclid.Modulus(x, divisor);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for the given dividend for each element of the vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {number}                                     dividend    The scalar numerator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result      A vector to store the results in.
             * @return  {void}
             */
            DoModulusByThis: function (dividend, result) {
                this.Map$1(function (x) {
                    return MathNet.Numerics.Euclid.Modulus(dividend, x);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Computes the remainder (% operator), where the result has the sign of the dividend,
             for each element of the vector for the given divisor.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {number}                                     divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     A vector to store the results in.
             * @return  {void}
             */
            DoRemainder: function (divisor, result) {
                this.Map$1(function (x) {
                    return MathNet.Numerics.Euclid.Remainder(x, divisor);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Computes the remainder (% operator), where the result has the sign of the dividend,
             for the given dividend for each element of the vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {number}                                     dividend    The scalar numerator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result      A vector to store the results in.
             * @return  {void}
             */
            DoRemainderByThis: function (dividend, result) {
                this.Map$1(function (x) {
                    return MathNet.Numerics.Euclid.Remainder(dividend, x);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseMinimum: function (scalar, result) {
                this.Map$1(function (x) {
                    return Math.min(scalar, x);
                }, result, scalar >= 0.0 ? MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip : MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseMinimum$1: function (other, result) {
                this.Map2$1(Math.min, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseMaximum: function (scalar, result) {
                this.Map$1(function (x) {
                    return Math.max(scalar, x);
                }, result, scalar <= 0.0 ? MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip : MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseMaximum$1: function (other, result) {
                this.Map2$1(Math.max, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseAbsoluteMinimum: function (scalar, result) {
                var absolute = Math.abs(scalar);
                this.Map$1(function (x) {
                    return Math.min(absolute, Math.abs(x));
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseAbsoluteMinimum$1: function (other, result) {
                this.Map2$1(function (x, y) {
                    return Math.min(Math.abs(x), Math.abs(y));
                }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            DoPointwiseAbsoluteMaximum: function (scalar, result) {
                var absolute = Math.abs(scalar);
                this.Map$1(function (x) {
                    return Math.max(absolute, Math.abs(x));
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            DoPointwiseAbsoluteMaximum$1: function (other, result) {
                this.Map2$1(function (x, y) {
                    return Math.max(Math.abs(x), Math.abs(y));
                }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Returns the value of the absolute minimum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @return  {number}        The value of the absolute minimum element.
             */
            AbsoluteMinimum: function () {
                return Math.abs(this.At(this.AbsoluteMinimumIndex()));
            },
            /**
             * Returns the index of the absolute minimum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @return  {number}        The index of absolute minimum element.
             */
            AbsoluteMinimumIndex: function () {
                var index = 0;
                var min = Math.abs(this.At(index));
                for (var i = 1; i < this.Count; i = (i + 1) | 0) {
                    var test = Math.abs(this.At(i));
                    if (test < min) {
                        index = i;
                        min = test;
                    }
                }

                return index;
            },
            /**
             * Returns the value of the absolute maximum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @return  {number}        The value of the absolute maximum element.
             */
            AbsoluteMaximum: function () {
                return Math.abs(this.At(this.AbsoluteMaximumIndex()));
            },
            /**
             * Returns the index of the absolute maximum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @return  {number}        The index of absolute maximum element.
             */
            AbsoluteMaximumIndex: function () {
                var index = 0;
                var max = Math.abs(this.At(index));
                for (var i = 1; i < this.Count; i = (i + 1) | 0) {
                    var test = Math.abs(this.At(i));
                    if (test > max) {
                        index = i;
                        max = test;
                    }
                }

                return index;
            },
            /**
             * Computes the sum of the vector's elements.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @return  {number}        The sum of the vector's elements.
             */
            Sum: function () {
                var sum = 0.0;
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    sum += this.At(i);
                }
                return sum;
            },
            /**
             * Calculates the L1 norm of the vector, also known as Manhattan norm.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @return  {number}        The sum of the absolute values.
             */
            L1Norm: function () {
                var sum = 0.0;
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    sum += Math.abs(this.At(i));
                }
                return sum;
            },
            /**
             * Calculates the L2 norm of the vector, also known as Euclidean norm.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @return  {number}        The square root of the sum of the squared values.
             */
            L2Norm: function () {
                return Math.sqrt(this.DoDotProduct(this));
            },
            /**
             * Calculates the infinity norm of the vector.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @return  {number}        The maximum absolute value.
             */
            InfinityNorm: function () {
                var max = 0.0;
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (Math.abs(this.At(i)) > max) {
                        max = this.At(i);
                    }
                }
                return max;

            },
            /**
             * Computes the p-Norm.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {number}    p    The p value.
             * @return  {number}         <pre><code>Scalar ret = ( â|At(i)|^p )^(1/p)</code></pre>
             */
            Norm: function (p) {
                if (p < 0.0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("p");
                }

                if (p === 1.0) {
                    return this.L1Norm();
                }
                if (p === 2.0) {
                    return this.L2Norm();
                }
                if ((p === Number.POSITIVE_INFINITY)) {
                    return this.InfinityNorm();
                }

                var sum = 0.0;
                for (var index = 0; index < this.Count; index = (index + 1) | 0) {
                    sum += Math.pow(Math.abs(this.At(index)), p);
                }
                return Math.pow(sum, 1.0 / p);
            },
            /**
             * Returns the index of the maximum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @return  {number}        The index of maximum element.
             */
            MaximumIndex: function () {
                var index = 0;
                var max = this.At(index);
                for (var i = 1; i < this.Count; i = (i + 1) | 0) {
                    var test = this.At(i);
                    if (test > max) {
                        index = i;
                        max = test;
                    }
                }

                return index;
            },
            /**
             * Returns the index of the minimum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @return  {number}        The index of minimum element.
             */
            MinimumIndex: function () {
                var index = 0;
                var min = this.At(index);
                for (var i = 1; i < this.Count; i = (i + 1) | 0) {
                    var test = this.At(i);
                    if (test < min) {
                        index = i;
                        min = test;
                    }
                }

                return index;
            },
            /**
             * Normalizes this vector to a unit vector with respect to the p-norm.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Vector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Vector
             * @param   {number}                                     p    The p value.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}         This vector normalized to a unit vector with respect to the p-norm.
             */
            Normalize: function (p) {
                if (p < 0.0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("p");
                }

                var norm = this.Norm(p);
                var clone = this.Clone();
                if (norm === 0.0) {
                    return clone;
                }

                clone.Multiply$1(1.0 / norm, clone);

                return clone;
            }
        }
    });

    /**
     * <p>A class which encapsulates the functionality of an LU factorization.</p><p>For a matrix A, the LU factorization is a pair of lower triangular matrix L and
     upper triangular matrix U so that A = L*U.</p><p>In the Math.Net implementation we also store a set of pivot elements for increased
     numerical stability. The pivot elements encode a permutation matrix P such that P*A = L*U.</p>
     *
     * @abstract
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Factorization.LU$1
     * @implements  MathNet.Numerics.LinearAlgebra.Factorization.ISolver$1
     * @param   {Function}    [name]    Supported data types are double, single, {@link }, and {@link }.
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Factorization.LU$1", function (T) { return {
        inherits: [MathNet.Numerics.LinearAlgebra.Factorization.ISolver$1(T)],
        statics: {
            fields: {
                One: null
            },
            ctors: {
                init: function () {
                    this.One = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix.One;
                }
            }
        },
        fields: {
            v_builder: null,
            m_builder: null,
            _lazyL: null,
            _lazyU: null,
            _lazyP: null,
            Factors: null,
            Pivots: null
        },
        props: {
            /**
             * Gets the lower triangular factor.
             *
             * @instance
             * @public
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.LU$1
             * @function L
             * @type MathNet.Numerics.LinearAlgebra.Matrix$1
             */
            L: {
                get: function () {
                    return this._lazyL;
                }
            },
            /**
             * Gets the upper triangular factor.
             *
             * @instance
             * @public
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.LU$1
             * @function U
             * @type MathNet.Numerics.LinearAlgebra.Matrix$1
             */
            U: {
                get: function () {
                    return this._lazyU;
                }
            },
            /**
             * Gets the permutation applied to LU factorization.
             *
             * @instance
             * @public
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.LU$1
             * @function P
             * @type MathNet.Numerics.Permutation
             */
            P: {
                get: function () {
                    return this._lazyP;
                }
            }
        },
        alias: [
            "Solve", "MathNet$Numerics$LinearAlgebra$Factorization$ISolver$1$" + Bridge.getTypeAlias(T) + "$Solve",
            "Solve$2", "MathNet$Numerics$LinearAlgebra$Factorization$ISolver$1$" + Bridge.getTypeAlias(T) + "$Solve$1"
        ],
        ctors: {
            init: function () {
                this.v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;
                this.m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
            },
            ctor: function (factors, pivots) {
                this.$initialize();
                this.Factors = factors;
                this.Pivots = pivots;

                this._lazyL = this.ComputeL();
                this._lazyU = this.Factors.UpperTriangle();
                this._lazyP = MathNet.Numerics.Permutation.FromInversions(this.Pivots);
            }
        },
        methods: {
            ComputeL: function () {
                var result = this.Factors.LowerTriangle();
                for (var i = 0; i < result.RowCount; i = (i + 1) | 0) {
                    result.At$1(i, i, MathNet.Numerics.LinearAlgebra.Factorization.LU$1(T).One);
                }
                return result;
            },
            /**
             * Solves a system of linear equations, <b>AX = B</b>, with A LU factorized.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Factorization.LU$1
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.LU$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    input    The right hand side {@link }, <b>B</b>.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The left hand side {@link }, <b>X</b>.
             */
            Solve: function (input) {
                var x = this.m_builder.SameAs$4(T, input, input.RowCount, input.ColumnCount, true);
                this.Solve$1(input, x);
                return x;
            },
            /**
             * Solves a system of linear equations, <b>Ax = b</b>, with A LU factorized.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Factorization.LU$1
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.LU$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    input    The right hand side vector, <b>b</b>.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}             The left hand side {@link }, <b>x</b>.
             */
            Solve$2: function (input) {
                var x = this.v_builder.SameAs$5(T, input, input.Count);
                this.Solve$3(input, x);
                return x;
            }
        }
    }; });

    /**
     * <p>A class which encapsulates the functionality of the singular value decomposition (SVD).</p><p>Suppose M is an m-by-n matrix whose entries are real numbers.
     Then there exists a factorization of the form M = UÎ£VT where:
     - U is an m-by-m unitary matrix;
     - Î£ is m-by-n diagonal matrix with nonnegative real numbers on the diagonal;
     - VT denotes transpose of V, an n-by-n unitary matrix;
     Such a factorization is called a singular-value decomposition of M. A common convention is to order the diagonal
     entries Î£(i,i) in descending order. In this case, the diagonal matrix Î£ is uniquely determined
     by M (though the matrices U and V are not). The diagonal entries of Î£ are known as the singular values of M.</p>
     *
     * @abstract
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Factorization.Svd$1
     * @implements  MathNet.Numerics.LinearAlgebra.Factorization.ISolver$1
     * @param   {Function}    [name]    Supported data types are double, single, {@link }, and {@link }.
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Factorization.Svd$1", function (T) { return {
        inherits: [MathNet.Numerics.LinearAlgebra.Factorization.ISolver$1(T)],
        fields: {
            v_builder: null,
            m_builder: null,
            _lazyW: null,
            /**
             * Indicating whether U and VT matrices have been computed during SVD factorization.
             *
             * @instance
             * @protected
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.Svd$1
             * @type boolean
             */
            VectorsComputed: false,
            /**
             * Gets the singular values (Î£) of matrix in ascending value.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.Svd$1
             * @function S
             * @type MathNet.Numerics.LinearAlgebra.Vector$1
             */
            S: null,
            /**
             * Gets the left singular vectors (U - m-by-m unitary matrix)
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.Svd$1
             * @function U
             * @type MathNet.Numerics.LinearAlgebra.Matrix$1
             */
            U: null,
            /**
             * Gets the transpose right singular vectors (transpose of V, an n-by-n unitary matrix)
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.Svd$1
             * @function VT
             * @type MathNet.Numerics.LinearAlgebra.Matrix$1
             */
            VT: null
        },
        props: {
            /**
             * Returns the singular values as a diagonal {@link }.
             *
             * @instance
             * @public
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.Svd$1
             * @function W
             * @type MathNet.Numerics.LinearAlgebra.Matrix$1
             * @return  {[type]}        The singular values as a diagonal {@link }.
             */
            W: {
                get: function () {
                    return this._lazyW;
                }
            }
        },
        alias: [
            "Solve", "MathNet$Numerics$LinearAlgebra$Factorization$ISolver$1$" + Bridge.getTypeAlias(T) + "$Solve",
            "Solve$2", "MathNet$Numerics$LinearAlgebra$Factorization$ISolver$1$" + Bridge.getTypeAlias(T) + "$Solve$1"
        ],
        ctors: {
            init: function () {
                this.v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;
                this.m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
            },
            ctor: function (s, u, vt, vectorsComputed) {
                this.$initialize();
                this.S = s;
                this.U = u;
                this.VT = vt;

                this.VectorsComputed = vectorsComputed;

                var _lazyW = this.ComputeW();
            }
        },
        methods: {
            ComputeW: function () {
                var rows = this.U.RowCount;
                var columns = this.VT.ColumnCount;
                var result = this.m_builder.SameAs$4(T, this.U, rows, columns, false);

                for (var i = 0; i < rows; i = (i + 1) | 0) {
                    for (var j = 0; j < columns; j = (j + 1) | 0) {
                        if (i === j) {
                            result.At$1(i, i, this.S.getItem(i));
                        }
                    }
                }

                return result;
            },
            /**
             * Solves a system of linear equations, <b>AX = B</b>, with A SVD factorized.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Factorization.Svd$1
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.Svd$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    input    The right hand side {@link }, <b>B</b>.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The left hand side {@link }, <b>X</b>.
             */
            Solve: function (input) {
                if (!this.VectorsComputed) {
                    throw new System.InvalidOperationException.$ctor1("Resources.SingularVectorsNotComputed");
                }

                var x = this.m_builder.SameAs$4(T, this.U, this.VT.ColumnCount, input.ColumnCount, true);
                this.Solve$1(input, x);
                return x;
            },
            /**
             * Solves a system of linear equations, <b>Ax = b</b>, with A SVD factorized.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Factorization.Svd$1
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.Svd$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    input    The right hand side vector, <b>b</b>.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}             The left hand side {@link }, <b>x</b>.
             */
            Solve$2: function (input) {
                if (!this.VectorsComputed) {
                    throw new System.InvalidOperationException.$ctor1("Resources.SingularVectorsNotComputed");
                }

                var x = this.v_builder.SameAs$3(T, this.U, this.VT.ColumnCount);
                this.Solve$3(input, x);
                return x;
            }
        }
    }; });

    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.MatrixBuilder", {
        inherits: [MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.MatrixBuilder$1(System.Double)],
        props: {
            Zero: {
                get: function () {
                    return 0.0;
                }
            },
            One: {
                get: function () {
                    return 1.0;
                }
            }
        },
        methods: {
            Dense: function (storage) {
                return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(storage);
            },
            Sparse: function (storage) {
                return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(storage);
            },
            Diagonal$1: function (storage) {
                return new MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.ctor(storage);
            }
        }
    });

    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.VectorBuilder", {
        inherits: [MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1(System.Double)],
        props: {
            Zero: {
                get: function () {
                    return 0.0;
                }
            },
            One: {
                get: function () {
                    return 1.0;
                }
            }
        },
        methods: {
            Dense$1: function (storage) {
                return new MathNet.Numerics.LinearAlgebra.Double.DenseVector.ctor(storage);
            },
            Sparse: function (storage) {
                return new MathNet.Numerics.LinearAlgebra.Double.SparseVector.ctor(storage);
            }
        }
    });

    /**
     * Eigenvalues and eigenvectors of a real matrix.
     *
     * @abstract
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Factorization.Evd$1
     * @implements  MathNet.Numerics.LinearAlgebra.Factorization.ISolver$1
     * @param   {Function}    [name]    Supported data types are double, single, {@link }, and {@link }.
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Factorization.Evd$1", function (T) { return {
        inherits: [MathNet.Numerics.LinearAlgebra.Factorization.ISolver$1(T)],
        fields: {
            v_builder: null,
            m_builder: null,
            /**
             * Gets or sets a value indicating whether matrix is symmetric or not
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.Evd$1
             * @function IsSymmetric
             * @type boolean
             */
            IsSymmetric: false,
            /**
             * Gets or sets the eigen values (Î») of matrix in ascending value.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.Evd$1
             * @function EigenValues
             * @type MathNet.Numerics.LinearAlgebra.Vector$1
             */
            EigenValues: null,
            /**
             * Gets or sets eigenvectors.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.Evd$1
             * @function EigenVectors
             * @type MathNet.Numerics.LinearAlgebra.Matrix$1
             */
            EigenVectors: null,
            /**
             * Gets or sets the block diagonal eigenvalue matrix.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.Evd$1
             * @function D
             * @type MathNet.Numerics.LinearAlgebra.Matrix$1
             */
            D: null
        },
        alias: [
            "Solve", "MathNet$Numerics$LinearAlgebra$Factorization$ISolver$1$" + Bridge.getTypeAlias(T) + "$Solve",
            "Solve$2", "MathNet$Numerics$LinearAlgebra$Factorization$ISolver$1$" + Bridge.getTypeAlias(T) + "$Solve$1"
        ],
        ctors: {
            init: function () {
                this.v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Vector;
                this.m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(T).Matrix;
            },
            ctor: function (eigenVectors, eigenValues, blockDiagonal, isSymmetric) {
                this.$initialize();
                this.EigenVectors = eigenVectors;
                this.EigenValues = eigenValues;
                this.D = blockDiagonal;
                this.IsSymmetric = isSymmetric;
            }
        },
        methods: {
            /**
             * Solves a system of linear equations, <b>AX = B</b>, with A EVD factorized.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Factorization.Evd$1
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.Evd$1
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    input    The right hand side {@link }, <b>B</b>.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}             The left hand side {@link }, <b>X</b>.
             */
            Solve: function (input) {
                var x = this.m_builder.SameAs$4(T, this.EigenVectors, this.EigenVectors.ColumnCount, input.ColumnCount, true);
                this.Solve$1(input, x);
                return x;
            },
            /**
             * Solves a system of linear equations, <b>Ax = b</b>, with A EVD factorized.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Factorization.Evd$1
             * @memberof MathNet.Numerics.LinearAlgebra.Factorization.Evd$1
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    input    The right hand side vector, <b>b</b>.
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}             The left hand side {@link }, <b>x</b>.
             */
            Solve$2: function (input) {
                var x = this.v_builder.SameAs$3(T, this.EigenVectors, this.EigenVectors.ColumnCount);
                this.Solve$3(input, x);
                return x;
            }
        }
    }; });

    Bridge.define("MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1", function (T) { return {
        inherits: [MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T)],
        statics: {
            methods: {
                OfMatrix: function (matrix) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).ctor(matrix.RowCount, matrix.ColumnCount);
                    matrix.CopyToUnchecked(storage, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                    return storage;
                },
                OfValue: function (rows, columns, value) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).ctor(rows, columns);
                    var data = storage.Data;

                    for (var i = 0; i < data.length; i = (i + 1) | 0) {
                        data[System.Array.index(i, data)] = value;
                    }

                    return storage;
                },
                OfInit: function (rows, columns, init) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).ctor(rows, columns);
                    var index = 0;
                    for (var j = 0; j < columns; j = (j + 1) | 0) {
                        for (var i = 0; i < rows; i = (i + 1) | 0) {
                            storage.Data[System.Array.index(Bridge.identity(index, ((index = (index + 1) | 0))), storage.Data)] = init(i, j);
                        }
                    }
                    return storage;
                },
                OfDiagonalInit: function (rows, columns, init) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).ctor(rows, columns);
                    var index = 0;
                    var stride = (rows + 1) | 0;
                    for (var i = 0; i < Math.min(rows, columns); i = (i + 1) | 0) {
                        storage.Data[System.Array.index(index, storage.Data)] = init(i);
                        index = (index + stride) | 0;
                    }
                    return storage;
                },
                OfArray: function (array) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).ctor(System.Array.getLength(array, 0), System.Array.getLength(array, 1));
                    var index = 0;
                    for (var j = 0; j < storage.ColumnCount; j = (j + 1) | 0) {
                        for (var i = 0; i < storage.RowCount; i = (i + 1) | 0) {
                            storage.Data[System.Array.index(Bridge.identity(index, ((index = (index + 1) | 0))), storage.Data)] = array.get([i, j]);
                        }
                    }
                    return storage;
                },
                OfColumnArrays: function (data) {
                    if (data.length <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("data", "Resources.MatrixCanNotBeEmpty");
                    }

                    var columns = data.length;
                    var rows = data[System.Array.index(0, data)].length;
                    var array = System.Array.init(Bridge.Int.mul(rows, columns), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    for (var j = 0; j < data.length; j = (j + 1) | 0) {
                        System.Array.copy(data[System.Array.index(j, data)], 0, array, Bridge.Int.mul(j, rows), rows);
                    }
                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).$ctor1(rows, columns, array);
                },
                OfRowArrays: function (data) {
                    var $t;
                    if (data.length <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("data", "Resources.MatrixCanNotBeEmpty");
                    }

                    var rows = data.length;
                    var columns = data[System.Array.index(0, data)].length;
                    var array = System.Array.init(Bridge.Int.mul(rows, columns), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    for (var j = 0; j < columns; j = (j + 1) | 0) {
                        var offset = Bridge.Int.mul(j, rows);
                        for (var i = 0; i < rows; i = (i + 1) | 0) {
                            array[System.Array.index(((offset + i) | 0), array)] = ($t = data[System.Array.index(i, data)])[System.Array.index(j, $t)];
                        }
                    }
                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).$ctor1(rows, columns, array);
                },
                OfColumnMajorArray: function (rows, columns, data) {
                    var ret = System.Array.init(Bridge.Int.mul(rows, columns), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    System.Array.copy(data, 0, ret, 0, Math.min(ret.length, data.length));
                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).$ctor1(rows, columns, ret);
                },
                OfRowMajorArray: function (rows, columns, data) {
                    var ret = System.Array.init(Bridge.Int.mul(rows, columns), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    for (var i = 0; i < rows; i = (i + 1) | 0) {
                        var offset = Bridge.Int.mul(i, columns);
                        for (var j = 0; j < columns; j = (j + 1) | 0) {
                            ret[System.Array.index((((Bridge.Int.mul(j, rows)) + i) | 0), ret)] = data[System.Array.index(((offset + j) | 0), data)];
                        }
                    }
                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).$ctor1(rows, columns, ret);
                },
                OfColumnVectors: function (data) {
                    if (data.length <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("data", "Resources.MatrixCanNotBeEmpty");
                    }

                    var columns = data.length;
                    var rows = data[System.Array.index(0, data)].Length;
                    var array = System.Array.init(Bridge.Int.mul(rows, columns), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    for (var j = 0; j < data.length; j = (j + 1) | 0) {
                        var column = data[System.Array.index(j, data)];
                        var denseColumn = Bridge.as(column, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T));
                        if (denseColumn != null) {
                            System.Array.copy(denseColumn.Data, 0, array, Bridge.Int.mul(j, rows), rows);
                        } else {
                            var offset = Bridge.Int.mul(j, rows);
                            for (var i = 0; i < rows; i = (i + 1) | 0) {
                                array[System.Array.index(((offset + i) | 0), array)] = column.At(i);
                            }
                        }
                    }
                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).$ctor1(rows, columns, array);
                },
                OfRowVectors: function (data) {
                    if (data.length <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("data", "Resources.MatrixCanNotBeEmpty");
                    }

                    var rows = data.length;
                    var columns = data[System.Array.index(0, data)].Length;
                    var array = System.Array.init(Bridge.Int.mul(rows, columns), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    for (var j = 0; j < columns; j = (j + 1) | 0) {
                        var offset = Bridge.Int.mul(j, rows);
                        for (var i = 0; i < rows; i = (i + 1) | 0) {
                            array[System.Array.index(((offset + i) | 0), array)] = data[System.Array.index(i, data)].At(j);
                        }
                    }
                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).$ctor1(rows, columns, array);
                },
                OfIndexedEnumerable: function (rows, columns, data) {
                    var $t;
                    var array = System.Array.init(Bridge.Int.mul(rows, columns), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    $t = Bridge.getEnumerator(data, System.Tuple$3(System.Int32,System.Int32,T));
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            array[System.Array.index((((Bridge.Int.mul(item.Item2, rows)) + item.Item1) | 0), array)] = item.Item3;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).$ctor1(rows, columns, array);
                },
                OfColumnMajorEnumerable: function (rows, columns, data) {
                    var $t;
                    var arrayData = Bridge.as(data, System.Array.type(T));
                    if (arrayData != null) {
                        return MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfColumnMajorArray(rows, columns, arrayData);
                    }

                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).$ctor1(rows, columns, ($t = T, System.Linq.Enumerable.from(data, $t).ToArray($t)));
                },
                OfRowMajorEnumerable: function (rows, columns, data) {
                    var $t;
                    return MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T).OfRowMajorArray(rows, columns, Bridge.as(data, System.Array.type(T)) || ($t = T, System.Linq.Enumerable.from(data, $t).ToArray($t)));
                },
                OfColumnEnumerables: function (rows, columns, data) {
                    var array = System.Array.init(Bridge.Int.mul(rows, columns), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    var columnIterator = Bridge.getEnumerator(data, System.Collections.Generic.IEnumerable$1(T));
                    try {
                        for (var column = 0; column < columns; column = (column + 1) | 0) {
                            if (!columnIterator.System$Collections$IEnumerator$moveNext()) {
                                throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(columns, System.Int32)]));
                            }
                            var arrayColumn = Bridge.as(columnIterator[Bridge.geti(columnIterator, "System$Collections$Generic$IEnumerator$1$System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")], System.Array.type(T));
                            if (arrayColumn != null) {
                                System.Array.copy(arrayColumn, 0, array, Bridge.Int.mul(column, rows), rows);
                            } else {
                                var rowIterator = Bridge.getEnumerator(columnIterator[Bridge.geti(columnIterator, "System$Collections$Generic$IEnumerator$1$System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")], T);
                                try {
                                    var end = Bridge.Int.mul((((column + 1) | 0)), rows);
                                    for (var index = Bridge.Int.mul(column, rows); index < end; index = (index + 1) | 0) {
                                        if (!rowIterator.System$Collections$IEnumerator$moveNext()) {
                                            throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(rows, System.Int32)]));
                                        }
                                        array[System.Array.index(index, array)] = rowIterator[Bridge.geti(rowIterator, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")];
                                    }
                                    if (rowIterator.System$Collections$IEnumerator$moveNext()) {
                                        throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(rows, System.Int32)]));
                                    }
                                }
                                finally {
                                    if (Bridge.hasValue(rowIterator)) {
                                        rowIterator.System$IDisposable$Dispose();
                                    }
                                }
                            }
                        }
                        if (columnIterator.System$Collections$IEnumerator$moveNext()) {
                            throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(columns, System.Int32)]));
                        }

                    }
                    finally {
                        if (Bridge.hasValue(columnIterator)) {
                            columnIterator.System$IDisposable$Dispose();
                        }
                    }
                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).$ctor1(rows, columns, array);
                },
                OfRowEnumerables: function (rows, columns, data) {
                    var array = System.Array.init(Bridge.Int.mul(rows, columns), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    var rowIterator = Bridge.getEnumerator(data, System.Collections.Generic.IEnumerable$1(T));
                    try {
                        for (var row = 0; row < rows; row = (row + 1) | 0) {
                            if (!rowIterator.System$Collections$IEnumerator$moveNext()) {
                                throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(rows, System.Int32)]));
                            }
                            var columnIterator = Bridge.getEnumerator(rowIterator[Bridge.geti(rowIterator, "System$Collections$Generic$IEnumerator$1$System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")], T);
                            try {
                                for (var index = row; index < array.length; index = (index + rows) | 0) {
                                    if (!columnIterator.System$Collections$IEnumerator$moveNext()) {
                                        throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(columns, System.Int32)]));
                                    }
                                    array[System.Array.index(index, array)] = columnIterator[Bridge.geti(columnIterator, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")];
                                }
                                if (columnIterator.System$Collections$IEnumerator$moveNext()) {
                                    throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(columns, System.Int32)]));
                                }
                            }
                            finally {
                                if (Bridge.hasValue(columnIterator)) {
                                    columnIterator.System$IDisposable$Dispose();
                                }
                            }
                        }
                        if (rowIterator.System$Collections$IEnumerator$moveNext()) {
                            throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(rows, System.Int32)]));
                        }
                    }
                    finally {
                        if (Bridge.hasValue(rowIterator)) {
                            rowIterator.System$IDisposable$Dispose();
                        }
                    }
                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T)).$ctor1(rows, columns, array);
                }
            }
        },
        fields: {
            Data: null
        },
        props: {
            /**
             * True if the matrix storage format is dense.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1
             * @function IsDense
             * @type boolean
             */
            IsDense: {
                get: function () {
                    return true;
                }
            },
            /**
             * True if all fields of this matrix can be set to any value.
             False if some fields are fixed, like on a diagonal matrix.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1
             * @function IsFullyMutable
             * @type boolean
             */
            IsFullyMutable: {
                get: function () {
                    return true;
                }
            }
        },
        ctors: {
            ctor: function (rows, columns) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).ctor.call(this, rows, columns);
                this.Data = System.Array.init(Bridge.Int.mul(rows, columns), function (){
                    return Bridge.getDefaultValue(T);
                }, T);
            },
            $ctor1: function (rows, columns, data) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).ctor.call(this, rows, columns);
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor1("data");
                }

                if (data.length !== Bridge.Int.mul(rows, columns)) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength, rows*columns", null));
                }

                this.Data = data;
            }
        },
        methods: {
            /**
             * True if the specified field can be set to any value.
             False if the field is fixed, like an off-diagonal field on a diagonal matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1
             * @param   {number}     row       
             * @param   {number}     column
             * @return  {boolean}
             */
            IsMutableAt: function (row, column) {
                return true;
            },
            /**
             * Retrieves the requested element without range checking.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1
             * @param   {number}    row       
             * @param   {number}    column
             * @return  {T}
             */
            At: function (row, column) {
                return this.Data[System.Array.index((((Bridge.Int.mul(column, this.RowCount)) + row) | 0), this.Data)];
            },
            /**
             * Sets the element without range checking.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1
             * @param   {number}    row       
             * @param   {number}    column    
             * @param   {T}         value
             * @return  {void}
             */
            At$1: function (row, column, value) {
                this.Data[System.Array.index((((Bridge.Int.mul(column, this.RowCount)) + row) | 0), this.Data)] = value;
            },
            /**
             * Evaluate the row and column at a specific data index.
             *
             * @instance
             * @private
             * @this MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1
             * @param   {number}          index     
             * @param   {System.Int32}    row       
             * @param   {System.Int32}    column
             * @return  {void}
             */
            RowColumnAtIndex: function (index, row, column) {
                column.v = Bridge.Math.divRem(index, this.RowCount, row);
            },
            Clear: function () {
                System.Array.fill(this.Data, function () {
                    return Bridge.getDefaultValue(T);
                }, 0, this.Data.length);
            },
            ClearUnchecked: function (rowIndex, rowCount, columnIndex, columnCount) {
                if (rowIndex === 0 && columnIndex === 0 && rowCount === this.RowCount && columnCount === this.ColumnCount) {
                    System.Array.fill(this.Data, function () {
                        return Bridge.getDefaultValue(T);
                    }, 0, this.Data.length);
                    return;
                }

                for (var j = columnIndex; j < ((columnIndex + columnCount) | 0); j = (j + 1) | 0) {
                    System.Array.fill(this.Data, function () {
                        return Bridge.getDefaultValue(T);
                    }, ((Bridge.Int.mul(j, this.RowCount) + rowIndex) | 0), rowCount);
                }
            },
            ClearRowsUnchecked: function (rowIndices) {
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    var offset = Bridge.Int.mul(j, this.RowCount);
                    for (var k = 0; k < rowIndices.length; k = (k + 1) | 0) {
                        this.Data[System.Array.index(((offset + rowIndices[System.Array.index(k, rowIndices)]) | 0), this.Data)] = MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero;
                    }
                }
            },
            ClearColumnsUnchecked: function (columnIndices) {
                for (var k = 0; k < columnIndices.length; k = (k + 1) | 0) {
                    System.Array.fill(this.Data, function () {
                        return Bridge.getDefaultValue(T);
                    }, Bridge.Int.mul(columnIndices[System.Array.index(k, columnIndices)], this.RowCount), this.RowCount);
                }
            },
            CopyToUnchecked: function (target, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T));
                if (denseTarget != null) {
                    this.CopyToUnchecked$1(denseTarget);
                    return;
                }


                for (var j = 0, offset = 0; j < this.ColumnCount; j = (j + 1) | 0, offset = (offset + this.RowCount) | 0) {
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        target.At$1(i, j, this.Data[System.Array.index(((i + offset) | 0), this.Data)]);
                    }
                }
            },
            CopyToUnchecked$1: function (target) {
                System.Array.copy(this.Data, 0, target.Data, 0, this.Data.length);
            },
            CopySubMatrixToUnchecked: function (target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T));
                if (denseTarget != null) {
                    this.CopySubMatrixToUnchecked$1(denseTarget, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount);
                    return;
                }



                for (var j = sourceColumnIndex, jj = targetColumnIndex; j < ((sourceColumnIndex + columnCount) | 0); j = (j + 1) | 0, jj = (jj + 1) | 0) {
                    var index = (sourceRowIndex + Bridge.Int.mul(j, this.RowCount)) | 0;
                    for (var ii = targetRowIndex; ii < ((targetRowIndex + rowCount) | 0); ii = (ii + 1) | 0) {
                        target.At$1(ii, jj, this.Data[System.Array.index(Bridge.identity(index, ((index = (index + 1) | 0))), this.Data)]);
                    }
                }
            },
            CopySubMatrixToUnchecked$1: function (target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount) {
                for (var j = sourceColumnIndex, jj = targetColumnIndex; j < ((sourceColumnIndex + columnCount) | 0); j = (j + 1) | 0, jj = (jj + 1) | 0) {
                    System.Array.copy(this.Data, ((Bridge.Int.mul(j, this.RowCount) + sourceRowIndex) | 0), target.Data, ((Bridge.Int.mul(jj, target.RowCount) + targetRowIndex) | 0), rowCount);
                }
            },
            CopySubRowToUnchecked: function (target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                var targetDense = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T));
                if (targetDense != null) {
                    for (var j = 0; j < columnCount; j = (j + 1) | 0) {
                        targetDense.Data[System.Array.index(((j + targetColumnIndex) | 0), targetDense.Data)] = this.Data[System.Array.index(((Bridge.Int.mul((((j + sourceColumnIndex) | 0)), this.RowCount) + rowIndex) | 0), this.Data)];
                    }
                    return;
                }


                for (var j1 = sourceColumnIndex, jj = targetColumnIndex; j1 < ((sourceColumnIndex + columnCount) | 0); j1 = (j1 + 1) | 0, jj = (jj + 1) | 0) {
                    target.At$1(jj, this.Data[System.Array.index((((Bridge.Int.mul(j1, this.RowCount)) + rowIndex) | 0), this.Data)]);
                }
            },
            CopySubColumnToUnchecked: function (target, columnIndex, sourceRowIndex, targetRowIndex, rowCount, existingData) {
                var targetDense = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T));
                if (targetDense != null) {
                    System.Array.copy(this.Data, ((Bridge.Int.mul(columnIndex, this.RowCount) + sourceRowIndex) | 0), targetDense.Data, targetRowIndex, rowCount);
                    return;
                }


                var offset = Bridge.Int.mul(columnIndex, this.RowCount);
                for (var i = sourceRowIndex, ii = targetRowIndex; i < ((sourceRowIndex + rowCount) | 0); i = (i + 1) | 0, ii = (ii + 1) | 0) {
                    target.At$1(ii, this.Data[System.Array.index(((offset + i) | 0), this.Data)]);
                }
            },
            TransposeToUnchecked: function (target, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T));
                if (denseTarget != null) {
                    this.TransposeToUnchecked$1(denseTarget);
                    return;
                }

                var sparseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T));
                if (sparseTarget != null) {
                    this.TransposeToUnchecked$2(sparseTarget);
                    return;
                }


                for (var j = 0, offset = 0; j < this.ColumnCount; j = (j + 1) | 0, offset = (offset + this.RowCount) | 0) {
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        target.At$1(j, i, this.Data[System.Array.index(((i + offset) | 0), this.Data)]);
                    }
                }
            },
            TransposeToUnchecked$1: function (target) {
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    var index = Bridge.Int.mul(j, this.RowCount);
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        target.Data[System.Array.index((((Bridge.Int.mul(i, this.ColumnCount)) + j) | 0), target.Data)] = this.Data[System.Array.index(((index + i) | 0), this.Data)];
                    }
                }
            },
            TransposeToUnchecked$2: function (target) {
                var rowPointers = target.RowPointers;
                var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                var values = new (System.Collections.Generic.List$1(T)).ctor();

                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    rowPointers[System.Array.index(j, rowPointers)] = values.Count;
                    var index = Bridge.Int.mul(j, this.RowCount);
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, this.Data[System.Array.index(((index + i) | 0), this.Data)], T)) {
                            values.add(this.Data[System.Array.index(((index + i) | 0), this.Data)]);
                            columnIndices.add(i);
                        }
                    }
                }

                rowPointers[System.Array.index(this.ColumnCount, rowPointers)] = values.Count;
                target.ColumnIndices = columnIndices.ToArray();
                target.Values = values.ToArray();
            },
            TransposeSquareInplaceUnchecked: function () {
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    var index = Bridge.Int.mul(j, this.RowCount);
                    for (var i = 0; i < j; i = (i + 1) | 0) {
                        var swap = this.Data[System.Array.index(((index + i) | 0), this.Data)];
                        this.Data[System.Array.index(((index + i) | 0), this.Data)] = this.Data[System.Array.index(((Bridge.Int.mul(i, this.ColumnCount) + j) | 0), this.Data)];
                        this.Data[System.Array.index(((Bridge.Int.mul(i, this.ColumnCount) + j) | 0), this.Data)] = swap;
                    }
                }
            },
            ToRowMajorArray: function () {
                var ret = System.Array.init(this.Data.length, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var offset = Bridge.Int.mul(i, this.ColumnCount);
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        ret[System.Array.index(((offset + j) | 0), ret)] = this.Data[System.Array.index((((Bridge.Int.mul(j, this.RowCount)) + i) | 0), this.Data)];
                    }
                }
                return ret;
            },
            ToColumnMajorArray: function () {
                var ret = System.Array.init(this.Data.length, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                System.Array.copy(this.Data, 0, ret, 0, this.Data.length);
                return ret;
            },
            ToRowArrays: function () {
                var ret = System.Array.init(this.RowCount, null, System.Array.type(T));

                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var row = System.Array.init(this.ColumnCount, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        row[System.Array.index(j, row)] = this.Data[System.Array.index(((Bridge.Int.mul(j, this.RowCount) + i) | 0), this.Data)];
                    }
                    ret[System.Array.index(i, ret)] = row;
                }

                return ret;
            },
            ToColumnArrays: function () {
                var ret = System.Array.init(this.ColumnCount, null, System.Array.type(T));

                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    var column = System.Array.init(this.RowCount, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    System.Array.copy(this.Data, Bridge.Int.mul(j, this.RowCount), column, 0, this.RowCount);
                    ret[System.Array.index(j, ret)] = column;
                }

                return ret;
            },
            ToArray: function () {
                var ret = System.Array.create(function (){
                    return Bridge.getDefaultValue(T);
                }, null, T, this.RowCount, this.ColumnCount);
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        ret.set([i, j], this.Data[System.Array.index((((Bridge.Int.mul(j, this.RowCount)) + i) | 0), this.Data)]);
                    }
                }
                return ret;
            },
            AsColumnMajorArray: function () {
                return this.Data;
            },
            Enumerate: function () {
                return this.Data;
            },
            EnumerateIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        index,
                        j,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        index = 0;
                                            j = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( j < this.ColumnCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 9;
                                        continue;
                                    }
                                    case 2: {
                                        i = 0;
                                            $step = 3;
                                            continue;
                                    }
                                    case 3: {
                                        if ( i < this.RowCount ) {
                                                $step = 4;
                                                continue;
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 4: {
                                        $enumerator.current = { Item1: i, Item2: j, Item3: this.Data[System.Array.index(index, this.Data)] };
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        index = (index + 1) | 0;
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {
                                        i = (i + 1) | 0;
                                        $step = 3;
                                        continue;
                                    }
                                    case 7: {
                                        $step = 8;
                                        continue;
                                    }
                                    case 8: {
                                        j = (j + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 9: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            EnumerateNonZero: function () {
                return System.Linq.Enumerable.from(this.Data, T).where(function (x) {
                        return !Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, x, T);
                    });
            },
            EnumerateNonZeroIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        index,
                        j,
                        i,
                        x,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        index = 0;
                                            j = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( j < this.ColumnCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 11;
                                        continue;
                                    }
                                    case 2: {
                                        i = 0;
                                            $step = 3;
                                            continue;
                                    }
                                    case 3: {
                                        if ( i < this.RowCount ) {
                                                $step = 4;
                                                continue;
                                            }
                                        $step = 9;
                                        continue;
                                    }
                                    case 4: {
                                        x = this.Data[System.Array.index(index, this.Data)];
                                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, x, T)) {
                                                $step = 5;
                                                continue;
                                            } 
                                            $step = 7;
                                            continue;
                                    }
                                    case 5: {
                                        $enumerator.current = { Item1: i, Item2: j, Item3: x };
                                            $step = 6;
                                            return true;
                                    }
                                    case 6: {
                                        $step = 7;
                                        continue;
                                    }
                                    case 7: {
                                        index = (index + 1) | 0;
                                        $step = 8;
                                        continue;
                                    }
                                    case 8: {
                                        i = (i + 1) | 0;
                                        $step = 3;
                                        continue;
                                    }
                                    case 9: {
                                        $step = 10;
                                        continue;
                                    }
                                    case 10: {
                                        j = (j + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 11: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            Find: function (predicate, zeros) {
                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    if (predicate(this.Data[System.Array.index(i, this.Data)])) {
                        var row = { }, column = { };
                        this.RowColumnAtIndex(i, row, column);
                        return { Item1: row.v, Item2: column.v, Item3: this.Data[System.Array.index(i, this.Data)] };
                    }
                }
                return null;
            },
            Find2Unchecked: function (TOther, other, predicate, zeros) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(TOther));
                if (denseOther != null) {
                    var otherData = denseOther.Data;
                    for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                        if (predicate(this.Data[System.Array.index(i, this.Data)], otherData[System.Array.index(i, otherData)])) {
                            var row = { }, column = { };
                            this.RowColumnAtIndex(i, row, column);
                            return { Item1: row.v, Item2: column.v, Item3: this.Data[System.Array.index(i, this.Data)], Item4: otherData[System.Array.index(i, otherData)] };

                        }
                    }
                    return null;
                }

                var diagonalOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(TOther));
                if (diagonalOther != null) {
                    var otherData1 = diagonalOther.Data;
                    var otherZero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;
                    var k = 0;
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        for (var i1 = 0; i1 < this.RowCount; i1 = (i1 + 1) | 0) {
                            if (predicate(this.Data[System.Array.index(k, this.Data)], i1 === j ? otherData1[System.Array.index(i1, otherData1)] : otherZero)) {
                                return { Item1: i1, Item2: j, Item3: this.Data[System.Array.index(k, this.Data)], Item4: i1 === j ? otherData1[System.Array.index(i1, otherData1)] : otherZero };
                            }
                            k = (k + 1) | 0;
                        }
                    }
                    return null;
                }

                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(TOther));
                if (sparseOther != null) {
                    var otherRowPointers = sparseOther.RowPointers;
                    var otherColumnIndices = sparseOther.ColumnIndices;
                    var otherValues = sparseOther.Values;
                    var otherZero1 = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;
                    var k1 = 0;
                    for (var row1 = 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                        for (var col = 0; col < this.ColumnCount; col = (col + 1) | 0) {
                            if (k1 < otherRowPointers[System.Array.index(((row1 + 1) | 0), otherRowPointers)] && otherColumnIndices[System.Array.index(k1, otherColumnIndices)] === col) {
                                if (predicate(this.Data[System.Array.index(((Bridge.Int.mul(col, this.RowCount) + row1) | 0), this.Data)], otherValues[System.Array.index(k1, otherValues)])) {
                                    return { Item1: row1, Item2: col, Item3: this.Data[System.Array.index(((Bridge.Int.mul(col, this.RowCount) + row1) | 0), this.Data)], Item4: otherValues[System.Array.index(k1, otherValues)] };
                                }
                                k1 = (k1 + 1) | 0;
                            } else {
                                if (predicate(this.Data[System.Array.index(((Bridge.Int.mul(col, this.RowCount) + row1) | 0), this.Data)], otherZero1)) {
                                    return { Item1: row1, Item2: col, Item3: this.Data[System.Array.index(((Bridge.Int.mul(col, this.RowCount) + row1) | 0), this.Data)], Item4: otherValues[System.Array.index(k1, otherValues)] };
                                }
                            }
                        }
                    }
                    return null;
                }


                return MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).prototype.Find2Unchecked.call(this, TOther, other, predicate, zeros);
            },
            MapInplace: function (f, zeros) {

                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    this.Data[System.Array.index(i, this.Data)] = f(this.Data[System.Array.index(i, this.Data)]);
                }

            },
            MapIndexedInplace: function (f, zeros) {

                var index = Bridge.Int.mul(0, this.RowCount);
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        this.Data[System.Array.index(index, this.Data)] = f(i, j, this.Data[System.Array.index(index, this.Data)]);
                        index = (index + 1) | 0;
                    }
                }

            },
            MapToUnchecked: function (TU, target, f, zeros, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(TU));
                if (denseTarget != null) {

                    for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                        denseTarget.Data[System.Array.index(i, denseTarget.Data)] = f(this.Data[System.Array.index(i, this.Data)]);
                    }

                    return;
                }


                var index = 0;
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    for (var i1 = 0; i1 < this.RowCount; i1 = (i1 + 1) | 0) {
                        target.At$1(i1, j, f(this.Data[System.Array.index(Bridge.identity(index, ((index = (index + 1) | 0))), this.Data)]));
                    }
                }
            },
            MapIndexedToUnchecked: function (TU, target, f, zeros, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(TU));
                if (denseTarget != null) {

                    var index = Bridge.Int.mul(0, this.RowCount);
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                            denseTarget.Data[System.Array.index(index, denseTarget.Data)] = f(i, j, this.Data[System.Array.index(index, this.Data)]);
                            index = (index + 1) | 0;
                        }
                    }

                    return;
                }


                var index2 = 0;
                for (var j1 = 0; j1 < this.ColumnCount; j1 = (j1 + 1) | 0) {
                    for (var i1 = 0; i1 < this.RowCount; i1 = (i1 + 1) | 0) {
                        target.At$1(i1, j1, f(i1, j1, this.Data[System.Array.index(Bridge.identity(index2, ((index2 = (index2 + 1) | 0))), this.Data)]));
                    }
                }
            },
            MapSubMatrixIndexedToUnchecked: function (TU, target, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(TU));
                if (denseTarget != null) {

                    for (var j = 0; j < columnCount; j = (j + 1) | 0) {
                        var sourceIndex = (sourceRowIndex + Bridge.Int.mul((((j + sourceColumnIndex) | 0)), this.RowCount)) | 0;
                        var targetIndex = (targetRowIndex + Bridge.Int.mul((((j + targetColumnIndex) | 0)), target.RowCount)) | 0;
                        for (var i = 0; i < rowCount; i = (i + 1) | 0) {
                            denseTarget.Data[System.Array.index(Bridge.identity(targetIndex, ((targetIndex = (targetIndex + 1) | 0))), denseTarget.Data)] = f(((targetRowIndex + i) | 0), ((targetColumnIndex + j) | 0), this.Data[System.Array.index(Bridge.identity(sourceIndex, ((sourceIndex = (sourceIndex + 1) | 0))), this.Data)]);
                        }
                    }

                    return;
                }



                for (var j1 = sourceColumnIndex, jj = targetColumnIndex; j1 < ((sourceColumnIndex + columnCount) | 0); j1 = (j1 + 1) | 0, jj = (jj + 1) | 0) {
                    var index = (sourceRowIndex + Bridge.Int.mul(j1, this.RowCount)) | 0;
                    for (var ii = targetRowIndex; ii < ((targetRowIndex + rowCount) | 0); ii = (ii + 1) | 0) {
                        target.At$1(ii, jj, f(ii, jj, this.Data[System.Array.index(Bridge.identity(index, ((index = (index + 1) | 0))), this.Data)]));
                    }
                }
            },
            FoldByRowUnchecked: function (TU, target, f, finalize, state, zeros) {
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var s = state[System.Array.index(i, state)];
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        s = f(s, this.Data[System.Array.index(((Bridge.Int.mul(j, this.RowCount) + i) | 0), this.Data)]);
                    }
                    target[System.Array.index(i, target)] = finalize(s, this.ColumnCount);
                }
            },
            FoldByColumnUnchecked: function (TU, target, f, finalize, state, zeros) {
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    var offset = Bridge.Int.mul(j, this.RowCount);
                    var s = state[System.Array.index(j, state)];
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        s = f(s, this.Data[System.Array.index(((offset + i) | 0), this.Data)]);
                    }
                    target[System.Array.index(j, target)] = finalize(s, this.RowCount);
                }
            },
            Fold2Unchecked: function (TOther, TState, other, f, state, zeros) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(TOther));
                if (denseOther != null) {
                    var otherData = denseOther.Data;
                    for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                        state = f(state, this.Data[System.Array.index(i, this.Data)], otherData[System.Array.index(i, otherData)]);
                    }
                    return state;
                }

                var diagonalOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(TOther));
                if (diagonalOther != null) {
                    var otherData1 = diagonalOther.Data;
                    var otherZero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;
                    var k = 0;
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        for (var i1 = 0; i1 < this.RowCount; i1 = (i1 + 1) | 0) {
                            state = f(state, this.Data[System.Array.index(k, this.Data)], i1 === j ? otherData1[System.Array.index(i1, otherData1)] : otherZero);
                            k = (k + 1) | 0;
                        }
                    }
                    return state;
                }

                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(TOther));
                if (sparseOther != null) {
                    var otherRowPointers = sparseOther.RowPointers;
                    var otherColumnIndices = sparseOther.ColumnIndices;
                    var otherValues = sparseOther.Values;
                    var otherZero1 = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;
                    var k1 = 0;
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        for (var col = 0; col < this.ColumnCount; col = (col + 1) | 0) {
                            if (k1 < otherRowPointers[System.Array.index(((row + 1) | 0), otherRowPointers)] && otherColumnIndices[System.Array.index(k1, otherColumnIndices)] === col) {
                                state = f(state, this.Data[System.Array.index(((Bridge.Int.mul(col, this.RowCount) + row) | 0), this.Data)], otherValues[System.Array.index(Bridge.identity(k1, ((k1 = (k1 + 1) | 0))), otherValues)]);
                            } else {
                                state = f(state, this.Data[System.Array.index(((Bridge.Int.mul(col, this.RowCount) + row) | 0), this.Data)], otherZero1);
                            }
                        }
                    }
                    return state;
                }


                return MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).prototype.Fold2Unchecked.call(this, TOther, TState, other, f, state, zeros);
            }
        }
    }; });

    Bridge.define("MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1", function (T) { return {
        inherits: [MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T)],
        statics: {
            methods: {
                OfVector: function (vector) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).ctor(vector.Length);
                    vector.CopyToUnchecked(storage, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                    return storage;
                },
                OfValue: function (length, value) {
                    if (length < 1) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("length", System.String.format("Resources.ArgumentLessThanOne", [Bridge.box(length, System.Int32)]));
                    }

                    var data = System.Array.init(length, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);

                    for (var i = 0; i < data.length; i = (i + 1) | 0) {
                        data[System.Array.index(i, data)] = value;
                    }

                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).$ctor1(length, data);
                },
                OfInit: function (length, init) {
                    if (length < 1) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("length", System.String.format("Resources.ArgumentLessThanOne,{0}", [Bridge.box(length, System.Int32)]));
                    }

                    var data = System.Array.init(length, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);

                    for (var i = 0; i < data.length; i = (i + 1) | 0) {
                        data[System.Array.index(i, data)] = init(i);
                    }

                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).$ctor1(length, data);
                },
                OfEnumerable: function (data) {
                    var $t;
                    if (data == null) {
                        throw new System.ArgumentNullException.$ctor1("data");
                    }

                    var arrayData = Bridge.as(data, System.Array.type(T));
                    if (arrayData != null) {
                        var copy = System.Array.init(arrayData.length, function (){
                            return Bridge.getDefaultValue(T);
                        }, T);
                        System.Array.copy(arrayData, 0, copy, 0, arrayData.length);
                        return new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).$ctor1(copy.length, copy);
                    }

                    var array = ($t = T, System.Linq.Enumerable.from(data, $t).ToArray($t));
                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).$ctor1(array.length, array);
                },
                OfIndexedEnumerable: function (length, data) {
                    var $t;
                    if (data == null) {
                        throw new System.ArgumentNullException.$ctor1("data");
                    }

                    var array = System.Array.init(length, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    $t = Bridge.getEnumerator(data, System.Tuple$2(System.Int32,T));
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            array[System.Array.index(item.Item1, array)] = item.Item2;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).$ctor1(array.length, array);
                }
            }
        },
        fields: {
            Data: null
        },
        props: {
            /**
             * True if the vector storage format is dense.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1
             * @function IsDense
             * @type boolean
             */
            IsDense: {
                get: function () {
                    return true;
                }
            }
        },
        ctors: {
            ctor: function (length) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).ctor.call(this, length);
                this.Data = System.Array.init(length, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
            },
            $ctor1: function (length, data) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).ctor.call(this, length);
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor1("data");
                }

                if (data.length !== length) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength {0}", [Bridge.box(length, System.Int32)]));
                }

                this.Data = data;
            }
        },
        methods: {
            /**
             * Retrieves the requested element without range checking.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1
             * @param   {number}    index
             * @return  {T}
             */
            At: function (index) {
                return this.Data[System.Array.index(index, this.Data)];
            },
            /**
             * Sets the element without range checking.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1
             * @param   {number}    index    
             * @param   {T}         value
             * @return  {void}
             */
            At$1: function (index, value) {
                this.Data[System.Array.index(index, this.Data)] = value;
            },
            Clear: function () {
                System.Array.fill(this.Data, function () {
                    return Bridge.getDefaultValue(T);
                }, 0, this.Data.length);
            },
            Clear$1: function (index, count) {
                System.Array.fill(this.Data, function () {
                    return Bridge.getDefaultValue(T);
                }, index, count);
            },
            CopyToUnchecked: function (target, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T));
                if (denseTarget != null) {
                    if (!Bridge.referenceEquals(this, denseTarget)) {
                        System.Array.copy(this.Data, 0, denseTarget.Data, 0, this.Data.length);
                    }

                    return;
                }

                var sparseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T));
                if (sparseTarget != null) {
                    var indices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();

                    for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                        var item = this.Data[System.Array.index(i, this.Data)];
                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, item, T)) {
                            values.add(item);
                            indices.add(i);
                        }
                    }

                    sparseTarget.Indices = indices.ToArray();
                    sparseTarget.Values = values.ToArray();
                    sparseTarget.ValueCount = values.Count;
                    return;
                }


                for (var i1 = 0; i1 < this.Data.length; i1 = (i1 + 1) | 0) {
                    target.At$1(i1, this.Data[System.Array.index(i1, this.Data)]);
                }
            },
            CopyToRowUnchecked: function (target, rowIndex, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T));
                if (denseTarget != null) {
                    for (var j = 0; j < this.Data.length; j = (j + 1) | 0) {
                        denseTarget.Data[System.Array.index(((Bridge.Int.mul(j, target.RowCount) + rowIndex) | 0), denseTarget.Data)] = this.Data[System.Array.index(j, this.Data)];
                    }
                    return;
                }


                for (var j1 = 0; j1 < this.Length; j1 = (j1 + 1) | 0) {
                    target.At$1(rowIndex, j1, this.Data[System.Array.index(j1, this.Data)]);
                }
            },
            CopyToColumnUnchecked: function (target, columnIndex, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T));
                if (denseTarget != null) {
                    System.Array.copy(this.Data, 0, denseTarget.Data, Bridge.Int.mul(columnIndex, denseTarget.RowCount), this.Data.length);
                    return;
                }


                for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                    target.At$1(i, columnIndex, this.Data[System.Array.index(i, this.Data)]);
                }
            },
            CopySubVectorToUnchecked: function (target, sourceIndex, targetIndex, count, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T));
                if (denseTarget != null) {
                    System.Array.copy(this.Data, sourceIndex, denseTarget.Data, targetIndex, count);
                    return;
                }


                MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).prototype.CopySubVectorToUnchecked.call(this, target, sourceIndex, targetIndex, count, existingData);
            },
            CopyToSubRowUnchecked: function (target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T));
                if (denseTarget != null) {
                    for (var j = 0; j < this.Data.length; j = (j + 1) | 0) {
                        denseTarget.Data[System.Array.index(((Bridge.Int.mul((((j + targetColumnIndex) | 0)), target.RowCount) + rowIndex) | 0), denseTarget.Data)] = this.Data[System.Array.index(((j + sourceColumnIndex) | 0), this.Data)];
                    }
                    return;
                }


                for (var j1 = sourceColumnIndex, jj = targetColumnIndex; j1 < ((sourceColumnIndex + columnCount) | 0); j1 = (j1 + 1) | 0, jj = (jj + 1) | 0) {
                    target.At$1(rowIndex, jj, this.Data[System.Array.index(j1, this.Data)]);
                }
            },
            CopyToSubColumnUnchecked: function (target, columnIndex, sourceRowIndex, targetRowIndex, rowCount, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T));
                if (denseTarget != null) {
                    System.Array.copy(this.Data, sourceRowIndex, denseTarget.Data, ((Bridge.Int.mul(columnIndex, denseTarget.RowCount) + targetRowIndex) | 0), rowCount);
                    return;
                }


                for (var i = sourceRowIndex, ii = targetRowIndex; i < ((sourceRowIndex + rowCount) | 0); i = (i + 1) | 0, ii = (ii + 1) | 0) {
                    target.At$1(ii, columnIndex, this.Data[System.Array.index(i, this.Data)]);
                }
            },
            ToArray: function () {
                var ret = System.Array.init(this.Data.length, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                System.Array.copy(this.Data, 0, ret, 0, this.Data.length);
                return ret;
            },
            AsArray: function () {
                return this.Data;
            },
            Enumerate: function () {
                return this.Data;
            },
            EnumerateIndexed: function () {
                return System.Linq.Enumerable.from(this.Data, T).select(function (t, i) {
                        return { Item1: i, Item2: t };
                    });
            },
            EnumerateNonZero: function () {
                return System.Linq.Enumerable.from(this.Data, T).where(function (x) {
                        return !Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, x, T);
                    });
            },
            EnumerateNonZeroIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$2(System.Int32,T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$2(System.Int32,T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.Data.length ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 2: {
                                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, this.Data[System.Array.index(i, this.Data)], T)) {
                                                $step = 3;
                                                continue;
                                            } 
                                            $step = 5;
                                            continue;
                                    }
                                    case 3: {
                                        $enumerator.current = { Item1: i, Item2: this.Data[System.Array.index(i, this.Data)] };
                                            $step = 4;
                                            return true;
                                    }
                                    case 4: {
                                        $step = 5;
                                        continue;
                                    }
                                    case 5: {
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 7: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            Find: function (predicate, zeros) {
                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    if (predicate(this.Data[System.Array.index(i, this.Data)])) {
                        return { Item1: i, Item2: this.Data[System.Array.index(i, this.Data)] };
                    }
                }
                return null;
            },
            Find2Unchecked: function (TOther, other, predicate, zeros) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(TOther));
                if (denseOther != null) {
                    var otherData = denseOther.Data;
                    for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                        if (predicate(this.Data[System.Array.index(i, this.Data)], otherData[System.Array.index(i, otherData)])) {
                            return { Item1: i, Item2: this.Data[System.Array.index(i, this.Data)], Item3: otherData[System.Array.index(i, otherData)] };

                        }
                    }
                    return null;
                }

                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(TOther));
                if (sparseOther != null) {
                    var otherIndices = sparseOther.Indices;
                    var otherValues = sparseOther.Values;
                    var otherValueCount = sparseOther.ValueCount;
                    var otherZero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;
                    var k = 0;
                    for (var i1 = 0; i1 < this.Data.length; i1 = (i1 + 1) | 0) {
                        if (k < otherValueCount && otherIndices[System.Array.index(k, otherIndices)] === i1) {
                            if (predicate(this.Data[System.Array.index(i1, this.Data)], otherValues[System.Array.index(k, otherValues)])) {
                                return { Item1: i1, Item2: this.Data[System.Array.index(i1, this.Data)], Item3: otherValues[System.Array.index(k, otherValues)] };
                            }
                            k = (k + 1) | 0;
                        } else {
                            if (predicate(this.Data[System.Array.index(i1, this.Data)], otherZero)) {
                                return { Item1: i1, Item2: this.Data[System.Array.index(i1, this.Data)], Item3: otherZero };
                            }
                        }
                    }
                    return null;
                }


                return MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).prototype.Find2Unchecked.call(this, TOther, other, predicate, zeros);
            },
            MapInplace: function (f, zeros) {

                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    this.Data[System.Array.index(i, this.Data)] = f(this.Data[System.Array.index(i, this.Data)]);
                }

            },
            MapIndexedInplace: function (f, zeros) {

                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    this.Data[System.Array.index(i, this.Data)] = f(i, this.Data[System.Array.index(i, this.Data)]);
                }

            },
            MapToUnchecked: function (TU, target, f, zeros, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(TU));
                if (denseTarget != null) {

                    for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                        denseTarget.Data[System.Array.index(i, denseTarget.Data)] = f(this.Data[System.Array.index(i, this.Data)]);
                    }

                    return;
                }


                for (var i1 = 0; i1 < this.Length; i1 = (i1 + 1) | 0) {
                    target.At$1(i1, f(this.Data[System.Array.index(i1, this.Data)]));
                }
            },
            MapIndexedToUnchecked: function (TU, target, f, zeros, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(TU));
                if (denseTarget != null) {

                    for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                        denseTarget.Data[System.Array.index(i, denseTarget.Data)] = f(i, this.Data[System.Array.index(i, this.Data)]);
                    }

                    return;
                }


                for (var i1 = 0; i1 < this.Length; i1 = (i1 + 1) | 0) {
                    target.At$1(i1, f(i1, this.Data[System.Array.index(i1, this.Data)]));
                }
            },
            Map2ToUnchecked: function (target, other, f, zeros, existingData) {
                if (Bridge.is(target, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T))) {
                    var intermediate = new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).ctor(target.Length);
                    this.Map2ToUnchecked(intermediate, other, f, zeros, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                    intermediate.CopyTo(target, existingData);
                    return;
                }

                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T));
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T));
                if (denseTarget != null && denseOther != null) {

                    for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                        denseTarget.Data[System.Array.index(i, denseTarget.Data)] = f(this.Data[System.Array.index(i, this.Data)], denseOther.Data[System.Array.index(i, denseOther.Data)]);
                    }


                    return;
                }

                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T));
                if (denseTarget != null && sparseOther != null) {
                    var targetData = denseTarget.Data;
                    var otherIndices = sparseOther.Indices;
                    var otherValues = sparseOther.Values;
                    var otherValueCount = sparseOther.ValueCount;

                    var k = 0;
                    for (var i1 = 0; i1 < this.Data.length; i1 = (i1 + 1) | 0) {
                        if (k < otherValueCount && otherIndices[System.Array.index(k, otherIndices)] === i1) {
                            targetData[System.Array.index(i1, targetData)] = f(this.Data[System.Array.index(i1, this.Data)], otherValues[System.Array.index(k, otherValues)]);
                            k = (k + 1) | 0;
                        } else {
                            targetData[System.Array.index(i1, targetData)] = f(this.Data[System.Array.index(i1, this.Data)], MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero);
                        }
                    }

                    return;
                }

                MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).prototype.Map2ToUnchecked.call(this, target, other, f, zeros, existingData);
            },
            Fold2Unchecked: function (TOther, TState, other, f, state, zeros) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(TOther));
                if (denseOther != null) {
                    var otherData = denseOther.Data;
                    for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                        state = f(state, this.Data[System.Array.index(i, this.Data)], otherData[System.Array.index(i, otherData)]);
                    }

                    return state;
                }

                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(TOther));
                if (sparseOther != null) {
                    var otherIndices = sparseOther.Indices;
                    var otherValues = sparseOther.Values;
                    var otherValueCount = sparseOther.ValueCount;
                    var otherZero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Vector.Zero;

                    var k = 0;
                    for (var i1 = 0; i1 < this.Data.length; i1 = (i1 + 1) | 0) {
                        if (k < otherValueCount && otherIndices[System.Array.index(k, otherIndices)] === i1) {
                            state = f(state, this.Data[System.Array.index(i1, this.Data)], otherValues[System.Array.index(k, otherValues)]);
                            k = (k + 1) | 0;
                        } else {
                            state = f(state, this.Data[System.Array.index(i1, this.Data)], otherZero);
                        }
                    }

                    return state;
                }

                return MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).prototype.Fold2Unchecked.call(this, TOther, TState, other, f, state, zeros);
            }
        }
    }; });

    Bridge.define("MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1", function (T) { return {
        inherits: [MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T)],
        statics: {
            methods: {
                OfMatrix: function (matrix) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T)).ctor(matrix.RowCount, matrix.ColumnCount);
                    matrix.CopyToUnchecked(storage, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                    return storage;
                },
                OfArray: function (array) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T)).ctor(System.Array.getLength(array, 0), System.Array.getLength(array, 1));
                    for (var i = 0; i < storage.RowCount; i = (i + 1) | 0) {
                        for (var j = 0; j < storage.ColumnCount; j = (j + 1) | 0) {
                            if (i === j) {
                                storage.Data[System.Array.index(i, storage.Data)] = array.get([i, j]);
                            } else if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, array.get([i, j]), T)) {
                                throw new System.ArgumentException.$ctor1("Cannot set an off-diagonal element in a diagonal matrix.");
                            }
                        }
                    }
                    return storage;
                },
                OfValue: function (rows, columns, diagonalValue) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T)).ctor(rows, columns);
                    for (var i = 0; i < storage.Data.length; i = (i + 1) | 0) {
                        storage.Data[System.Array.index(i, storage.Data)] = diagonalValue;
                    }
                    return storage;
                },
                OfInit: function (rows, columns, init) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T)).ctor(rows, columns);
                    for (var i = 0; i < storage.Data.length; i = (i + 1) | 0) {
                        storage.Data[System.Array.index(i, storage.Data)] = init(i);
                    }
                    return storage;
                },
                OfEnumerable: function (rows, columns, data) {
                    var $t;
                    if (data == null) {
                        throw new System.ArgumentNullException.$ctor1("data");
                    }

                    var arrayData = Bridge.as(data, System.Array.type(T));
                    if (arrayData != null) {
                        var copy = System.Array.init(arrayData.length, function (){
                            return Bridge.getDefaultValue(T);
                        }, T);
                        System.Array.copy(arrayData, 0, copy, 0, arrayData.length);
                        return new (MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T)).$ctor1(rows, columns, copy);
                    }

                    return new (MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T)).$ctor1(rows, columns, ($t = T, System.Linq.Enumerable.from(data, $t).ToArray($t)));
                },
                OfIndexedEnumerable: function (rows, columns, data) {
                    var $t;
                    if (data == null) {
                        throw new System.ArgumentNullException.$ctor1("data");
                    }

                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T)).ctor(rows, columns);
                    $t = Bridge.getEnumerator(data, System.Tuple$2(System.Int32,T));
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            storage.Data[System.Array.index(item.Item1, storage.Data)] = item.Item2;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return storage;
                }
            }
        },
        fields: {
            Data: null
        },
        props: {
            /**
             * True if the matrix storage format is dense.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1
             * @function IsDense
             * @type boolean
             */
            IsDense: {
                get: function () {
                    return false;
                }
            },
            /**
             * True if all fields of this matrix can be set to any value.
             False if some fields are fixed, like on a diagonal matrix.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1
             * @function IsFullyMutable
             * @type boolean
             */
            IsFullyMutable: {
                get: function () {
                    return false;
                }
            }
        },
        ctors: {
            ctor: function (rows, columns) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).ctor.call(this, rows, columns);
                this.Data = System.Array.init(Math.min(rows, columns), function (){
                    return Bridge.getDefaultValue(T);
                }, T);
            },
            $ctor1: function (rows, columns, data) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).ctor.call(this, rows, columns);
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor1("data");
                }

                if (data.length !== Math.min(rows, columns)) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(Math.min(rows, columns), System.Int32)]));
                }

                this.Data = data;
            }
        },
        methods: {
            /**
             * True if the specified field can be set to any value.
             False if the field is fixed, like an off-diagonal field on a diagonal matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1
             * @param   {number}     row       
             * @param   {number}     column
             * @return  {boolean}
             */
            IsMutableAt: function (row, column) {
                return row === column;
            },
            /**
             * Retrieves the requested element without range checking.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1
             * @param   {number}    row       
             * @param   {number}    column
             * @return  {T}
             */
            At: function (row, column) {
                return row === column ? this.Data[System.Array.index(row, this.Data)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero;
            },
            /**
             * Sets the element without range checking.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1
             * @param   {number}    row       
             * @param   {number}    column    
             * @param   {T}         value
             * @return  {void}
             */
            At$1: function (row, column, value) {
                if (row === column) {
                    this.Data[System.Array.index(row, this.Data)] = value;
                } else if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, value, T)) {
                    throw new System.IndexOutOfRangeException.$ctor1("Cannot set an off-diagonal element in a diagonal matrix.");
                }
            },
            /**
             * Returns a hash code for this instance.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1
             * @return  {number}        A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
             */
            getHashCode: function () {
                var hashNum = Math.min(this.Data.length, 25);
                var hash = 17;
                for (var i = 0; i < hashNum; i = (i + 1) | 0) {
                    hash = (Bridge.Int.mul(hash, 31) + Bridge.getHashCode(this.Data[i])) | 0;
                }
                return hash;
            },
            Clear: function () {
                System.Array.fill(this.Data, function () {
                    return Bridge.getDefaultValue(T);
                }, 0, this.Data.length);
            },
            ClearUnchecked: function (rowIndex, rowCount, columnIndex, columnCount) {
                var beginInclusive = Math.max(rowIndex, columnIndex);
                var endExclusive = Math.min(((rowIndex + rowCount) | 0), ((columnIndex + columnCount) | 0));
                if (endExclusive > beginInclusive) {
                    System.Array.fill(this.Data, function () {
                        return Bridge.getDefaultValue(T);
                    }, beginInclusive, ((endExclusive - beginInclusive) | 0));
                }
            },
            ClearRowsUnchecked: function (rowIndices) {
                for (var i = 0; i < rowIndices.length; i = (i + 1) | 0) {
                    this.Data[System.Array.index(rowIndices[System.Array.index(i, rowIndices)], this.Data)] = MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero;
                }
            },
            ClearColumnsUnchecked: function (columnIndices) {
                for (var i = 0; i < columnIndices.length; i = (i + 1) | 0) {
                    this.Data[System.Array.index(columnIndices[System.Array.index(i, columnIndices)], this.Data)] = MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero;
                }
            },
            CopyToUnchecked: function (target, existingData) {
                var diagonalTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T));
                if (diagonalTarget != null) {
                    this.CopyToUnchecked$2(diagonalTarget);
                    return;
                }

                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T));
                if (denseTarget != null) {
                    this.CopyToUnchecked$1(denseTarget, existingData);
                    return;
                }

                var sparseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T));
                if (sparseTarget != null) {
                    this.CopyToUnchecked$3(sparseTarget, existingData);
                    return;
                }


                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.Clear();
                }

                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    target.At$1(i, i, this.Data[System.Array.index(i, this.Data)]);
                }
            },
            CopyToUnchecked$2: function (target) {
                System.Array.copy(this.Data, 0, target.Data, 0, this.Data.length);
            },
            CopyToUnchecked$3: function (target, existingData) {
                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.Clear();
                }

                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    target.At$1(i, i, this.Data[System.Array.index(i, this.Data)]);
                }
            },
            CopyToUnchecked$1: function (target, existingData) {
                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.Clear();
                }

                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    target.Data[System.Array.index(Bridge.Int.mul(i, (((target.RowCount + 1) | 0))), target.Data)] = this.Data[System.Array.index(i, this.Data)];
                }
            },
            CopySubMatrixToUnchecked: function (target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T));
                if (denseTarget != null) {
                    this.CopySubMatrixToUnchecked$1(denseTarget, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, existingData);
                    return;
                }

                var diagonalTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(T));
                if (diagonalTarget != null) {
                    this.CopySubMatrixToUnchecked$2(diagonalTarget, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount);
                    return;
                }



                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
                }

                if (sourceRowIndex === sourceColumnIndex) {
                    for (var i = 0; i < Math.min(columnCount, rowCount); i = (i + 1) | 0) {
                        target.At$1(((targetRowIndex + i) | 0), ((targetColumnIndex + i) | 0), this.Data[System.Array.index(((sourceRowIndex + i) | 0), this.Data)]);
                    }
                } else if (sourceRowIndex > sourceColumnIndex && ((sourceColumnIndex + columnCount) | 0) > sourceRowIndex) {
                    var columnInit = (sourceRowIndex - sourceColumnIndex) | 0;
                    for (var i1 = 0; i1 < Math.min(((columnCount - columnInit) | 0), rowCount); i1 = (i1 + 1) | 0) {
                        target.At$1(((targetRowIndex + i1) | 0), ((((columnInit + targetColumnIndex) | 0) + i1) | 0), this.Data[System.Array.index(((sourceRowIndex + i1) | 0), this.Data)]);
                    }
                } else if (sourceRowIndex < sourceColumnIndex && ((sourceRowIndex + rowCount) | 0) > sourceColumnIndex) {
                    var rowInit = (sourceColumnIndex - sourceRowIndex) | 0;
                    for (var i2 = 0; i2 < Math.min(columnCount, ((rowCount - rowInit) | 0)); i2 = (i2 + 1) | 0) {
                        target.At$1(((((rowInit + targetRowIndex) | 0) + i2) | 0), ((targetColumnIndex + i2) | 0), this.Data[System.Array.index(((sourceColumnIndex + i2) | 0), this.Data)]);
                    }
                }
            },
            CopySubMatrixToUnchecked$2: function (target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount) {
                if (((sourceRowIndex - sourceColumnIndex) | 0) !== ((targetRowIndex - targetColumnIndex) | 0)) {
                    if (System.Linq.Enumerable.from(this.Data, T).any(function (x) {
                            return !Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, x, T);
                        })) {
                        throw new System.NotSupportedException.ctor();
                    }

                    target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
                    return;
                }

                var beginInclusive = Math.max(sourceRowIndex, sourceColumnIndex);
                var endExclusive = Math.min(((sourceRowIndex + rowCount) | 0), ((sourceColumnIndex + columnCount) | 0));
                if (endExclusive > beginInclusive) {
                    var beginTarget = Math.max(targetRowIndex, targetColumnIndex);
                    System.Array.copy(this.Data, beginInclusive, target.Data, beginTarget, ((endExclusive - beginInclusive) | 0));
                }
            },
            CopySubMatrixToUnchecked$1: function (target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
                }

                if (sourceRowIndex > sourceColumnIndex && ((sourceColumnIndex + columnCount) | 0) > sourceRowIndex) {

                    var columnInit = (sourceRowIndex - sourceColumnIndex) | 0;
                    var offset = (Bridge.Int.mul((((columnInit + targetColumnIndex) | 0)), target.RowCount) + targetRowIndex) | 0;
                    var step = (target.RowCount + 1) | 0;
                    var end = (Math.min(((columnCount - columnInit) | 0), rowCount) + sourceRowIndex) | 0;

                    for (var i = sourceRowIndex, j = offset; i < end; i = (i + 1) | 0, j = (j + step) | 0) {
                        target.Data[System.Array.index(j, target.Data)] = this.Data[System.Array.index(i, this.Data)];
                    }
                } else if (sourceRowIndex < sourceColumnIndex && ((sourceRowIndex + rowCount) | 0) > sourceColumnIndex) {

                    var rowInit = (sourceColumnIndex - sourceRowIndex) | 0;
                    var offset1 = (((Bridge.Int.mul(targetColumnIndex, target.RowCount) + rowInit) | 0) + targetRowIndex) | 0;
                    var step1 = (target.RowCount + 1) | 0;
                    var end1 = (Math.min(columnCount, ((rowCount - rowInit) | 0)) + sourceColumnIndex) | 0;

                    for (var i1 = sourceColumnIndex, j1 = offset1; i1 < end1; i1 = (i1 + 1) | 0, j1 = (j1 + step1) | 0) {
                        target.Data[System.Array.index(j1, target.Data)] = this.Data[System.Array.index(i1, this.Data)];
                    }
                } else {
                    var offset2 = (Bridge.Int.mul(targetColumnIndex, target.RowCount) + targetRowIndex) | 0;
                    var step2 = (target.RowCount + 1) | 0;
                    var end2 = (Math.min(columnCount, rowCount) + sourceRowIndex) | 0;

                    for (var i2 = sourceRowIndex, j2 = offset2; i2 < end2; i2 = (i2 + 1) | 0, j2 = (j2 + step2) | 0) {
                        target.Data[System.Array.index(j2, target.Data)] = this.Data[System.Array.index(i2, this.Data)];
                    }
                }
            },
            CopySubRowToUnchecked: function (target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.Clear$1(targetColumnIndex, columnCount);
                }

                if (rowIndex >= sourceColumnIndex && rowIndex < ((sourceColumnIndex + columnCount) | 0) && rowIndex < this.Data.length) {
                    target.At$1(((((rowIndex - sourceColumnIndex) | 0) + targetColumnIndex) | 0), this.Data[System.Array.index(rowIndex, this.Data)]);
                }
            },
            CopySubColumnToUnchecked: function (target, columnIndex, sourceRowIndex, targetRowIndex, rowCount, existingData) {
                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.Clear$1(targetRowIndex, rowCount);
                }

                if (columnIndex >= sourceRowIndex && columnIndex < ((sourceRowIndex + rowCount) | 0) && columnIndex < this.Data.length) {
                    target.At$1(((((columnIndex - sourceRowIndex) | 0) + targetRowIndex) | 0), this.Data[System.Array.index(columnIndex, this.Data)]);
                }
            },
            TransposeToUnchecked: function (target, existingData) {
                this.CopyToUnchecked(target, existingData);
            },
            TransposeSquareInplaceUnchecked: function () { },
            ToRowMajorArray: function () {
                var ret = System.Array.init(Bridge.Int.mul(this.RowCount, this.ColumnCount), function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                var stride = (this.ColumnCount + 1) | 0;
                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    ret[System.Array.index(Bridge.Int.mul(i, stride), ret)] = this.Data[System.Array.index(i, this.Data)];
                }
                return ret;
            },
            ToColumnMajorArray: function () {
                var ret = System.Array.init(Bridge.Int.mul(this.RowCount, this.ColumnCount), function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                var stride = (this.RowCount + 1) | 0;
                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    ret[System.Array.index(Bridge.Int.mul(i, stride), ret)] = this.Data[System.Array.index(i, this.Data)];
                }
                return ret;
            },
            ToRowArrays: function () {
                var $t;
                var ret = System.Array.init(this.RowCount, null, System.Array.type(T));
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    ret[System.Array.index(i, ret)] = System.Array.init(this.ColumnCount, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
                for (var i1 = 0; i1 < this.Data.length; i1 = (i1 + 1) | 0) {
                    ($t = ret[System.Array.index(i1, ret)])[System.Array.index(i1, $t)] = this.Data[System.Array.index(i1, this.Data)];
                }
                return ret;
            },
            ToColumnArrays: function () {
                var $t;
                var ret = System.Array.init(this.ColumnCount, null, System.Array.type(T));
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    ret[System.Array.index(j, ret)] = System.Array.init(this.RowCount, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    ($t = ret[System.Array.index(i, ret)])[System.Array.index(i, $t)] = this.Data[System.Array.index(i, this.Data)];
                }
                return ret;
            },
            ToArray: function () {
                var ret = System.Array.create(function (){
                    return Bridge.getDefaultValue(T);
                }, null, T, this.RowCount, this.ColumnCount);
                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    ret.set([i, i], this.Data[System.Array.index(i, this.Data)]);
                }
                return ret;
            },
            Enumerate: function () {
                return new (Bridge.GeneratorEnumerable$1(T))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        j,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        j = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( j < this.ColumnCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 9;
                                        continue;
                                    }
                                    case 2: {
                                        i = 0;
                                            $step = 3;
                                            continue;
                                    }
                                    case 3: {
                                        if ( i < this.RowCount ) {
                                                $step = 4;
                                                continue;
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 4: {
                                        $enumerator.current = i === j ? this.Data[System.Array.index(i, this.Data)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero;
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {
                                        i = (i + 1) | 0;
                                        $step = 3;
                                        continue;
                                    }
                                    case 7: {
                                        $step = 8;
                                        continue;
                                    }
                                    case 8: {
                                        j = (j + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 9: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            EnumerateIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        j,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        j = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( j < this.ColumnCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 9;
                                        continue;
                                    }
                                    case 2: {
                                        i = 0;
                                            $step = 3;
                                            continue;
                                    }
                                    case 3: {
                                        if ( i < this.RowCount ) {
                                                $step = 4;
                                                continue;
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 4: {
                                        $enumerator.current = i === j ? { Item1: i, Item2: i, Item3: this.Data[System.Array.index(i, this.Data)] } : { Item1: i, Item2: j, Item3: MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero };
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {
                                        i = (i + 1) | 0;
                                        $step = 3;
                                        continue;
                                    }
                                    case 7: {
                                        $step = 8;
                                        continue;
                                    }
                                    case 8: {
                                        j = (j + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 9: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            EnumerateNonZero: function () {
                return System.Linq.Enumerable.from(this.Data, T).where(function (x) {
                        return !Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, x, T);
                    });
            },
            EnumerateNonZeroIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.Data.length ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 2: {
                                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, this.Data[System.Array.index(i, this.Data)], T)) {
                                                $step = 3;
                                                continue;
                                            } 
                                            $step = 5;
                                            continue;
                                    }
                                    case 3: {
                                        $enumerator.current = { Item1: i, Item2: i, Item3: this.Data[System.Array.index(i, this.Data)] };
                                            $step = 4;
                                            return true;
                                    }
                                    case 4: {
                                        $step = 5;
                                        continue;
                                    }
                                    case 5: {
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 7: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            Find: function (predicate, zeros) {
                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    if (predicate(this.Data[System.Array.index(i, this.Data)])) {
                        return { Item1: i, Item2: i, Item3: this.Data[System.Array.index(i, this.Data)] };
                    }
                }
                if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include && (this.RowCount > 1 || this.ColumnCount > 1)) {
                    if (predicate(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero)) {
                        return { Item1: this.RowCount > 1 ? 1 : 0, Item2: this.RowCount > 1 ? 0 : 1, Item3: MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero };
                    }
                }
                return null;
            },
            Find2Unchecked: function (TOther, other, predicate, zeros) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(TOther));
                if (denseOther != null) {
                    var otherData = denseOther.Data;
                    var k = 0;
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                            if (predicate(i === j ? this.Data[System.Array.index(i, this.Data)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherData[System.Array.index(k, otherData)])) {
                                return { Item1: i, Item2: j, Item3: i === j ? this.Data[System.Array.index(i, this.Data)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, Item4: otherData[System.Array.index(k, otherData)] };
                            }
                            k = (k + 1) | 0;
                        }
                    }
                    return null;
                }

                var diagonalOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(TOther));
                if (diagonalOther != null) {
                    var otherData1 = diagonalOther.Data;
                    for (var i1 = 0; i1 < this.Data.length; i1 = (i1 + 1) | 0) {
                        if (predicate(this.Data[System.Array.index(i1, this.Data)], otherData1[System.Array.index(i1, otherData1)])) {
                            return { Item1: i1, Item2: i1, Item3: this.Data[System.Array.index(i1, this.Data)], Item4: otherData1[System.Array.index(i1, otherData1)] };
                        }
                    }
                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include && (this.RowCount > 1 || this.ColumnCount > 1)) {
                        var otherZero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;
                        if (predicate(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherZero)) {
                            return { Item1: this.RowCount > 1 ? 1 : 0, Item2: this.RowCount > 1 ? 0 : 1, Item3: MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, Item4: otherZero };
                        }
                    }
                    return null;
                }

                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(TOther));
                if (sparseOther != null) {
                    var otherRowPointers = sparseOther.RowPointers;
                    var otherColumnIndices = sparseOther.ColumnIndices;
                    var otherValues = sparseOther.Values;
                    var otherZero1 = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var diagonal = false;
                        var startIndex = otherRowPointers[System.Array.index(row, otherRowPointers)];
                        var endIndex = otherRowPointers[System.Array.index(((row + 1) | 0), otherRowPointers)];
                        for (var j1 = startIndex; j1 < endIndex; j1 = (j1 + 1) | 0) {
                            if (otherColumnIndices[System.Array.index(j1, otherColumnIndices)] === row) {
                                diagonal = true;
                                if (predicate(this.Data[System.Array.index(row, this.Data)], otherValues[System.Array.index(j1, otherValues)])) {
                                    return { Item1: row, Item2: row, Item3: this.Data[System.Array.index(row, this.Data)], Item4: otherValues[System.Array.index(j1, otherValues)] };
                                }
                            } else {
                                if (predicate(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherValues[System.Array.index(j1, otherValues)])) {
                                    return { Item1: row, Item2: otherColumnIndices[System.Array.index(j1, otherColumnIndices)], Item3: MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, Item4: otherValues[System.Array.index(j1, otherValues)] };
                                }
                            }
                        }
                        if (!diagonal && row < this.ColumnCount) {
                            if (predicate(this.Data[System.Array.index(row, this.Data)], otherZero1)) {
                                return { Item1: row, Item2: row, Item3: this.Data[System.Array.index(row, this.Data)], Item4: otherZero1 };
                            }
                        }
                    }
                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include && sparseOther.ValueCount < (Bridge.Int.mul(this.RowCount, this.ColumnCount))) {
                        if (predicate(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherZero1)) {
                            var k1 = 0;
                            for (var row1 = 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                                for (var col = 0; col < this.ColumnCount; col = (col + 1) | 0) {
                                    if (k1 < otherRowPointers[System.Array.index(((row1 + 1) | 0), otherRowPointers)] && otherColumnIndices[System.Array.index(k1, otherColumnIndices)] === col) {
                                        k1 = (k1 + 1) | 0;
                                    } else if (row1 !== col) {
                                        return { Item1: row1, Item2: col, Item3: MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, Item4: otherZero1 };
                                    }
                                }
                            }
                        }
                    }
                    return null;
                }


                return MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).prototype.Find2Unchecked.call(this, TOther, other, predicate, zeros);
            },
            MapInplace: function (f, zeros) {
                if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include) {
                    throw new System.NotSupportedException.$ctor1("Cannot map non-zero off-diagonal values into a diagonal matrix");
                }


                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    this.Data[System.Array.index(i, this.Data)] = f(this.Data[System.Array.index(i, this.Data)]);
                }

            },
            MapIndexedInplace: function (f, zeros) {
                if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include) {
                    throw new System.NotSupportedException.$ctor1("Cannot map non-zero off-diagonal values into a diagonal matrix");
                }


                for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                    this.Data[System.Array.index(i, this.Data)] = f(i, i, this.Data[System.Array.index(i, this.Data)]);
                }

            },
            MapToUnchecked: function (TU, target, f, zeros, existingData) {
                var processZeros = zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, f(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));

                var diagonalTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(TU));
                if (diagonalTarget != null) {
                    if (processZeros) {
                        throw new System.NotSupportedException.$ctor1("Cannot map non-zero off-diagonal values into a diagonal matrix");
                    }


                    for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                        diagonalTarget.Data[System.Array.index(i, diagonalTarget.Data)] = f(this.Data[System.Array.index(i, this.Data)]);
                    }

                    return;
                }


                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear && !processZeros) {
                    target.Clear();
                }

                if (processZeros) {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        for (var i1 = 0; i1 < this.RowCount; i1 = (i1 + 1) | 0) {
                            target.At$1(i1, j, f(i1 === j ? this.Data[System.Array.index(i1, this.Data)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));
                        }
                    }
                } else {
                    for (var i2 = 0; i2 < this.Data.length; i2 = (i2 + 1) | 0) {
                        target.At$1(i2, i2, f(this.Data[System.Array.index(i2, this.Data)]));
                    }
                }
            },
            MapIndexedToUnchecked: function (TU, target, f, zeros, existingData) {
                var processZeros = zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, f(0, 1, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));

                var diagonalTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(TU));
                if (diagonalTarget != null) {
                    if (processZeros) {
                        throw new System.NotSupportedException.$ctor1("Cannot map non-zero off-diagonal values into a diagonal matrix");
                    }


                    for (var i = 0; i < this.Data.length; i = (i + 1) | 0) {
                        diagonalTarget.Data[System.Array.index(i, diagonalTarget.Data)] = f(i, i, this.Data[System.Array.index(i, this.Data)]);
                    }

                    return;
                }


                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear && !processZeros) {
                    target.Clear();
                }

                if (processZeros) {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        for (var i1 = 0; i1 < this.RowCount; i1 = (i1 + 1) | 0) {
                            target.At$1(i1, j, f(i1, j, i1 === j ? this.Data[System.Array.index(i1, this.Data)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));
                        }
                    }
                } else {
                    for (var i2 = 0; i2 < this.Data.length; i2 = (i2 + 1) | 0) {
                        target.At$1(i2, i2, f(i2, i2, this.Data[System.Array.index(i2, this.Data)]));
                    }
                }
            },
            MapSubMatrixIndexedToUnchecked: function (TU, target, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros, existingData) {
                var diagonalTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(TU));
                if (diagonalTarget != null) {
                    this.MapSubMatrixIndexedToUnchecked$2(TU, diagonalTarget, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros);
                    return;
                }

                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(TU));
                if (denseTarget != null) {
                    this.MapSubMatrixIndexedToUnchecked$1(TU, denseTarget, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros, existingData);
                    return;
                }



                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
                }

                if (sourceRowIndex === sourceColumnIndex) {
                    var targetRow = targetRowIndex;
                    var targetColumn = targetColumnIndex;
                    for (var i = 0; i < Math.min(columnCount, rowCount); i = (i + 1) | 0) {
                        target.At$1(targetRow, targetColumn, f(targetRow, targetColumn, this.Data[System.Array.index(((sourceRowIndex + i) | 0), this.Data)]));
                        targetRow = (targetRow + 1) | 0;
                        targetColumn = (targetColumn + 1) | 0;
                    }
                } else if (sourceRowIndex > sourceColumnIndex && ((sourceColumnIndex + columnCount) | 0) > sourceRowIndex) {
                    var columnInit = (sourceRowIndex - sourceColumnIndex) | 0;
                    var targetRow1 = targetRowIndex;
                    var targetColumn1 = (targetColumnIndex + columnInit) | 0;
                    for (var i1 = 0; i1 < Math.min(((columnCount - columnInit) | 0), rowCount); i1 = (i1 + 1) | 0) {
                        target.At$1(targetRow1, targetColumn1, f(targetRow1, targetColumn1, this.Data[System.Array.index(((sourceRowIndex + i1) | 0), this.Data)]));
                        targetRow1 = (targetRow1 + 1) | 0;
                        targetColumn1 = (targetColumn1 + 1) | 0;
                    }
                } else if (sourceRowIndex < sourceColumnIndex && ((sourceRowIndex + rowCount) | 0) > sourceColumnIndex) {
                    var rowInit = (sourceColumnIndex - sourceRowIndex) | 0;
                    var targetRow2 = (targetRowIndex + rowInit) | 0;
                    var targetColumn2 = targetColumnIndex;
                    for (var i2 = 0; i2 < Math.min(columnCount, ((rowCount - rowInit) | 0)); i2 = (i2 + 1) | 0) {
                        target.At$1(targetRow2, targetColumn2, f(targetRow2, targetColumn2, this.Data[System.Array.index(((sourceColumnIndex + i2) | 0), this.Data)]));
                        targetRow2 = (targetRow2 + 1) | 0;
                        targetColumn2 = (targetColumn2 + 1) | 0;
                    }
                }
            },
            MapSubMatrixIndexedToUnchecked$2: function (TU, target, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros) {
                var processZeros = zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, f(0, 1, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));
                if (processZeros || ((sourceRowIndex - sourceColumnIndex) | 0) !== ((targetRowIndex - targetColumnIndex) | 0)) {
                    throw new System.NotSupportedException.$ctor1("Cannot map non-zero off-diagonal values into a diagonal matrix");
                }

                var beginInclusive = Math.max(sourceRowIndex, sourceColumnIndex);
                var count = (Math.min(((sourceRowIndex + rowCount) | 0), ((sourceColumnIndex + columnCount) | 0)) - beginInclusive) | 0;
                if (count > 0) {
                    var beginTarget = Math.max(targetRowIndex, targetColumnIndex);

                    var targetIndex = (beginTarget + 0) | 0;
                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        target.Data[System.Array.index(targetIndex, target.Data)] = f(targetIndex, targetIndex, this.Data[System.Array.index(((beginInclusive + i) | 0), this.Data)]);
                        targetIndex = (targetIndex + 1) | 0;
                    }

                }
            },
            MapSubMatrixIndexedToUnchecked$1: function (TU, target, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros, existingData) {
                var processZeros = zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, f(0, 1, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));
                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear && !processZeros) {
                    target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
                }

                if (processZeros) {

                    var sourceColumn = (sourceColumnIndex + 0) | 0;
                    var targetColumn = (targetColumnIndex + 0) | 0;
                    for (var j = 0; j < columnCount; j = (j + 1) | 0) {
                        var targetIndex = (targetRowIndex + Bridge.Int.mul((((j + targetColumnIndex) | 0)), target.RowCount)) | 0;
                        var sourceRow = sourceRowIndex;
                        var targetRow = targetRowIndex;
                        for (var i = 0; i < rowCount; i = (i + 1) | 0) {
                            target.Data[System.Array.index(Bridge.identity(targetIndex, ((targetIndex = (targetIndex + 1) | 0))), target.Data)] = f(Bridge.identity(targetRow, ((targetRow = (targetRow + 1) | 0))), targetColumn, Bridge.identity(sourceRow, ((sourceRow = (sourceRow + 1) | 0))) === sourceColumn ? this.Data[System.Array.index(sourceColumn, this.Data)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                        }
                        sourceColumn = (sourceColumn + 1) | 0;
                        targetColumn = (targetColumn + 1) | 0;
                    }

                } else {
                    if (sourceRowIndex > sourceColumnIndex && ((sourceColumnIndex + columnCount) | 0) > sourceRowIndex) {

                        var columnInit = (sourceRowIndex - sourceColumnIndex) | 0;
                        var offset = (Bridge.Int.mul((((columnInit + targetColumnIndex) | 0)), target.RowCount) + targetRowIndex) | 0;
                        var step = (target.RowCount + 1) | 0;
                        var count = Math.min(((columnCount - columnInit) | 0), rowCount);

                        for (var k = 0, j1 = offset; k < count; j1 = (j1 + step) | 0, k = (k + 1) | 0) {
                            target.Data[System.Array.index(j1, target.Data)] = f(((targetRowIndex + k) | 0), ((((targetColumnIndex + columnInit) | 0) + k) | 0), this.Data[System.Array.index(((sourceRowIndex + k) | 0), this.Data)]);
                        }
                    } else if (sourceRowIndex < sourceColumnIndex && ((sourceRowIndex + rowCount) | 0) > sourceColumnIndex) {

                        var rowInit = (sourceColumnIndex - sourceRowIndex) | 0;
                        var offset1 = (((Bridge.Int.mul(targetColumnIndex, target.RowCount) + rowInit) | 0) + targetRowIndex) | 0;
                        var step1 = (target.RowCount + 1) | 0;
                        var count1 = Math.min(columnCount, ((rowCount - rowInit) | 0));

                        for (var k1 = 0, j2 = offset1; k1 < count1; j2 = (j2 + step1) | 0, k1 = (k1 + 1) | 0) {
                            target.Data[System.Array.index(j2, target.Data)] = f(((((targetRowIndex + rowInit) | 0) + k1) | 0), ((targetColumnIndex + k1) | 0), this.Data[System.Array.index(((sourceColumnIndex + k1) | 0), this.Data)]);
                        }
                    } else {
                        var offset2 = (Bridge.Int.mul(targetColumnIndex, target.RowCount) + targetRowIndex) | 0;
                        var step2 = (target.RowCount + 1) | 0;
                        var count2 = Math.min(columnCount, rowCount);

                        for (var k2 = 0, j3 = offset2; k2 < count2; j3 = (j3 + step2) | 0, k2 = (k2 + 1) | 0) {
                            target.Data[System.Array.index(j3, target.Data)] = f(((targetRowIndex + k2) | 0), ((targetColumnIndex + k2) | 0), this.Data[System.Array.index(((sourceRowIndex + k2) | 0), this.Data)]);
                        }
                    }
                }
            },
            FoldByRowUnchecked: function (TU, target, f, finalize, state, zeros) {
                if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip) {
                    for (var k = 0; k < this.Data.length; k = (k + 1) | 0) {
                        target[System.Array.index(k, target)] = finalize(f(state[System.Array.index(k, state)], this.Data[System.Array.index(k, this.Data)]), 1);
                    }

                    for (var k1 = this.Data.length; k1 < this.RowCount; k1 = (k1 + 1) | 0) {
                        target[System.Array.index(k1, target)] = finalize(state[System.Array.index(k1, state)], 0);
                    }
                } else {
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        var s = state[System.Array.index(i, state)];
                        for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                            s = f(s, i === j ? this.Data[System.Array.index(i, this.Data)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                        }
                        target[System.Array.index(i, target)] = finalize(s, this.ColumnCount);
                    }
                }
            },
            FoldByColumnUnchecked: function (TU, target, f, finalize, state, zeros) {
                if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip) {
                    for (var k = 0; k < this.Data.length; k = (k + 1) | 0) {
                        target[System.Array.index(k, target)] = finalize(f(state[System.Array.index(k, state)], this.Data[System.Array.index(k, this.Data)]), 1);
                    }

                    for (var k1 = this.Data.length; k1 < this.ColumnCount; k1 = (k1 + 1) | 0) {
                        target[System.Array.index(k1, target)] = finalize(state[System.Array.index(k1, state)], 0);
                    }
                } else {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        var s = state[System.Array.index(j, state)];
                        for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                            s = f(s, i === j ? this.Data[System.Array.index(i, this.Data)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                        }
                        target[System.Array.index(j, target)] = finalize(s, this.RowCount);
                    }
                }
            },
            Fold2Unchecked: function (TOther, TState, other, f, state, zeros) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(TOther));
                if (denseOther != null) {
                    var otherData = denseOther.Data;
                    var k = 0;
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                            state = f(state, i === j ? this.Data[System.Array.index(i, this.Data)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherData[System.Array.index(k, otherData)]);
                            k = (k + 1) | 0;
                        }
                    }
                    return state;
                }

                var diagonalOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(TOther));
                if (diagonalOther != null) {
                    var otherData1 = diagonalOther.Data;
                    for (var i1 = 0; i1 < this.Data.length; i1 = (i1 + 1) | 0) {
                        state = f(state, this.Data[System.Array.index(i1, this.Data)], otherData1[System.Array.index(i1, otherData1)]);
                    }

                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include) {
                        var otherZero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;
                        var count = (Bridge.Int.mul(this.RowCount, this.ColumnCount) - this.Data.length) | 0;
                        for (var i2 = 0; i2 < count; i2 = (i2 + 1) | 0) {
                            state = f(state, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherZero);
                        }
                    }

                    return state;
                }

                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(TOther));
                if (sparseOther != null) {
                    var otherRowPointers = sparseOther.RowPointers;
                    var otherColumnIndices = sparseOther.ColumnIndices;
                    var otherValues = sparseOther.Values;
                    var otherZero1 = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;

                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include) {
                        var k1 = 0;
                        for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                            for (var col = 0; col < this.ColumnCount; col = (col + 1) | 0) {
                                if (k1 < otherRowPointers[System.Array.index(((row + 1) | 0), otherRowPointers)] && otherColumnIndices[System.Array.index(k1, otherColumnIndices)] === col) {
                                    state = f(state, row === col ? this.Data[System.Array.index(row, this.Data)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherValues[System.Array.index(Bridge.identity(k1, ((k1 = (k1 + 1) | 0))), otherValues)]);
                                } else {
                                    state = f(state, row === col ? this.Data[System.Array.index(row, this.Data)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherZero1);
                                }
                            }
                        }
                        return state;
                    }

                    for (var row1 = 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                        var diagonal = false;

                        var startIndex = otherRowPointers[System.Array.index(row1, otherRowPointers)];
                        var endIndex = otherRowPointers[System.Array.index(((row1 + 1) | 0), otherRowPointers)];
                        for (var j1 = startIndex; j1 < endIndex; j1 = (j1 + 1) | 0) {
                            if (otherColumnIndices[System.Array.index(j1, otherColumnIndices)] === row1) {
                                diagonal = true;
                                state = f(state, this.Data[System.Array.index(row1, this.Data)], otherValues[System.Array.index(j1, otherValues)]);
                            } else {
                                state = f(state, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherValues[System.Array.index(j1, otherValues)]);
                            }
                        }

                        if (!diagonal && row1 < this.ColumnCount) {
                            state = f(state, this.Data[System.Array.index(row1, this.Data)], otherZero1);
                        }
                    }

                    return state;
                }


                return MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).prototype.Fold2Unchecked.call(this, TOther, TState, other, f, state, zeros);
            }
        }
    }; });

    Bridge.define("MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1", function (T) { return {
        inherits: [MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T)],
        statics: {
            methods: {
                OfMatrix: function (matrix) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(matrix.RowCount, matrix.ColumnCount);
                    matrix.CopyToUnchecked(storage, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                    return storage;
                },
                OfValue: function (rows, columns, value) {
                    if (Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, value, T)) {
                        return new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(rows, columns);
                    }

                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(rows, columns);

                    var values = System.Array.init(Bridge.Int.mul(rows, columns), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    for (var i = 0; i < values.length; i = (i + 1) | 0) {
                        values[System.Array.index(i, values)] = value;
                    }

                    var rowPointers = storage.RowPointers;
                    for (var i1 = 0; i1 <= rows; i1 = (i1 + 1) | 0) {
                        rowPointers[System.Array.index(i1, rowPointers)] = Bridge.Int.mul(i1, columns);
                    }

                    var columnIndices = System.Array.init(values.length, 0, System.Int32);
                    for (var row = 0; row < rows; row = (row + 1) | 0) {
                        var offset = Bridge.Int.mul(row, columns);
                        for (var col = 0; col < columns; col = (col + 1) | 0) {
                            columnIndices[System.Array.index(((offset + col) | 0), columnIndices)] = col;
                        }
                    }

                    rowPointers[System.Array.index(rows, rowPointers)] = values.length;
                    storage.ColumnIndices = columnIndices;
                    storage.Values = values;
                    return storage;
                },
                OfInit: function (rows, columns, init) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(rows, columns);
                    var rowPointers = storage.RowPointers;
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();

                    for (var row = 0; row < rows; row = (row + 1) | 0) {
                        rowPointers[System.Array.index(row, rowPointers)] = values.Count;
                        for (var col = 0; col < columns; col = (col + 1) | 0) {
                            var x = init(row, col);
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, x, T)) {
                                values.add(x);
                                columnIndices.add(col);
                            }
                        }
                    }

                    rowPointers[System.Array.index(rows, rowPointers)] = values.Count;
                    storage.ColumnIndices = columnIndices.ToArray();
                    storage.Values = values.ToArray();
                    return storage;
                },
                OfDiagonalInit: function (rows, columns, init) {
                    var diagonalLength = Math.min(rows, columns);
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(rows, columns);
                    var rowPointers = storage.RowPointers;
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).$ctor2(diagonalLength);
                    var values = new (System.Collections.Generic.List$1(T)).$ctor2(diagonalLength);

                    for (var i = 0; i < diagonalLength; i = (i + 1) | 0) {
                        rowPointers[System.Array.index(i, rowPointers)] = values.Count;
                        var x = init(i);
                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, x, T)) {
                            values.add(x);
                            columnIndices.add(i);
                        }
                    }

                    rowPointers[System.Array.index(rows, rowPointers)] = values.Count;
                    storage.ColumnIndices = columnIndices.ToArray();
                    storage.Values = values.ToArray();
                    return storage;
                },
                OfArray: function (array) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(System.Array.getLength(array, 0), System.Array.getLength(array, 1));
                    var rowPointers = storage.RowPointers;
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();

                    for (var row = 0; row < storage.RowCount; row = (row + 1) | 0) {
                        rowPointers[System.Array.index(row, rowPointers)] = values.Count;
                        for (var col = 0; col < storage.ColumnCount; col = (col + 1) | 0) {
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, array.get([row, col]), T)) {
                                values.add(array.get([row, col]));
                                columnIndices.add(col);
                            }
                        }
                    }

                    rowPointers[System.Array.index(storage.RowCount, rowPointers)] = values.Count;
                    storage.ColumnIndices = columnIndices.ToArray();
                    storage.Values = values.ToArray();
                    return storage;
                },
                OfRowArrays: function (data) {
                    var $t;
                    if (data.length <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("data", "Resources.MatrixCanNotBeEmpty");
                    }

                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(data.length, data[System.Array.index(0, data)].length);
                    var rowPointers = storage.RowPointers;
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();

                    for (var row = 0; row < storage.RowCount; row = (row + 1) | 0) {
                        rowPointers[System.Array.index(row, rowPointers)] = values.Count;
                        for (var col = 0; col < storage.ColumnCount; col = (col + 1) | 0) {
                            var x = ($t = data[System.Array.index(row, data)])[System.Array.index(col, $t)];
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, x, T)) {
                                values.add(x);
                                columnIndices.add(col);
                            }
                        }
                    }

                    rowPointers[System.Array.index(storage.RowCount, rowPointers)] = values.Count;
                    storage.ColumnIndices = columnIndices.ToArray();
                    storage.Values = values.ToArray();
                    return storage;
                },
                OfColumnArrays: function (data) {
                    var $t;
                    if (data.length <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("data", "Resources.MatrixCanNotBeEmpty");
                    }

                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(data[System.Array.index(0, data)].length, data.length);
                    var rowPointers = storage.RowPointers;
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();

                    for (var row = 0; row < storage.RowCount; row = (row + 1) | 0) {
                        rowPointers[System.Array.index(row, rowPointers)] = values.Count;
                        for (var col = 0; col < storage.ColumnCount; col = (col + 1) | 0) {
                            var x = ($t = data[System.Array.index(col, data)])[System.Array.index(row, $t)];
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, x, T)) {
                                values.add(x);
                                columnIndices.add(col);
                            }
                        }
                    }

                    rowPointers[System.Array.index(storage.RowCount, rowPointers)] = values.Count;
                    storage.ColumnIndices = columnIndices.ToArray();
                    storage.Values = values.ToArray();
                    return storage;
                },
                OfRowVectors: function (data) {
                    if (data.length <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("data", "Resources.MatrixCanNotBeEmpty");
                    }

                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(data.length, data[System.Array.index(0, data)].Length);
                    var rowPointers = storage.RowPointers;
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();

                    for (var row = 0; row < storage.RowCount; row = (row + 1) | 0) {
                        var vector = data[System.Array.index(row, data)];
                        rowPointers[System.Array.index(row, rowPointers)] = values.Count;
                        for (var col = 0; col < storage.ColumnCount; col = (col + 1) | 0) {
                            var x = vector.At(col);
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, x, T)) {
                                values.add(x);
                                columnIndices.add(col);
                            }
                        }
                    }

                    rowPointers[System.Array.index(storage.RowCount, rowPointers)] = values.Count;
                    storage.ColumnIndices = columnIndices.ToArray();
                    storage.Values = values.ToArray();
                    return storage;
                },
                OfColumnVectors: function (data) {
                    if (data.length <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("data", "Resources.MatrixCanNotBeEmpty");
                    }

                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(data[System.Array.index(0, data)].Length, data.length);
                    var rowPointers = storage.RowPointers;
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();

                    for (var row = 0; row < storage.RowCount; row = (row + 1) | 0) {
                        rowPointers[System.Array.index(row, rowPointers)] = values.Count;
                        for (var col = 0; col < storage.ColumnCount; col = (col + 1) | 0) {
                            var x = data[System.Array.index(col, data)].At(row);
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, x, T)) {
                                values.add(x);
                                columnIndices.add(col);
                            }
                        }
                    }

                    rowPointers[System.Array.index(storage.RowCount, rowPointers)] = values.Count;
                    storage.ColumnIndices = columnIndices.ToArray();
                    storage.Values = values.ToArray();
                    return storage;
                },
                OfIndexedEnumerable: function (rows, columns, data) {
                    var $t, $t1, $t2;
                    var trows = System.Array.init(rows, null, System.Collections.Generic.List$1(System.Tuple$2(System.Int32,T)));
                    $t = Bridge.getEnumerator(data, System.Tuple$3(System.Int32,System.Int32,T));
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, item.Item3, T)) {
                                var row = trows[System.Array.index(item.Item1, trows)] || (($t1 = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,T))).ctor(), trows[System.Array.index(item.Item1, trows)] = $t1, $t1));
                                row.add({ Item1: item.Item2, Item2: item.Item3 });
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(rows, columns);
                    var rowPointers = storage.RowPointers;
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();

                    var index = 0;
                    for (var row1 = 0; row1 < rows; row1 = (row1 + 1) | 0) {
                        rowPointers[System.Array.index(row1, rowPointers)] = index;
                        var trow = trows[System.Array.index(row1, trows)];
                        if (trow != null) {
                            trow.Sort();
                            $t2 = Bridge.getEnumerator(trow);
                            try {
                                while ($t2.moveNext()) {
                                    var item1 = $t2.Current;
                                    values.add(item1.Item2);
                                    columnIndices.add(item1.Item1);
                                    index = (index + 1) | 0;
                                }
                            } finally {
                                if (Bridge.is($t2, System.IDisposable)) {
                                    $t2.System$IDisposable$Dispose();
                                }
                            }
                        }
                    }

                    rowPointers[System.Array.index(rows, rowPointers)] = values.Count;
                    storage.ColumnIndices = columnIndices.ToArray();
                    storage.Values = values.ToArray();
                    return storage;
                },
                OfRowEnumerables: function (rows, columns, data) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(rows, columns);
                    var rowPointers = storage.RowPointers;
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();

                    var rowIterator = Bridge.getEnumerator(data, System.Collections.Generic.IEnumerable$1(T));
                    try {
                        for (var row = 0; row < rows; row = (row + 1) | 0) {
                            if (!rowIterator.System$Collections$IEnumerator$moveNext()) {
                                throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(rows, System.Int32)]));
                            }

                            rowPointers[System.Array.index(row, rowPointers)] = values.Count;
                            var columnIterator = Bridge.getEnumerator(rowIterator[Bridge.geti(rowIterator, "System$Collections$Generic$IEnumerator$1$System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")], T);
                            try {
                                for (var col = 0; col < columns; col = (col + 1) | 0) {
                                    if (!columnIterator.System$Collections$IEnumerator$moveNext()) {
                                        throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(columns, System.Int32)]));
                                    }
                                    if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, columnIterator[Bridge.geti(columnIterator, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")], T)) {
                                        values.add(columnIterator[Bridge.geti(columnIterator, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")]);
                                        columnIndices.add(col);
                                    }
                                }
                                if (columnIterator.System$Collections$IEnumerator$moveNext()) {
                                    throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(columns, System.Int32)]));
                                }
                            }
                            finally {
                                if (Bridge.hasValue(columnIterator)) {
                                    columnIterator.System$IDisposable$Dispose();
                                }
                            }
                        }
                        if (rowIterator.System$Collections$IEnumerator$moveNext()) {
                            throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(rows, System.Int32)]));
                        }

                    }
                    finally {
                        if (Bridge.hasValue(rowIterator)) {
                            rowIterator.System$IDisposable$Dispose();
                        }
                    }

                    rowPointers[System.Array.index(rows, rowPointers)] = values.Count;
                    storage.ColumnIndices = columnIndices.ToArray();
                    storage.Values = values.ToArray();
                    return storage;
                },
                OfColumnEnumerables: function (rows, columns, data) {
                    var $t, $t1;
                    var trows = System.Array.init(rows, null, System.Collections.Generic.List$1(System.Tuple$2(System.Int32,T)));
                    var columnIterator = Bridge.getEnumerator(data, System.Collections.Generic.IEnumerable$1(T));
                    try {
                        for (var column = 0; column < columns; column = (column + 1) | 0) {
                            if (!columnIterator.System$Collections$IEnumerator$moveNext()) {
                                throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(columns, System.Int32)]));
                            }
                            var rowIterator = Bridge.getEnumerator(columnIterator[Bridge.geti(columnIterator, "System$Collections$Generic$IEnumerator$1$System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")], T);
                            try {
                                for (var row = 0; row < rows; row = (row + 1) | 0) {
                                    if (!rowIterator.System$Collections$IEnumerator$moveNext()) {
                                        throw new System.ArgumentOutOfRangeException.$ctor4("data", System.String.format("Resources.ArgumentArrayWrongLength", [Bridge.box(rows, System.Int32)]));
                                    }

                                    if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, rowIterator[Bridge.geti(rowIterator, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")], T)) {
                                        var trow = trows[System.Array.index(row, trows)] || (($t = new (System.Collections.Generic.List$1(System.Tuple$2(System.Int32,T))).ctor(), trows[System.Array.index(row, trows)] = $t, $t));
                                        trow.add({ Item1: column, Item2: rowIterator[Bridge.geti(rowIterator, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")] });
                                    }
                                }
                            }
                            finally {
                                if (Bridge.hasValue(rowIterator)) {
                                    rowIterator.System$IDisposable$Dispose();
                                }
                            }
                        }
                    }
                    finally {
                        if (Bridge.hasValue(columnIterator)) {
                            columnIterator.System$IDisposable$Dispose();
                        }
                    }

                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(rows, columns);
                    var rowPointers = storage.RowPointers;
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();

                    var index = 0;
                    for (var row1 = 0; row1 < rows; row1 = (row1 + 1) | 0) {
                        rowPointers[System.Array.index(row1, rowPointers)] = index;
                        var trow1 = trows[System.Array.index(row1, trows)];
                        if (trow1 != null) {
                            trow1.Sort();
                            $t1 = Bridge.getEnumerator(trow1);
                            try {
                                while ($t1.moveNext()) {
                                    var item = $t1.Current;
                                    values.add(item.Item2);
                                    columnIndices.add(item.Item1);
                                    index = (index + 1) | 0;
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    }

                    rowPointers[System.Array.index(rows, rowPointers)] = values.Count;
                    storage.ColumnIndices = columnIndices.ToArray();
                    storage.Values = values.ToArray();
                    return storage;
                },
                OfRowMajorEnumerable: function (rows, columns, data) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(rows, columns);
                    var rowPointers = storage.RowPointers;
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();

                    var iterator = Bridge.getEnumerator(data, T);
                    try {
                        for (var row = 0; row < rows; row = (row + 1) | 0) {
                            rowPointers[System.Array.index(row, rowPointers)] = values.Count;
                            for (var col = 0; col < columns; col = (col + 1) | 0) {
                                iterator.System$Collections$IEnumerator$moveNext();
                                if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, iterator[Bridge.geti(iterator, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")], T)) {
                                    values.add(iterator[Bridge.geti(iterator, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")]);
                                    columnIndices.add(col);
                                }
                            }
                        }
                    }
                    finally {
                        if (Bridge.hasValue(iterator)) {
                            iterator.System$IDisposable$Dispose();
                        }
                    }

                    rowPointers[System.Array.index(rows, rowPointers)] = values.Count;
                    storage.ColumnIndices = columnIndices.ToArray();
                    storage.Values = values.ToArray();
                    return storage;
                },
                OfColumnMajorList: function (rows, columns, data) {
                    if (Bridge.Int.mul(rows, columns) !== System.Array.getCount(data, T)) {
                        throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixDimensions");

                    }

                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T))(rows, columns);
                    var rowPointers = storage.RowPointers;
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();

                    for (var row = 0; row < rows; row = (row + 1) | 0) {
                        rowPointers[System.Array.index(row, rowPointers)] = values.Count;
                        for (var col = 0; col < columns; col = (col + 1) | 0) {
                            var item = System.Array.getItem(data, ((row + (Bridge.Int.mul(col, rows))) | 0), T);
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, item, T)) {
                                values.add(item);
                                columnIndices.add(col);
                            }
                        }
                    }

                    rowPointers[System.Array.index(rows, rowPointers)] = values.Count;
                    storage.ColumnIndices = columnIndices.ToArray();
                    storage.Values = values.ToArray();
                    return storage;
                }
            }
        },
        fields: {
            /**
             * The array containing the row indices of the existing rows. Element "i" of the array gives the index of the
             element in the {@link } array that is first non-zero element in a row "i".
             The last value is equal to ValueCount, so that the number of non-zero entries in row "i" is always
             given by RowPointers[i+i] - RowPointers[i]. This array thus has length RowCount+1.
             *
             * @instance
             * @public
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @type Array.<number>
             */
            RowPointers: null,
            /**
             * An array containing the column indices of the non-zero values. Element "j" of the array
             is the number of the column in matrix that contains the j-th value in the {@link } array.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @type Array.<number>
             */
            ColumnIndices: null,
            /**
             * Array that contains the non-zero elements of matrix. Values of the non-zero elements of matrix are mapped into the values
             array using the row-major storage mapping described in a compressed sparse row (CSR) format.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @type Array.<T>
             */
            Values: null
        },
        props: {
            /**
             * Gets the number of non zero elements in the matrix.
             *
             * @instance
             * @public
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @function ValueCount
             * @type number
             */
            ValueCount: {
                get: function () {
                    return this.RowPointers[System.Array.index(this.RowCount, this.RowPointers)];
                }
            },
            /**
             * True if the matrix storage format is dense.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @function IsDense
             * @type boolean
             */
            IsDense: {
                get: function () {
                    return false;
                }
            },
            /**
             * True if all fields of this matrix can be set to any value.
             False if some fields are fixed, like on a diagonal matrix.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @function IsFullyMutable
             * @type boolean
             */
            IsFullyMutable: {
                get: function () {
                    return true;
                }
            }
        },
        ctors: {
            ctor: function (rows, columns) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).ctor.call(this, rows, columns);
                this.RowPointers = System.Array.init(((rows + 1) | 0), 0, System.Int32);
                this.ColumnIndices = System.Array.init(0, 0, System.Int32);
                this.Values = System.Array.init(0, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
            }
        },
        methods: {
            /**
             * True if the specified field can be set to any value.
             False if the field is fixed, like an off-diagonal field on a diagonal matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @param   {number}     row       
             * @param   {number}     column
             * @return  {boolean}
             */
            IsMutableAt: function (row, column) {
                return true;
            },
            /**
             * Retrieves the requested element without range checking.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @param   {number}    row       The row of the element.
             * @param   {number}    column    The column of the element.
             * @return  {T}                   The requested element.
             */
            At: function (row, column) {
                var index = this.FindItem(row, column);
                return index >= 0 ? this.Values[System.Array.index(index, this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero;
            },
            /**
             * Sets the element without range checking.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @param   {number}    row       The row of the element.
             * @param   {number}    column    The column of the element.
             * @param   {T}         value     The value to set the element to.
             * @return  {void}
             */
            At$1: function (row, column, value) {
                var index = this.FindItem(row, column);
                if (index >= 0) {
                    if (Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, value, T)) {
                        this.RemoveAtIndexUnchecked(index, row);
                    } else {
                        this.Values[System.Array.index(index, this.Values)] = value;
                    }
                } else {
                    if (Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, value, T)) {
                        return;
                    }

                    index = ~index;
                    var valueCount = this.RowPointers[System.Array.index(((this.RowPointers.length - 1) | 0), this.RowPointers)];

                    if ((valueCount === this.Values.length) && (System.Int64(valueCount).lt((System.Int64(this.RowCount).mul(System.Int64(this.ColumnCount)))))) {
                        var size = System.Int64.min(System.Int64(this.Values.length + this.GrowthSize()), System.Int64(this.RowCount).mul(System.Int64(this.ColumnCount)));
                        if (size.gt(System.Int64(2147483647))) {
                            throw new System.NotSupportedException.$ctor1("Resources.TooManyElements");
                        }

                        System.Array.resize(Bridge.ref(this, "Values"), System.Int64.clip32(size), function () {
                            return Bridge.getDefaultValue(T);
                        }, T);
                        System.Array.resize(Bridge.ref(this, "ColumnIndices"), System.Int64.clip32(size), 0, System.Int32);
                    }

                    System.Array.copy(this.Values, index, this.Values, ((index + 1) | 0), ((valueCount - index) | 0));
                    System.Array.copy(this.ColumnIndices, index, this.ColumnIndices, ((index + 1) | 0), ((valueCount - index) | 0));

                    this.Values[System.Array.index(index, this.Values)] = value;
                    this.ColumnIndices[System.Array.index(index, this.ColumnIndices)] = column;

                    for (var i = (row + 1) | 0; i < this.RowPointers.length; i = (i + 1) | 0) {
                        this.RowPointers[System.Array.index(i, this.RowPointers)] = (this.RowPointers[System.Array.index(i, this.RowPointers)] + 1) | 0;
                    }
                }
            },
            /**
             * Delete value from internal storage
             *
             * @instance
             * @private
             * @this MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @param   {number}    itemIndex    Index of value in nonZeroValues array
             * @param   {number}    row          Row number of matrix
             * @return  {void}
             */
            RemoveAtIndexUnchecked: function (itemIndex, row) {
                var valueCount = this.RowPointers[System.Array.index(((this.RowPointers.length - 1) | 0), this.RowPointers)];

                System.Array.copy(this.Values, ((itemIndex + 1) | 0), this.Values, itemIndex, ((((valueCount - itemIndex) | 0) - 1) | 0));
                System.Array.copy(this.ColumnIndices, ((itemIndex + 1) | 0), this.ColumnIndices, itemIndex, ((((valueCount - itemIndex) | 0) - 1) | 0));

                for (var i = (row + 1) | 0; i < this.RowPointers.length; i = (i + 1) | 0) {
                    this.RowPointers[System.Array.index(i, this.RowPointers)] = (this.RowPointers[System.Array.index(i, this.RowPointers)] - 1) | 0;
                }

                valueCount = (valueCount - 1) | 0;

                if ((valueCount > 1024) && (valueCount < ((Bridge.Int.div(this.Values.length, 2)) | 0))) {
                    System.Array.resize(Bridge.ref(this, "Values"), valueCount, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                    System.Array.resize(Bridge.ref(this, "ColumnIndices"), valueCount, 0, System.Int32);
                }
            },
            /**
             * Find item Index in nonZeroValues array
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @param   {number}    row       Matrix row index
             * @param   {number}    column    Matrix column index
             * @return  {number}              Item index
             */
            FindItem: function (row, column) {
                return System.Array.binarySearch(this.ColumnIndices, this.RowPointers[System.Array.index(row, this.RowPointers)], ((this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)] - this.RowPointers[System.Array.index(row, this.RowPointers)]) | 0), column);
            },
            /**
             * Calculates the amount with which to grow the storage array's if they need to be
             increased in size.
             *
             * @instance
             * @private
             * @this MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @return  {number}        The amount grown.
             */
            GrowthSize: function () {
                var delta;
                if (this.Values.length > 1024) {
                    delta = (Bridge.Int.div(this.Values.length, 4)) | 0;
                } else {
                    if (this.Values.length > 256) {
                        delta = 512;
                    } else {
                        delta = this.Values.length > 64 ? 128 : 32;
                    }
                }

                return delta;
            },
            Normalize: function () {
                this.NormalizeOrdering();
                this.NormalizeZeros();
            },
            NormalizeOrdering: function () {
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var index = this.RowPointers[System.Array.index(i, this.RowPointers)];
                    var count = (this.RowPointers[System.Array.index(((i + 1) | 0), this.RowPointers)] - index) | 0;
                    if (count > 1) {
                        MathNet.Numerics.Sorting.Sort$3(System.Int32, T, this.ColumnIndices, this.Values, index, count);
                    }
                }
            },
            NormalizeZeros: function () {
                this.MapInplace(function (x) {
                    return x;
                }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Returns a hash code for this instance.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1
             * @return  {number}        A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
             */
            getHashCode: function () {
                var values = this.Values;
                var hashNum = Math.min(this.ValueCount, 25);
                var hash = 17;
                for (var i = 0; i < hashNum; i = (i + 1) | 0) {
                    hash = (Bridge.Int.mul(hash, 31) + Bridge.getHashCode(values[i])) | 0;
                }
                return hash;
            },
            Clear: function () {
                System.Array.fill(this.RowPointers, 0, 0, this.RowPointers.length);
            },
            ClearUnchecked: function (rowIndex, rowCount, columnIndex, columnCount) {
                if (rowIndex === 0 && columnIndex === 0 && rowCount === this.RowCount && columnCount === this.ColumnCount) {
                    this.Clear();
                    return;
                }

                var valueCount = this.RowPointers[System.Array.index(((this.RowPointers.length - 1) | 0), this.RowPointers)];

                for (var row = (((rowIndex + rowCount) | 0) - 1) | 0; row >= rowIndex; row = (row - 1) | 0) {
                    var startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                    var endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];

                    if (startIndex === endIndex) {
                        continue;
                    }

                    var first = System.Array.binarySearch(this.ColumnIndices, startIndex, ((endIndex - startIndex) | 0), columnIndex);
                    var last = System.Array.binarySearch(this.ColumnIndices, startIndex, ((endIndex - startIndex) | 0), ((((columnIndex + columnCount) | 0) - 1) | 0));
                    if (first < 0) {
                        first = ~first;
                    }
                    if (last < 0) {
                        last = (~last - 1) | 0;
                    }
                    var count = (((last - first) | 0) + 1) | 0;

                    if (count > 0) {
                        System.Array.copy(this.Values, ((first + count) | 0), this.Values, first, ((((valueCount - first) | 0) - count) | 0));
                        System.Array.copy(this.ColumnIndices, ((first + count) | 0), this.ColumnIndices, first, ((((valueCount - first) | 0) - count) | 0));

                        for (var k = (row + 1) | 0; k < this.RowPointers.length; k = (k + 1) | 0) {
                            this.RowPointers[System.Array.index(k, this.RowPointers)] = (this.RowPointers[System.Array.index(k, this.RowPointers)] - count) | 0;
                        }

                        valueCount = (valueCount - count) | 0;
                    }
                }

                if ((valueCount > 1024) && (valueCount < ((Bridge.Int.div(this.Values.length, 2)) | 0))) {
                    System.Array.resize(Bridge.ref(this, "Values"), valueCount, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                    System.Array.resize(Bridge.ref(this, "ColumnIndices"), valueCount, 0, System.Int32);
                }
            },
            ClearRowsUnchecked: function (rowIndices) {
                var rows = System.Array.init(this.RowCount, false, System.Boolean);
                for (var i = 0; i < rowIndices.length; i = (i + 1) | 0) {
                    rows[System.Array.index(rowIndices[System.Array.index(i, rowIndices)], rows)] = true;
                }
                this.MapIndexedInplace(function (i1, j, x) {
                    return rows[System.Array.index(i1, rows)] ? MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero : x;
                }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            ClearColumnsUnchecked: function (columnIndices) {
                var columns = System.Array.init(this.ColumnCount, false, System.Boolean);
                for (var i = 0; i < columnIndices.length; i = (i + 1) | 0) {
                    columns[System.Array.index(columnIndices[System.Array.index(i, columnIndices)], columns)] = true;
                }
                this.MapIndexedInplace(function (i1, j, x) {
                    return columns[System.Array.index(j, columns)] ? MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero : x;
                }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            CopyToUnchecked: function (target, existingData) {
                var sparseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T));
                if (sparseTarget != null) {
                    this.CopyToUnchecked$2(sparseTarget);
                    return;
                }

                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T));
                if (denseTarget != null) {
                    this.CopyToUnchecked$1(denseTarget, existingData);
                    return;
                }


                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.Clear();
                }

                if (this.ValueCount !== 0) {
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            target.At$1(row, this.ColumnIndices[System.Array.index(j, this.ColumnIndices)], this.Values[System.Array.index(j, this.Values)]);
                        }
                    }
                }
            },
            CopyToUnchecked$2: function (target) {
                target.Values = System.Array.init(this.ValueCount, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                target.ColumnIndices = System.Array.init(this.ValueCount, 0, System.Int32);

                if (this.ValueCount !== 0) {
                    System.Array.copy(this.Values, 0, target.Values, 0, this.ValueCount);


                    System.Array.copy(this.ColumnIndices, 0, target.ColumnIndices, 0, this.ValueCount);
                    System.Array.copy(this.RowPointers, 0, target.RowPointers, 0, (((this.RowCount + 1) | 0)));
                }
            },
            CopyToUnchecked$1: function (target, existingData) {
                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.Clear();
                }


                if (this.ValueCount !== 0) {
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            target.At$1(row, this.ColumnIndices[System.Array.index(j, this.ColumnIndices)], this.Values[System.Array.index(j, this.Values)]);
                        }
                    }
                }
            },
            CopySubMatrixToUnchecked: function (target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                if (target == null) {
                    throw new System.ArgumentNullException.$ctor1("target");
                }

                var sparseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T));
                if (sparseTarget != null) {
                    this.CopySubMatrixToUnchecked$1(sparseTarget, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, existingData);
                    return;
                }


                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
                }

                for (var i = sourceRowIndex, row = 0; i < ((sourceRowIndex + rowCount) | 0); i = (i + 1) | 0, row = (row + 1) | 0) {
                    var startIndex = this.RowPointers[System.Array.index(i, this.RowPointers)];
                    var endIndex = this.RowPointers[System.Array.index(((i + 1) | 0), this.RowPointers)];

                    for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                        if ((this.ColumnIndices[System.Array.index(j, this.ColumnIndices)] >= sourceColumnIndex) && (this.ColumnIndices[System.Array.index(j, this.ColumnIndices)] < ((sourceColumnIndex + columnCount) | 0))) {
                            var column = (this.ColumnIndices[System.Array.index(j, this.ColumnIndices)] - sourceColumnIndex) | 0;
                            target.At$1(((targetRowIndex + row) | 0), ((targetColumnIndex + column) | 0), this.Values[System.Array.index(j, this.Values)]);
                        }
                    }
                }
            },
            CopySubMatrixToUnchecked$1: function (target, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                var rowOffset = (targetRowIndex - sourceRowIndex) | 0;
                var columnOffset = (targetColumnIndex - sourceColumnIndex) | 0;

                if (target.ValueCount === 0) {
                    var values = new (System.Collections.Generic.List$1(T)).$ctor2(this.ValueCount);
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).$ctor2(this.ValueCount);
                    var rowPointers = target.RowPointers;

                    for (var i = sourceRowIndex; i < ((sourceRowIndex + rowCount) | 0); i = (i + 1) | 0) {
                        rowPointers[System.Array.index(((i + rowOffset) | 0), rowPointers)] = values.Count;

                        var startIndex = this.RowPointers[System.Array.index(i, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((i + 1) | 0), this.RowPointers)];

                        for (var k = startIndex; k < endIndex; k = (k + 1) | 0) {
                            if ((this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] >= sourceColumnIndex) && (this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] < ((sourceColumnIndex + columnCount) | 0))) {
                                values.add(this.Values[System.Array.index(k, this.Values)]);
                                columnIndices.add(((this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] + columnOffset) | 0));
                            }
                        }
                    }

                    for (var i1 = (targetRowIndex + rowCount) | 0; i1 < rowPointers.length; i1 = (i1 + 1) | 0) {
                        rowPointers[System.Array.index(i1, rowPointers)] = values.Count;
                    }

                    target.RowPointers[System.Array.index(target.RowCount, target.RowPointers)] = values.Count;
                    target.Values = values.ToArray();
                    target.ColumnIndices = columnIndices.ToArray();

                    return;
                }

                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
                }

                for (var i2 = sourceRowIndex, row = 0; row < rowCount; i2 = (i2 + 1) | 0, row = (row + 1) | 0) {
                    var startIndex1 = this.RowPointers[System.Array.index(i2, this.RowPointers)];
                    var endIndex1 = this.RowPointers[System.Array.index(((i2 + 1) | 0), this.RowPointers)];

                    for (var j = startIndex1; j < endIndex1; j = (j + 1) | 0) {
                        if ((this.ColumnIndices[System.Array.index(j, this.ColumnIndices)] >= sourceColumnIndex) && (this.ColumnIndices[System.Array.index(j, this.ColumnIndices)] < ((sourceColumnIndex + columnCount) | 0))) {
                            var column = (this.ColumnIndices[System.Array.index(j, this.ColumnIndices)] - sourceColumnIndex) | 0;
                            target.At$1(((targetRowIndex + row) | 0), ((targetColumnIndex + column) | 0), this.Values[System.Array.index(j, this.Values)]);
                        }
                    }
                }
            },
            CopySubRowToUnchecked: function (target, rowIndex, sourceColumnIndex, targetColumnIndex, columnCount, existingData) {
                var startIndexOfRow = this.RowPointers[System.Array.index(rowIndex, this.RowPointers)];
                var endIndexOfRow = this.RowPointers[System.Array.index(((rowIndex + 1) | 0), this.RowPointers)];

                if (startIndexOfRow === endIndexOfRow) {
                    if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                        target.Clear$1(targetColumnIndex, columnCount);
                    }
                    return;
                }

                var targetSparse = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T));
                if (targetSparse != null) {
                    if ((sourceColumnIndex === 0) && (targetColumnIndex === 0) && (columnCount === this.ColumnCount) && (this.ColumnCount === targetSparse.Length)) {
                        targetSparse.ValueCount = (endIndexOfRow - startIndexOfRow) | 0;
                        targetSparse.Values = System.Array.init(targetSparse.ValueCount, function (){
                            return Bridge.getDefaultValue(T);
                        }, T);
                        targetSparse.Indices = System.Array.init(targetSparse.ValueCount, 0, System.Int32);
                        System.Array.copy(this.ColumnIndices, startIndexOfRow, targetSparse.Indices, 0, targetSparse.ValueCount);
                        System.Array.copy(this.Values, startIndexOfRow, targetSparse.Values, 0, targetSparse.ValueCount);
                    } else {
                        var sourceStartPos = System.Array.binarySearch(this.ColumnIndices, startIndexOfRow, ((endIndexOfRow - startIndexOfRow) | 0), sourceColumnIndex);
                        if (sourceStartPos < 0) {
                            sourceStartPos = ~sourceStartPos;
                        }
                        var sourceEndPos = System.Array.binarySearch(this.ColumnIndices, startIndexOfRow, ((endIndexOfRow - startIndexOfRow) | 0), ((sourceColumnIndex + columnCount) | 0));
                        if (sourceEndPos < 0) {
                            sourceEndPos = ~sourceEndPos;
                        }
                        var positionsToCopy = (sourceEndPos - sourceStartPos) | 0;
                        if (positionsToCopy > 0) {
                            var targetStartPos = System.Array.binarySearch(targetSparse.Indices, 0, targetSparse.ValueCount, targetColumnIndex);
                            if (targetStartPos < 0) {
                                targetStartPos = ~targetStartPos;
                            }
                            var targetEndPos = System.Array.binarySearch(targetSparse.Indices, 0, targetSparse.ValueCount, ((targetColumnIndex + columnCount) | 0));
                            if (targetEndPos < 0) {
                                targetEndPos = Math.max(~targetEndPos, targetStartPos);
                            }
                            var newValueCount = (((targetSparse.ValueCount - (((targetEndPos - targetStartPos) | 0))) | 0) + positionsToCopy) | 0;
                            var newValues = System.Array.init(newValueCount, function (){
                                return Bridge.getDefaultValue(T);
                            }, T);
                            var newIndices = System.Array.init(newValueCount, 0, System.Int32);
                            System.Array.copy(targetSparse.Indices, 0, newIndices, 0, targetStartPos);
                            System.Array.copy(targetSparse.Values, 0, newValues, 0, targetStartPos);
                            var shiftRight = (targetColumnIndex - sourceColumnIndex) | 0;
                            for (var i = 0; i < positionsToCopy; i = (i + 1) | 0) {
                                newIndices[System.Array.index(((targetStartPos + i) | 0), newIndices)] = (this.ColumnIndices[System.Array.index(((sourceStartPos + i) | 0), this.ColumnIndices)] + shiftRight) | 0;
                            }
                            System.Array.copy(this.Values, sourceStartPos, newValues, targetStartPos, positionsToCopy);
                            System.Array.copy(targetSparse.Indices, targetEndPos, newIndices, ((positionsToCopy + targetStartPos) | 0), ((targetSparse.ValueCount - targetEndPos) | 0));
                            System.Array.copy(targetSparse.Values, targetEndPos, newValues, ((positionsToCopy + targetStartPos) | 0), ((targetSparse.ValueCount - targetEndPos) | 0));
                            targetSparse.Values = newValues;
                            targetSparse.Indices = newIndices;
                            targetSparse.ValueCount = newValueCount;
                        } else {
                            if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                                target.Clear$1(targetColumnIndex, columnCount);
                            }
                        }
                    }
                    return;
                }
                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.Clear$1(targetColumnIndex, columnCount);
                }
                for (var i1 = sourceColumnIndex, j = 0; i1 < ((sourceColumnIndex + columnCount) | 0); i1 = (i1 + 1) | 0, j = (j + 1) | 0) {
                    var index = this.FindItem(rowIndex, i1);
                    target.At$1(j, index >= 0 ? this.Values[System.Array.index(index, this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                }
            },
            TransposeToUnchecked: function (target, existingData) {
                var sparseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(T));
                if (sparseTarget != null) {
                    this.TransposeToUnchecked$2(sparseTarget);
                    return;
                }

                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(T));
                if (denseTarget != null) {
                    this.TransposeToUnchecked$1(denseTarget, existingData);
                    return;
                }


                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.Clear();
                }

                if (this.ValueCount !== 0) {
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            target.At$1(this.ColumnIndices[System.Array.index(j, this.ColumnIndices)], row, this.Values[System.Array.index(j, this.Values)]);
                        }
                    }
                }
            },
            TransposeToUnchecked$2: function (target) {
                var $t, $t1, $t2;
                target.Values = System.Array.init(this.ValueCount, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                target.ColumnIndices = System.Array.init(this.ValueCount, 0, System.Int32);
                var cx = target.Values;
                var cp = target.RowPointers;
                var ci = target.ColumnIndices;

                var w = System.Array.init(this.ColumnCount, 0, System.Int32);
                for (var p = 0; p < this.RowPointers[System.Array.index(this.RowCount, this.RowPointers)]; p = (p + 1) | 0) {
                    w[System.Array.index(($t = this.ColumnIndices[System.Array.index(p, this.ColumnIndices)]), w)] = (w[System.Array.index($t, w)] + 1) | 0;
                }

                var nz = 0;
                for (var i = 0; i < this.ColumnCount; i = (i + 1) | 0) {
                    cp[System.Array.index(i, cp)] = nz;
                    nz = (nz + w[System.Array.index(i, w)]) | 0;
                    w[System.Array.index(i, w)] = cp[System.Array.index(i, cp)];
                }
                cp[System.Array.index(this.ColumnCount, cp)] = nz;

                for (var i1 = 0; i1 < this.RowCount; i1 = (i1 + 1) | 0) {
                    for (var p1 = this.RowPointers[System.Array.index(i1, this.RowPointers)]; p1 < this.RowPointers[System.Array.index(((i1 + 1) | 0), this.RowPointers)]; p1 = (p1 + 1) | 0) {
                        var j = Bridge.identity(w[System.Array.index(($t1 = this.ColumnIndices[System.Array.index(p1, this.ColumnIndices)]), w)], (($t2 = (w[System.Array.index($t1, w)] + 1) | 0, w[System.Array.index($t1, w)] = $t2, $t2)));

                        ci[System.Array.index(j, ci)] = i1;
                        cx[System.Array.index(j, cx)] = this.Values[System.Array.index(p1, this.Values)];
                    }
                }
            },
            TransposeToUnchecked$1: function (target, existingData) {
                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.Clear();
                }

                if (this.ValueCount !== 0) {
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var targetIndex = Bridge.Int.mul(row, this.ColumnCount);
                        var startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            target.Data[System.Array.index(((targetIndex + this.ColumnIndices[System.Array.index(j, this.ColumnIndices)]) | 0), target.Data)] = this.Values[System.Array.index(j, this.Values)];
                        }
                    }
                }
            },
            TransposeSquareInplaceUnchecked: function () {
                var $t, $t1, $t2;
                var cx = System.Array.init(this.ValueCount, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                var cp = System.Array.init(((this.RowCount + 1) | 0), 0, System.Int32);
                var ci = System.Array.init(this.ValueCount, 0, System.Int32);

                var w = System.Array.init(this.ColumnCount, 0, System.Int32);
                for (var p = 0; p < this.RowPointers[System.Array.index(this.RowCount, this.RowPointers)]; p = (p + 1) | 0) {
                    w[System.Array.index(($t = this.ColumnIndices[System.Array.index(p, this.ColumnIndices)]), w)] = (w[System.Array.index($t, w)] + 1) | 0;
                }

                var nz = 0;
                for (var i = 0; i < this.ColumnCount; i = (i + 1) | 0) {
                    cp[System.Array.index(i, cp)] = nz;
                    nz = (nz + w[System.Array.index(i, w)]) | 0;
                    w[System.Array.index(i, w)] = cp[System.Array.index(i, cp)];
                }
                cp[System.Array.index(this.ColumnCount, cp)] = nz;

                for (var i1 = 0; i1 < this.RowCount; i1 = (i1 + 1) | 0) {
                    for (var p1 = this.RowPointers[System.Array.index(i1, this.RowPointers)]; p1 < this.RowPointers[System.Array.index(((i1 + 1) | 0), this.RowPointers)]; p1 = (p1 + 1) | 0) {
                        var j = Bridge.identity(w[System.Array.index(($t1 = this.ColumnIndices[System.Array.index(p1, this.ColumnIndices)]), w)], (($t2 = (w[System.Array.index($t1, w)] + 1) | 0, w[System.Array.index($t1, w)] = $t2, $t2)));

                        ci[System.Array.index(j, ci)] = i1;
                        cx[System.Array.index(j, cx)] = this.Values[System.Array.index(p1, this.Values)];
                    }
                }

                System.Array.copy(cx, 0, this.Values, 0, this.ValueCount);

                System.Array.copy(ci, 0, this.ColumnIndices, 0, this.ValueCount);
                System.Array.copy(cp, 0, this.RowPointers, 0, (((this.RowCount + 1) | 0)));
            },
            ToRowMajorArray: function () {
                var ret = System.Array.init(Bridge.Int.mul(this.RowCount, this.ColumnCount), function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                if (this.ValueCount !== 0) {
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var offset = Bridge.Int.mul(row, this.ColumnCount);
                        var startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            ret[System.Array.index(((offset + this.ColumnIndices[System.Array.index(j, this.ColumnIndices)]) | 0), ret)] = this.Values[System.Array.index(j, this.Values)];
                        }
                    }
                }
                return ret;
            },
            ToColumnMajorArray: function () {
                var ret = System.Array.init(Bridge.Int.mul(this.RowCount, this.ColumnCount), function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                if (this.ValueCount !== 0) {
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            ret[System.Array.index(((Bridge.Int.mul((this.ColumnIndices[System.Array.index(j, this.ColumnIndices)]), this.RowCount) + row) | 0), ret)] = this.Values[System.Array.index(j, this.Values)];
                        }
                    }
                }
                return ret;
            },
            ToRowArrays: function () {
                var ret = System.Array.init(this.RowCount, null, System.Array.type(T));
                if (this.ValueCount !== 0) {
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var array = System.Array.init(this.ColumnCount, function (){
                            return Bridge.getDefaultValue(T);
                        }, T);
                        var startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            array[System.Array.index(this.ColumnIndices[System.Array.index(j, this.ColumnIndices)], array)] = this.Values[System.Array.index(j, this.Values)];
                        }
                        ret[System.Array.index(row, ret)] = array;
                    }
                }
                return ret;
            },
            ToColumnArrays: function () {
                var $t;
                var ret = System.Array.init(this.ColumnCount, null, System.Array.type(T));
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    ret[System.Array.index(j, ret)] = System.Array.init(this.RowCount, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
                if (this.ValueCount !== 0) {
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];
                        for (var j1 = startIndex; j1 < endIndex; j1 = (j1 + 1) | 0) {
                            ($t = ret[System.Array.index(this.ColumnIndices[System.Array.index(j1, this.ColumnIndices)], ret)])[System.Array.index(row, $t)] = this.Values[System.Array.index(j1, this.Values)];
                        }
                    }
                }
                return ret;
            },
            ToArray: function () {
                var ret = System.Array.create(function (){
                    return Bridge.getDefaultValue(T);
                }, null, T, this.RowCount, this.ColumnCount);
                if (this.ValueCount !== 0) {
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            ret.set([row, this.ColumnIndices[System.Array.index(j, this.ColumnIndices)]], this.Values[System.Array.index(j, this.Values)]);
                        }
                    }
                }
                return ret;
            },
            Enumerate: function () {
                return new (Bridge.GeneratorEnumerable$1(T))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        k,
                        row,
                        col,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        k = 0;
                                            row = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( row < this.RowCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 9;
                                        continue;
                                    }
                                    case 2: {
                                        col = 0;
                                            $step = 3;
                                            continue;
                                    }
                                    case 3: {
                                        if ( col < this.ColumnCount ) {
                                                $step = 4;
                                                continue;
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 4: {
                                        $enumerator.current = k < this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)] && this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] === col ? this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero;
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {
                                        col = (col + 1) | 0;
                                        $step = 3;
                                        continue;
                                    }
                                    case 7: {
                                        $step = 8;
                                        continue;
                                    }
                                    case 8: {
                                        row = (row + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 9: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            EnumerateIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        k,
                        row,
                        col,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        k = 0;
                                            row = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( row < this.RowCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 9;
                                        continue;
                                    }
                                    case 2: {
                                        col = 0;
                                            $step = 3;
                                            continue;
                                    }
                                    case 3: {
                                        if ( col < this.ColumnCount ) {
                                                $step = 4;
                                                continue;
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 4: {
                                        $enumerator.current = k < this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)] && this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] === col ? { Item1: row, Item2: col, Item3: this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)] } : { Item1: row, Item2: col, Item3: MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero };
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {
                                        col = (col + 1) | 0;
                                        $step = 3;
                                        continue;
                                    }
                                    case 7: {
                                        $step = 8;
                                        continue;
                                    }
                                    case 8: {
                                        row = (row + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 9: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            EnumerateNonZero: function () {
                return System.Linq.Enumerable.from(this.Values, T).take(this.ValueCount).where(function (x) {
                    return !Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, x, T);
                });
            },
            EnumerateNonZeroIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        row,
                        startIndex,
                        endIndex,
                        j,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$3(System.Int32,System.Int32,T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        row = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( row < this.RowCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 11;
                                        continue;
                                    }
                                    case 2: {
                                        startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                                            endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];
                                            j = startIndex;
                                            $step = 3;
                                            continue;
                                    }
                                    case 3: {
                                        if ( j < endIndex ) {
                                                $step = 4;
                                                continue;
                                            }
                                        $step = 9;
                                        continue;
                                    }
                                    case 4: {
                                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, this.Values[System.Array.index(j, this.Values)], T)) {
                                                $step = 5;
                                                continue;
                                            } 
                                            $step = 7;
                                            continue;
                                    }
                                    case 5: {
                                        $enumerator.current = { Item1: row, Item2: this.ColumnIndices[System.Array.index(j, this.ColumnIndices)], Item3: this.Values[System.Array.index(j, this.Values)] };
                                            $step = 6;
                                            return true;
                                    }
                                    case 6: {
                                        $step = 7;
                                        continue;
                                    }
                                    case 7: {
                                        $step = 8;
                                        continue;
                                    }
                                    case 8: {
                                        j = (j + 1) | 0;
                                        $step = 3;
                                        continue;
                                    }
                                    case 9: {
                                        $step = 10;
                                        continue;
                                    }
                                    case 10: {
                                        row = (row + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 11: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            Find: function (predicate, zeros) {
                for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                    var startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                    var endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];
                    for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                        if (predicate(this.Values[System.Array.index(j, this.Values)])) {
                            return { Item1: row, Item2: this.ColumnIndices[System.Array.index(j, this.ColumnIndices)], Item3: this.Values[System.Array.index(j, this.Values)] };
                        }
                    }
                }
                if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include && this.ValueCount < (Bridge.Int.mul(this.RowCount, this.ColumnCount))) {
                    if (predicate(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero)) {
                        var k = 0;
                        for (var row1 = 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                            for (var col = 0; col < this.ColumnCount; col = (col + 1) | 0) {
                                if (k < this.RowPointers[System.Array.index(((row1 + 1) | 0), this.RowPointers)] && this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] === col) {
                                    k = (k + 1) | 0;
                                } else {
                                    return { Item1: row1, Item2: col, Item3: MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero };
                                }
                            }
                        }
                    }
                }
                return null;
            },
            Find2Unchecked: function (TOther, other, predicate, zeros) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(TOther));
                if (denseOther != null) {
                    var otherData = denseOther.Data;
                    var k = 0;
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        for (var col = 0; col < this.ColumnCount; col = (col + 1) | 0) {
                            var available = k < this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)] && this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] === col;
                            if (predicate(available ? this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherData[System.Array.index(((Bridge.Int.mul(col, this.RowCount) + row) | 0), otherData)])) {
                                return { Item1: row, Item2: col, Item3: available ? this.Values[System.Array.index(((k - 1) | 0), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, Item4: otherData[System.Array.index(((Bridge.Int.mul(col, this.RowCount) + row) | 0), otherData)] };
                            }
                        }
                    }
                    return null;
                }

                var diagonalOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(TOther));
                if (diagonalOther != null) {
                    var otherData1 = diagonalOther.Data;
                    var otherZero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;

                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include && predicate(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherZero)) {
                        var k1 = 0;
                        for (var row1 = 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                            for (var col1 = 0; col1 < this.ColumnCount; col1 = (col1 + 1) | 0) {
                                var available1 = k1 < this.RowPointers[System.Array.index(((row1 + 1) | 0), this.RowPointers)] && this.ColumnIndices[System.Array.index(k1, this.ColumnIndices)] === col1;
                                if (predicate(available1 ? this.Values[System.Array.index(Bridge.identity(k1, ((k1 = (k1 + 1) | 0))), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, row1 === col1 ? otherData1[System.Array.index(row1, otherData1)] : otherZero)) {
                                    return { Item1: row1, Item2: col1, Item3: available1 ? this.Values[System.Array.index(((k1 - 1) | 0), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, Item4: row1 === col1 ? otherData1[System.Array.index(row1, otherData1)] : otherZero };
                                }
                            }
                        }
                        return null;
                    }

                    for (var row2 = 0; row2 < this.RowCount; row2 = (row2 + 1) | 0) {
                        var diagonal = false;
                        var startIndex = this.RowPointers[System.Array.index(row2, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row2 + 1) | 0), this.RowPointers)];
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            if (this.ColumnIndices[System.Array.index(j, this.ColumnIndices)] === row2) {
                                diagonal = true;
                                if (predicate(this.Values[System.Array.index(j, this.Values)], otherData1[System.Array.index(row2, otherData1)])) {
                                    return { Item1: row2, Item2: row2, Item3: this.Values[System.Array.index(j, this.Values)], Item4: otherData1[System.Array.index(row2, otherData1)] };
                                }
                            } else {
                                if (predicate(this.Values[System.Array.index(j, this.Values)], otherZero)) {
                                    return { Item1: row2, Item2: this.ColumnIndices[System.Array.index(j, this.ColumnIndices)], Item3: this.Values[System.Array.index(j, this.Values)], Item4: otherZero };
                                }
                            }
                        }
                        if (!diagonal && row2 < this.ColumnCount) {
                            if (predicate(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherData1[System.Array.index(row2, otherData1)])) {
                                return { Item1: row2, Item2: row2, Item3: MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, Item4: otherData1[System.Array.index(row2, otherData1)] };
                            }
                        }
                    }
                    return null;
                }

                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(TOther));
                if (sparseOther != null) {
                    var otherRowPointers = sparseOther.RowPointers;
                    var otherColumnIndices = sparseOther.ColumnIndices;
                    var otherValues = sparseOther.Values;
                    var otherZero1 = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;

                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include) {
                        var k2 = 0, otherk = 0;
                        for (var row3 = 0; row3 < this.RowCount; row3 = (row3 + 1) | 0) {
                            for (var col2 = 0; col2 < this.ColumnCount; col2 = (col2 + 1) | 0) {
                                var available2 = k2 < this.RowPointers[System.Array.index(((row3 + 1) | 0), this.RowPointers)] && this.ColumnIndices[System.Array.index(k2, this.ColumnIndices)] === col2;
                                var otherAvailable = otherk < otherRowPointers[System.Array.index(((row3 + 1) | 0), otherRowPointers)] && otherColumnIndices[System.Array.index(otherk, otherColumnIndices)] === col2;
                                if (predicate(available2 ? this.Values[System.Array.index(Bridge.identity(k2, ((k2 = (k2 + 1) | 0))), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherAvailable ? otherValues[System.Array.index(Bridge.identity(otherk, ((otherk = (otherk + 1) | 0))), otherValues)] : otherZero1)) {
                                    return { Item1: row3, Item2: col2, Item3: available2 ? this.Values[System.Array.index(((k2 - 1) | 0), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, Item4: otherAvailable ? otherValues[System.Array.index(((otherk - 1) | 0), otherValues)] : otherZero1 };
                                }
                            }
                        }
                        return null;
                    }

                    for (var row4 = 0; row4 < this.RowCount; row4 = (row4 + 1) | 0) {
                        var endIndex1 = this.RowPointers[System.Array.index(((row4 + 1) | 0), this.RowPointers)];
                        var otherEndIndex = otherRowPointers[System.Array.index(((row4 + 1) | 0), otherRowPointers)];
                        var k3 = this.RowPointers[System.Array.index(row4, this.RowPointers)];
                        var otherk1 = otherRowPointers[System.Array.index(row4, otherRowPointers)];
                        while (k3 < endIndex1 || otherk1 < otherEndIndex) {
                            if (k3 === endIndex1 || otherk1 < otherEndIndex && this.ColumnIndices[System.Array.index(k3, this.ColumnIndices)] > otherColumnIndices[System.Array.index(otherk1, otherColumnIndices)]) {
                                if (predicate(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherValues[System.Array.index(Bridge.identity(otherk1, ((otherk1 = (otherk1 + 1) | 0))), otherValues)])) {
                                    return { Item1: row4, Item2: otherColumnIndices[System.Array.index(((otherk1 - 1) | 0), otherColumnIndices)], Item3: MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, Item4: otherValues[System.Array.index(((otherk1 - 1) | 0), otherValues)] };
                                }
                            } else if (otherk1 === otherEndIndex || this.ColumnIndices[System.Array.index(k3, this.ColumnIndices)] < otherColumnIndices[System.Array.index(otherk1, otherColumnIndices)]) {
                                if (predicate(this.Values[System.Array.index(Bridge.identity(k3, ((k3 = (k3 + 1) | 0))), this.Values)], otherZero1)) {
                                    return { Item1: row4, Item2: this.ColumnIndices[System.Array.index(((k3 - 1) | 0), this.ColumnIndices)], Item3: this.Values[System.Array.index(((k3 - 1) | 0), this.Values)], Item4: otherZero1 };
                                }
                            } else {
                                if (predicate(this.Values[System.Array.index(Bridge.identity(k3, ((k3 = (k3 + 1) | 0))), this.Values)], otherValues[System.Array.index(Bridge.identity(otherk1, ((otherk1 = (otherk1 + 1) | 0))), otherValues)])) {
                                    return { Item1: row4, Item2: this.ColumnIndices[System.Array.index(((k3 - 1) | 0), this.ColumnIndices)], Item3: this.Values[System.Array.index(((k3 - 1) | 0), this.Values)], Item4: otherValues[System.Array.index(((otherk1 - 1) | 0), otherValues)] };
                                }
                            }
                        }
                    }
                    return null;
                }


                return MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).prototype.Find2Unchecked.call(this, TOther, other, predicate, zeros);
            },
            MapInplace: function (f, zeros) {
                if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, f(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero), T)) {
                    var newRowPointers = this.RowPointers;
                    var newColumnIndices = new (System.Collections.Generic.List$1(System.Int32)).$ctor2(this.ColumnIndices.length);
                    var newValues = new (System.Collections.Generic.List$1(T)).$ctor2(this.Values.length);

                    var k = 0;
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        newRowPointers[System.Array.index(row, newRowPointers)] = newValues.Count;
                        for (var col = 0; col < this.ColumnCount; col = (col + 1) | 0) {
                            var item = k < this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)] && this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] === col ? f(this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)]) : f(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, item, T)) {
                                newValues.add(item);
                                newColumnIndices.add(col);
                            }
                        }
                    }

                    this.ColumnIndices = newColumnIndices.ToArray();
                    this.Values = newValues.ToArray();
                    newRowPointers[System.Array.index(this.RowCount, newRowPointers)] = newValues.Count;
                } else {
                    var nonZero = 0;
                    for (var row1 = 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                        var startIndex = this.RowPointers[System.Array.index(row1, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row1 + 1) | 0), this.RowPointers)];
                        this.RowPointers[System.Array.index(row1, this.RowPointers)] = nonZero;
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            var item1 = f(this.Values[System.Array.index(j, this.Values)]);
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, item1, T)) {
                                this.Values[System.Array.index(nonZero, this.Values)] = item1;
                                this.ColumnIndices[System.Array.index(nonZero, this.ColumnIndices)] = this.ColumnIndices[System.Array.index(j, this.ColumnIndices)];
                                nonZero = (nonZero + 1) | 0;
                            }
                        }
                    }
                    System.Array.resize(Bridge.ref(this, "ColumnIndices"), nonZero, 0, System.Int32);
                    System.Array.resize(Bridge.ref(this, "Values"), nonZero, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                    this.RowPointers[System.Array.index(this.RowCount, this.RowPointers)] = nonZero;
                }
            },
            MapIndexedInplace: function (f, zeros) {
                if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, f(0, 1, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero), T)) {
                    var newRowPointers = this.RowPointers;
                    var newColumnIndices = new (System.Collections.Generic.List$1(System.Int32)).$ctor2(this.ColumnIndices.length);
                    var newValues = new (System.Collections.Generic.List$1(T)).$ctor2(this.Values.length);

                    var k = 0;
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        newRowPointers[System.Array.index(row, newRowPointers)] = newValues.Count;
                        for (var col = 0; col < this.ColumnCount; col = (col + 1) | 0) {
                            var item = k < this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)] && this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] === col ? f(row, col, this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)]) : f(row, col, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, item, T)) {
                                newValues.add(item);
                                newColumnIndices.add(col);
                            }
                        }
                    }

                    this.ColumnIndices = newColumnIndices.ToArray();
                    this.Values = newValues.ToArray();
                    newRowPointers[System.Array.index(this.RowCount, newRowPointers)] = newValues.Count;
                } else {
                    var nonZero = 0;
                    for (var row1 = 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                        var startIndex = this.RowPointers[System.Array.index(row1, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row1 + 1) | 0), this.RowPointers)];
                        this.RowPointers[System.Array.index(row1, this.RowPointers)] = nonZero;
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            var item1 = f(row1, this.ColumnIndices[System.Array.index(j, this.ColumnIndices)], this.Values[System.Array.index(j, this.Values)]);
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, item1, T)) {
                                this.Values[System.Array.index(nonZero, this.Values)] = item1;
                                this.ColumnIndices[System.Array.index(nonZero, this.ColumnIndices)] = this.ColumnIndices[System.Array.index(j, this.ColumnIndices)];
                                nonZero = (nonZero + 1) | 0;
                            }
                        }
                    }
                    System.Array.resize(Bridge.ref(this, "ColumnIndices"), nonZero, 0, System.Int32);
                    System.Array.resize(Bridge.ref(this, "Values"), nonZero, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                    this.RowPointers[System.Array.index(this.RowCount, this.RowPointers)] = nonZero;
                }
            },
            MapToUnchecked: function (TU, target, f, zeros, existingData) {
                var processZeros = zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, f(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));

                var sparseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(TU));
                if (sparseTarget != null) {
                    var newRowPointers = sparseTarget.RowPointers;
                    var newColumnIndices = new (System.Collections.Generic.List$1(System.Int32)).$ctor2(this.ColumnIndices.length);
                    var newValues = new (System.Collections.Generic.List$1(TU)).$ctor2(this.Values.length);

                    if (processZeros) {
                        var k = 0;
                        for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                            newRowPointers[System.Array.index(row, newRowPointers)] = newValues.Count;
                            for (var col = 0; col < this.ColumnCount; col = (col + 1) | 0) {
                                var item = k < this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)] && this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] === col ? f(this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)]) : f(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                                if (!Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, item)) {
                                    newValues.add(item);
                                    newColumnIndices.add(col);
                                }
                            }
                        }
                    } else {
                        for (var row1 = 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                            newRowPointers[System.Array.index(row1, newRowPointers)] = newValues.Count;
                            var startIndex = this.RowPointers[System.Array.index(row1, this.RowPointers)];
                            var endIndex = this.RowPointers[System.Array.index(((row1 + 1) | 0), this.RowPointers)];
                            for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                                var item1 = f(this.Values[System.Array.index(j, this.Values)]);
                                if (!Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, item1)) {
                                    newValues.add(item1);
                                    newColumnIndices.add(this.ColumnIndices[System.Array.index(j, this.ColumnIndices)]);
                                }
                            }
                        }
                    }

                    sparseTarget.ColumnIndices = newColumnIndices.ToArray();
                    sparseTarget.Values = newValues.ToArray();
                    newRowPointers[System.Array.index(this.RowCount, newRowPointers)] = newValues.Count;
                    return;
                }


                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear && !processZeros) {
                    target.Clear();
                }

                if (processZeros) {
                    for (var row2 = 0; row2 < this.RowCount; row2 = (row2 + 1) | 0) {
                        var index = this.RowPointers[System.Array.index(row2, this.RowPointers)];
                        var endIndex1 = this.RowPointers[System.Array.index(((row2 + 1) | 0), this.RowPointers)];
                        for (var j1 = 0; j1 < this.ColumnCount; j1 = (j1 + 1) | 0) {
                            if (index < endIndex1 && j1 === this.ColumnIndices[System.Array.index(index, this.ColumnIndices)]) {
                                target.At$1(row2, j1, f(this.Values[System.Array.index(index, this.Values)]));
                                index = Math.min(((index + 1) | 0), endIndex1);
                            } else {
                                target.At$1(row2, j1, f(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));
                            }
                        }
                    }
                } else {
                    for (var row3 = 0; row3 < this.RowCount; row3 = (row3 + 1) | 0) {
                        var startIndex1 = this.RowPointers[System.Array.index(row3, this.RowPointers)];
                        var endIndex2 = this.RowPointers[System.Array.index(((row3 + 1) | 0), this.RowPointers)];
                        for (var j2 = startIndex1; j2 < endIndex2; j2 = (j2 + 1) | 0) {
                            target.At$1(row3, this.ColumnIndices[System.Array.index(j2, this.ColumnIndices)], f(this.Values[System.Array.index(j2, this.Values)]));
                        }
                    }
                }
            },
            MapIndexedToUnchecked: function (TU, target, f, zeros, existingData) {
                var processZeros = zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, f(0, 1, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));

                var sparseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(TU));
                if (sparseTarget != null) {
                    var newRowPointers = sparseTarget.RowPointers;
                    var newColumnIndices = new (System.Collections.Generic.List$1(System.Int32)).$ctor2(this.ColumnIndices.length);
                    var newValues = new (System.Collections.Generic.List$1(TU)).$ctor2(this.Values.length);

                    if (processZeros) {
                        var k = 0;
                        for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                            newRowPointers[System.Array.index(row, newRowPointers)] = newValues.Count;
                            for (var col = 0; col < this.ColumnCount; col = (col + 1) | 0) {
                                var item = k < this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)] && this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] === col ? f(row, col, this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)]) : f(row, col, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                                if (!Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, item)) {
                                    newValues.add(item);
                                    newColumnIndices.add(col);
                                }
                            }
                        }
                    } else {
                        for (var row1 = 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                            newRowPointers[System.Array.index(row1, newRowPointers)] = newValues.Count;
                            var startIndex = this.RowPointers[System.Array.index(row1, this.RowPointers)];
                            var endIndex = this.RowPointers[System.Array.index(((row1 + 1) | 0), this.RowPointers)];
                            for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                                var item1 = f(row1, this.ColumnIndices[System.Array.index(j, this.ColumnIndices)], this.Values[System.Array.index(j, this.Values)]);
                                if (!Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, item1)) {
                                    newValues.add(item1);
                                    newColumnIndices.add(this.ColumnIndices[System.Array.index(j, this.ColumnIndices)]);
                                }
                            }
                        }
                    }

                    sparseTarget.ColumnIndices = newColumnIndices.ToArray();
                    sparseTarget.Values = newValues.ToArray();
                    newRowPointers[System.Array.index(this.RowCount, newRowPointers)] = newValues.Count;
                    return;
                }


                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear && !processZeros) {
                    target.Clear();
                }

                if (processZeros) {
                    for (var row2 = 0; row2 < this.RowCount; row2 = (row2 + 1) | 0) {
                        var index = this.RowPointers[System.Array.index(row2, this.RowPointers)];
                        var endIndex1 = this.RowPointers[System.Array.index(((row2 + 1) | 0), this.RowPointers)];
                        for (var j1 = 0; j1 < this.ColumnCount; j1 = (j1 + 1) | 0) {
                            if (index < endIndex1 && j1 === this.ColumnIndices[System.Array.index(index, this.ColumnIndices)]) {
                                target.At$1(row2, j1, f(row2, j1, this.Values[System.Array.index(index, this.Values)]));
                                index = Math.min(((index + 1) | 0), endIndex1);
                            } else {
                                target.At$1(row2, j1, f(row2, j1, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));
                            }
                        }
                    }
                } else {
                    for (var row3 = 0; row3 < this.RowCount; row3 = (row3 + 1) | 0) {
                        var startIndex1 = this.RowPointers[System.Array.index(row3, this.RowPointers)];
                        var endIndex2 = this.RowPointers[System.Array.index(((row3 + 1) | 0), this.RowPointers)];
                        for (var j2 = startIndex1; j2 < endIndex2; j2 = (j2 + 1) | 0) {
                            target.At$1(row3, this.ColumnIndices[System.Array.index(j2, this.ColumnIndices)], f(row3, this.ColumnIndices[System.Array.index(j2, this.ColumnIndices)], this.Values[System.Array.index(j2, this.Values)]));
                        }
                    }
                }
            },
            MapSubMatrixIndexedToUnchecked: function (TU, target, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros, existingData) {
                var sparseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(TU));
                if (sparseTarget != null) {
                    this.MapSubMatrixIndexedToUnchecked$1(TU, sparseTarget, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros, existingData);
                    return;
                }


                var processZeros = zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, f(0, 1, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));
                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear && !processZeros) {
                    target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
                }

                if (processZeros) {
                    for (var sr = sourceRowIndex, tr = targetRowIndex; sr < ((sourceRowIndex + rowCount) | 0); sr = (sr + 1) | 0, tr = (tr + 1) | 0) {
                        var index = this.RowPointers[System.Array.index(sr, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((sr + 1) | 0), this.RowPointers)];

                        for (; this.ColumnIndices[System.Array.index(index, this.ColumnIndices)] < sourceColumnIndex && index < endIndex; index = (index + 1) | 0) {
                        }
                        for (var sc = sourceColumnIndex, tc = targetColumnIndex; sc < ((sourceColumnIndex + columnCount) | 0); sc = (sc + 1) | 0, tc = (tc + 1) | 0) {
                            if (index < endIndex && sc === this.ColumnIndices[System.Array.index(index, this.ColumnIndices)]) {
                                target.At$1(tr, tc, f(tr, tc, this.Values[System.Array.index(index, this.Values)]));
                                index = Math.min(((index + 1) | 0), endIndex);
                            } else {
                                target.At$1(tr, tc, f(tr, tc, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));
                            }
                        }
                    }
                } else {
                    var columnOffset = (targetColumnIndex - sourceColumnIndex) | 0;
                    for (var sr1 = sourceRowIndex, tr1 = targetRowIndex; sr1 < ((sourceRowIndex + rowCount) | 0); sr1 = (sr1 + 1) | 0, tr1 = (tr1 + 1) | 0) {
                        var startIndex = this.RowPointers[System.Array.index(sr1, this.RowPointers)];
                        var endIndex1 = this.RowPointers[System.Array.index(((sr1 + 1) | 0), this.RowPointers)];
                        for (var k = startIndex; k < endIndex1; k = (k + 1) | 0) {
                            if ((this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] >= sourceColumnIndex) && (this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] < ((sourceColumnIndex + columnCount) | 0))) {
                                var tc1 = (this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] + columnOffset) | 0;
                                target.At$1(tr1, tc1, f(tr1, tc1, this.Values[System.Array.index(k, this.Values)]));
                            }
                        }
                    }
                }
            },
            MapSubMatrixIndexedToUnchecked$1: function (TU, target, f, sourceRowIndex, targetRowIndex, rowCount, sourceColumnIndex, targetColumnIndex, columnCount, zeros, existingData) {
                var processZeros = zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, f(0, 1, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));
                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear && !processZeros) {
                    target.ClearUnchecked(targetRowIndex, rowCount, targetColumnIndex, columnCount);
                }

                var rowOffset = (targetRowIndex - sourceRowIndex) | 0;
                var columnOffset = (targetColumnIndex - sourceColumnIndex) | 0;
                var zero = MathNet.Numerics.LinearAlgebra.Matrix$1(TU).Zero;

                if (target.ValueCount === 0) {
                    var values = new (System.Collections.Generic.List$1(TU)).$ctor2(this.ValueCount);
                    var columnIndices = new (System.Collections.Generic.List$1(System.Int32)).$ctor2(this.ValueCount);
                    var rowPointers = target.RowPointers;

                    if (processZeros) {
                        for (var sr = sourceRowIndex; sr < ((sourceRowIndex + rowCount) | 0); sr = (sr + 1) | 0) {
                            var tr = (sr + rowOffset) | 0;
                            rowPointers[System.Array.index(tr, rowPointers)] = values.Count;

                            var index = this.RowPointers[System.Array.index(sr, this.RowPointers)];
                            var endIndex = this.RowPointers[System.Array.index(((sr + 1) | 0), this.RowPointers)];

                            for (; this.ColumnIndices[System.Array.index(index, this.ColumnIndices)] < sourceColumnIndex && index < endIndex; index = (index + 1) | 0) {
                            }
                            for (var sc = sourceColumnIndex, tc = targetColumnIndex; sc < ((sourceColumnIndex + columnCount) | 0); sc = (sc + 1) | 0, tc = (tc + 1) | 0) {
                                if (index < endIndex && sc === this.ColumnIndices[System.Array.index(index, this.ColumnIndices)]) {
                                    var item = f(tr, tc, this.Values[System.Array.index(index, this.Values)]);
                                    if (!Bridge.equalsT(zero, item, TU)) {
                                        values.add(item);
                                        columnIndices.add(tc);
                                    }
                                    index = Math.min(((index + 1) | 0), endIndex);
                                } else {
                                    var item1 = f(tr, tc, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                                    if (!Bridge.equalsT(zero, item1, TU)) {
                                        values.add(item1);
                                        columnIndices.add(tc);
                                    }
                                }
                            }
                        }
                    } else {
                        for (var sr1 = sourceRowIndex; sr1 < ((sourceRowIndex + rowCount) | 0); sr1 = (sr1 + 1) | 0) {
                            var tr1 = (sr1 + rowOffset) | 0;
                            rowPointers[System.Array.index(tr1, rowPointers)] = values.Count;

                            var startIndex = this.RowPointers[System.Array.index(sr1, this.RowPointers)];
                            var endIndex1 = this.RowPointers[System.Array.index(((sr1 + 1) | 0), this.RowPointers)];

                            for (var k = startIndex; k < endIndex1; k = (k + 1) | 0) {
                                if ((this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] >= sourceColumnIndex) && (this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] < ((sourceColumnIndex + columnCount) | 0))) {
                                    var tc1 = (this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] + columnOffset) | 0;
                                    var item2 = f(tr1, tc1, this.Values[System.Array.index(k, this.Values)]);
                                    if (!Bridge.equalsT(zero, item2, TU)) {
                                        values.add(item2);
                                        columnIndices.add(tc1);
                                    }
                                }
                            }
                        }
                    }

                    for (var i = (targetRowIndex + rowCount) | 0; i < rowPointers.length; i = (i + 1) | 0) {
                        rowPointers[System.Array.index(i, rowPointers)] = values.Count;
                    }

                    target.RowPointers[System.Array.index(target.RowCount, target.RowPointers)] = values.Count;
                    target.Values = values.ToArray();
                    target.ColumnIndices = columnIndices.ToArray();
                    return;
                }


                if (processZeros) {
                    for (var sr2 = sourceRowIndex, tr2 = targetRowIndex; sr2 < ((sourceRowIndex + rowCount) | 0); sr2 = (sr2 + 1) | 0, tr2 = (tr2 + 1) | 0) {
                        var index1 = this.RowPointers[System.Array.index(sr2, this.RowPointers)];
                        var endIndex2 = this.RowPointers[System.Array.index(((sr2 + 1) | 0), this.RowPointers)];

                        for (; this.ColumnIndices[System.Array.index(index1, this.ColumnIndices)] < sourceColumnIndex && index1 < endIndex2; index1 = (index1 + 1) | 0) {
                        }
                        for (var sc1 = sourceColumnIndex, tc2 = targetColumnIndex; sc1 < ((sourceColumnIndex + columnCount) | 0); sc1 = (sc1 + 1) | 0, tc2 = (tc2 + 1) | 0) {
                            if (index1 < endIndex2 && sc1 === this.ColumnIndices[System.Array.index(index1, this.ColumnIndices)]) {
                                target.At$1(tr2, tc2, f(tr2, tc2, this.Values[System.Array.index(index1, this.Values)]));
                                index1 = Math.min(((index1 + 1) | 0), endIndex2);
                            } else {
                                target.At$1(tr2, tc2, f(tr2, tc2, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero));
                            }
                        }
                    }
                } else {
                    for (var sr3 = sourceRowIndex, tr3 = targetRowIndex; sr3 < ((sourceRowIndex + rowCount) | 0); sr3 = (sr3 + 1) | 0, tr3 = (tr3 + 1) | 0) {
                        var startIndex1 = this.RowPointers[System.Array.index(sr3, this.RowPointers)];
                        var endIndex3 = this.RowPointers[System.Array.index(((sr3 + 1) | 0), this.RowPointers)];
                        for (var k1 = startIndex1; k1 < endIndex3; k1 = (k1 + 1) | 0) {
                            if ((this.ColumnIndices[System.Array.index(k1, this.ColumnIndices)] >= sourceColumnIndex) && (this.ColumnIndices[System.Array.index(k1, this.ColumnIndices)] < ((sourceColumnIndex + columnCount) | 0))) {
                                var tc3 = (this.ColumnIndices[System.Array.index(k1, this.ColumnIndices)] + columnOffset) | 0;
                                target.At$1(tr3, tc3, f(tr3, tc3, this.Values[System.Array.index(k1, this.Values)]));
                            }
                        }
                    }
                }
            },
            FoldByRowUnchecked: function (TU, target, f, finalize, state, zeros) {
                if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip) {
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];
                        var s = state[System.Array.index(row, state)];
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            s = f(s, this.Values[System.Array.index(j, this.Values)]);
                        }
                        target[System.Array.index(row, target)] = finalize(s, ((endIndex - startIndex) | 0));
                    }
                } else {
                    for (var row1 = 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                        var index = this.RowPointers[System.Array.index(row1, this.RowPointers)];
                        var endIndex1 = this.RowPointers[System.Array.index(((row1 + 1) | 0), this.RowPointers)];
                        var s1 = state[System.Array.index(row1, state)];
                        for (var j1 = 0; j1 < this.ColumnCount; j1 = (j1 + 1) | 0) {
                            if (index < endIndex1 && j1 === this.ColumnIndices[System.Array.index(index, this.ColumnIndices)]) {
                                s1 = f(s1, this.Values[System.Array.index(index, this.Values)]);
                                index = Math.min(((index + 1) | 0), endIndex1);
                            } else {
                                s1 = f(s1, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                            }
                        }
                        target[System.Array.index(row1, target)] = finalize(s1, this.ColumnCount);
                    }
                }
            },
            FoldByColumnUnchecked: function (TU, target, f, finalize, state, zeros) {
                if (!Bridge.referenceEquals(state, target)) {
                    System.Array.copy(state, 0, target, 0, state.length);
                }
                if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip) {
                    var count = System.Array.init(this.ColumnCount, 0, System.Int32);
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var startIndex = this.RowPointers[System.Array.index(row, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)];
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            var column = this.ColumnIndices[System.Array.index(j, this.ColumnIndices)];
                            target[System.Array.index(column, target)] = f(target[System.Array.index(column, target)], this.Values[System.Array.index(j, this.Values)]);
                            count[System.Array.index(column, count)] = (count[System.Array.index(column, count)] + 1) | 0;
                        }
                    }
                    for (var j1 = 0; j1 < this.ColumnCount; j1 = (j1 + 1) | 0) {
                        target[System.Array.index(j1, target)] = finalize(target[System.Array.index(j1, target)], count[System.Array.index(j1, count)]);
                    }
                } else {
                    for (var row1 = 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                        var index = this.RowPointers[System.Array.index(row1, this.RowPointers)];
                        var endIndex1 = this.RowPointers[System.Array.index(((row1 + 1) | 0), this.RowPointers)];
                        for (var j2 = 0; j2 < this.ColumnCount; j2 = (j2 + 1) | 0) {
                            if (index < endIndex1 && j2 === this.ColumnIndices[System.Array.index(index, this.ColumnIndices)]) {
                                target[System.Array.index(j2, target)] = f(target[System.Array.index(j2, target)], this.Values[System.Array.index(index, this.Values)]);
                                index = Math.min(((index + 1) | 0), endIndex1);
                            } else {
                                target[System.Array.index(j2, target)] = f(target[System.Array.index(j2, target)], MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero);
                            }
                        }
                    }
                    for (var j3 = 0; j3 < this.ColumnCount; j3 = (j3 + 1) | 0) {
                        target[System.Array.index(j3, target)] = finalize(target[System.Array.index(j3, target)], this.RowCount);
                    }
                }
            },
            Fold2Unchecked: function (TOther, TState, other, f, state, zeros) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(TOther));
                if (denseOther != null) {
                    var otherData = denseOther.Data;
                    var k = 0;
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        for (var col = 0; col < this.ColumnCount; col = (col + 1) | 0) {
                            var available = k < this.RowPointers[System.Array.index(((row + 1) | 0), this.RowPointers)] && this.ColumnIndices[System.Array.index(k, this.ColumnIndices)] === col;
                            state = f(state, available ? this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherData[System.Array.index(((Bridge.Int.mul(col, this.RowCount) + row) | 0), otherData)]);
                        }
                    }
                    return state;
                }

                var diagonalOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(TOther));
                if (diagonalOther != null) {
                    var otherData1 = diagonalOther.Data;
                    var otherZero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;

                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include) {
                        var k1 = 0;
                        for (var row1 = 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                            for (var col1 = 0; col1 < this.ColumnCount; col1 = (col1 + 1) | 0) {
                                var available1 = k1 < this.RowPointers[System.Array.index(((row1 + 1) | 0), this.RowPointers)] && this.ColumnIndices[System.Array.index(k1, this.ColumnIndices)] === col1;
                                state = f(state, available1 ? this.Values[System.Array.index(Bridge.identity(k1, ((k1 = (k1 + 1) | 0))), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, row1 === col1 ? otherData1[System.Array.index(row1, otherData1)] : otherZero);
                            }
                        }
                        return state;
                    }

                    for (var row2 = 0; row2 < this.RowCount; row2 = (row2 + 1) | 0) {
                        var diagonal = false;

                        var startIndex = this.RowPointers[System.Array.index(row2, this.RowPointers)];
                        var endIndex = this.RowPointers[System.Array.index(((row2 + 1) | 0), this.RowPointers)];
                        for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                            if (this.ColumnIndices[System.Array.index(j, this.ColumnIndices)] === row2) {
                                diagonal = true;
                                state = f(state, this.Values[System.Array.index(j, this.Values)], otherData1[System.Array.index(row2, otherData1)]);
                            } else {
                                state = f(state, this.Values[System.Array.index(j, this.Values)], otherZero);
                            }
                        }

                        if (!diagonal && row2 < this.ColumnCount) {
                            state = f(state, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherData1[System.Array.index(row2, otherData1)]);
                        }
                    }
                    return state;
                }

                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(TOther));
                if (sparseOther != null) {
                    var otherRowPointers = sparseOther.RowPointers;
                    var otherColumnIndices = sparseOther.ColumnIndices;
                    var otherValues = sparseOther.Values;
                    var otherZero1 = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;

                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include) {
                        var k2 = 0, otherk = 0;
                        for (var row3 = 0; row3 < this.RowCount; row3 = (row3 + 1) | 0) {
                            for (var col2 = 0; col2 < this.ColumnCount; col2 = (col2 + 1) | 0) {
                                var available2 = k2 < this.RowPointers[System.Array.index(((row3 + 1) | 0), this.RowPointers)] && this.ColumnIndices[System.Array.index(k2, this.ColumnIndices)] === col2;
                                var otherAvailable = otherk < otherRowPointers[System.Array.index(((row3 + 1) | 0), otherRowPointers)] && otherColumnIndices[System.Array.index(otherk, otherColumnIndices)] === col2;
                                state = f(state, available2 ? this.Values[System.Array.index(Bridge.identity(k2, ((k2 = (k2 + 1) | 0))), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherAvailable ? otherValues[System.Array.index(Bridge.identity(otherk, ((otherk = (otherk + 1) | 0))), otherValues)] : otherZero1);
                            }
                        }
                        return state;
                    }

                    for (var row4 = 0; row4 < this.RowCount; row4 = (row4 + 1) | 0) {
                        var startIndex1 = this.RowPointers[System.Array.index(row4, this.RowPointers)];
                        var endIndex1 = this.RowPointers[System.Array.index(((row4 + 1) | 0), this.RowPointers)];
                        var otherStartIndex = otherRowPointers[System.Array.index(row4, otherRowPointers)];
                        var otherEndIndex = otherRowPointers[System.Array.index(((row4 + 1) | 0), otherRowPointers)];

                        var j1 = startIndex1;
                        var j2 = otherStartIndex;

                        while (j1 < endIndex1 || j2 < otherEndIndex) {
                            if (j1 === endIndex1 || j2 < otherEndIndex && this.ColumnIndices[System.Array.index(j1, this.ColumnIndices)] > otherColumnIndices[System.Array.index(j2, otherColumnIndices)]) {
                                state = f(state, MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).Zero, otherValues[System.Array.index(Bridge.identity(j2, ((j2 = (j2 + 1) | 0))), otherValues)]);
                            } else if (j2 === otherEndIndex || this.ColumnIndices[System.Array.index(j1, this.ColumnIndices)] < otherColumnIndices[System.Array.index(j2, otherColumnIndices)]) {
                                state = f(state, this.Values[System.Array.index(Bridge.identity(j1, ((j1 = (j1 + 1) | 0))), this.Values)], otherZero1);
                            } else {
                                state = f(state, this.Values[System.Array.index(Bridge.identity(j1, ((j1 = (j1 + 1) | 0))), this.Values)], otherValues[System.Array.index(Bridge.identity(j2, ((j2 = (j2 + 1) | 0))), otherValues)]);
                            }
                        }
                    }
                    return state;
                }


                return MathNet.Numerics.LinearAlgebra.Storage.MatrixStorage$1(T).prototype.Fold2Unchecked.call(this, TOther, TState, other, f, state, zeros);
            }
        }
    }; });

    Bridge.define("MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1", function (T) { return {
        inherits: [MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T)],
        statics: {
            methods: {
                OfVector: function (vector) {
                    var storage = new (MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T))(vector.Length);
                    vector.CopyToUnchecked(storage, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                    return storage;
                },
                OfValue: function (length, value) {
                    var $t;
                    if (Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, value, T)) {
                        return new (MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T))(length);
                    }

                    if (length < 1) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("length", System.String.format("Resources.ArgumentLessThanOne{0}", [Bridge.box(length, System.Int32)]));
                    }

                    var indices = System.Array.init(length, 0, System.Int32);
                    var values = System.Array.init(length, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    for (var i = 0; i < indices.length; i = (i + 1) | 0) {
                        indices[System.Array.index(i, indices)] = i;
                        values[System.Array.index(i, values)] = value;
                    }

                    return ($t = new (MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T))(length), $t.Indices = indices, $t.Values = values, $t.ValueCount = length, $t);
                },
                OfInit: function (length, init) {
                    var $t;
                    if (length < 1) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("length", System.String.format("Resources.ArgumentLessThanOne{0}", [Bridge.box(length, System.Int32)]));
                    }

                    var indices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();
                    for (var i = 0; i < length; i = (i + 1) | 0) {
                        var item = init(i);
                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, item, T)) {
                            values.add(item);
                            indices.add(i);
                        }
                    }
                    return ($t = new (MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T))(length), $t.Indices = indices.ToArray(), $t.Values = values.ToArray(), $t.ValueCount = values.Count, $t);
                },
                OfEnumerable: function (data) {
                    var $t, $t1;
                    if (data == null) {
                        throw new System.ArgumentNullException.$ctor1("data");
                    }

                    var indices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();
                    var index = 0;

                    $t = Bridge.getEnumerator(data, T);
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, item, T)) {
                                values.add(item);
                                indices.add(index);
                            }
                            index = (index + 1) | 0;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return ($t1 = new (MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T))(index), $t1.Indices = indices.ToArray(), $t1.Values = values.ToArray(), $t1.ValueCount = values.Count, $t1);
                },
                OfIndexedEnumerable: function (length, data) {
                    var $t, $t1;
                    if (data == null) {
                        throw new System.ArgumentNullException.$ctor1("data");
                    }

                    var indices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();
                    $t = Bridge.getEnumerator(data, System.Tuple$2(System.Int32,T));
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, item.Item2, T)) {
                                values.add(item.Item2);
                                indices.add(item.Item1);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    var indicesArray = indices.ToArray();
                    var valuesArray = values.ToArray();
                    MathNet.Numerics.Sorting.Sort$2(System.Int32, T, indicesArray, valuesArray);

                    return ($t1 = new (MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T))(length), $t1.Indices = indicesArray, $t1.Values = valuesArray, $t1.ValueCount = values.Count, $t1);
                }
            }
        },
        fields: {
            /**
             * Array that contains the indices of the non-zero values.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1
             * @type Array.<number>
             */
            Indices: null,
            /**
             * Array that contains the non-zero elements of the vector.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1
             * @type Array.<T>
             */
            Values: null,
            /**
             * Gets the number of non-zero elements in the vector.
             *
             * @instance
             * @public
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1
             * @type number
             */
            ValueCount: 0
        },
        props: {
            /**
             * True if the vector storage format is dense.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1
             * @function IsDense
             * @type boolean
             */
            IsDense: {
                get: function () {
                    return false;
                }
            }
        },
        alias: ["equalsT", "System$IEquatable$1$MathNet$Numerics$LinearAlgebra$Storage$VectorStorage$1$" + Bridge.getTypeAlias(T) + "$equalsT"],
        ctors: {
            ctor: function (length) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).ctor.call(this, length);
                this.Indices = System.Array.init(0, 0, System.Int32);
                this.Values = System.Array.init(0, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                this.ValueCount = 0;
            }
        },
        methods: {
            /**
             * Retrieves the requested element without range checking.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1
             * @param   {number}    index
             * @return  {T}
             */
            At: function (index) {
                var itemIndex = System.Array.binarySearch(this.Indices, 0, this.ValueCount, index);
                return itemIndex >= 0 ? this.Values[System.Array.index(itemIndex, this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero;
            },
            /**
             * Sets the element without range checking.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1
             * @param   {number}    index    
             * @param   {T}         value
             * @return  {void}
             */
            At$1: function (index, value) {
                var itemIndex = System.Array.binarySearch(this.Indices, 0, this.ValueCount, index);
                if (itemIndex >= 0) {
                    if (Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, value, T)) {
                        this.RemoveAtIndexUnchecked(itemIndex);
                    } else {
                        this.Values[System.Array.index(itemIndex, this.Values)] = value;
                    }
                } else {
                    if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, value, T)) {
                        this.InsertAtIndexUnchecked(~itemIndex, index, value);
                    }
                }
            },
            InsertAtIndexUnchecked: function (itemIndex, index, value) {
                if ((this.ValueCount === this.Values.length) && (this.ValueCount < this.Length)) {
                    var size = Math.min(((this.Values.length + this.GrowthSize()) | 0), this.Length);
                    System.Array.resize(Bridge.ref(this, "Values"), size, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                    System.Array.resize(Bridge.ref(this, "Indices"), size, 0, System.Int32);
                }

                System.Array.copy(this.Values, itemIndex, this.Values, ((itemIndex + 1) | 0), ((this.ValueCount - itemIndex) | 0));
                System.Array.copy(this.Indices, itemIndex, this.Indices, ((itemIndex + 1) | 0), ((this.ValueCount - itemIndex) | 0));

                this.Values[System.Array.index(itemIndex, this.Values)] = value;
                this.Indices[System.Array.index(itemIndex, this.Indices)] = index;

                this.ValueCount = (this.ValueCount + 1) | 0;
            },
            RemoveAtIndexUnchecked: function (itemIndex) {
                System.Array.copy(this.Values, ((itemIndex + 1) | 0), this.Values, itemIndex, ((((this.ValueCount - itemIndex) | 0) - 1) | 0));
                System.Array.copy(this.Indices, ((itemIndex + 1) | 0), this.Indices, itemIndex, ((((this.ValueCount - itemIndex) | 0) - 1) | 0));

                this.ValueCount = (this.ValueCount - 1) | 0;

                if ((this.ValueCount > 1024) && (this.ValueCount < ((Bridge.Int.div(this.Indices.length, 2)) | 0))) {
                    System.Array.resize(Bridge.ref(this, "Values"), this.ValueCount, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                    System.Array.resize(Bridge.ref(this, "Indices"), this.ValueCount, 0, System.Int32);
                }
            },
            /**
             * Calculates the amount with which to grow the storage array's if they need to be
             increased in size.
             *
             * @instance
             * @private
             * @this MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1
             * @return  {number}        The amount grown.
             */
            GrowthSize: function () {
                var delta;
                if (this.Values.length > 1024) {
                    delta = (Bridge.Int.div(this.Values.length, 4)) | 0;
                } else {
                    if (this.Values.length > 256) {
                        delta = 512;
                    } else {
                        delta = this.Values.length > 64 ? 128 : 32;
                    }
                }

                return delta;
            },
            equalsT: function (other) {
                if (other == null || this.Length !== other.Length) {
                    return false;
                }

                if (Bridge.referenceEquals(this, other)) {
                    return true;
                }

                var otherSparse = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T));
                if (otherSparse == null) {
                    return MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).prototype.equalsT.call(this, other);
                }

                var i = 0, j = 0;
                while (i < this.ValueCount || j < otherSparse.ValueCount) {
                    if (j >= otherSparse.ValueCount || i < this.ValueCount && this.Indices[System.Array.index(i, this.Indices)] < otherSparse.Indices[System.Array.index(j, otherSparse.Indices)]) {
                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, this.Values[System.Array.index(Bridge.identity(i, ((i = (i + 1) | 0))), this.Values)], T)) {
                            return false;
                        }
                        continue;
                    }

                    if (i >= this.ValueCount || j < otherSparse.ValueCount && otherSparse.Indices[System.Array.index(j, otherSparse.Indices)] < this.Indices[System.Array.index(i, this.Indices)]) {
                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, otherSparse.Values[System.Array.index(Bridge.identity(j, ((j = (j + 1) | 0))), otherSparse.Values)], T)) {
                            return false;
                        }
                        continue;
                    }

                    if (!Bridge.equalsT(this.Values[System.Array.index(i, this.Values)], otherSparse.Values[System.Array.index(j, otherSparse.Values)], T)) {
                        return false;
                    }

                    i = (i + 1) | 0;
                    j = (j + 1) | 0;
                }

                return true;
            },
            /**
             * Returns a hash code for this instance.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1
             * @memberof MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1
             * @return  {number}        A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
             */
            getHashCode: function () {
                var values = this.Values;
                var hashNum = Math.min(this.ValueCount, 25);
                var hash = 17;
                for (var i = 0; i < hashNum; i = (i + 1) | 0) {
                    hash = (Bridge.Int.mul(hash, 31) + Bridge.getHashCode(values[i])) | 0;
                }
                return hash;
            },
            Clear: function () {
                this.ValueCount = 0;
            },
            Clear$1: function (index, count) {
                if (index === 0 && count === this.Length) {
                    this.Clear();
                    return;
                }

                var first = System.Array.binarySearch(this.Indices, 0, this.ValueCount, index);
                var last = System.Array.binarySearch(this.Indices, 0, this.ValueCount, ((((index + count) | 0) - 1) | 0));
                if (first < 0) {
                    first = ~first;
                }
                if (last < 0) {
                    last = (~last - 1) | 0;
                }
                var itemCount = (((last - first) | 0) + 1) | 0;

                if (itemCount > 0) {
                    System.Array.copy(this.Values, ((first + itemCount) | 0), this.Values, first, ((((this.ValueCount - first) | 0) - itemCount) | 0));
                    System.Array.copy(this.Indices, ((first + itemCount) | 0), this.Indices, first, ((((this.ValueCount - first) | 0) - itemCount) | 0));

                    this.ValueCount = (this.ValueCount - itemCount) | 0;
                }

                if ((this.ValueCount > 1024) && (this.ValueCount < ((Bridge.Int.div(this.Indices.length, 2)) | 0))) {
                    System.Array.resize(Bridge.ref(this, "Values"), this.ValueCount, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                    System.Array.resize(Bridge.ref(this, "Indices"), this.ValueCount, 0, System.Int32);
                }
            },
            CopyToRowUnchecked: function (target, rowIndex, existingData) {
                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.ClearUnchecked(rowIndex, 1, 0, this.Length);
                }

                if (this.ValueCount === 0) {
                    return;
                }

                for (var i = 0; i < this.ValueCount; i = (i + 1) | 0) {
                    target.At$1(rowIndex, this.Indices[System.Array.index(i, this.Indices)], this.Values[System.Array.index(i, this.Values)]);
                }
            },
            CopyToColumnUnchecked: function (target, columnIndex, existingData) {
                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.ClearUnchecked(0, this.Length, columnIndex, 1);
                }

                if (this.ValueCount === 0) {
                    return;
                }

                for (var i = 0; i < this.ValueCount; i = (i + 1) | 0) {
                    target.At$1(this.Indices[System.Array.index(i, this.Indices)], columnIndex, this.Values[System.Array.index(i, this.Values)]);
                }
            },
            CopySubVectorToUnchecked: function (target, sourceIndex, targetIndex, count, existingData) {
                var sparseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T));
                if (sparseTarget != null) {
                    this.CopySubVectorToUnchecked$1(sparseTarget, sourceIndex, targetIndex, count, existingData);
                    return;
                }


                var offset = (targetIndex - sourceIndex) | 0;

                var sourceFirst = System.Array.binarySearch(this.Indices, 0, this.ValueCount, sourceIndex);
                var sourceLast = System.Array.binarySearch(this.Indices, 0, this.ValueCount, ((((sourceIndex + count) | 0) - 1) | 0));
                if (sourceFirst < 0) {
                    sourceFirst = ~sourceFirst;
                }
                if (sourceLast < 0) {
                    sourceLast = (~sourceLast - 1) | 0;
                }

                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.Clear$1(targetIndex, count);
                }

                for (var i = sourceFirst; i <= sourceLast; i = (i + 1) | 0) {
                    target.At$1(((this.Indices[System.Array.index(i, this.Indices)] + offset) | 0), this.Values[System.Array.index(i, this.Values)]);
                }
            },
            CopySubVectorToUnchecked$1: function (target, sourceIndex, targetIndex, count, existingData) {
                var offset = (targetIndex - sourceIndex) | 0;

                var sourceFirst = System.Array.binarySearch(this.Indices, 0, this.ValueCount, sourceIndex);
                var sourceLast = System.Array.binarySearch(this.Indices, 0, this.ValueCount, ((((sourceIndex + count) | 0) - 1) | 0));
                if (sourceFirst < 0) {
                    sourceFirst = ~sourceFirst;
                }
                if (sourceLast < 0) {
                    sourceLast = (~sourceLast - 1) | 0;
                }
                var sourceCount = (((sourceLast - sourceFirst) | 0) + 1) | 0;

                if (Bridge.referenceEquals(this, target)) {
                    var values = System.Array.init(sourceCount, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    var indices = System.Array.init(sourceCount, 0, System.Int32);

                    System.Array.copy(this.Values, sourceFirst, values, 0, sourceCount);
                    for (var i = 0; i < indices.length; i = (i + 1) | 0) {
                        indices[System.Array.index(i, indices)] = this.Indices[System.Array.index(((i + sourceFirst) | 0), this.Indices)];
                    }

                    if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                        this.Clear$1(targetIndex, count);
                    }

                    for (var i1 = sourceFirst; i1 <= sourceLast; i1 = (i1 + 1) | 0) {
                        this.At$1(((indices[System.Array.index(i1, indices)] + offset) | 0), values[System.Array.index(i1, values)]);
                    }

                    return;
                }

                if (target.ValueCount === 0) {
                    var values1 = System.Array.init(sourceCount, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    var indices1 = System.Array.init(sourceCount, 0, System.Int32);

                    System.Array.copy(this.Values, sourceFirst, values1, 0, sourceCount);
                    for (var i2 = 0; i2 < indices1.length; i2 = (i2 + 1) | 0) {
                        indices1[System.Array.index(i2, indices1)] = (this.Indices[System.Array.index(((i2 + sourceFirst) | 0), this.Indices)] + offset) | 0;
                    }

                    target.ValueCount = sourceCount;
                    target.Values = values1;
                    target.Indices = indices1;

                    return;
                }

                if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                    target.Clear$1(targetIndex, count);
                }

                for (var i3 = sourceFirst; i3 <= sourceLast; i3 = (i3 + 1) | 0) {
                    target.At$1(((this.Indices[System.Array.index(i3, this.Indices)] + offset) | 0), this.Values[System.Array.index(i3, this.Values)]);
                }
            },
            ToArray: function () {
                var ret = System.Array.init(this.Length, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                for (var i = 0; i < this.ValueCount; i = (i + 1) | 0) {
                    ret[System.Array.index(this.Indices[System.Array.index(i, this.Indices)], ret)] = this.Values[System.Array.index(i, this.Values)];
                }
                return ret;
            },
            Enumerate: function () {
                return new (Bridge.GeneratorEnumerable$1(T))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        k,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        k = 0;
                                            i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.Length ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = k < this.ValueCount && this.Indices[System.Array.index(k, this.Indices)] === i ? this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero;
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            EnumerateIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$2(System.Int32,T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        k,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$2(System.Int32,T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        k = 0;
                                            i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.Length ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = k < this.ValueCount && this.Indices[System.Array.index(k, this.Indices)] === i ? { Item1: i, Item2: this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)] } : { Item1: i, Item2: MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero };
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            EnumerateNonZero: function () {
                return System.Linq.Enumerable.from(this.Values, T).take(this.ValueCount).where(function (x) {
                    return !Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, x, T);
                });
            },
            EnumerateNonZeroIndexed: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Tuple$2(System.Int32,T)))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Tuple$2(System.Int32,T)))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < this.ValueCount ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 7;
                                        continue;
                                    }
                                    case 2: {
                                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, this.Values[System.Array.index(i, this.Values)], T)) {
                                                $step = 3;
                                                continue;
                                            } 
                                            $step = 5;
                                            continue;
                                    }
                                    case 3: {
                                        $enumerator.current = { Item1: this.Indices[System.Array.index(i, this.Indices)], Item2: this.Values[System.Array.index(i, this.Values)] };
                                            $step = 4;
                                            return true;
                                    }
                                    case 4: {
                                        $step = 5;
                                        continue;
                                    }
                                    case 5: {
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 7: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            Find: function (predicate, zeros) {
                for (var i = 0; i < this.ValueCount; i = (i + 1) | 0) {
                    if (predicate(this.Values[System.Array.index(i, this.Values)])) {
                        return { Item1: this.Indices[System.Array.index(i, this.Indices)], Item2: this.Values[System.Array.index(i, this.Values)] };
                    }
                }
                if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include && this.ValueCount < this.Length && predicate(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero)) {
                    for (var i1 = 0; i1 < this.Length; i1 = (i1 + 1) | 0) {
                        if (i1 >= this.ValueCount || this.Indices[System.Array.index(i1, this.Indices)] !== i1) {
                            return { Item1: i1, Item2: MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero };
                        }
                    }
                }
                return null;
            },
            Find2Unchecked: function (TOther, other, predicate, zeros) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(TOther));
                if (denseOther != null) {
                    var otherData = denseOther.Data;
                    var k = 0;
                    for (var i = 0; i < otherData.length; i = (i + 1) | 0) {
                        if (k < this.ValueCount && this.Indices[System.Array.index(k, this.Indices)] === i) {
                            if (predicate(this.Values[System.Array.index(k, this.Values)], otherData[System.Array.index(i, otherData)])) {
                                return { Item1: i, Item2: this.Values[System.Array.index(k, this.Values)], Item3: otherData[System.Array.index(i, otherData)] };
                            }
                            k = (k + 1) | 0;
                        } else {
                            if (predicate(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, otherData[System.Array.index(i, otherData)])) {
                                return { Item1: i, Item2: MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, Item3: otherData[System.Array.index(i, otherData)] };
                            }
                        }
                    }
                    return null;
                }

                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(TOther));
                if (sparseOther != null) {
                    var otherIndices = sparseOther.Indices;
                    var otherValues = sparseOther.Values;
                    var otherValueCount = sparseOther.ValueCount;
                    var otherZero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Matrix.Zero;

                    var k1 = 0, otherk = 0;
                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include && this.ValueCount < this.Length && sparseOther.ValueCount < this.Length && predicate(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, otherZero)) {
                        for (var i1 = 0; i1 < this.Length; i1 = (i1 + 1) | 0) {
                            var left = k1 < this.ValueCount && this.Indices[System.Array.index(k1, this.Indices)] === i1 ? this.Values[System.Array.index(Bridge.identity(k1, ((k1 = (k1 + 1) | 0))), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero;
                            var right = otherk < otherValueCount && otherIndices[System.Array.index(otherk, otherIndices)] === i1 ? otherValues[System.Array.index(Bridge.identity(otherk, ((otherk = (otherk + 1) | 0))), otherValues)] : otherZero;
                            if (predicate(left, right)) {
                                return { Item1: i1, Item2: left, Item3: right };
                            }
                        }
                        return null;
                    }

                    k1 = 0;
                    otherk = 0;
                    while (k1 < this.ValueCount || otherk < otherValueCount) {
                        if (k1 === this.ValueCount || otherk < otherValueCount && this.Indices[System.Array.index(k1, this.Indices)] > otherIndices[System.Array.index(otherk, otherIndices)]) {
                            if (predicate(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, otherValues[System.Array.index(Bridge.identity(otherk, ((otherk = (otherk + 1) | 0))), otherValues)])) {
                                return { Item1: otherIndices[System.Array.index(((otherk - 1) | 0), otherIndices)], Item2: MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, Item3: otherValues[System.Array.index(((otherk - 1) | 0), otherValues)] };
                            }
                        } else if (otherk === otherValueCount || this.Indices[System.Array.index(k1, this.Indices)] < otherIndices[System.Array.index(otherk, otherIndices)]) {
                            if (predicate(this.Values[System.Array.index(Bridge.identity(k1, ((k1 = (k1 + 1) | 0))), this.Values)], otherZero)) {
                                return { Item1: this.Indices[System.Array.index(((k1 - 1) | 0), this.Indices)], Item2: this.Values[System.Array.index(((k1 - 1) | 0), this.Values)], Item3: otherZero };
                            }
                        } else {
                            if (predicate(this.Values[System.Array.index(Bridge.identity(k1, ((k1 = (k1 + 1) | 0))), this.Values)], otherValues[System.Array.index(Bridge.identity(otherk, ((otherk = (otherk + 1) | 0))), otherValues)])) {
                                return { Item1: this.Indices[System.Array.index(((k1 - 1) | 0), this.Indices)], Item2: this.Values[System.Array.index(((k1 - 1) | 0), this.Values)], Item3: otherValues[System.Array.index(((otherk - 1) | 0), otherValues)] };
                            }
                        }
                    }
                    return null;
                }


                return MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).prototype.Find2Unchecked.call(this, TOther, other, predicate, zeros);
            },
            MapInplace: function (f, zeros) {
                var indices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                var values = new (System.Collections.Generic.List$1(T)).$ctor2(this.ValueCount);
                if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, f(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero), T)) {
                    var k = 0;
                    for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                        var item = k < this.ValueCount && (this.Indices[System.Array.index(k, this.Indices)]) === i ? f(this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)]) : f(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero);
                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, item, T)) {
                            values.add(item);
                            indices.add(i);
                        }
                    }
                } else {
                    for (var i1 = 0; i1 < this.ValueCount; i1 = (i1 + 1) | 0) {
                        var item1 = f(this.Values[System.Array.index(i1, this.Values)]);
                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, item1, T)) {
                            values.add(item1);
                            indices.add(this.Indices[System.Array.index(i1, this.Indices)]);
                        }
                    }
                }
                this.Indices = indices.ToArray();
                this.Values = values.ToArray();
                this.ValueCount = values.Count;
            },
            MapIndexedInplace: function (f, zeros) {
                var indices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                var values = new (System.Collections.Generic.List$1(T)).$ctor2(this.ValueCount);
                if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include) {
                    var k = 0;
                    for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                        var item = k < this.ValueCount && (this.Indices[System.Array.index(k, this.Indices)]) === i ? f(i, this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)]) : f(i, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero);
                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, item, T)) {
                            values.add(item);
                            indices.add(i);
                        }
                    }
                } else {
                    for (var i1 = 0; i1 < this.ValueCount; i1 = (i1 + 1) | 0) {
                        var item1 = f(this.Indices[System.Array.index(i1, this.Indices)], this.Values[System.Array.index(i1, this.Values)]);
                        if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, item1, T)) {
                            values.add(item1);
                            indices.add(this.Indices[System.Array.index(i1, this.Indices)]);
                        }
                    }
                }
                this.Indices = indices.ToArray();
                this.Values = values.ToArray();
                this.ValueCount = values.Count;
            },
            MapToUnchecked: function (TU, target, f, zeros, existingData) {
                var sparseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(TU));
                if (sparseTarget != null) {
                    var indices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(TU)).ctor();
                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, f(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero))) {
                        var k = 0;
                        for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                            var item = k < this.ValueCount && (this.Indices[System.Array.index(k, this.Indices)]) === i ? f(this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)]) : f(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero);
                            if (!Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, item)) {
                                values.add(item);
                                indices.add(i);
                            }
                        }
                    } else {
                        for (var i1 = 0; i1 < this.ValueCount; i1 = (i1 + 1) | 0) {
                            var item1 = f(this.Values[System.Array.index(i1, this.Values)]);
                            if (!Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, item1)) {
                                values.add(item1);
                                indices.add(this.Indices[System.Array.index(i1, this.Indices)]);
                            }
                        }
                    }
                    sparseTarget.Indices = indices.ToArray();
                    sparseTarget.Values = values.ToArray();
                    sparseTarget.ValueCount = values.Count;
                    return;
                }

                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(TU));
                if (denseTarget != null) {
                    if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                        denseTarget.Clear();
                    }

                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, f(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero))) {
                        var k1 = 0;
                        for (var i2 = 0; i2 < this.Length; i2 = (i2 + 1) | 0) {
                            denseTarget.Data[System.Array.index(i2, denseTarget.Data)] = k1 < this.ValueCount && (this.Indices[System.Array.index(k1, this.Indices)]) === i2 ? f(this.Values[System.Array.index(Bridge.identity(k1, ((k1 = (k1 + 1) | 0))), this.Values)]) : f(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero);
                        }
                    } else {

                        for (var i3 = 0; i3 < this.ValueCount; i3 = (i3 + 1) | 0) {
                            denseTarget.Data[System.Array.index(this.Indices[System.Array.index(i3, this.Indices)], denseTarget.Data)] = f(this.Values[System.Array.index(i3, this.Values)]);
                        }

                    }
                    return;
                }


                MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).prototype.MapToUnchecked.call(this, TU, target, f, zeros, existingData);
            },
            MapIndexedToUnchecked: function (TU, target, f, zeros, existingData) {
                var sparseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(TU));
                if (sparseTarget != null) {
                    var indices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(TU)).ctor();
                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, f(0, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero))) {
                        var k = 0;
                        for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                            var item = k < this.ValueCount && (this.Indices[System.Array.index(k, this.Indices)]) === i ? f(i, this.Values[System.Array.index(Bridge.identity(k, ((k = (k + 1) | 0))), this.Values)]) : f(i, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero);
                            if (!Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, item)) {
                                values.add(item);
                                indices.add(i);
                            }
                        }
                    } else {
                        for (var i1 = 0; i1 < this.ValueCount; i1 = (i1 + 1) | 0) {
                            var item1 = f(this.Indices[System.Array.index(i1, this.Indices)], this.Values[System.Array.index(i1, this.Values)]);
                            if (!Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, item1)) {
                                values.add(item1);
                                indices.add(this.Indices[System.Array.index(i1, this.Indices)]);
                            }
                        }
                    }
                    sparseTarget.Indices = indices.ToArray();
                    sparseTarget.Values = values.ToArray();
                    sparseTarget.ValueCount = values.Count;
                    return;
                }

                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(TU));
                if (denseTarget != null) {
                    if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                        denseTarget.Clear();
                    }

                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equals(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, f(0, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero))) {
                        var k1 = 0;
                        for (var i2 = 0; i2 < this.Length; i2 = (i2 + 1) | 0) {
                            denseTarget.Data[System.Array.index(i2, denseTarget.Data)] = k1 < this.ValueCount && (this.Indices[System.Array.index(k1, this.Indices)]) === i2 ? f(i2, this.Values[System.Array.index(Bridge.identity(k1, ((k1 = (k1 + 1) | 0))), this.Values)]) : f(i2, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero);
                        }
                    } else {

                        for (var i3 = 0; i3 < this.ValueCount; i3 = (i3 + 1) | 0) {
                            denseTarget.Data[System.Array.index(this.Indices[System.Array.index(i3, this.Indices)], denseTarget.Data)] = f(this.Indices[System.Array.index(i3, this.Indices)], this.Values[System.Array.index(i3, this.Values)]);
                        }

                    }
                    return;
                }


                MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).prototype.MapIndexedToUnchecked.call(this, TU, target, f, zeros, existingData);
            },
            Map2ToUnchecked: function (target, other, f, zeros, existingData) {
                var processZeros = zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include || !Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, f(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero), T);

                var denseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T));
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T));

                if (denseTarget == null && (denseOther != null || processZeros)) {
                    var intermediate = new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(T)).ctor(target.Length);
                    this.Map2ToUnchecked(intermediate, other, f, zeros, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                    intermediate.CopyTo(target, existingData);
                    return;
                }

                if (denseOther != null) {
                    var targetData = denseTarget.Data;
                    var otherData = denseOther.Data;

                    var k = 0;
                    for (var i = 0; i < otherData.length; i = (i + 1) | 0) {
                        if (k < this.ValueCount && this.Indices[System.Array.index(k, this.Indices)] === i) {
                            targetData[System.Array.index(i, targetData)] = f(this.Values[System.Array.index(k, this.Values)], otherData[System.Array.index(i, otherData)]);
                            k = (k + 1) | 0;
                        } else {
                            targetData[System.Array.index(i, targetData)] = f(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, otherData[System.Array.index(i, otherData)]);
                        }
                    }

                    return;
                }

                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T));
                if (sparseOther != null && denseTarget != null) {
                    var targetData1 = denseTarget.Data;
                    var otherIndices = sparseOther.Indices;
                    var otherValues = sparseOther.Values;
                    var otherValueCount = sparseOther.ValueCount;

                    if (processZeros) {
                        var p = 0, q = 0;
                        for (var i1 = 0; i1 < targetData1.length; i1 = (i1 + 1) | 0) {
                            var left = p < this.ValueCount && this.Indices[System.Array.index(p, this.Indices)] === i1 ? this.Values[System.Array.index(Bridge.identity(p, ((p = (p + 1) | 0))), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero;
                            var right = q < otherValueCount && otherIndices[System.Array.index(q, otherIndices)] === i1 ? otherValues[System.Array.index(Bridge.identity(q, ((q = (q + 1) | 0))), otherValues)] : MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero;
                            targetData1[System.Array.index(i1, targetData1)] = f(left, right);
                        }
                    } else {
                        if (existingData === MathNet.Numerics.LinearAlgebra.ExistingData.Clear) {
                            denseTarget.Clear();
                        }

                        var p1 = 0, q1 = 0;
                        while (p1 < this.ValueCount || q1 < otherValueCount) {
                            if (q1 >= otherValueCount || p1 < this.ValueCount && this.Indices[System.Array.index(p1, this.Indices)] < otherIndices[System.Array.index(q1, otherIndices)]) {
                                targetData1[System.Array.index(this.Indices[System.Array.index(p1, this.Indices)], targetData1)] = f(this.Values[System.Array.index(p1, this.Values)], MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero);
                                p1 = (p1 + 1) | 0;
                            } else if (p1 >= this.ValueCount || q1 < otherValueCount && this.Indices[System.Array.index(p1, this.Indices)] > otherIndices[System.Array.index(q1, otherIndices)]) {
                                targetData1[System.Array.index(otherIndices[System.Array.index(q1, otherIndices)], targetData1)] = f(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, otherValues[System.Array.index(q1, otherValues)]);
                                q1 = (q1 + 1) | 0;
                            } else {
                                System.Diagnostics.Debug.Assert(this.Indices[System.Array.index(p1, this.Indices)] === otherIndices[System.Array.index(q1, otherIndices)]);
                                targetData1[System.Array.index(this.Indices[System.Array.index(p1, this.Indices)], targetData1)] = f(this.Values[System.Array.index(p1, this.Values)], otherValues[System.Array.index(q1, otherValues)]);
                                p1 = (p1 + 1) | 0;
                                q1 = (q1 + 1) | 0;
                            }
                        }
                    }

                    return;
                }

                var sparseTarget = Bridge.as(target, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(T));
                if (sparseOther != null && sparseTarget != null) {
                    var indices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var values = new (System.Collections.Generic.List$1(T)).ctor();
                    var otherIndices1 = sparseOther.Indices;
                    var otherValues1 = sparseOther.Values;
                    var otherValueCount1 = sparseOther.ValueCount;

                    var p2 = 0, q2 = 0;
                    while (p2 < this.ValueCount || q2 < otherValueCount1) {
                        if (q2 >= otherValueCount1 || p2 < this.ValueCount && this.Indices[System.Array.index(p2, this.Indices)] < otherIndices1[System.Array.index(q2, otherIndices1)]) {
                            var value = f(this.Values[System.Array.index(p2, this.Values)], MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero);
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, value, T)) {
                                indices.add(this.Indices[System.Array.index(p2, this.Indices)]);
                                values.add(value);
                            }

                            p2 = (p2 + 1) | 0;
                        } else if (p2 >= this.ValueCount || q2 < otherValueCount1 && this.Indices[System.Array.index(p2, this.Indices)] > otherIndices1[System.Array.index(q2, otherIndices1)]) {
                            var value1 = f(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, otherValues1[System.Array.index(q2, otherValues1)]);
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, value1, T)) {
                                indices.add(otherIndices1[System.Array.index(q2, otherIndices1)]);
                                values.add(value1);
                            }

                            q2 = (q2 + 1) | 0;
                        } else {
                            var value2 = f(this.Values[System.Array.index(p2, this.Values)], otherValues1[System.Array.index(q2, otherValues1)]);
                            if (!Bridge.equalsT(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, value2, T)) {
                                indices.add(this.Indices[System.Array.index(p2, this.Indices)]);
                                values.add(value2);
                            }

                            p2 = (p2 + 1) | 0;
                            q2 = (q2 + 1) | 0;
                        }
                    }

                    sparseTarget.Indices = indices.ToArray();
                    sparseTarget.Values = values.ToArray();
                    sparseTarget.ValueCount = values.Count;
                    return;
                }


                MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).prototype.Map2ToUnchecked.call(this, target, other, f, zeros, existingData);
            },
            Fold2Unchecked: function (TOther, TState, other, f, state, zeros) {
                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(TOther));
                if (sparseOther != null) {
                    var otherIndices = sparseOther.Indices;
                    var otherValues = sparseOther.Values;
                    var otherValueCount = sparseOther.ValueCount;
                    var otherZero = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(TOther).Vector.Zero;

                    if (zeros === MathNet.Numerics.LinearAlgebra.Zeros.Include) {
                        var p = 0, q = 0;
                        for (var i = 0; i < this.Length; i = (i + 1) | 0) {
                            var left = p < this.ValueCount && this.Indices[System.Array.index(p, this.Indices)] === i ? this.Values[System.Array.index(Bridge.identity(p, ((p = (p + 1) | 0))), this.Values)] : MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero;
                            var right = q < otherValueCount && otherIndices[System.Array.index(q, otherIndices)] === i ? otherValues[System.Array.index(Bridge.identity(q, ((q = (q + 1) | 0))), otherValues)] : otherZero;
                            state = f(state, left, right);
                        }
                    } else {
                        var p1 = 0, q1 = 0;
                        while (p1 < this.ValueCount || q1 < otherValueCount) {
                            if (q1 >= otherValueCount || p1 < this.ValueCount && this.Indices[System.Array.index(p1, this.Indices)] < otherIndices[System.Array.index(q1, otherIndices)]) {
                                state = f(state, this.Values[System.Array.index(p1, this.Values)], otherZero);
                                p1 = (p1 + 1) | 0;
                            } else if (p1 >= this.ValueCount || q1 < otherValueCount && this.Indices[System.Array.index(p1, this.Indices)] > otherIndices[System.Array.index(q1, otherIndices)]) {
                                state = f(state, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, otherValues[System.Array.index(q1, otherValues)]);
                                q1 = (q1 + 1) | 0;
                            } else {
                                System.Diagnostics.Debug.Assert(this.Indices[System.Array.index(p1, this.Indices)] === otherIndices[System.Array.index(q1, otherIndices)]);
                                state = f(state, this.Values[System.Array.index(p1, this.Values)], otherValues[System.Array.index(q1, otherValues)]);
                                p1 = (p1 + 1) | 0;
                                q1 = (q1 + 1) | 0;
                            }
                        }
                    }

                    return state;
                }

                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(TOther));
                if (denseOther != null) {
                    var otherData = denseOther.Data;

                    var k = 0;
                    for (var i1 = 0; i1 < otherData.length; i1 = (i1 + 1) | 0) {
                        if (k < this.ValueCount && this.Indices[System.Array.index(k, this.Indices)] === i1) {
                            state = f(state, this.Values[System.Array.index(k, this.Values)], otherData[System.Array.index(i1, otherData)]);
                            k = (k + 1) | 0;
                        } else {
                            state = f(state, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).Zero, otherData[System.Array.index(i1, otherData)]);
                        }
                    }

                    return state;
                }

                return MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(T).prototype.Fold2Unchecked.call(this, TOther, TState, other, f, state, zeros);
            }
        }
    }; });

    /**
     * A Matrix class with dense storage. The underlying storage is a one dimensional array in column-major order (column by column).
     *
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
     * @augments MathNet.Numerics.LinearAlgebra.Double.Matrix
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.DenseMatrix", {
        inherits: [MathNet.Numerics.LinearAlgebra.Double.Matrix],
        statics: {
            methods: {
                /**
                 * Create a new dense matrix as a copy of the given other matrix.
                 This new matrix will be independent from the other matrix.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}              matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfMatrix: function (matrix) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfMatrix(matrix.Storage));
                },
                /**
                 * Create a new dense matrix as a copy of the given two-dimensional array.
                 This new matrix will be independent from the provided array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {Array.<number>}                                       array
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfArray: function (array) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfArray(array));
                },
                /**
                 * Create a new dense matrix as a copy of the given indexed enumerable.
                 Keys must be provided at most once, zero is assumed if a key is omitted.
                 This new matrix will be independent from the enumerable.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {number}                                               rows          
                 * @param   {number}                                               columns       
                 * @param   {System.Collections.Generic.IEnumerable$1}             enumerable
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfIndexed: function (rows, columns, enumerable) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfIndexedEnumerable(rows, columns, enumerable));
                },
                /**
                 * Create a new dense matrix as a copy of the given enumerable.
                 The enumerable is assumed to be in column-major order (column by column).
                 This new matrix will be independent from the enumerable.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {number}                                               rows           
                 * @param   {number}                                               columns        
                 * @param   {System.Collections.Generic.IEnumerable$1}             columnMajor
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfColumnMajor: function (rows, columns, columnMajor) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfColumnMajorEnumerable(rows, columns, columnMajor));
                },
                /**
                 * Create a new dense matrix as a copy of the given enumerable of enumerable columns.
                 Each enumerable in the master enumerable specifies a column.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {System.Collections.Generic.IEnumerable$1}             data
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfColumns: function (data) {
                    return MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.OfColumnArrays$1(System.Linq.Enumerable.from(data, System.Collections.Generic.IEnumerable$1(System.Double)).select(function (v) {
                            var $t;
                            return ($t = System.Double, System.Linq.Enumerable.from(v, $t).ToArray($t));
                        }).ToArray(System.Array.type(System.Double)));
                },
                /**
                 * Create a new dense matrix as a copy of the given enumerable of enumerable columns.
                 Each enumerable in the master enumerable specifies a column.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {number}                                               rows       
                 * @param   {number}                                               columns    
                 * @param   {System.Collections.Generic.IEnumerable$1}             data
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfColumns$1: function (rows, columns, data) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfColumnEnumerables(rows, columns, data));
                },
                /**
                 * Create a new dense matrix as a copy of the given column arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {Array.<Array.<number>>}                               columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfColumnArrays$1: function (columns) {
                    if (columns === void 0) { columns = []; }
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfColumnArrays(columns));
                },
                /**
                 * Create a new dense matrix as a copy of the given column arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {System.Collections.Generic.IEnumerable$1}             columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfColumnArrays: function (columns) {
                    var $t;
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfColumnArrays((Bridge.as(columns, System.Array.type(System.Array.type(System.Double)))) || ($t = System.Array.type(System.Double), System.Linq.Enumerable.from(columns, $t).ToArray($t))));
                },
                /**
                 * Create a new dense matrix as a copy of the given column vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}      columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfColumnVectors: function (columns) {
                    if (columns === void 0) { columns = []; }
                    var storage = System.Array.init(columns.length, null, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(System.Double));
                    for (var i = 0; i < columns.length; i = (i + 1) | 0) {
                        storage[System.Array.index(i, storage)] = columns[System.Array.index(i, columns)].Storage;
                    }
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfColumnVectors(storage));
                },
                /**
                 * Create a new dense matrix as a copy of the given column vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {System.Collections.Generic.IEnumerable$1}             columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfColumnVectors$1: function (columns) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfColumnVectors(System.Linq.Enumerable.from(columns, MathNet.Numerics.LinearAlgebra.Vector$1(System.Double)).select(function (c) {
                            return c.Storage;
                        }).ToArray(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(System.Double))));
                },
                /**
                 * Create a new dense matrix as a copy of the given enumerable of enumerable rows.
                 Each enumerable in the master enumerable specifies a row.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {System.Collections.Generic.IEnumerable$1}             data
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfRows: function (data) {
                    return MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.OfRowArrays$1(System.Linq.Enumerable.from(data, System.Collections.Generic.IEnumerable$1(System.Double)).select(function (v) {
                            var $t;
                            return ($t = System.Double, System.Linq.Enumerable.from(v, $t).ToArray($t));
                        }).ToArray(System.Array.type(System.Double)));
                },
                /**
                 * Create a new dense matrix as a copy of the given enumerable of enumerable rows.
                 Each enumerable in the master enumerable specifies a row.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {number}                                               rows       
                 * @param   {number}                                               columns    
                 * @param   {System.Collections.Generic.IEnumerable$1}             data
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfRows$1: function (rows, columns, data) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfRowEnumerables(rows, columns, data));
                },
                /**
                 * Create a new dense matrix as a copy of the given row arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {Array.<Array.<number>>}                               rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfRowArrays$1: function (rows) {
                    if (rows === void 0) { rows = []; }
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfRowArrays(rows));
                },
                /**
                 * Create a new dense matrix as a copy of the given row arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {System.Collections.Generic.IEnumerable$1}             rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfRowArrays: function (rows) {
                    var $t;
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfRowArrays((Bridge.as(rows, System.Array.type(System.Array.type(System.Double)))) || ($t = System.Array.type(System.Double), System.Linq.Enumerable.from(rows, $t).ToArray($t))));
                },
                /**
                 * Create a new dense matrix as a copy of the given row vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}      rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfRowVectors: function (rows) {
                    if (rows === void 0) { rows = []; }
                    var storage = System.Array.init(rows.length, null, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(System.Double));
                    for (var i = 0; i < rows.length; i = (i + 1) | 0) {
                        storage[System.Array.index(i, storage)] = rows[System.Array.index(i, rows)].Storage;
                    }
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfRowVectors(storage));
                },
                /**
                 * Create a new dense matrix as a copy of the given row vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {System.Collections.Generic.IEnumerable$1}             rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfRowVectors$1: function (rows) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfRowVectors(System.Linq.Enumerable.from(rows, MathNet.Numerics.LinearAlgebra.Vector$1(System.Double)).select(function (r) {
                            return r.Storage;
                        }).ToArray(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(System.Double))));
                },
                /**
                 * Create a new dense matrix with the diagonal as a copy of the given vector.
                 This new matrix will be independent from the vector.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}              diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfDiagonalVector: function (diagonal) {
                    var m = new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.$ctor2(diagonal.Count, diagonal.Count);
                    m.SetDiagonal$1(diagonal);
                    return m;
                },
                /**
                 * Create a new dense matrix with the diagonal as a copy of the given vector.
                 This new matrix will be independent from the vector.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {number}                                               rows        
                 * @param   {number}                                               columns     
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}              diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfDiagonalVector$1: function (rows, columns, diagonal) {
                    var m = new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.$ctor2(rows, columns);
                    m.SetDiagonal$1(diagonal);
                    return m;
                },
                /**
                 * Create a new dense matrix with the diagonal as a copy of the given array.
                 This new matrix will be independent from the array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {Array.<number>}                                       diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfDiagonalArray: function (diagonal) {
                    var m = new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.$ctor2(diagonal.length, diagonal.length);
                    m.SetDiagonal(diagonal);
                    return m;
                },
                /**
                 * Create a new dense matrix with the diagonal as a copy of the given array.
                 This new matrix will be independent from the array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {number}                                               rows        
                 * @param   {number}                                               columns     
                 * @param   {Array.<number>}                                       diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                OfDiagonalArray$1: function (rows, columns, diagonal) {
                    var m = new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.$ctor2(rows, columns);
                    m.SetDiagonal(diagonal);
                    return m;
                },
                /**
                 * Create a new dense matrix and initialize each value to the same provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {number}                                               rows       
                 * @param   {number}                                               columns    
                 * @param   {number}                                               value
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                Create: function (rows, columns, value) {
                    if (value === 0.0) {
                        return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.$ctor2(rows, columns);
                    }
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfValue(rows, columns, value));
                },
                /**
                 * Create a new dense matrix and initialize each value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {number}                                               rows       
                 * @param   {number}                                               columns    
                 * @param   {System.Func}                                          init
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                Create$1: function (rows, columns, init) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfInit(rows, columns, init));
                },
                /**
                 * Create a new diagonal dense matrix and initialize each diagonal value to the same provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {number}                                               rows       
                 * @param   {number}                                               columns    
                 * @param   {number}                                               value
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                CreateDiagonal: function (rows, columns, value) {
                    if (value === 0.0) {
                        return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.$ctor2(rows, columns);
                    }
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfDiagonalInit(rows, columns, function (i) {
                        return value;
                    }));
                },
                /**
                 * Create a new diagonal dense matrix and initialize each diagonal value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {number}                                               rows       
                 * @param   {number}                                               columns    
                 * @param   {System.Func}                                          init
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                CreateDiagonal$1: function (rows, columns, init) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfDiagonalInit(rows, columns, init));
                },
                /**
                 * Create a new square sparse identity matrix where each diagonal value is set to One.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @param   {number}                                               order
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}
                 */
                CreateIdentity: function (order) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double).OfDiagonalInit(order, order, function (i) {
                        return MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).One;
                    }));
                }/**
                 * Adds two matrices together and returns the results.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @throws If <b /> and <b /> don't have the same dimensions.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}    leftSide     The left matrix to add.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}    rightSide    The right matrix to add.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}                 The result of the addition.
                 */
                ,
                op_Addition: function (leftSide, rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    if (leftSide._rowCount !== rightSide._rowCount || leftSide._columnCount !== rightSide._columnCount) {
                        throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentOutOfRangeException, leftSide, rightSide);
                    }

                    return Bridge.cast(leftSide.Add$1(rightSide), MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                }/**
                 * Returns a <strong>Matrix</strong> containing the same values of <b />.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}    rightSide    The matrix to get the values from.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}                 A matrix containing a the same values as <b />.
                 */
                ,
                op_UnaryPlus: function (rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    return Bridge.cast(rightSide.Clone(), MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                }/**
                 * Subtracts two matrices together and returns the results.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @throws If <b /> and <b /> don't have the same dimensions.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}    leftSide     The left matrix to subtract.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}    rightSide    The right matrix to subtract.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}                 The result of the addition.
                 */
                ,
                op_Subtraction: function (leftSide, rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    if (leftSide._rowCount !== rightSide._rowCount || leftSide._columnCount !== rightSide._columnCount) {
                        throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentOutOfRangeException, leftSide, rightSide);
                    }

                    return Bridge.cast(leftSide.Subtract$1(rightSide), MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                }/**
                 * Negates each element of the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}    rightSide    The matrix to negate.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}                 A matrix containing the negated values.
                 */
                ,
                op_UnaryNegation: function (rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    return Bridge.cast(rightSide.Negate(), MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                }/**
                 * Multiplies a <strong>Matrix</strong> by a constant and returns the result.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}    leftSide     The matrix to multiply.
                 * @param   {number}                                               rightSide    The constant to multiply the matrix by.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}                 The result of the multiplication.
                 */
                ,
                op_Multiply$1: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Multiply(rightSide), MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                }/**
                 * Multiplies a <strong>Matrix</strong> by a constant and returns the result.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {number}                                               leftSide     The matrix to multiply.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}    rightSide    The constant to multiply the matrix by.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}                 The result of the multiplication.
                 */
                ,
                op_Multiply$2: function (leftSide, rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    return Bridge.cast(rightSide.Multiply(leftSide), MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                }/**
                 * Multiplies two matrices.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @throws If the dimensions of <b /> or <b /> don't conform.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}    leftSide     The left matrix to multiply.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}    rightSide    The right matrix to multiply.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}                 The result of multiplication.
                 */
                ,
                op_Multiply: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    if (leftSide._columnCount !== rightSide._rowCount) {
                        throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentOutOfRangeException, leftSide, rightSide);
                    }

                    return Bridge.cast(leftSide.Multiply$1(rightSide), MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                }/**
                 * Multiplies a <strong>Matrix</strong> and a Vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}    leftSide     The matrix to multiply.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    rightSide    The vector to multiply.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}                 The result of multiplication.
                 */
                ,
                op_Multiply$3: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Multiply$2(rightSide), MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                }/**
                 * Multiplies a Vector and a <strong>Matrix</strong>.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    leftSide     The vector to multiply.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}    rightSide    The matrix to multiply.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}                 The result of multiplication.
                 */
                ,
                op_Multiply$4: function (leftSide, rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    return Bridge.cast(rightSide.LeftMultiply(leftSide), MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                }/**
                 * Multiplies a <strong>Matrix</strong> by a constant and returns the result.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}    leftSide     The matrix to multiply.
                 * @param   {number}                                               rightSide    The constant to multiply the matrix by.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}                 The result of the multiplication.
                 */
                ,
                op_Modulus: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Remainder(rightSide), MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                }
            }
        },
        fields: {
            /**
             * Number of rows.
             *
             * @instance
             * @private
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @type number
             */
            _rowCount: 0,
            /**
             * Number of columns.
             *
             * @instance
             * @private
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @type number
             */
            _columnCount: 0,
            /**
             * Gets the matrix's data.
             *
             * @instance
             * @private
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @type Array.<number>
             */
            _values: null
        },
        props: {
            /**
             * Create a new dense matrix with values sampled from the provided random distribution.
             * Gets the matrix's data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @function Values
             * @type Array.<number>
             */
            Values: {
                get: function () {
                    return this._values;
                }
            }
        },
        ctors: {
            /**
             * Create a new dense matrix straight from an initialized matrix storage instance.
             The storage is used directly without copying.
             Intended for advanced scenarios where you're working directly with
             storage for performance or interop reasons.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1}    storage
             * @return  {void}
             */
            ctor: function (storage) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Double.Matrix.ctor.call(this, storage);
                this._rowCount = storage.RowCount;
                this._columnCount = storage.ColumnCount;
                this._values = storage.Data;
            },
            /**
             * Create a new square dense matrix with the given number of rows and columns.
             All cells of the matrix will be initialized to zero.
             Zero-length matrices are not supported.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @throws If the order is less than one.
             * @param   {number}    order
             * @return  {void}
             */
            $ctor1: function (order) {
                MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor.call(this, new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double)).ctor(order, order));
            },
            /**
             * Create a new dense matrix with the given number of rows and columns.
             All cells of the matrix will be initialized to zero.
             Zero-length matrices are not supported.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @throws If the row or column count is less than one.
             * @param   {number}    rows       
             * @param   {number}    columns
             * @return  {void}
             */
            $ctor2: function (rows, columns) {
                MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor.call(this, new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double)).ctor(rows, columns));
            },
            /**
             * Create a new dense matrix with the given number of rows and columns directly binding to a raw array.
             The array is assumed to be in column-major order (column by column) and is used directly without copying.
             Very efficient, but changes to the array and the matrix will affect each other.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {number}            rows       
             * @param   {number}            columns    
             * @param   {Array.<number>}    storage
             * @return  {void}
             * @see {@link }
             */
            $ctor3: function (rows, columns, storage) {
                MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.ctor.call(this, new (MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double)).$ctor1(rows, columns, storage));
            }
        },
        methods: {
            /**
             * Calculates the induced L1 norm of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @return  {number}        The maximum absolute column sum of the matrix.
             */
            L1Norm: function () {
                var norm = 0.0;
                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    var s = 0.0;
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        s += Math.abs(this.At(i, j));
                    }
                    norm = Math.max(norm, s);
                }
                return norm;
            },
            /**
             * Calculates the induced infinity norm of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @return  {number}        The maximum absolute row sum of the matrix.
             */
            InfinityNorm: function () {
                var norm = 0.0;
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var s = 0.0;
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        s += Math.abs(this.At(i, j));
                    }
                    norm = Math.max(norm, s);
                }
                return norm;
            },
            /**
             * Calculates the entry-wise Frobenius norm of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @return  {number}        The square root of the sum of the squared values.
             */
            FrobeniusNorm: function () {
                var transpose = this.Transpose();
                var aat = MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).op_Multiply$2(this, transpose);
                var norm = 0.0;
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    norm += aat.At(i, i);
                }
                return Math.sqrt(norm);
            },
            /**
             * Negate each element of this matrix and place the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the negation.
             * @return  {void}
             */
            DoNegate: function (result) {
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (denseResult != null) {
                    this.Map$1(function (x) {
                        return -x;
                    }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                    return;
                }

                MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoNegate.call(this, result);
            },
            /**
             * Add a scalar to each element of the matrix and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {number}                                     scalar    The scalar to add.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the addition.
             * @return  {void}
             */
            DoAdd: function (scalar, result) {
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoAdd.call(this, scalar, result);
                    return;
                }

                this.Map$1(function (x) {
                    return x + scalar;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Adds another matrix to this matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @throws If the other matrix is {@link ArgumentNullException}.
             * @throws If the two matrices don't have the same dimensions.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to add to this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of add
             * @return  {void}
             */
            DoAdd$1: function (other, result) {
                var denseOther = Bridge.as(other.Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double));
                var denseResult = Bridge.as(result.Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double));
                if (denseOther != null && denseResult != null) {
                    this.Map2$1(function (x, y) {
                        return x + y;
                    }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                    return;
                }

                var diagonalOther = Bridge.as(other.Storage, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double));
                if (diagonalOther != null) {
                    this.Storage.CopyToUnchecked(result.Storage, MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
                    var diagonal = diagonalOther.Data;
                    for (var i = 0; i < diagonal.length; i = (i + 1) | 0) {
                        result.At$1(i, i, result.At(i, i) + diagonal[System.Array.index(i, diagonal)]);
                    }
                    return;
                }

                MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoAdd$1.call(this, other, result);
            },
            /**
             * Subtracts a scalar from each element of the matrix and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {number}                                     scalar    The scalar to subtract.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the subtraction.
             * @return  {void}
             */
            DoSubtract: function (scalar, result) {
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoSubtract.call(this, scalar, result);
                    return;
                }

                this.Map$1(function (x) {
                    return x - scalar;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Subtracts another matrix from this matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to subtract.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the subtraction.
             * @return  {void}
             */
            DoSubtract$1: function (other, result) {
                var denseOther = Bridge.as(other.Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double));
                var denseResult = Bridge.as(result.Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double));
                if (denseOther != null && denseResult != null) {
                    this.Map2$1(function (x, y) {
                        return x - y;
                    }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                    return;
                }

                var diagonalOther = Bridge.as(other.Storage, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double));
                if (diagonalOther != null) {
                    this.CopyTo(result);
                    var diagonal = diagonalOther.Data;
                    for (var i = 0; i < diagonal.length; i = (i + 1) | 0) {
                        result.At$1(i, i, result.At(i, i) - diagonal[System.Array.index(i, diagonal)]);
                    }
                    return;
                }

                MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoSubtract$1.call(this, other, result);
            },
            /**
             * Multiplies each element of the matrix by a scalar and places results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {number}                                     scalar    The scalar to multiply the matrix with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the multiplication.
             * @return  {void}
             */
            DoMultiply: function (scalar, result) {
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoMultiply.call(this, scalar, result);
                } else {
                    for (var x = 0; x < this.ColumnCount; x = (x + 1) | 0) {
                        for (var y = 0; y < this.RowCount; y = (y + 1) | 0) {
                            result.setItem(y, x, this._values[System.Array.index(((Bridge.Int.mul(x, 3) + y) | 0), this._values)] * scalar);
                        }
                    }
                }
            },
            /**
             * Multiplies this matrix with a vector and places the results into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result       The result of the multiplication.
             * @return  {void}
             */
            DoMultiply$2: function (rightSide, result) {
                var denseRight = Bridge.as(rightSide, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);

                if (denseRight == null || denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoMultiply$2.call(this, rightSide, result);
                } else {
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        var s = 0.0;
                        for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                            s += this.At(i, j) * rightSide.getItem(j);
                        }
                        result.setItem(i, s);
                    }
                }
            },
            /**
             * Multiplies this matrix with another matrix and places the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            DoMultiply$1: function (other, result) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (denseOther != null && denseResult != null) {
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        for (var j = 0; j < other.ColumnCount; j = (j + 1) | 0) {
                            var s = 0.0;
                            for (var k = 0; k < this.ColumnCount; k = (k + 1) | 0) {
                                s += this.At(i, k) * other.At(k, j);
                            }
                            result.At$1(i, j, s);
                        }
                    }
                    return;
                }

                var diagonalOther = Bridge.as(other.Storage, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double));
                if (diagonalOther != null) {
                    var diagonal = diagonalOther.Data;
                    var d = Math.min(this.ColumnCount, other.ColumnCount);
                    if (d < other.ColumnCount) {
                        result.ClearSubMatrix(0, this.RowCount, this.ColumnCount, ((other.ColumnCount - this.ColumnCount) | 0));
                    }
                    var index = 0;
                    for (var j1 = 0; j1 < d; j1 = (j1 + 1) | 0) {
                        for (var i1 = 0; i1 < this.RowCount; i1 = (i1 + 1) | 0) {
                            result.At$1(i1, j1, this._values[System.Array.index(index, this._values)] * diagonal[System.Array.index(j1, diagonal)]);
                            index = (index + 1) | 0;
                        }
                    }
                    return;
                }

                MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoMultiply$1.call(this, other, result);
            },
            /**
             * Multiplies this matrix with transpose of another matrix and places the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            DoTransposeAndMultiply: function (other, result) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (denseOther != null && denseResult != null) {
                    for (var j = 0; j < other.RowCount; j = (j + 1) | 0) {
                        for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                            var s = 0.0;
                            for (var k = 0; k < this.ColumnCount; k = (k + 1) | 0) {
                                s += this.At(i, k) * other.At(j, k);
                            }
                            result.At$1(i, j, s);
                        }
                    }
                    return;
                }

                var diagonalOther = Bridge.as(other.Storage, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double));
                if (diagonalOther != null) {
                    var diagonal = diagonalOther.Data;
                    var d = Math.min(this.ColumnCount, other.RowCount);
                    if (d < other.RowCount) {
                        result.ClearSubMatrix(0, this.RowCount, this.ColumnCount, ((other.RowCount - this.ColumnCount) | 0));
                    }
                    var index = 0;
                    for (var j1 = 0; j1 < d; j1 = (j1 + 1) | 0) {
                        for (var i1 = 0; i1 < this.RowCount; i1 = (i1 + 1) | 0) {
                            result.At$1(i1, j1, this._values[System.Array.index(index, this._values)] * diagonal[System.Array.index(j1, diagonal)]);
                            index = (index + 1) | 0;
                        }
                    }
                    return;
                }

                MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoTransposeAndMultiply.call(this, other, result);
            },
            /**
             * Multiplies the transpose of this matrix with a vector and places the results into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result       The result of the multiplication.
             * @return  {void}
             */
            DoTransposeThisAndMultiply$1: function (rightSide, result) {
                var denseRight = Bridge.as(rightSide, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);

                if (denseRight == null || denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoTransposeThisAndMultiply$1.call(this, rightSide, result);
                } else {
                    for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                        var s = 0.0;
                        for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                            s += this.At(i, j) * rightSide.getItem(i);
                        }
                        result.setItem(j, s);
                    }
                }
            },
            /**
             * Multiplies the transpose of this matrix with another matrix and places the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            DoTransposeThisAndMultiply: function (other, result) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (denseOther != null && denseResult != null) {
                    for (var j = 0; j < other.ColumnCount; j = (j + 1) | 0) {
                        for (var i = 0; i < this.ColumnCount; i = (i + 1) | 0) {
                            var s = 0.0;
                            for (var k = 0; k < this.RowCount; k = (k + 1) | 0) {
                                s += this.At(k, i) * other.At(k, j);
                            }
                            result.At$1(i, j, s);
                        }
                    }
                    return;
                }

                var diagonalOther = Bridge.as(other.Storage, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double));
                if (diagonalOther != null) {
                    var diagonal = diagonalOther.Data;
                    var d = Math.min(this.RowCount, other.ColumnCount);
                    if (d < other.ColumnCount) {
                        result.ClearSubMatrix(0, this.ColumnCount, this.RowCount, ((other.ColumnCount - this.RowCount) | 0));
                    }
                    var index = 0;
                    for (var i1 = 0; i1 < this.ColumnCount; i1 = (i1 + 1) | 0) {
                        for (var j1 = 0; j1 < d; j1 = (j1 + 1) | 0) {
                            result.At$1(i1, j1, this._values[System.Array.index(index, this._values)] * diagonal[System.Array.index(j1, diagonal)]);
                            index = (index + 1) | 0;
                        }
                        index = (index + (((this.RowCount - d) | 0))) | 0;
                    }
                    return;
                }

                MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoTransposeThisAndMultiply.call(this, other, result);
            },
            /**
             * Divides each element of the matrix by a scalar and places results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {number}                                     divisor    The scalar to divide the matrix with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     The matrix to store the result of the division.
             * @return  {void}
             */
            DoDivide: function (divisor, result) {
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoDivide.call(this, divisor, result);
                } else {

                    var I = this.m_builder$1.Dense$1(this.ColumnCount, this.RowCount);

                    for (var x = 0; x < this.ColumnCount; x = (x + 1) | 0) {
                        for (var y = 0; y < this.RowCount; y = (y + 1) | 0) {
                            I.setItem(y, x, this.getItem(y, x) / divisor);
                        }
                    }
                    result = I;
                }
            },
            /**
             * Pointwise multiplies this matrix with another matrix and stores the result into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to pointwise multiply with this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the pointwise multiplication.
             * @return  {void}
             */
            DoPointwiseMultiply: function (other, result) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);

                if (denseOther == null || denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoPointwiseMultiply.call(this, other, result);
                } else {
                    this.Map2$1(function (x, y) {
                        return x * y;
                    }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                }
            },
            /**
             * Pointwise divide this matrix by another matrix and stores the result into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor    The matrix to pointwise divide this one by.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     The matrix to store the result of the pointwise division.
             * @return  {void}
             */
            DoPointwiseDivide: function (divisor, result) {
                var denseDivisor = Bridge.as(divisor, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);

                if (denseDivisor == null || denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoPointwiseDivide.call(this, divisor, result);
                } else {
                    this.Map2$1(function (x, y) {
                        return x / y;
                    }, divisor, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
                }
            },
            /**
             * Pointwise raise this matrix to an exponent and store the result into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    exponent    The exponent to raise this matrix values to.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      The vector to store the result of the pointwise power.
             * @return  {void}
             */
            DoPointwisePower$1: function (exponent, result) {
                var denseExponent = Bridge.as(exponent, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);

                if (denseExponent == null || denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoPointwisePower$1.call(this, exponent, result);
                } else {
                    this.Map2(Math.pow, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
                }
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for the given divisor each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {number}                                     divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     Matrix to store the results in.
             * @return  {void}
             */
            DoModulus: function (divisor, result) {
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoModulus.call(this, divisor, result);
                    return;
                }

                if (!Bridge.referenceEquals(this, result)) {
                    this.CopyTo(result);
                }

                this.Map$1(function (x) {
                    return MathNet.Numerics.Euclid.Modulus(x, divisor);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for the given dividend for each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {number}                                     dividend    The scalar numerator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      A vector to store the results in.
             * @return  {void}
             */
            DoModulusByThis: function (dividend, result) {
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoModulusByThis.call(this, dividend, result);
                    return;
                }

                this.Map$1(function (x) {
                    return MathNet.Numerics.Euclid.Modulus(dividend, x);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Computes the remainder (% operator), where the result has the sign of the dividend,
             for the given divisor each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {number}                                     divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     Matrix to store the results in.
             * @return  {void}
             */
            DoRemainder: function (divisor, result) {
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoRemainder.call(this, divisor, result);
                    return;
                }

                if (!Bridge.referenceEquals(this, result)) {
                    this.CopyTo(result);
                }

                this.Map$1(function (x) {
                    return MathNet.Numerics.Euclid.Remainder(x, divisor);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Computes the remainder (% operator), where the result has the sign of the dividend,
             for the given dividend for each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @param   {number}                                     dividend    The scalar numerator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      A vector to store the results in.
             * @return  {void}
             */
            DoRemainderByThis: function (dividend, result) {
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoRemainderByThis.call(this, dividend, result);
                    return;
                }

                this.Map$1(function (x) {
                    return MathNet.Numerics.Euclid.Remainder(dividend, x);
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
            },
            /**
             * Computes the trace of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @throws If the matrix is not square
             * @return  {number}        The trace of this matrix
             */
            Trace: function () {
                if (this._rowCount !== this._columnCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSquare");
                }

                var sum = 0.0;
                for (var i = 0; i < this._rowCount; i = (i + 1) | 0) {
                    sum += this._values[System.Array.index((((Bridge.Int.mul(i, this._rowCount)) + i) | 0), this._values)];
                }

                return sum;
            },
            /**
             * Evaluates whether this matrix is symmetric.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseMatrix
             * @return  {boolean}
             */
            IsSymmetric: function () {
                if (this.RowCount !== this.ColumnCount) {
                    return false;
                }

                for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                    var index = Bridge.Int.mul(j, this.RowCount);
                    for (var i = (j + 1) | 0; i < this.RowCount; i = (i + 1) | 0) {
                        if (this._values[System.Array.index((((Bridge.Int.mul(i, this.ColumnCount)) + j) | 0), this._values)] !== this._values[System.Array.index(((index + i) | 0), this._values)]) {
                            return false;
                        }
                    }
                }

                return true;
            },
            LU: function () {
                return MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU.Create(this);
            },
            Svd$1: function (computeVectors) {
                if (computeVectors === void 0) { computeVectors = true; }
                return MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseSvd.Create(this, computeVectors);
            }
        }
    });

    /**
     * A vector using dense storage.
     * Creates a double dense vector based on a string. The string can be in the following formats (without the
     quotes): 'n', 'n,n,..', '(n,n,..)', '[n,n,...]', where n is a double.
     * Converts the string representation of a real dense vector to double-precision dense vector equivalent.
     A return value indicates whether the conversion succeeded or failed.
     * Converts the string representation of a real dense vector to double-precision dense vector equivalent.
     A return value indicates whether the conversion succeeded or failed.
     *
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Double.DenseVector
     * @augments MathNet.Numerics.LinearAlgebra.Double.Vector
     * @return  {[type]}        If the conversion succeeds, the result will contain a complex number equivalent to value.
     Otherwise the result will be <pre><code>null</code></pre>.
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.DenseVector", {
        inherits: [MathNet.Numerics.LinearAlgebra.Double.Vector],
        statics: {
            methods: {
                /**
                 * Create a new dense vector as a copy of the given other vector.
                 This new vector will be independent from the other vector.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}              vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}
                 */
                OfVector: function (vector) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseVector.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double).OfVector(vector.Storage));
                },
                /**
                 * Create a new dense vector as a copy of the given array.
                 This new vector will be independent from the array.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @param   {Array.<number>}                                       array
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}
                 */
                OfArray: function (array) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseVector.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double).OfVector(new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double)).$ctor1(array.length, array)));
                },
                /**
                 * Create a new dense vector as a copy of the given enumerable.
                 This new vector will be independent from the enumerable.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @param   {System.Collections.Generic.IEnumerable$1}             enumerable
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}
                 */
                OfEnumerable: function (enumerable) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseVector.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double).OfEnumerable(enumerable));
                },
                /**
                 * Create a new dense vector as a copy of the given indexed enumerable.
                 Keys must be provided at most once, zero is assumed if a key is omitted.
                 This new vector will be independent from the enumerable.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @param   {number}                                               length        
                 * @param   {System.Collections.Generic.IEnumerable$1}             enumerable
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}
                 */
                OfIndexedEnumerable: function (length, enumerable) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseVector.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double).OfIndexedEnumerable(length, enumerable));
                },
                /**
                 * Create a new dense vector and initialize each value using the provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @param   {number}                                               length    
                 * @param   {number}                                               value
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}
                 */
                Create: function (length, value) {
                    if (value === 0.0) {
                        return new MathNet.Numerics.LinearAlgebra.Double.DenseVector.$ctor2(length);
                    }
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseVector.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double).OfValue(length, value));
                },
                /**
                 * Create a new dense vector and initialize each value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @param   {number}                                               length    
                 * @param   {System.Func}                                          init
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}
                 */
                Create$1: function (length, init) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DenseVector.ctor(MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double).OfInit(length, init));
                }/**
                 * Returns a reference to the internal data structure.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    vector    The <pre><code>DenseVector</code></pre> whose internal data we are
                 returning.
                 * @return  {Array.<number>}                                                 A reference to the internal date of the given vector.
                 */
                ,
                op_Explicit: function (vector) {
                    if (vector == null) {
                        throw new System.ArgumentNullException.$ctor1("vector");
                    }

                    return vector.Values;
                }/**
                 * Returns a vector bound directly to a reference of the provided array.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @param   {Array.<number>}                                       array    The array to bind to the <pre><code>DenseVector</code></pre> object.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}             A <pre><code>DenseVector</code></pre> whose values are bound to the given array.
                 */
                ,
                op_Implicit: function (array) {
                    if (array == null) {
                        throw new System.ArgumentNullException.$ctor1("array");
                    }

                    return new MathNet.Numerics.LinearAlgebra.Double.DenseVector.$ctor1(array);
                }/**
                 * Adds two <strong>Vectors</strong> together and returns the results.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @throws If <b /> and <b /> are not the same size.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    leftSide     One of the vectors to add.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    rightSide    The other vector to add.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}                 The result of the addition.
                 */
                ,
                op_Addition: function (leftSide, rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    if (leftSide.Count !== rightSide.Count) {
                        throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "rightSide");
                    }

                    return Bridge.cast(leftSide.Add$1(rightSide), MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                }/**
                 * Returns a <strong>Vector</strong> containing the negated values of <b />.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    rightSide    The vector to get the values from.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}                 A vector containing the negated values as <b />.
                 */
                ,
                op_UnaryNegation: function (rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    return Bridge.cast(rightSide.Negate(), MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                }/**
                 * Subtracts two <strong>Vectors</strong> and returns the results.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @throws If <b /> and <b /> are not the same size.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    leftSide     The vector to subtract from.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    rightSide    The vector to subtract.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}                 The result of the subtraction.
                 */
                ,
                op_Subtraction: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Subtract$1(rightSide), MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                }/**
                 * Multiplies a vector with a scalar.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    leftSide     The vector to scale.
                 * @param   {number}                                               rightSide    The scalar value.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}                 The result of the multiplication.
                 */
                ,
                op_Multiply: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Multiply(rightSide), MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                }/**
                 * Multiplies a vector with a scalar.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {number}                                               leftSide     The scalar value.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    rightSide    The vector to scale.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}                 The result of the multiplication.
                 */
                ,
                op_Multiply$1: function (leftSide, rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    return Bridge.cast(rightSide.Multiply(leftSide), MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                }/**
                 * Computes the dot product between two <strong>Vectors</strong>.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @throws If <b /> and <b /> are not the same size.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    leftSide     The left row vector.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    rightSide    The right column vector.
                 * @return  {number}                                                            The dot product between the two vectors.
                 */
                ,
                op_Multiply$2: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return leftSide.DotProduct(rightSide);
                }/**
                 * Divides a vector with a scalar.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    leftSide     The vector to divide.
                 * @param   {number}                                               rightSide    The scalar value.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}                 The result of the division.
                 */
                ,
                op_Division: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Divide(rightSide), MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                }/**
                 * Computes the remainder (% operator), where the result has the sign of the dividend,
                 of each element of the vector of the given divisor.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseVector}    leftSide     The vector whose elements we want to compute the remainder of.
                 * @param   {number}                                               rightSide    The divisor to use,
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DenseVector}
                 */
                ,
                op_Modulus: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Remainder(rightSide), MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                }
            }
        },
        fields: {
            /**
             * Number of elements
             *
             * @instance
             * @private
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @type number
             */
            _length: 0,
            /**
             * Gets the vector's data.
             *
             * @instance
             * @private
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @type Array.<number>
             */
            _values: null
        },
        props: {
            /**
             * Create a new dense vector with values sampled from the provided random distribution.
             * Gets the vector's data.
             *
             * @instance
             * @public
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @function Values
             * @type Array.<number>
             */
            Values: {
                get: function () {
                    return this._values;
                }
            }
        },
        ctors: {
            /**
             * Create a new dense vector straight from an initialized vector storage instance.
             The storage is used directly without copying.
             Intended for advanced scenarios where you're working directly with
             storage for performance or interop reasons.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1}    storage
             * @return  {void}
             */
            ctor: function (storage) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Double.Vector.ctor.call(this, storage);
                this._length = storage.Length;
                this._values = storage.Data;
            },
            /**
             * Create a new dense vector with the given length.
             All cells of the vector will be initialized to zero.
             Zero-length vectors are not supported.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @throws If length is less than one.
             * @param   {number}    length
             * @return  {void}
             */
            $ctor2: function (length) {
                MathNet.Numerics.LinearAlgebra.Double.DenseVector.ctor.call(this, new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double)).ctor(length));
            },
            /**
             * Create a new dense vector directly binding to a raw array.
             The array is used directly without copying.
             Very efficient, but changes to the array and the vector will affect each other.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {Array.<number>}    storage
             * @return  {void}
             */
            $ctor1: function (storage) {
                MathNet.Numerics.LinearAlgebra.Double.DenseVector.ctor.call(this, new (MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double)).$ctor1(storage.length, storage));
            }
        },
        methods: {
            /**
             * Adds a scalar to each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {number}                                     scalar    The scalar to add.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the addition.
             * @return  {void}
             */
            DoAdd: function (scalar, result) {
                var dense = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                if (dense == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoAdd.call(this, scalar, result);
                } else {

                    for (var i = 0; i < this._values.length; i = (i + 1) | 0) {
                        dense._values[System.Array.index(i, dense._values)] = this._values[System.Array.index(i, this._values)] + scalar;
                    }

                }
            },
            /**
             * Adds another vector to this vector and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector to add to this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the addition.
             * @return  {void}
             */
            DoAdd$1: function (other, result) {
                var otherDense = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                var resultDense = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);

                if (otherDense == null || resultDense == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoAdd$1.call(this, other, result);
                } else {
                    this.Map2$1(function (x, y) {
                        return x + y;
                    }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                }
            },
            /**
             * Subtracts a scalar from each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {number}                                     scalar    The scalar to subtract.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the subtraction.
             * @return  {void}
             */
            DoSubtract: function (scalar, result) {
                var dense = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                if (dense == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoSubtract.call(this, scalar, result);
                } else {

                    for (var i = 0; i < this._values.length; i = (i + 1) | 0) {
                        dense._values[System.Array.index(i, dense._values)] = this._values[System.Array.index(i, this._values)] - scalar;
                    }

                }
            },
            /**
             * Subtracts another vector to this vector and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector to subtract from this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the subtraction.
             * @return  {void}
             */
            DoSubtract$1: function (other, result) {
                var otherDense = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                var resultDense = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);

                if (otherDense == null || resultDense == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoSubtract$1.call(this, other, result);
                } else {
                    this.Map2$1(function (x, y) {
                        return x - y;
                    }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                }
            },
            /**
             * Negates vector and saves result to <b />
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    Target vector
             * @return  {void}
             */
            DoNegate: function (result) {
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                if (denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoNegate.call(this, result);
                    return;
                }

                this.Map$1(function (x) {
                    return -x;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Multiplies a scalar to each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {number}                                     scalar    The scalar to multiply.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the multiplication.
             * @return  {void}
             */
            DoMultiply: function (scalar, result) {
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                if (denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoMultiply.call(this, scalar, result);
                    return;
                }

                this.Map$1(function (x) {
                    return x * scalar;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Computes the dot product between this vector and another vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The other vector.
             * @return  {number}                                              The sum of a[i]*b[i] for all i.
             */
            DoDotProduct: function (other) {
                var dot = 0.0;
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    dot += this.At(i) * other.At(i);
                }
                return dot;
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for each element of the vector for the given divisor.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {number}                                     divisor    The divisor to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     A vector to store the results in.
             * @return  {void}
             */
            DoModulus: function (divisor, result) {
                var dense = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                if (dense == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoModulus.call(this, divisor, result);
                } else {

                    for (var i = 0; i < this._length; i = (i + 1) | 0) {
                        dense._values[System.Array.index(i, dense._values)] = MathNet.Numerics.Euclid.Modulus(this._values[System.Array.index(i, this._values)], divisor);
                    }

                }
            },
            /**
             * Computes the remainder (% operator), where the result has the sign of the dividend,
             for each element of the vector for the given divisor.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {number}                                     divisor    The divisor to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     A vector to store the results in.
             * @return  {void}
             */
            DoRemainder: function (divisor, result) {
                var dense = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                if (dense == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoRemainder.call(this, divisor, result);
                } else {

                    for (var i = 0; i < this._length; i = (i + 1) | 0) {
                        dense._values[System.Array.index(i, dense._values)] = this._values[System.Array.index(i, this._values)] % divisor;
                    }

                }
            },
            /**
             * Returns the index of the absolute minimum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @return  {number}        The index of absolute minimum element.
             */
            AbsoluteMinimumIndex: function () {
                var index = 0;
                var min = Math.abs(this._values[System.Array.index(index, this._values)]);
                for (var i = 1; i < this._length; i = (i + 1) | 0) {
                    var test = Math.abs(this._values[System.Array.index(i, this._values)]);
                    if (test < min) {
                        index = i;
                        min = test;
                    }
                }

                return index;
            },
            /**
             * Returns the index of the absolute maximum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @return  {number}        The index of absolute maximum element.
             */
            AbsoluteMaximumIndex: function () {
                var index = 0;
                var max = Math.abs(this._values[System.Array.index(index, this._values)]);
                for (var i = 1; i < this._length; i = (i + 1) | 0) {
                    var test = Math.abs(this._values[System.Array.index(i, this._values)]);
                    if (test > max) {
                        index = i;
                        max = test;
                    }
                }

                return index;
            },
            /**
             * Returns the index of the maximum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @return  {number}        The index of maximum element.
             */
            MaximumIndex: function () {
                var index = 0;
                var max = this._values[System.Array.index(0, this._values)];
                for (var i = 1; i < this._length; i = (i + 1) | 0) {
                    if (max < this._values[System.Array.index(i, this._values)]) {
                        index = i;
                        max = this._values[System.Array.index(i, this._values)];
                    }
                }

                return index;
            },
            /**
             * Returns the index of the minimum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @return  {number}        The index of minimum element.
             */
            MinimumIndex: function () {
                var index = 0;
                var min = this._values[System.Array.index(0, this._values)];
                for (var i = 1; i < this._length; i = (i + 1) | 0) {
                    if (min > this._values[System.Array.index(i, this._values)]) {
                        index = i;
                        min = this._values[System.Array.index(i, this._values)];
                    }
                }

                return index;
            },
            /**
             * Computes the sum of the vector's elements.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @return  {number}        The sum of the vector's elements.
             */
            Sum: function () {
                var sum = 0.0;
                for (var index = 0; index < this._length; index = (index + 1) | 0) {
                    sum += this._values[System.Array.index(index, this._values)];
                }
                return sum;
            },
            /**
             * Calculates the L1 norm of the vector, also known as Manhattan norm.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @return  {number}        The sum of the absolute values.
             */
            L1Norm: function () {
                var sum = 0.0;
                for (var index = 0; index < this._length; index = (index + 1) | 0) {
                    sum += Math.abs(this._values[System.Array.index(index, this._values)]);
                }
                return sum;
            },
            /**
             * Calculates the L2 norm of the vector, also known as Euclidean norm.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @return  {number}        The square root of the sum of the squared values.
             */
            L2Norm: function () {
                var $t;
                var total = 0.0;
                $t = Bridge.getEnumerator(this._values);
                try {
                    while ($t.moveNext()) {
                        var val = $t.Current;
                        total += Math.pow(Math.abs(val), 2.0);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return Math.sqrt(total);
            },
            /**
             * Calculates the infinity norm of the vector.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @return  {number}        The maximum absolute value.
             */
            InfinityNorm: function () {
                var $t;
                var max = 0.0;
                $t = Bridge.getEnumerator(this._values);
                try {
                    while ($t.moveNext()) {
                        var val = $t.Current;
                        if (Math.abs(val) > max) {
                            max = Math.abs(val);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return max;
            },
            /**
             * Computes the p-Norm.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {number}    p    The p value.
             * @return  {number}         Scalar <pre><code>ret = ( â|this[i]|^p )^(1/p)</code></pre>
             */
            Norm: function (p) {
                if (p < 0.0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("p");
                }

                if (p === 1.0) {
                    return this.L1Norm();
                }
                if (p === 2.0) {
                    return this.L2Norm();
                }
                if ((p === Number.POSITIVE_INFINITY)) {
                    return this.InfinityNorm();
                }

                var sum = 0.0;
                for (var index = 0; index < this._length; index = (index + 1) | 0) {
                    sum += Math.pow(Math.abs(this._values[System.Array.index(index, this._values)]), p);
                }
                return Math.pow(sum, 1.0 / p);
            },
            /**
             * Pointwise divide this vector with another vector and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector to pointwise divide this one by.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the pointwise division.
             * @return  {void}
             */
            DoPointwiseMultiply: function (other, result) {
                var denseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);

                if (denseOther == null || denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoPointwiseMultiply.call(this, other, result);
                } else {
                    this.Map2$1(function (x, y) {
                        return x * y;
                    }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                }
            },
            /**
             * Pointwise divide this vector with another vector and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    divisor    The vector to pointwise divide this one by.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     The vector to store the result of the pointwise division.
             * @return  {void}
             */
            DoPointwiseDivide: function (divisor, result) {
                var denseOther = Bridge.as(divisor, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);

                if (denseOther == null || denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoPointwiseDivide.call(this, divisor, result);
                } else {
                    this.Map2$1(function (x, y) {
                        return x / y;
                    }, divisor, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
                }
            },
            /**
             * Pointwise raise this vector to an exponent vector and store the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DenseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    exponent    The exponent vector to raise this vector values to.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result      The vector to store the result of the pointwise power.
             * @return  {void}
             */
            DoPointwisePower$1: function (exponent, result) {
                var denseExponent = Bridge.as(exponent, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                var denseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);

                if (denseExponent == null || denseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoPointwisePower$1.call(this, exponent, result);
                } else {
                    this.Map2$1(Math.pow, exponent, result, MathNet.Numerics.LinearAlgebra.Zeros.Include);
                }
            }
        }
    });

    /**
     * A matrix type for diagonal matrices.
     *
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
     * @augments MathNet.Numerics.LinearAlgebra.Double.Matrix
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix", {
        inherits: [MathNet.Numerics.LinearAlgebra.Double.Matrix],
        statics: {
            methods: {
                /**
                 * Create a new diagonal matrix as a copy of the given other matrix.
                 This new matrix will be independent from the other matrix.
                 The matrix to copy from must be diagonal as well.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}                 matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix}
                 */
                OfMatrix: function (matrix) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double).OfMatrix(matrix.Storage));
                },
                /**
                 * Create a new diagonal matrix as a copy of the given two-dimensional array.
                 This new matrix will be independent from the provided array.
                 The array to copy from must be diagonal as well.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
                 * @param   {Array.<number>}                                          array
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix}
                 */
                OfArray: function (array) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double).OfArray(array));
                },
                /**
                 * Create a new diagonal matrix and initialize each diagonal value from the provided indexed enumerable.
                 Keys must be provided at most once, zero is assumed if a key is omitted.
                 This new matrix will be independent from the enumerable.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
                 * @param   {number}                                                  rows        
                 * @param   {number}                                                  columns     
                 * @param   {System.Collections.Generic.IEnumerable$1}                diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix}
                 */
                OfIndexedDiagonal: function (rows, columns, diagonal) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double).OfIndexedEnumerable(rows, columns, diagonal));
                },
                /**
                 * Create a new diagonal matrix and initialize each diagonal value from the provided enumerable.
                 This new matrix will be independent from the enumerable.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
                 * @param   {number}                                                  rows        
                 * @param   {number}                                                  columns     
                 * @param   {System.Collections.Generic.IEnumerable$1}                diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix}
                 */
                OfDiagonal: function (rows, columns, diagonal) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double).OfEnumerable(rows, columns, diagonal));
                },
                /**
                 * Create a new diagonal matrix and initialize each diagonal value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
                 * @param   {number}                                                  rows       
                 * @param   {number}                                                  columns    
                 * @param   {System.Func}                                             init
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix}
                 */
                Create: function (rows, columns, init) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double).OfInit(rows, columns, init));
                },
                /**
                 * Create a new square sparse identity matrix where each diagonal value is set to One.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
                 * @param   {number}                                                  order
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix}
                 */
                CreateIdentity: function (order) {
                    return new MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double).OfValue(order, order, MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).One));
                }
            }
        },
        fields: {
            /**
             * Gets the matrix's data.
             *
             * @instance
             * @private
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @type Array.<number>
             */
            _data: null
        },
        ctors: {
            /**
             * Create a new diagonal matrix straight from an initialized matrix storage instance.
             The storage is used directly without copying.
             Intended for advanced scenarios where you're working directly with
             storage for performance or interop reasons.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1}    storage
             * @return  {void}
             */
            ctor: function (storage) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Double.Matrix.ctor.call(this, storage);
                this._data = storage.Data;
            },
            /**
             * Create a new square diagonal matrix with the given number of rows and columns.
             All cells of the matrix will be initialized to zero.
             Zero-length matrices are not supported.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If the order is less than one.
             * @param   {number}    order
             * @return  {void}
             */
            $ctor1: function (order) {
                MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.ctor.call(this, new (MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double)).ctor(order, order));
            },
            /**
             * Create a new diagonal matrix with the given number of rows and columns.
             All cells of the matrix will be initialized to zero.
             Zero-length matrices are not supported.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If the row or column count is less than one.
             * @param   {number}    rows       
             * @param   {number}    columns
             * @return  {void}
             */
            $ctor2: function (rows, columns) {
                MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.ctor.call(this, new (MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double)).ctor(rows, columns));
            },
            /**
             * Create a new diagonal matrix with the given number of rows and columns.
             All diagonal cells of the matrix will be initialized to the provided value, all non-diagonal ones to zero.
             Zero-length matrices are not supported.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If the row or column count is less than one.
             * @param   {number}    rows             
             * @param   {number}    columns          
             * @param   {number}    diagonalValue
             * @return  {void}
             */
            $ctor3: function (rows, columns, diagonalValue) {
                MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.$ctor2.call(this, rows, columns);
                for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                    this._data[System.Array.index(i, this._data)] = diagonalValue;
                }
            },
            /**
             * Create a new diagonal matrix with the given number of rows and columns directly binding to a raw array.
             The array is assumed to contain the diagonal elements only and is used directly without copying.
             Very efficient, but changes to the array and the matrix will affect each other.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {number}            rows               
             * @param   {number}            columns            
             * @param   {Array.<number>}    diagonalStorage
             * @return  {void}
             */
            $ctor4: function (rows, columns, diagonalStorage) {
                MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.ctor.call(this, new (MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double)).$ctor1(rows, columns, diagonalStorage));
            }
        },
        methods: {
            /**
             * Create a new diagonal matrix with diagonal values sampled from the provided random distribution.
             * Negate each element of this matrix and place the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the negation.
             * @return  {void}
             */
            DoNegate: function (result) {
                var diagResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                if (diagResult != null) {
                    this.Map$1(function (x) {
                        return -x;
                    }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                    return;
                }

                result.Clear();
                for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                    result.At$1(i, i, -this._data[System.Array.index(i, this._data)]);
                }
            },
            /**
             * Adds another matrix to this matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If the two matrices don't have the same dimensions.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to add to this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the addition.
             * @return  {void}
             */
            DoAdd$1: function (other, result) {
                var diagOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                var diagResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                if (diagOther != null && diagResult != null) {
                    this.Map2$1(function (x, y) {
                        return x + y;
                    }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                    return;
                }

                other.CopyTo(result);
                for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                    result.At$1(i, i, result.At(i, i) + this._data[System.Array.index(i, this._data)]);
                }
            },
            /**
             * Subtracts another matrix from this matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If the two matrices don't have the same dimensions.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to subtract.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the subtraction.
             * @return  {void}
             */
            DoSubtract$1: function (other, result) {
                var diagOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                var diagResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                if (diagOther != null && diagResult != null) {
                    this.Map2$1(function (x, y) {
                        return x - y;
                    }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                    return;
                }

                other.Negate$1(result);
                for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                    result.At$1(i, i, result.At(i, i) + this._data[System.Array.index(i, this._data)]);
                }
            },
            /**
             * Multiplies each element of the matrix by a scalar and places results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {number}                                     scalar    The scalar to multiply the matrix with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the multiplication.
             * @return  {void}
             */
            DoMultiply: function (scalar, result) {
                if (scalar === 0.0) {
                    result.Clear();
                    return;
                }

                if (scalar === 1.0) {
                    this.CopyTo(result);
                    return;
                }

                var diagResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                if (diagResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoMultiply.call(this, scalar, result);
                } else {
                    var I = this.m_builder$1.Dense$1(this.ColumnCount, this.RowCount);

                    for (var x = 0; x < this.ColumnCount; x = (x + 1) | 0) {
                        for (var y = 0; y < this.RowCount; y = (y + 1) | 0) {
                            I.setItem(y, x, this.getItem(y, x) * scalar);
                        }
                    }
                    result = I;
                }
            },
            /**
             * Multiplies this matrix with a vector and places the results into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result       The result of the multiplication.
             * @return  {void}
             */
            DoMultiply$2: function (rightSide, result) {
                var d = Math.min(this.ColumnCount, this.RowCount);
                if (d < this.RowCount) {
                    result.ClearSubVector(this.ColumnCount, ((this.RowCount - this.ColumnCount) | 0));
                }

                if (d === this.ColumnCount) {
                    var denseOther = Bridge.as(rightSide.Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double));
                    var denseResult = Bridge.as(result.Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double));
                    if (denseOther != null && denseResult != null) {
                        for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                            var s = 0.0;
                            for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                                s += this.At(i, j) * rightSide.getItem(j);
                            }
                            result.setItem(i, s);
                        }
                        return;
                    }
                }

                for (var i1 = 0; i1 < d; i1 = (i1 + 1) | 0) {
                    result.At$1(i1, this._data[System.Array.index(i1, this._data)] * rightSide.At(i1));
                }
            },
            /**
             * Multiplies this matrix with another matrix and places the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            DoMultiply$1: function (other, result) {
                var diagonalOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                var diagonalResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                if (diagonalOther != null && diagonalResult != null) {
                    var thisDataCopy = System.Array.init(diagonalResult._data.length, 0, System.Double);
                    var otherDataCopy = System.Array.init(diagonalResult._data.length, 0, System.Double);
                    System.Array.copy(this._data, 0, thisDataCopy, 0, (diagonalResult._data.length > this._data.length) ? this._data.length : diagonalResult._data.length);
                    System.Array.copy(diagonalOther._data, 0, otherDataCopy, 0, (diagonalResult._data.length > diagonalOther._data.length) ? diagonalOther._data.length : diagonalResult._data.length);
                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        for (var j = 0; j < other.ColumnCount; j = (j + 1) | 0) {
                            var s = 0.0;
                            for (var k = 0; k < this.ColumnCount; k = (k + 1) | 0) {
                                s += this.At(i, k) * other.At(k, j);
                            }
                            result.At$1(i, j, s);
                        }
                    }
                    return;
                }

                var denseOther = Bridge.as(other.Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double));
                if (denseOther != null) {
                    var dense = denseOther.Data;
                    var diagonal = this._data;
                    var d = Math.min(denseOther.RowCount, this.RowCount);
                    if (d < this.RowCount) {
                        result.ClearSubMatrix(denseOther.RowCount, ((this.RowCount - denseOther.RowCount) | 0), 0, denseOther.ColumnCount);
                    }
                    var index = 0;
                    for (var i1 = 0; i1 < denseOther.ColumnCount; i1 = (i1 + 1) | 0) {
                        for (var j1 = 0; j1 < d; j1 = (j1 + 1) | 0) {
                            result.At$1(j1, i1, dense[System.Array.index(index, dense)] * diagonal[System.Array.index(j1, diagonal)]);
                            index = (index + 1) | 0;
                        }
                        index = (index + (((denseOther.RowCount - d) | 0))) | 0;
                    }
                    return;
                }

                if (this.ColumnCount === this.RowCount) {
                    other.Storage.MapIndexedTo(System.Double, result.Storage, Bridge.fn.bind(this, function (i2, j2, x) {
                        return x * this._data[System.Array.index(i2, this._data)];
                    }), MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip, MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
                } else {
                    result.Clear();
                    other.Storage.MapSubMatrixIndexedTo(System.Double, result.Storage, Bridge.fn.bind(this, function (i2, j2, x) {
                        return x * this._data[System.Array.index(i2, this._data)];
                    }), 0, 0, other.RowCount, 0, 0, other.ColumnCount, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                }
            },
            /**
             * Multiplies this matrix with transpose of another matrix and places the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            DoTransposeAndMultiply: function (other, result) {
                var diagonalOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                var diagonalResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                if (diagonalOther != null && diagonalResult != null) {
                    var thisDataCopy = System.Array.init(diagonalResult._data.length, 0, System.Double);
                    var otherDataCopy = System.Array.init(diagonalResult._data.length, 0, System.Double);
                    System.Array.copy(this._data, 0, thisDataCopy, 0, (diagonalResult._data.length > this._data.length) ? this._data.length : diagonalResult._data.length);
                    System.Array.copy(diagonalOther._data, 0, otherDataCopy, 0, (diagonalResult._data.length > diagonalOther._data.length) ? diagonalOther._data.length : diagonalResult._data.length);
                    for (var j = 0; j < other.RowCount; j = (j + 1) | 0) {
                        for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                            var s = 0.0;
                            for (var k = 0; k < this.ColumnCount; k = (k + 1) | 0) {
                                s += this.At(i, k) * other.At(j, k);
                            }
                            result.At$1(i, j, s);
                        }
                    }
                    return;
                }

                var denseOther = Bridge.as(other.Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double));
                if (denseOther != null) {
                    var dense = denseOther.Data;
                    var diagonal = this._data;
                    var d = Math.min(denseOther.ColumnCount, this.RowCount);
                    if (d < this.RowCount) {
                        result.ClearSubMatrix(denseOther.ColumnCount, ((this.RowCount - denseOther.ColumnCount) | 0), 0, denseOther.RowCount);
                    }
                    var index = 0;
                    for (var j1 = 0; j1 < d; j1 = (j1 + 1) | 0) {
                        for (var i1 = 0; i1 < denseOther.RowCount; i1 = (i1 + 1) | 0) {
                            result.At$1(j1, i1, dense[System.Array.index(index, dense)] * diagonal[System.Array.index(j1, diagonal)]);
                            index = (index + 1) | 0;
                        }
                    }
                    return;
                }

                MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoTransposeAndMultiply.call(this, other, result);
            },
            /**
             * Multiplies the transpose of this matrix with another matrix and places the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            DoTransposeThisAndMultiply: function (other, result) {
                var diagonalOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                var diagonalResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                if (diagonalOther != null && diagonalResult != null) {
                    var thisDataCopy = System.Array.init(diagonalResult._data.length, 0, System.Double);
                    var otherDataCopy = System.Array.init(diagonalResult._data.length, 0, System.Double);
                    System.Array.copy(this._data, 0, thisDataCopy, 0, (diagonalResult._data.length > this._data.length) ? this._data.length : diagonalResult._data.length);
                    System.Array.copy(diagonalOther._data, 0, otherDataCopy, 0, (diagonalResult._data.length > diagonalOther._data.length) ? diagonalOther._data.length : diagonalResult._data.length);
                    for (var j = 0; j < other.ColumnCount; j = (j + 1) | 0) {
                        for (var i = 0; i < this.ColumnCount; i = (i + 1) | 0) {
                            var s = 0.0;
                            for (var k = 0; k < this.RowCount; k = (k + 1) | 0) {
                                s += this.At(k, i) * other.At(k, j);
                            }
                            result.At$1(i, j, s);
                        }
                    }
                    return;
                }

                var denseOther = Bridge.as(other.Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double));
                if (denseOther != null) {
                    var dense = denseOther.Data;
                    var diagonal = this._data;
                    var d = Math.min(denseOther.RowCount, this.ColumnCount);
                    if (d < this.ColumnCount) {
                        result.ClearSubMatrix(denseOther.RowCount, ((this.ColumnCount - denseOther.RowCount) | 0), 0, denseOther.ColumnCount);
                    }
                    var index = 0;
                    for (var i1 = 0; i1 < denseOther.ColumnCount; i1 = (i1 + 1) | 0) {
                        for (var j1 = 0; j1 < d; j1 = (j1 + 1) | 0) {
                            result.At$1(j1, i1, dense[System.Array.index(index, dense)] * diagonal[System.Array.index(j1, diagonal)]);
                            index = (index + 1) | 0;
                        }
                        index = (index + (((denseOther.RowCount - d) | 0))) | 0;
                    }
                    return;
                }

                if (this.ColumnCount === this.RowCount) {
                    other.Storage.MapIndexedTo(System.Double, result.Storage, Bridge.fn.bind(this, function (i2, j2, x) {
                        return x * this._data[System.Array.index(i2, this._data)];
                    }), MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip, MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
                } else {
                    result.Clear();
                    other.Storage.MapSubMatrixIndexedTo(System.Double, result.Storage, Bridge.fn.bind(this, function (i2, j2, x) {
                        return x * this._data[System.Array.index(i2, this._data)];
                    }), 0, 0, other.RowCount, 0, 0, other.ColumnCount, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                }
            },
            /**
             * Multiplies the transpose of this matrix with a vector and places the results into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result       The result of the multiplication.
             * @return  {void}
             */
            DoTransposeThisAndMultiply$1: function (rightSide, result) {
                var d = Math.min(this.ColumnCount, this.RowCount);
                if (d < this.ColumnCount) {
                    result.ClearSubVector(this.RowCount, ((this.ColumnCount - this.RowCount) | 0));
                }

                if (d === this.RowCount) {
                    var denseOther = Bridge.as(rightSide.Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double));
                    var denseResult = Bridge.as(result.Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseVectorStorage$1(System.Double));
                    if (denseOther != null && denseResult != null) {
                        for (var j = 0; j < this.ColumnCount; j = (j + 1) | 0) {
                            var s = 0.0;
                            for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                                s += this.At(i, j) * rightSide.getItem(i);
                            }
                            result.setItem(j, s);
                        }
                        return;
                    }
                }

                for (var i1 = 0; i1 < d; i1 = (i1 + 1) | 0) {
                    result.At$1(i1, this._data[System.Array.index(i1, this._data)] * rightSide.At(i1));
                }
            },
            /**
             * Divides each element of the matrix by a scalar and places results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {number}                                     divisor    The scalar to divide the matrix with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     The matrix to store the result of the division.
             * @return  {void}
             */
            DoDivide: function (divisor, result) {
                if (divisor === 1.0) {
                    this.CopyTo(result);
                    return;
                }

                var diagResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                if (diagResult != null) {
                    this.Map$1(function (x) {
                        return x / divisor;
                    }, result, divisor === 0.0 ? MathNet.Numerics.LinearAlgebra.Zeros.Include : MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                    return;
                }

                result.Clear();
                for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                    result.At$1(i, i, this._data[System.Array.index(i, this._data)] / divisor);
                }
            },
            /**
             * Divides a scalar by each element of the matrix and stores the result in the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {number}                                     dividend    The scalar to add.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      The matrix to store the result of the division.
             * @return  {void}
             */
            DoDivideByThis: function (dividend, result) {
                var diagResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                if (diagResult != null) {
                    var resultData = diagResult._data;

                    for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                        resultData[System.Array.index(i, resultData)] = dividend / this._data[System.Array.index(i, this._data)];
                    }

                    return;
                }

                result.Clear();
                for (var i1 = 0; i1 < this._data.length; i1 = (i1 + 1) | 0) {
                    result.At$1(i1, i1, dividend / this._data[System.Array.index(i1, this._data)]);
                }
            },
            /**
             * Computes the determinant of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @return  {number}        The determinant of this matrix.
             */
            Determinant: function () {
                if (this.RowCount !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSquare");
                }

                return System.Linq.Enumerable.from(this._data, System.Double).aggregate(1.0, function (current, t) {
                        return current * t;
                    });
            },
            /**
             * Returns the elements of the diagonal in a {@link }.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @return  {MathNet.Numerics.LinearAlgebra.Vector$1}        The elements of the diagonal.
             */
            Diagonal: function () {
                return new MathNet.Numerics.LinearAlgebra.Double.DenseVector.$ctor1(this._data).Clone();
            },
            /**
             * Copies the values of the given array to the diagonal.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If the length of <b /> does not
             equal Min(Rows, Columns).
             * @param   {Array.<number>}    source    The array to copy the values from. The length of the vector should be
             Min(Rows, Columns).
             * @return  {void}
             */
            SetDiagonal: function (source) {
                if (source.length !== this._data.length) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentArraysSameLength", "source");
                }
                var m = new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.$ctor2(source.length, source.length);



                System.Array.copy(source, 0, this._data, 0, source.length);
            },
            /**
             * Copies the values of the given {@link } to the diagonal.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If the length of <b /> does not
             equal Min(Rows, Columns).
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    source    The vector to copy the values from. The length of the vector should be
             Min(Rows, Columns).
             * @return  {void}
             */
            SetDiagonal$1: function (source) {
                var denseSource = Bridge.as(source, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                if (denseSource == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.SetDiagonal$1.call(this, source);
                    return;
                }

                if (this._data.length !== denseSource.Values.length) {
                    throw new System.ArgumentException.$ctor3("Resources.ArgumentVectorsSameLength", "source");
                }

                System.Array.copy(denseSource.Values, 0, this._data, 0, denseSource.Values.length);
            },
            /**
             * Calculates the induced L1 norm of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @return  {number}        The maximum absolute column sum of the matrix.
             */
            L1Norm: function () {
                return System.Linq.Enumerable.from(this._data, System.Double).aggregate(0.0, function (current, t) {
                        return Math.max(current, Math.abs(t));
                    });
            },
            /**
             * Calculates the induced L2 norm of the matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @return  {number}        The largest singular value of the matrix.
             */
            L2Norm: function () {
                return System.Linq.Enumerable.from(this._data, System.Double).aggregate(0.0, function (current, t) {
                        return Math.max(current, Math.abs(t));
                    });
            },
            /**
             * Calculates the induced infinity norm of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @return  {number}        The maximum absolute row sum of the matrix.
             */
            InfinityNorm: function () {
                return this.L1Norm();
            },
            /**
             * Calculates the entry-wise Frobenius norm of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @return  {number}        The square root of the sum of the squared values.
             */
            FrobeniusNorm: function () {
                return Math.sqrt(System.Linq.Enumerable.from(this._data, System.Double).sum(function (t) {
                        return t * t;
                    }));
            },
            /**
             * Calculates the condition number of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @return  {number}        The condition number of the matrix.
             */
            ConditionNumber: function () {
                var $t;
                var maxSv = Number.NEGATIVE_INFINITY;
                var minSv = Number.POSITIVE_INFINITY;
                $t = Bridge.getEnumerator(this._data);
                try {
                    while ($t.moveNext()) {
                        var t = $t.Current;
                        maxSv = Math.max(maxSv, Math.abs(t));
                        minSv = Math.min(minSv, Math.abs(t));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return maxSv / minSv;
            },
            /**
             * Computes the inverse of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If {@link ArgumentException} is not a square matrix.
             * @throws If {@link ArgumentException} is singular.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The inverse of this matrix.
             */
            Inverse: function () {
                if (this.RowCount !== this.ColumnCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSquare");
                }

                var inverse = Bridge.cast(this.Clone(), MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                    if (this._data[System.Array.index(i, this._data)] !== 0.0) {
                        inverse._data[System.Array.index(i, inverse._data)] = 1.0 / this._data[System.Array.index(i, this._data)];
                    } else {
                        throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixNotSingular");
                    }
                }

                return inverse;
            },
            /**
             * Returns a new matrix containing the lower triangle of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The lower triangle of this matrix.
             */
            LowerTriangle: function () {
                return this.Clone();
            },
            /**
             * Puts the lower triangle of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            LowerTriangle$1: function (result) {
                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                if (Bridge.referenceEquals(this, result)) {
                    return;
                }

                result.Clear();
                for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                    result.At$1(i, i, this._data[System.Array.index(i, this._data)]);
                }
            },
            /**
             * Returns a new matrix containing the lower triangle of this matrix. The new matrix
             does not contain the diagonal elements of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The lower triangle of this matrix.
             */
            StrictlyLowerTriangle: function () {
                return new MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.$ctor2(this.RowCount, this.ColumnCount);
            },
            /**
             * Puts the strictly lower triangle of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            StrictlyLowerTriangle$1: function (result) {
                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                result.Clear();
            },
            /**
             * Returns a new matrix containing the upper triangle of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The upper triangle of this matrix.
             */
            UpperTriangle: function () {
                return this.Clone();
            },
            /**
             * Puts the upper triangle of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            UpperTriangle$1: function (result) {
                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                result.Clear();
                for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                    result.At$1(i, i, this._data[System.Array.index(i, this._data)]);
                }
            },
            /**
             * Returns a new matrix containing the upper triangle of this matrix. The new matrix
             does not contain the diagonal elements of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The upper triangle of this matrix.
             */
            StrictlyUpperTriangle: function () {
                return new MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.$ctor2(this.RowCount, this.ColumnCount);
            },
            /**
             * Puts the strictly upper triangle of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            StrictlyUpperTriangle$1: function (result) {
                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                result.Clear();
            },
            /**
             * Creates a matrix that contains the values from the requested sub-matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws If:
             * @throws If <b /> or <b />
             is not positive.
             * @param   {number}                                     rowIndex       The row to start copying from.
             * @param   {number}                                     rowCount       The number of rows to copy. Must be positive.
             * @param   {number}                                     columnIndex    The column to start copying from.
             * @param   {number}                                     columnCount    The number of columns to copy. Must be positive.
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}                   The requested sub-matrix.
             */
            SubMatrix: function (rowIndex, rowCount, columnIndex, columnCount) {
                var target = rowIndex === columnIndex ? Bridge.cast(new MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix.$ctor2(rowCount, columnCount), MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double)) : new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.$ctor2(rowCount, columnCount);

                this.Storage.CopySubMatrixTo(target.Storage, rowIndex, 0, rowCount, columnIndex, 0, columnCount, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                return target;
            },
            /**
             * Permute the columns of a matrix according to a permutation.
             * Evaluates whether this matrix is symmetric.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @throws Always thrown
             * @return  {boolean}
             */
            IsSymmetric: function () {
                return true;
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for the given divisor each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {number}                                     divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     Matrix to store the results in.
             * @return  {void}
             */
            DoModulus: function (divisor, result) {
                var diagonalResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                if (diagonalResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoModulus.call(this, divisor, result);
                    return;
                }


                var r = diagonalResult._data;
                for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                    r[System.Array.index(i, r)] = MathNet.Numerics.Euclid.Modulus(this._data[System.Array.index(i, this._data)], divisor);
                }

            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for the given dividend for each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {number}                                     dividend    The scalar numerator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      A vector to store the results in.
             * @return  {void}
             */
            DoModulusByThis: function (dividend, result) {
                var diagonalResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                if (diagonalResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoModulusByThis.call(this, dividend, result);
                    return;
                }


                var r = diagonalResult._data;
                for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                    r[System.Array.index(i, r)] = MathNet.Numerics.Euclid.Modulus(dividend, this._data[System.Array.index(i, this._data)]);
                }

            },
            /**
             * Computes the remainder (% operator), where the result has the sign of the dividend,
             for the given divisor each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {number}                                     divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     Matrix to store the results in.
             * @return  {void}
             */
            DoRemainder: function (divisor, result) {
                var diagonalResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                if (diagonalResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoRemainder.call(this, divisor, result);
                    return;
                }


                var r = diagonalResult._data;
                for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                    r[System.Array.index(i, r)] = this._data[System.Array.index(i, this._data)] % divisor;
                }

            },
            /**
             * Computes the remainder (% operator), where the result has the sign of the dividend,
             for the given dividend for each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix
             * @param   {number}                                     dividend    The scalar numerator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result      A vector to store the results in.
             * @return  {void}
             */
            DoRemainderByThis: function (dividend, result) {
                var diagonalResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DiagonalMatrix);
                if (diagonalResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoRemainderByThis.call(this, dividend, result);
                    return;
                }


                var r = diagonalResult._data;
                for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                    r[System.Array.index(i, r)] = dividend % this._data[System.Array.index(i, this._data)];
                }

            },
            LU: function () {
                throw new System.NotImplementedException.ctor();
            }
        }
    });

    /** @namespace MathNet.Numerics.LinearAlgebra.Double.Factorization */

    /**
     * <p>A class which encapsulates the functionality of an LU factorization.</p><p>For a matrix A, the LU factorization is a pair of lower triangular matrix L and
     upper triangular matrix U so that A = L*U.</p><p>In the Math.Net implementation we also store a set of pivot elements for increased
     numerical stability. The pivot elements encode a permutation matrix P such that P*A = L*U.</p>
     *
     * @abstract
     * @class MathNet.Numerics.LinearAlgebra.Double.Factorization.LU
     * @augments MathNet.Numerics.LinearAlgebra.Factorization.LU$1
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.Factorization.LU", {
        inherits: [MathNet.Numerics.LinearAlgebra.Factorization.LU$1(System.Double)],
        props: {
            /**
             * Gets the determinant of the matrix for which the LU factorization was computed.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.LU
             * @function Determinant
             * @type number
             */
            Determinant: {
                get: function () {
                    var det = 1.0;
                    for (var j = 0; j < this.Factors.RowCount; j = (j + 1) | 0) {
                        if (this.Pivots[System.Array.index(j, this.Pivots)] !== j) {
                            det *= -this.Factors.At(j, j);
                        } else {
                            det *= this.Factors.At(j, j);
                        }
                    }

                    return det;
                }
            }
        },
        ctors: {
            ctor: function (factors, pivots) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Factorization.LU$1(System.Double).ctor.call(this, factors, pivots);
            }
        }
    });

    /**
     * <p>A class which encapsulates the functionality of the singular value decomposition (SVD).</p><p>Suppose M is an m-by-n matrix whose entries are real numbers.
     Then there exists a factorization of the form M = UÎ£VT where:
     - U is an m-by-m unitary matrix;
     - Î£ is m-by-n diagonal matrix with nonnegative real numbers on the diagonal;
     - VT denotes transpose of V, an n-by-n unitary matrix;
     Such a factorization is called a singular-value decomposition of M. A common convention is to order the diagonal
     entries Î£(i,i) in descending order. In this case, the diagonal matrix Î£ is uniquely determined
     by M (though the matrices U and V are not). The diagonal entries of Î£ are known as the singular values of M.</p>
     *
     * @abstract
     * @class MathNet.Numerics.LinearAlgebra.Double.Factorization.Svd
     * @augments MathNet.Numerics.LinearAlgebra.Factorization.Svd$1
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.Factorization.Svd", {
        inherits: [MathNet.Numerics.LinearAlgebra.Factorization.Svd$1(System.Double)],
        props: {
            /**
             * Gets the effective numerical matrix rank.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.Svd
             * @function Rank
             * @type number
             */
            Rank: {
                get: function () {
                    var tolerance = 4.94065645841247E-324;
                    return System.Linq.Enumerable.from(this.S, System.Double).count(function (t) {
                            return Math.abs(t) > tolerance;
                        });
                }
            },
            /**
             * Gets the two norm of the {@link }.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.Svd
             * @function L2Norm
             * @type number
             * @return  {[type]}        The 2-norm of the {@link }.
             */
            L2Norm: {
                get: function () {
                    return Math.abs(this.S.getItem(0));
                }
            },
            /**
             * Gets the condition number <b>max(S) / min(S)</b>
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.Svd
             * @function ConditionNumber
             * @type number
             * @return  {[type]}        The condition number.
             */
            ConditionNumber: {
                get: function () {
                    var tmp = (Math.min(this.U.RowCount, this.VT.ColumnCount) - 1) | 0;
                    return Math.abs(this.S.getItem(0)) / Math.abs(this.S.getItem(tmp));
                }
            },
            /**
             * Gets the determinant of the square matrix for which the SVD was computed.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.Svd
             * @function Determinant
             * @type number
             */
            Determinant: {
                get: function () {
                    var $t;
                    if (this.U.RowCount !== this.VT.ColumnCount) {
                        throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSquare");
                    }

                    var det = 1.0;
                    $t = Bridge.getEnumerator(this.S, System.Double);
                    try {
                        while ($t.moveNext()) {
                            var value = $t.Current;
                            det *= value;
                            if (Math.abs(value) <= (Math.pow(10, -5))) {
                                return 0;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return Math.abs(det);
                }
            }
        },
        ctors: {
            ctor: function (s, u, vt, vectorsComputed) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Factorization.Svd$1(System.Double).ctor.call(this, s, u, vt, vectorsComputed);
            }
        }
    });

    /**
     * A Matrix with sparse storage, intended for very large matrices where most of the cells are zero.
     The underlying storage scheme is 3-array compressed-sparse-row (CSR) Format.
     <a href="http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR_or_CRS.29">Wikipedia - CSR</a>.
     *
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
     * @augments MathNet.Numerics.LinearAlgebra.Double.Matrix
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.SparseMatrix", {
        inherits: [MathNet.Numerics.LinearAlgebra.Double.Matrix],
        statics: {
            methods: {
                /**
                 * Create a new sparse matrix as a copy of the given other matrix.
                 This new matrix will be independent from the other matrix.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}               matrix
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfMatrix: function (matrix) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfMatrix(matrix.Storage));
                },
                /**
                 * Create a new sparse matrix as a copy of the given two-dimensional array.
                 This new matrix will be independent from the provided array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {Array.<number>}                                        array
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfArray: function (array) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfArray(array));
                },
                /**
                 * Create a new sparse matrix as a copy of the given indexed enumerable.
                 Keys must be provided at most once, zero is assumed if a key is omitted.
                 This new matrix will be independent from the enumerable.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {number}                                                rows          
                 * @param   {number}                                                columns       
                 * @param   {System.Collections.Generic.IEnumerable$1}              enumerable
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfIndexed: function (rows, columns, enumerable) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfIndexedEnumerable(rows, columns, enumerable));
                },
                /**
                 * Create a new sparse matrix as a copy of the given enumerable.
                 The enumerable is assumed to be in row-major order (row by row).
                 This new matrix will be independent from the enumerable.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {number}                                                rows        
                 * @param   {number}                                                columns     
                 * @param   {System.Collections.Generic.IEnumerable$1}              rowMajor
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 * @see {@link }
                 */
                OfRowMajor: function (rows, columns, rowMajor) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfRowMajorEnumerable(rows, columns, rowMajor));
                },
                /**
                 * Create a new sparse matrix with the given number of rows and columns as a copy of the given array.
                 The array is assumed to be in column-major order (column by column).
                 This new matrix will be independent from the provided array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {number}                                                rows           
                 * @param   {number}                                                columns        
                 * @param   {System.Collections.Generic.IList$1}                    columnMajor
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 * @see {@link }
                 */
                OfColumnMajor: function (rows, columns, columnMajor) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfColumnMajorList(rows, columns, columnMajor));
                },
                /**
                 * Create a new sparse matrix as a copy of the given enumerable of enumerable columns.
                 Each enumerable in the master enumerable specifies a column.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {System.Collections.Generic.IEnumerable$1}              data
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfColumns: function (data) {
                    return MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.OfColumnArrays$1(System.Linq.Enumerable.from(data, System.Collections.Generic.IEnumerable$1(System.Double)).select(function (v) {
                            var $t;
                            return ($t = System.Double, System.Linq.Enumerable.from(v, $t).ToArray($t));
                        }).ToArray(System.Array.type(System.Double)));
                },
                /**
                 * Create a new sparse matrix as a copy of the given enumerable of enumerable columns.
                 Each enumerable in the master enumerable specifies a column.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {number}                                                rows       
                 * @param   {number}                                                columns    
                 * @param   {System.Collections.Generic.IEnumerable$1}              data
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfColumns$1: function (rows, columns, data) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfColumnEnumerables(rows, columns, data));
                },
                /**
                 * Create a new sparse matrix as a copy of the given column arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {Array.<Array.<number>>}                                columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfColumnArrays$1: function (columns) {
                    if (columns === void 0) { columns = []; }
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfColumnArrays(columns));
                },
                /**
                 * Create a new sparse matrix as a copy of the given column arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {System.Collections.Generic.IEnumerable$1}              columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfColumnArrays: function (columns) {
                    var $t;
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfColumnArrays((Bridge.as(columns, System.Array.type(System.Array.type(System.Double)))) || ($t = System.Array.type(System.Double), System.Linq.Enumerable.from(columns, $t).ToArray($t))));
                },
                /**
                 * Create a new sparse matrix as a copy of the given column vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}       columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfColumnVectors: function (columns) {
                    if (columns === void 0) { columns = []; }
                    var storage = System.Array.init(columns.length, null, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(System.Double));
                    for (var i = 0; i < columns.length; i = (i + 1) | 0) {
                        storage[System.Array.index(i, storage)] = columns[System.Array.index(i, columns)].Storage;
                    }
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfColumnVectors(storage));
                },
                /**
                 * Create a new sparse matrix as a copy of the given column vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {System.Collections.Generic.IEnumerable$1}              columns
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfColumnVectors$1: function (columns) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfColumnVectors(System.Linq.Enumerable.from(columns, MathNet.Numerics.LinearAlgebra.Vector$1(System.Double)).select(function (c) {
                            return c.Storage;
                        }).ToArray(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(System.Double))));
                },
                /**
                 * Create a new sparse matrix as a copy of the given enumerable of enumerable rows.
                 Each enumerable in the master enumerable specifies a row.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {System.Collections.Generic.IEnumerable$1}              data
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfRows: function (data) {
                    return MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.OfRowArrays$1(System.Linq.Enumerable.from(data, System.Collections.Generic.IEnumerable$1(System.Double)).select(function (v) {
                            var $t;
                            return ($t = System.Double, System.Linq.Enumerable.from(v, $t).ToArray($t));
                        }).ToArray(System.Array.type(System.Double)));
                },
                /**
                 * Create a new sparse matrix as a copy of the given enumerable of enumerable rows.
                 Each enumerable in the master enumerable specifies a row.
                 This new matrix will be independent from the enumerables.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {number}                                                rows       
                 * @param   {number}                                                columns    
                 * @param   {System.Collections.Generic.IEnumerable$1}              data
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfRows$1: function (rows, columns, data) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfRowEnumerables(rows, columns, data));
                },
                /**
                 * Create a new sparse matrix as a copy of the given row arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {Array.<Array.<number>>}                                rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfRowArrays$1: function (rows) {
                    if (rows === void 0) { rows = []; }
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfRowArrays(rows));
                },
                /**
                 * Create a new sparse matrix as a copy of the given row arrays.
                 This new matrix will be independent from the arrays.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {System.Collections.Generic.IEnumerable$1}              rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfRowArrays: function (rows) {
                    var $t;
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfRowArrays((Bridge.as(rows, System.Array.type(System.Array.type(System.Double)))) || ($t = System.Array.type(System.Double), System.Linq.Enumerable.from(rows, $t).ToArray($t))));
                },
                /**
                 * Create a new sparse matrix as a copy of the given row vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {Array.<MathNet.Numerics.LinearAlgebra.Vector$1>}       rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfRowVectors: function (rows) {
                    if (rows === void 0) { rows = []; }
                    var storage = System.Array.init(rows.length, null, MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(System.Double));
                    for (var i = 0; i < rows.length; i = (i + 1) | 0) {
                        storage[System.Array.index(i, storage)] = rows[System.Array.index(i, rows)].Storage;
                    }
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfRowVectors(storage));
                },
                /**
                 * Create a new sparse matrix as a copy of the given row vectors.
                 This new matrix will be independent from the vectors.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {System.Collections.Generic.IEnumerable$1}              rows
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfRowVectors$1: function (rows) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfRowVectors(System.Linq.Enumerable.from(rows, MathNet.Numerics.LinearAlgebra.Vector$1(System.Double)).select(function (r) {
                            return r.Storage;
                        }).ToArray(MathNet.Numerics.LinearAlgebra.Storage.VectorStorage$1(System.Double))));
                },
                /**
                 * Create a new sparse matrix with the diagonal as a copy of the given vector.
                 This new matrix will be independent from the vector.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}               diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfDiagonalVector: function (diagonal) {
                    var m = new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.$ctor2(diagonal.Count, diagonal.Count);
                    m.SetDiagonal$1(diagonal);
                    return m;
                },
                /**
                 * Create a new sparse matrix with the diagonal as a copy of the given vector.
                 This new matrix will be independent from the vector.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {number}                                                rows        
                 * @param   {number}                                                columns     
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}               diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfDiagonalVector$1: function (rows, columns, diagonal) {
                    var m = new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.$ctor2(rows, columns);
                    m.SetDiagonal$1(diagonal);
                    return m;
                },
                /**
                 * Create a new sparse matrix with the diagonal as a copy of the given array.
                 This new matrix will be independent from the array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {Array.<number>}                                        diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfDiagonalArray: function (diagonal) {
                    var m = new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.$ctor2(diagonal.length, diagonal.length);
                    m.SetDiagonal(diagonal);
                    return m;
                },
                /**
                 * Create a new sparse matrix with the diagonal as a copy of the given array.
                 This new matrix will be independent from the array.
                 A new memory block will be allocated for storing the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {number}                                                rows        
                 * @param   {number}                                                columns     
                 * @param   {Array.<number>}                                        diagonal
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                OfDiagonalArray$1: function (rows, columns, diagonal) {
                    var m = new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.$ctor2(rows, columns);
                    m.SetDiagonal(diagonal);
                    return m;
                },
                /**
                 * Create a new sparse matrix and initialize each value to the same provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {number}                                                rows       
                 * @param   {number}                                                columns    
                 * @param   {number}                                                value
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                Create: function (rows, columns, value) {
                    if (value === 0.0) {
                        return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.$ctor2(rows, columns);
                    }
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfValue(rows, columns, value));
                },
                /**
                 * Create a new sparse matrix and initialize each value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {number}                                                rows       
                 * @param   {number}                                                columns    
                 * @param   {System.Func}                                           init
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                Create$1: function (rows, columns, init) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfInit(rows, columns, init));
                },
                /**
                 * Create a new diagonal sparse matrix and initialize each diagonal value to the same provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {number}                                                rows       
                 * @param   {number}                                                columns    
                 * @param   {number}                                                value
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                CreateDiagonal: function (rows, columns, value) {
                    if (value === 0.0) {
                        return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.$ctor2(rows, columns);
                    }
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfDiagonalInit(rows, columns, function (i) {
                        return value;
                    }));
                },
                /**
                 * Create a new diagonal sparse matrix and initialize each diagonal value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {number}                                                rows       
                 * @param   {number}                                                columns    
                 * @param   {System.Func}                                           init
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                CreateDiagonal$1: function (rows, columns, init) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfDiagonalInit(rows, columns, init));
                },
                /**
                 * Create a new square sparse identity matrix where each diagonal value is set to One.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @param   {number}                                                order
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}
                 */
                CreateIdentity: function (order) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double).OfDiagonalInit(order, order, function (i) {
                        return MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).One;
                    }));
                }/**
                 * Adds two matrices together and returns the results.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @throws If <b /> and <b /> don't have the same dimensions.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}    leftSide     The left matrix to add.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}    rightSide    The right matrix to add.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}                 The result of the addition.
                 */
                ,
                op_Addition: function (leftSide, rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    if (leftSide.RowCount !== rightSide.RowCount || leftSide.ColumnCount !== rightSide.ColumnCount) {
                        throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentOutOfRangeException, leftSide, rightSide);
                    }

                    return Bridge.cast(leftSide.Add$1(rightSide), MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                }/**
                 * Returns a <strong>Matrix</strong> containing the same values of <b />.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}    rightSide    The matrix to get the values from.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}                 A matrix containing a the same values as <b />.
                 */
                ,
                op_UnaryPlus: function (rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    return Bridge.cast(rightSide.Clone(), MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                }/**
                 * Subtracts two matrices together and returns the results.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @throws If <b /> and <b /> don't have the same dimensions.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}    leftSide     The left matrix to subtract.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}    rightSide    The right matrix to subtract.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}                 The result of the addition.
                 */
                ,
                op_Subtraction: function (leftSide, rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    if (leftSide.RowCount !== rightSide.RowCount || leftSide.ColumnCount !== rightSide.ColumnCount) {
                        throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentException, leftSide, rightSide);
                    }

                    return Bridge.cast(leftSide.Subtract$1(rightSide), MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                }/**
                 * Negates each element of the matrix.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}    rightSide    The matrix to negate.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}                 A matrix containing the negated values.
                 */
                ,
                op_UnaryNegation: function (rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    return Bridge.cast(rightSide.Negate(), MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                }/**
                 * Multiplies a <strong>Matrix</strong> by a constant and returns the result.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}    leftSide     The matrix to multiply.
                 * @param   {number}                                                rightSide    The constant to multiply the matrix by.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}                 The result of the multiplication.
                 */
                ,
                op_Multiply$1: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Multiply(rightSide), MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                }/**
                 * Multiplies a <strong>Matrix</strong> by a constant and returns the result.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {number}                                                leftSide     The matrix to multiply.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}    rightSide    The constant to multiply the matrix by.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}                 The result of the multiplication.
                 */
                ,
                op_Multiply$2: function (leftSide, rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    return Bridge.cast(rightSide.Multiply(leftSide), MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                }/**
                 * Multiplies two matrices.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @throws If the dimensions of <b /> or <b /> don't conform.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}    leftSide     The left matrix to multiply.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}    rightSide    The right matrix to multiply.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}                 The result of multiplication.
                 */
                ,
                op_Multiply: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    if (leftSide.ColumnCount !== rightSide.RowCount) {
                        throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentException, leftSide, rightSide);
                    }

                    return Bridge.cast(leftSide.Multiply$1(rightSide), MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                }/**
                 * Multiplies a <strong>Matrix</strong> and a Vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}    leftSide     The matrix to multiply.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseVector}    rightSide    The vector to multiply.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}                 The result of multiplication.
                 */
                ,
                op_Multiply$3: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Multiply$2(rightSide), MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                }/**
                 * Multiplies a Vector and a <strong>Matrix</strong>.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseVector}    leftSide     The vector to multiply.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}    rightSide    The matrix to multiply.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}                 The result of multiplication.
                 */
                ,
                op_Multiply$4: function (leftSide, rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    return Bridge.cast(rightSide.LeftMultiply(leftSide), MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                }/**
                 * Multiplies a <strong>Matrix</strong> by a constant and returns the result.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}    leftSide     The matrix to multiply.
                 * @param   {number}                                                rightSide    The constant to multiply the matrix by.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseMatrix}                 The result of the multiplication.
                 */
                ,
                op_Modulus: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Remainder(rightSide), MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                }
            }
        },
        fields: {
            _storage: null
        },
        props: {
            /**
             * Gets the number of non zero elements in the matrix.
             *
             * @instance
             * @public
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @function NonZerosCount
             * @type number
             */
            NonZerosCount: {
                get: function () {
                    return this._storage.ValueCount;
                }
            }
        },
        ctors: {
            /**
             * Create a new sparse matrix straight from an initialized matrix storage instance.
             The storage is used directly without copying.
             Intended for advanced scenarios where you're working directly with
             storage for performance or interop reasons.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1}    storage
             * @return  {void}
             */
            ctor: function (storage) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Double.Matrix.ctor.call(this, storage);
                this._storage = storage;
            },
            /**
             * Create a new square sparse matrix with the given number of rows and columns.
             All cells of the matrix will be initialized to zero.
             Zero-length matrices are not supported.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @throws If the order is less than one.
             * @param   {number}    order
             * @return  {void}
             */
            $ctor1: function (order) {
                MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.$ctor2.call(this, order, order);
            },
            /**
             * Create a new sparse matrix with the given number of rows and columns.
             All cells of the matrix will be initialized to zero.
             Zero-length matrices are not supported.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @throws If the row or column count is less than one.
             * @param   {number}    rows       
             * @param   {number}    columns
             * @return  {void}
             */
            $ctor2: function (rows, columns) {
                MathNet.Numerics.LinearAlgebra.Double.SparseMatrix.ctor.call(this, new (MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double))(rows, columns));
            }
        },
        methods: {
            /**
             * Returns a new matrix containing the lower triangle of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The lower triangle of this matrix.
             */
            LowerTriangle: function () {
                var result = this.m_builder$1.SameAs$3(System.Double, this);
                this.LowerTriangleImpl(result);
                return result;
            },
            /**
             * Puts the lower triangle of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            LowerTriangle$1: function (result) {
                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                if (Bridge.referenceEquals(this, result)) {
                    var tmp = this.m_builder$1.SameAs$3(System.Double, result);
                    this.LowerTriangle$1(tmp);
                    tmp.CopyTo(result);
                } else {
                    result.Clear();
                    this.LowerTriangleImpl(result);
                }
            },
            /**
             * Puts the lower triangle of this matrix into the result matrix.
             *
             * @instance
             * @private
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            LowerTriangleImpl: function (result) {
                var rowPointers = this._storage.RowPointers;
                var columnIndices = this._storage.ColumnIndices;
                var values = this._storage.Values;

                for (var row = 0; row < result.RowCount; row = (row + 1) | 0) {
                    var endIndex = rowPointers[System.Array.index(((row + 1) | 0), rowPointers)];
                    for (var j = rowPointers[System.Array.index(row, rowPointers)]; j < endIndex; j = (j + 1) | 0) {
                        if (row >= columnIndices[System.Array.index(j, columnIndices)]) {
                            result.At$1(row, columnIndices[System.Array.index(j, columnIndices)], values[System.Array.index(j, values)]);
                        }
                    }
                }
            },
            /**
             * Returns a new matrix containing the upper triangle of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The upper triangle of this matrix.
             */
            UpperTriangle: function () {
                var result = this.m_builder$1.SameAs$3(System.Double, this);
                this.UpperTriangleImpl(result);
                return result;
            },
            /**
             * Puts the upper triangle of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            UpperTriangle$1: function (result) {
                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                if (Bridge.referenceEquals(this, result)) {
                    var tmp = this.m_builder$1.SameAs$3(System.Double, result);
                    this.UpperTriangle$1(tmp);
                    tmp.CopyTo(result);
                } else {
                    result.Clear();
                    this.UpperTriangleImpl(result);
                }
            },
            /**
             * Puts the upper triangle of this matrix into the result matrix.
             *
             * @instance
             * @private
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            UpperTriangleImpl: function (result) {
                var rowPointers = this._storage.RowPointers;
                var columnIndices = this._storage.ColumnIndices;
                var values = this._storage.Values;

                for (var row = 0; row < result.RowCount; row = (row + 1) | 0) {
                    var endIndex = rowPointers[System.Array.index(((row + 1) | 0), rowPointers)];
                    for (var j = rowPointers[System.Array.index(row, rowPointers)]; j < endIndex; j = (j + 1) | 0) {
                        if (row <= columnIndices[System.Array.index(j, columnIndices)]) {
                            result.At$1(row, columnIndices[System.Array.index(j, columnIndices)], values[System.Array.index(j, values)]);
                        }
                    }
                }
            },
            /**
             * Returns a new matrix containing the lower triangle of this matrix. The new matrix
             does not contain the diagonal elements of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The lower triangle of this matrix.
             */
            StrictlyLowerTriangle: function () {
                var result = this.m_builder$1.SameAs$3(System.Double, this);
                this.StrictlyLowerTriangleImpl(result);
                return result;
            },
            /**
             * Puts the strictly lower triangle of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            StrictlyLowerTriangle$1: function (result) {
                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                if (Bridge.referenceEquals(this, result)) {
                    var tmp = this.m_builder$1.SameAs$3(System.Double, result);
                    this.StrictlyLowerTriangle$1(tmp);
                    tmp.CopyTo(result);
                } else {
                    result.Clear();
                    this.StrictlyLowerTriangleImpl(result);
                }
            },
            /**
             * Puts the strictly lower triangle of this matrix into the result matrix.
             *
             * @instance
             * @private
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            StrictlyLowerTriangleImpl: function (result) {
                var rowPointers = this._storage.RowPointers;
                var columnIndices = this._storage.ColumnIndices;
                var values = this._storage.Values;

                for (var row = 0; row < result.RowCount; row = (row + 1) | 0) {
                    var endIndex = rowPointers[System.Array.index(((row + 1) | 0), rowPointers)];
                    for (var j = rowPointers[System.Array.index(row, rowPointers)]; j < endIndex; j = (j + 1) | 0) {
                        if (row > columnIndices[System.Array.index(j, columnIndices)]) {
                            result.At$1(row, columnIndices[System.Array.index(j, columnIndices)], values[System.Array.index(j, values)]);
                        }
                    }
                }
            },
            /**
             * Returns a new matrix containing the upper triangle of this matrix. The new matrix
             does not contain the diagonal elements of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The upper triangle of this matrix.
             */
            StrictlyUpperTriangle: function () {
                var result = this.m_builder$1.SameAs$3(System.Double, this);
                this.StrictlyUpperTriangleImpl(result);
                return result;
            },
            /**
             * Puts the strictly upper triangle of this matrix into the result matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @throws If <b /> is {@link ArgumentNullException}.
             * @throws If the result matrix's dimensions are not the same as this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            StrictlyUpperTriangle$1: function (result) {
                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (result.RowCount !== this.RowCount || result.ColumnCount !== this.ColumnCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentException, this, result, "result");
                }

                if (Bridge.referenceEquals(this, result)) {
                    var tmp = this.m_builder$1.SameAs$3(System.Double, result);
                    this.StrictlyUpperTriangle$1(tmp);
                    tmp.CopyTo(result);
                } else {
                    result.Clear();
                    this.StrictlyUpperTriangleImpl(result);
                }
            },
            /**
             * Puts the strictly upper triangle of this matrix into the result matrix.
             *
             * @instance
             * @private
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    Where to store the lower triangle.
             * @return  {void}
             */
            StrictlyUpperTriangleImpl: function (result) {
                var rowPointers = this._storage.RowPointers;
                var columnIndices = this._storage.ColumnIndices;
                var values = this._storage.Values;

                for (var row = 0; row < result.RowCount; row = (row + 1) | 0) {
                    var endIndex = rowPointers[System.Array.index(((row + 1) | 0), rowPointers)];
                    for (var j = rowPointers[System.Array.index(row, rowPointers)]; j < endIndex; j = (j + 1) | 0) {
                        if (row < columnIndices[System.Array.index(j, columnIndices)]) {
                            result.At$1(row, columnIndices[System.Array.index(j, columnIndices)], values[System.Array.index(j, values)]);
                        }
                    }
                }
            },
            /**
             * Negate each element of this matrix and place the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the negation.
             * @return  {void}
             */
            DoNegate: function (result) {
                this.CopyTo(result);
                this.DoMultiply(-1, result);
            },
            /**
             * Calculates the induced infinity norm of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @return  {number}        The maximum absolute row sum of the matrix.
             */
            InfinityNorm: function () {
                var rowPointers = this._storage.RowPointers;
                var values = this._storage.Values;
                var norm = 0.0;
                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var startIndex = rowPointers[System.Array.index(i, rowPointers)];
                    var endIndex = rowPointers[System.Array.index(((i + 1) | 0), rowPointers)];

                    if (startIndex === endIndex) {
                        continue;
                    }

                    var s = 0.0;
                    for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                        s += Math.abs(values[System.Array.index(j, values)]);
                    }
                    norm = Math.max(norm, s);
                }
                return norm;
            },
            /**
             * Calculates the entry-wise Frobenius norm of this matrix.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @return  {number}        The square root of the sum of the squared values.
             */
            FrobeniusNorm: function () {
                var aat = Bridge.cast((MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).op_Multiply$2(this, this.Transpose())).Storage, MathNet.Numerics.LinearAlgebra.Storage.SparseCompressedRowMatrixStorage$1(System.Double));
                var norm = 0.0;
                for (var i = 0; i < aat.RowCount; i = (i + 1) | 0) {
                    var startIndex = aat.RowPointers[System.Array.index(i, aat.RowPointers)];
                    var endIndex = aat.RowPointers[System.Array.index(((i + 1) | 0), aat.RowPointers)];

                    if (startIndex === endIndex) {
                        continue;
                    }

                    for (var j = startIndex; j < endIndex; j = (j + 1) | 0) {
                        if (i === aat.ColumnIndices[System.Array.index(j, aat.ColumnIndices)]) {
                            norm += Math.abs(aat.Values[System.Array.index(j, aat.Values)]);
                        }
                    }
                }
                return Math.sqrt(norm);
            },
            /**
             * Adds another matrix to this matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @throws If the other matrix is {@link ArgumentNullException}.
             * @throws If the two matrices don't have the same dimensions.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to add to this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the addition.
             * @return  {void}
             */
            DoAdd$1: function (other, result) {
                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                var sparseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                if (sparseOther == null || sparseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoAdd$1.call(this, other, result);
                    return;
                }

                if (Bridge.referenceEquals(this, other)) {
                    if (!Bridge.referenceEquals(this, result)) {
                        this.CopyTo(result);
                    }

                    this.Map2$1(function (x, y) {
                        return x + y;
                    }, other, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                    return;
                }

                var left;

                if (Bridge.referenceEquals(sparseOther, sparseResult)) {
                    left = this;
                } else if (Bridge.referenceEquals(this, sparseResult)) {
                    left = sparseOther;
                } else {
                    this.CopyTo(sparseResult);
                    left = sparseOther;
                }

                var leftStorage = left._storage;
                for (var i = 0; i < leftStorage.RowCount; i = (i + 1) | 0) {
                    var endIndex = leftStorage.RowPointers[System.Array.index(((i + 1) | 0), leftStorage.RowPointers)];
                    for (var j = leftStorage.RowPointers[System.Array.index(i, leftStorage.RowPointers)]; j < endIndex; j = (j + 1) | 0) {
                        var columnIndex = leftStorage.ColumnIndices[System.Array.index(j, leftStorage.ColumnIndices)];
                        var resVal = leftStorage.Values[System.Array.index(j, leftStorage.Values)] + result.At(i, columnIndex);
                        result.At$1(i, columnIndex, resVal);
                    }
                }
            },
            /**
             * Subtracts another matrix from this matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @throws If the other matrix is {@link ArgumentNullException}.
             * @throws If the two matrices don't have the same dimensions.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to subtract to this matrix.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of subtraction.
             * @return  {void}
             */
            DoSubtract$1: function (other, result) {
                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                var sparseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);

                if (sparseOther == null || sparseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoSubtract$1.call(this, other, result);
                    return;
                }

                if (Bridge.referenceEquals(this, other)) {
                    result.Clear();
                    return;
                }

                var otherStorage = sparseOther._storage;

                if (Bridge.referenceEquals(this, sparseResult)) {
                    for (var i = 0; i < otherStorage.RowCount; i = (i + 1) | 0) {
                        var endIndex = otherStorage.RowPointers[System.Array.index(((i + 1) | 0), otherStorage.RowPointers)];
                        for (var j = otherStorage.RowPointers[System.Array.index(i, otherStorage.RowPointers)]; j < endIndex; j = (j + 1) | 0) {
                            var columnIndex = otherStorage.ColumnIndices[System.Array.index(j, otherStorage.ColumnIndices)];
                            var resVal = sparseResult.At(i, columnIndex) - otherStorage.Values[System.Array.index(j, otherStorage.Values)];
                            result.At$1(i, columnIndex, resVal);
                        }
                    }
                } else {
                    if (!Bridge.referenceEquals(sparseOther, sparseResult)) {
                        sparseOther.CopyTo(sparseResult);
                    }

                    sparseResult.Negate$1(sparseResult);

                    var rowPointers = this._storage.RowPointers;
                    var columnIndices = this._storage.ColumnIndices;
                    var values = this._storage.Values;

                    for (var i1 = 0; i1 < this.RowCount; i1 = (i1 + 1) | 0) {
                        var endIndex1 = rowPointers[System.Array.index(((i1 + 1) | 0), rowPointers)];
                        for (var j1 = rowPointers[System.Array.index(i1, rowPointers)]; j1 < endIndex1; j1 = (j1 + 1) | 0) {
                            var columnIndex1 = columnIndices[System.Array.index(j1, columnIndices)];
                            var resVal1 = sparseResult.At(i1, columnIndex1) + values[System.Array.index(j1, values)];
                            result.At$1(i1, columnIndex1, resVal1);
                        }
                    }
                }
            },
            /**
             * Multiplies each element of the matrix by a scalar and places results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {number}                                     scalar    The scalar to multiply the matrix with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the multiplication.
             * @return  {void}
             */
            DoMultiply: function (scalar, result) {
                if (scalar === 1.0) {
                    this.CopyTo(result);
                    return;
                }

                if (scalar === 0.0 || this.NonZerosCount === 0) {
                    result.Clear();
                    return;
                }

                var sparseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                if (sparseResult == null) {
                    result.Clear();

                    var rowPointers = this._storage.RowPointers;
                    var columnIndices = this._storage.ColumnIndices;
                    var values = this._storage.Values;

                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var start = rowPointers[System.Array.index(row, rowPointers)];
                        var end = rowPointers[System.Array.index(((row + 1) | 0), rowPointers)];

                        if (start === end) {
                            continue;
                        }

                        for (var index = start; index < end; index = (index + 1) | 0) {
                            var column = columnIndices[System.Array.index(index, columnIndices)];
                            result.At$1(row, column, values[System.Array.index(index, values)] * scalar);
                        }
                    }
                } else {
                    if (!Bridge.referenceEquals(this, result)) {
                        this.CopyTo(sparseResult);
                    }

                    this.Map$1(function (x) {
                        return x * scalar;
                    }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                }
            },
            /**
             * Multiplies this matrix with another matrix and places the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            DoMultiply$1: function (other, result) {
                var sparseOther = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                var sparseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                if (sparseOther != null && sparseResult != null) {
                    this.DoMultiplySparse(sparseOther, sparseResult);
                    return;
                }

                var diagonalOther = Bridge.as(other.Storage, MathNet.Numerics.LinearAlgebra.Storage.DiagonalMatrixStorage$1(System.Double));
                if (diagonalOther != null && sparseResult != null) {
                    var diagonal = diagonalOther.Data;
                    if (other.ColumnCount === other.RowCount) {
                        this.Storage.MapIndexedTo(System.Double, result.Storage, function (i, j, x) {
                            return x * diagonal[System.Array.index(j, diagonal)];
                        }, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip, MathNet.Numerics.LinearAlgebra.ExistingData.Clear);
                    } else {
                        result.Storage.Clear();
                        this.Storage.MapSubMatrixIndexedTo(System.Double, result.Storage, function (i, j, x) {
                            return x * diagonal[System.Array.index(j, diagonal)];
                        }, 0, 0, this.RowCount, 0, 0, this.ColumnCount, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip, MathNet.Numerics.LinearAlgebra.ExistingData.AssumeZeros);
                    }
                    return;
                }

                result.Clear();
                var rowPointers = this._storage.RowPointers;
                var columnIndices = this._storage.ColumnIndices;
                var values = this._storage.Values;

                var denseOther = Bridge.as(other.Storage, MathNet.Numerics.LinearAlgebra.Storage.DenseColumnMajorMatrixStorage$1(System.Double));
                if (denseOther != null) {
                    for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                        var startIndex = rowPointers[System.Array.index(row, rowPointers)];
                        var endIndex = rowPointers[System.Array.index(((row + 1) | 0), rowPointers)];

                        if (startIndex === endIndex) {
                            continue;
                        }

                        for (var column = 0; column < other.ColumnCount; column = (column + 1) | 0) {
                            var otherColumnStartPosition = Bridge.Int.mul(column, other.RowCount);
                            var sum = 0.0;
                            for (var index = startIndex; index < endIndex; index = (index + 1) | 0) {
                                sum += values[System.Array.index(index, values)] * denseOther.Data[System.Array.index(((otherColumnStartPosition + columnIndices[System.Array.index(index, columnIndices)]) | 0), denseOther.Data)];
                            }

                            result.At$1(row, column, sum);
                        }
                    }
                    return;
                }

                var columnVector = new MathNet.Numerics.LinearAlgebra.Double.DenseVector.$ctor2(other.RowCount);
                for (var row1 = 0; row1 < this.RowCount; row1 = (row1 + 1) | 0) {
                    var startIndex1 = rowPointers[System.Array.index(row1, rowPointers)];
                    var endIndex1 = rowPointers[System.Array.index(((row1 + 1) | 0), rowPointers)];

                    if (startIndex1 === endIndex1) {
                        continue;
                    }

                    for (var column1 = 0; column1 < other.ColumnCount; column1 = (column1 + 1) | 0) {
                        other.Column$2(column1, columnVector);

                        var sum1 = 0.0;
                        for (var index1 = startIndex1; index1 < endIndex1; index1 = (index1 + 1) | 0) {
                            sum1 += values[System.Array.index(index1, values)] * columnVector.getItem(columnIndices[System.Array.index(index1, columnIndices)]);
                        }

                        result.At$1(row1, column1, sum1);
                    }
                }
            },
            /**
             * Multiplies this matrix with a vector and places the results into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result       The result of the multiplication.
             * @return  {void}
             */
            DoMultiply$2: function (rightSide, result) {
                var rowPointers = this._storage.RowPointers;
                var columnIndices = this._storage.ColumnIndices;
                var values = this._storage.Values;

                for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                    var startIndex = rowPointers[System.Array.index(row, rowPointers)];
                    var endIndex = rowPointers[System.Array.index(((row + 1) | 0), rowPointers)];

                    if (startIndex === endIndex) {
                        continue;
                    }

                    var sum = 0.0;
                    for (var index = startIndex; index < endIndex; index = (index + 1) | 0) {
                        sum += values[System.Array.index(index, values)] * rightSide.getItem(columnIndices[System.Array.index(index, columnIndices)]);
                    }

                    result.setItem(row, sum);
                }
            },
            DoMultiplySparse: function (other, result) {
                result.Clear();

                var ax = this._storage.Values;
                var ap = this._storage.RowPointers;
                var ai = this._storage.ColumnIndices;

                var bx = other._storage.Values;
                var bp = other._storage.RowPointers;
                var bi = other._storage.ColumnIndices;

                var rows = this.RowCount;
                var cols = other.ColumnCount;

                var cp = result._storage.RowPointers;

                var marker = System.Array.init(cols, 0, System.Int32);
                for (var ib = 0; ib < cols; ib = (ib + 1) | 0) {
                    marker[System.Array.index(ib, marker)] = -1;
                }

                var count = 0;
                for (var i = 0; i < rows; i = (i + 1) | 0) {
                    for (var j = ap[System.Array.index(i, ap)]; j < ap[System.Array.index(((i + 1) | 0), ap)]; j = (j + 1) | 0) {
                        var a = ai[System.Array.index(j, ai)];
                        for (var k = bp[System.Array.index(a, bp)]; k < bp[System.Array.index(((a + 1) | 0), bp)]; k = (k + 1) | 0) {
                            var b = bi[System.Array.index(k, bi)];
                            if (marker[System.Array.index(b, marker)] !== i) {
                                marker[System.Array.index(b, marker)] = i;
                                count = (count + 1) | 0;
                            }
                        }
                    }

                    cp[System.Array.index(((i + 1) | 0), cp)] = count;
                }

                var ci = System.Array.init(count, 0, System.Int32);
                var cx = System.Array.init(count, 0, System.Double);

                for (var ib1 = 0; ib1 < cols; ib1 = (ib1 + 1) | 0) {
                    marker[System.Array.index(ib1, marker)] = -1;
                }

                count = 0;
                for (var i1 = 0; i1 < rows; i1 = (i1 + 1) | 0) {
                    var rowStart = cp[System.Array.index(i1, cp)];
                    for (var j1 = ap[System.Array.index(i1, ap)]; j1 < ap[System.Array.index(((i1 + 1) | 0), ap)]; j1 = (j1 + 1) | 0) {
                        var a1 = ai[System.Array.index(j1, ai)];
                        var aEntry = ax[System.Array.index(j1, ax)];
                        for (var k1 = bp[System.Array.index(a1, bp)]; k1 < bp[System.Array.index(((a1 + 1) | 0), bp)]; k1 = (k1 + 1) | 0) {
                            var b1 = bi[System.Array.index(k1, bi)];
                            var bEntry = bx[System.Array.index(k1, bx)];
                            if (marker[System.Array.index(b1, marker)] < rowStart) {
                                marker[System.Array.index(b1, marker)] = count;
                                ci[System.Array.index(marker[System.Array.index(b1, marker)], ci)] = b1;
                                cx[System.Array.index(marker[System.Array.index(b1, marker)], cx)] = aEntry * bEntry;
                                count = (count + 1) | 0;
                            } else {
                                cx[System.Array.index(marker[System.Array.index(b1, marker)], cx)] += aEntry * bEntry;
                            }
                        }
                    }
                }

                result._storage.Values = cx;
                result._storage.ColumnIndices = ci;
                result._storage.Normalize();
            },
            /**
             * Multiplies this matrix with transpose of another matrix and places the results into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The result of the multiplication.
             * @return  {void}
             */
            DoTransposeAndMultiply: function (other, result) {
                var otherSparse = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                var resultSparse = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);

                if (otherSparse == null || resultSparse == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoTransposeAndMultiply.call(this, other, result);
                    return;
                }

                resultSparse.Clear();

                var rowPointers = this._storage.RowPointers;
                var values = this._storage.Values;

                var otherStorage = otherSparse._storage;

                for (var j = 0; j < this.RowCount; j = (j + 1) | 0) {
                    var startIndexOther = otherStorage.RowPointers[System.Array.index(j, otherStorage.RowPointers)];
                    var endIndexOther = otherStorage.RowPointers[System.Array.index(((j + 1) | 0), otherStorage.RowPointers)];

                    if (startIndexOther === endIndexOther) {
                        continue;
                    }

                    for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                        var startIndexThis = rowPointers[System.Array.index(i, rowPointers)];
                        var endIndexThis = rowPointers[System.Array.index(((i + 1) | 0), rowPointers)];

                        if (startIndexThis === endIndexThis) {
                            continue;
                        }

                        var sum = 0.0;
                        for (var index = startIndexOther; index < endIndexOther; index = (index + 1) | 0) {
                            var ind = this._storage.FindItem(i, otherStorage.ColumnIndices[System.Array.index(index, otherStorage.ColumnIndices)]);
                            if (ind >= 0) {
                                sum += otherStorage.Values[System.Array.index(index, otherStorage.Values)] * values[System.Array.index(ind, values)];
                            }
                        }

                        resultSparse._storage.At$1(i, j, sum + result.At(i, j));
                    }
                }
            },
            /**
             * Multiplies the transpose of this matrix with a vector and places the results into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    rightSide    The vector to multiply with.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result       The result of the multiplication.
             * @return  {void}
             */
            DoTransposeThisAndMultiply$1: function (rightSide, result) {
                var rowPointers = this._storage.RowPointers;
                var columnIndices = this._storage.ColumnIndices;
                var values = this._storage.Values;

                for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                    var startIndex = rowPointers[System.Array.index(row, rowPointers)];
                    var endIndex = rowPointers[System.Array.index(((row + 1) | 0), rowPointers)];

                    if (startIndex === endIndex) {
                        continue;
                    }

                    var rightSideValue = rightSide.getItem(row);
                    for (var index = startIndex; index < endIndex; index = (index + 1) | 0) {
                        result.setItem(columnIndices[System.Array.index(index, columnIndices)], result.getItem(columnIndices[System.Array.index(index, columnIndices)]) +(values[System.Array.index(index, values)] * rightSideValue));
                    }
                }
            },
            /**
             * Pointwise multiplies this matrix with another matrix and stores the result into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    other     The matrix to pointwise multiply with this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The matrix to store the result of the pointwise multiplication.
             * @return  {void}
             */
            DoPointwiseMultiply: function (other, result) {
                result.Clear();

                var rowPointers = this._storage.RowPointers;
                var columnIndices = this._storage.ColumnIndices;
                var values = this._storage.Values;

                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var endIndex = rowPointers[System.Array.index(((i + 1) | 0), rowPointers)];
                    for (var j = rowPointers[System.Array.index(i, rowPointers)]; j < endIndex; j = (j + 1) | 0) {
                        var resVal = values[System.Array.index(j, values)] * other.At(i, columnIndices[System.Array.index(j, columnIndices)]);
                        if (resVal !== 0.0) {
                            result.At$1(i, columnIndices[System.Array.index(j, columnIndices)], resVal);
                        }
                    }
                }
            },
            /**
             * Pointwise divide this matrix by another matrix and stores the result into the result matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    divisor    The matrix to pointwise divide this one by.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     The matrix to store the result of the pointwise division.
             * @return  {void}
             */
            DoPointwiseDivide: function (divisor, result) {
                result.Clear();

                var rowPointers = this._storage.RowPointers;
                var columnIndices = this._storage.ColumnIndices;
                var values = this._storage.Values;

                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var endIndex = rowPointers[System.Array.index(((i + 1) | 0), rowPointers)];
                    for (var j = rowPointers[System.Array.index(i, rowPointers)]; j < endIndex; j = (j + 1) | 0) {
                        if (values[System.Array.index(j, values)] !== 0.0) {
                            result.At$1(i, columnIndices[System.Array.index(j, columnIndices)], values[System.Array.index(j, values)] / divisor.At(i, columnIndices[System.Array.index(j, columnIndices)]));
                        }
                    }
                }
            },
            KroneckerProduct$1: function (other, result) {
                if (other == null) {
                    throw new System.ArgumentNullException.$ctor1("other");
                }

                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (result.RowCount !== (Bridge.Int.mul(this.RowCount, other.RowCount)) || result.ColumnCount !== (Bridge.Int.mul(this.ColumnCount, other.ColumnCount))) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$1(System.ArgumentOutOfRangeException, this, other, result);
                }

                var rowPointers = this._storage.RowPointers;
                var columnIndices = this._storage.ColumnIndices;
                var values = this._storage.Values;

                for (var i = 0; i < this.RowCount; i = (i + 1) | 0) {
                    var endIndex = rowPointers[System.Array.index(((i + 1) | 0), rowPointers)];
                    for (var j = rowPointers[System.Array.index(i, rowPointers)]; j < endIndex; j = (j + 1) | 0) {
                        if (values[System.Array.index(j, values)] !== 0.0) {
                            result.SetSubMatrix$1(Bridge.Int.mul(i, other.RowCount), other.RowCount, Bridge.Int.mul(columnIndices[System.Array.index(j, columnIndices)], other.ColumnCount), other.ColumnCount, MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).op_Multiply(values[System.Array.index(j, values)], other));
                        }
                    }
                }
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for the given divisor each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {number}                                     divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     Matrix to store the results in.
             * @return  {void}
             */
            DoModulus: function (divisor, result) {
                var sparseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                if (sparseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoModulus.call(this, divisor, result);
                    return;
                }

                if (!Bridge.referenceEquals(this, result)) {
                    this.CopyTo(result);
                }

                var resultStorage = sparseResult._storage;
                for (var index = 0; index < resultStorage.Values.length; index = (index + 1) | 0) {
                    resultStorage.Values[System.Array.index(index, resultStorage.Values)] = MathNet.Numerics.Euclid.Modulus(resultStorage.Values[System.Array.index(index, resultStorage.Values)], divisor);
                }
            },
            /**
             * Computes the remainder (% operator), where the result has the sign of the dividend,
             for the given divisor each element of the matrix.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @param   {number}                                     divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result     Matrix to store the results in.
             * @return  {void}
             */
            DoRemainder: function (divisor, result) {
                var sparseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.SparseMatrix);
                if (sparseResult == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Matrix.prototype.DoRemainder.call(this, divisor, result);
                    return;
                }

                if (!Bridge.referenceEquals(this, result)) {
                    this.CopyTo(result);
                }

                var resultStorage = sparseResult._storage;
                for (var index = 0; index < resultStorage.Values.length; index = (index + 1) | 0) {
                    resultStorage.Values[System.Array.index(index, resultStorage.Values)] %= divisor;
                }
            },
            /**
             * Evaluates whether this matrix is symmetric.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseMatrix
             * @return  {boolean}
             */
            IsSymmetric: function () {
                if (this.RowCount !== this.ColumnCount) {
                    return false;
                }

                var rowPointers = this._storage.RowPointers;
                var columnIndices = this._storage.ColumnIndices;
                var values = this._storage.Values;

                for (var row = 0; row < this.RowCount; row = (row + 1) | 0) {
                    var start = rowPointers[System.Array.index(row, rowPointers)];
                    var end = rowPointers[System.Array.index(((row + 1) | 0), rowPointers)];

                    if (start === end) {
                        continue;
                    }

                    for (var index = start; index < end; index = (index + 1) | 0) {
                        var column = columnIndices[System.Array.index(index, columnIndices)];
                        if (!values[System.Array.index(index, values)] === this.At(column, row)) {
                            return false;
                        }
                    }
                }

                return true;
            },
            ToTypeString: function () {
                return System.String.format("SparseMatrix {0}x{1}-Double {2:P2} Filled", Bridge.box(this.RowCount, System.Int32), Bridge.box(this.ColumnCount, System.Int32), Bridge.box(this.NonZerosCount / (this.RowCount * this.ColumnCount), System.Double, System.Double.format, System.Double.getHashCode));
            },
            LU: function () {
                throw new System.NotImplementedException.ctor();
            }
        }
    });

    /**
     * A vector with sparse storage, intended for very large vectors where most of the cells are zero.
     *
     * @public
     * @class MathNet.Numerics.LinearAlgebra.Double.SparseVector
     * @augments MathNet.Numerics.LinearAlgebra.Double.Vector
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.SparseVector", {
        inherits: [MathNet.Numerics.LinearAlgebra.Double.Vector],
        statics: {
            methods: {
                /**
                 * Create a new sparse vector as a copy of the given other vector.
                 This new vector will be independent from the other vector.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}               vector
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}
                 */
                OfVector: function (vector) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseVector.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(System.Double).OfVector(vector.Storage));
                },
                /**
                 * Create a new sparse vector as a copy of the given enumerable.
                 This new vector will be independent from the enumerable.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @param   {System.Collections.Generic.IEnumerable$1}              enumerable
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}
                 */
                OfEnumerable: function (enumerable) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseVector.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(System.Double).OfEnumerable(enumerable));
                },
                /**
                 * Create a new sparse vector as a copy of the given indexed enumerable.
                 Keys must be provided at most once, zero is assumed if a key is omitted.
                 This new vector will be independent from the enumerable.
                 A new memory block will be allocated for storing the vector.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @param   {number}                                                length        
                 * @param   {System.Collections.Generic.IEnumerable$1}              enumerable
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}
                 */
                OfIndexedEnumerable: function (length, enumerable) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseVector.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(System.Double).OfIndexedEnumerable(length, enumerable));
                },
                /**
                 * Create a new sparse vector and initialize each value using the provided value.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @param   {number}                                                length    
                 * @param   {number}                                                value
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}
                 */
                Create: function (length, value) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseVector.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(System.Double).OfValue(length, value));
                },
                /**
                 * Create a new sparse vector and initialize each value using the provided init function.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @param   {number}                                                length    
                 * @param   {System.Func}                                           init
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}
                 */
                Create$1: function (length, init) {
                    return new MathNet.Numerics.LinearAlgebra.Double.SparseVector.ctor(MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(System.Double).OfInit(length, init));
                }/**
                 * Adds two <strong>Vectors</strong> together and returns the results.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @throws If <b /> and <b /> are not the same size.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseVector}    leftSide     One of the vectors to add.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseVector}    rightSide    The other vector to add.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}                 The result of the addition.
                 */
                ,
                op_Addition: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Add$1(rightSide), MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                }/**
                 * Returns a <strong>Vector</strong> containing the negated values of <b />.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseVector}    rightSide    The vector to get the values from.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}                 A vector containing the negated values as <b />.
                 */
                ,
                op_UnaryNegation: function (rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    return Bridge.cast(rightSide.Negate(), MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                }/**
                 * Subtracts two <strong>Vectors</strong> and returns the results.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @throws If <b /> and <b /> are not the same size.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseVector}    leftSide     The vector to subtract from.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseVector}    rightSide    The vector to subtract.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}                 The result of the subtraction.
                 */
                ,
                op_Subtraction: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Subtract$1(rightSide), MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                }/**
                 * Multiplies a vector with a scalar.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseVector}    leftSide     The vector to scale.
                 * @param   {number}                                                rightSide    The scalar value.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}                 The result of the multiplication.
                 */
                ,
                op_Multiply: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Multiply(rightSide), MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                }/**
                 * Multiplies a vector with a scalar.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {number}                                                leftSide     The scalar value.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseVector}    rightSide    The vector to scale.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}                 The result of the multiplication.
                 */
                ,
                op_Multiply$1: function (leftSide, rightSide) {
                    if (rightSide == null) {
                        throw new System.ArgumentNullException.$ctor1("rightSide");
                    }

                    return Bridge.cast(rightSide.Multiply(leftSide), MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                }/**
                 * Computes the dot product between two <strong>Vectors</strong>.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @throws If <b /> and <b /> are not the same size.
                 * @throws If <b /> or <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseVector}    leftSide     The left row vector.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseVector}    rightSide    The right column vector.
                 * @return  {number}                                                             The dot product between the two vectors.
                 */
                ,
                op_Multiply$2: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return leftSide.DotProduct(rightSide);
                }/**
                 * Divides a vector with a scalar.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseVector}    leftSide     The vector to divide.
                 * @param   {number}                                                rightSide    The scalar value.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}                 The result of the division.
                 */
                ,
                op_Division: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Divide(rightSide), MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                }/**
                 * Computes the remainder (% operator), where the result has the sign of the dividend,
                 of each element of the vector of the given divisor.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
                 * @throws If <b /> is {@link ArgumentNullException}.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.SparseVector}    leftSide     The vector whose elements we want to compute the modulus of.
                 * @param   {number}                                                rightSide    The divisor to use,
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.SparseVector}                 The result of the calculation
                 */
                ,
                op_Modulus: function (leftSide, rightSide) {
                    if (leftSide == null) {
                        throw new System.ArgumentNullException.$ctor1("leftSide");
                    }

                    return Bridge.cast(leftSide.Remainder(rightSide), MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                }
            }
        },
        fields: {
            _storage: null
        },
        props: {
            /**
             * Gets the number of non zero elements in the vector.
             *
             * @instance
             * @public
             * @readonly
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @function NonZerosCount
             * @type number
             */
            NonZerosCount: {
                get: function () {
                    return this._storage.ValueCount;
                }
            }
        },
        ctors: {
            /**
             * Create a new sparse vector straight from an initialized vector storage instance.
             The storage is used directly without copying.
             Intended for advanced scenarios where you're working directly with
             storage for performance or interop reasons.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1}    storage
             * @return  {void}
             */
            ctor: function (storage) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Double.Vector.ctor.call(this, storage);
                this._storage = storage;
            },
            /**
             * Create a new sparse vector with the given length.
             All cells of the vector will be initialized to zero.
             Zero-length vectors are not supported.
             *
             * @instance
             * @public
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @throws If length is less than one.
             * @param   {number}    length
             * @return  {void}
             */
            $ctor1: function (length) {
                MathNet.Numerics.LinearAlgebra.Double.SparseVector.ctor.call(this, new (MathNet.Numerics.LinearAlgebra.Storage.SparseVectorStorage$1(System.Double))(length));
            }
        },
        methods: {
            /**
             * Adds a scalar to each element of the vector and stores the result in the result vector.
             Warning, the new 'sparse vector' with a non-zero scalar added to it will be a 100% filled
             sparse vector and very inefficient. Would be better to work with a dense vector instead.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @param   {number}                                     scalar    The scalar to add.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the addition.
             * @return  {void}
             */
            DoAdd: function (scalar, result) {
                if (scalar === 0.0) {
                    if (!Bridge.referenceEquals(this, result)) {
                        this.CopyTo(result);
                    }

                    return;
                }

                if (Bridge.referenceEquals(this, result)) {
                    var vnonZeroValues = System.Array.init(this.Count, 0, System.Double);
                    var vnonZeroIndices = System.Array.init(this.Count, 0, System.Int32);
                    for (var index = 0; index < this.Count; index = (index + 1) | 0) {
                        vnonZeroIndices[System.Array.index(index, vnonZeroIndices)] = index;
                        vnonZeroValues[System.Array.index(index, vnonZeroValues)] = scalar;
                    }

                    var indices = this._storage.Indices;
                    var values = this._storage.Values;
                    for (var j = 0; j < this._storage.ValueCount; j = (j + 1) | 0) {
                        vnonZeroValues[System.Array.index(indices[System.Array.index(j, indices)], vnonZeroValues)] = values[System.Array.index(j, values)] + scalar;
                    }

                    this._storage.Values = vnonZeroValues;
                    this._storage.Indices = vnonZeroIndices;
                    this._storage.ValueCount = this.Count;
                } else {
                    for (var index1 = 0; index1 < this.Count; index1 = (index1 + 1) | 0) {
                        result.At$1(index1, this.At(index1) + scalar);
                    }
                }
            },
            /**
             * Adds another vector to this vector and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector to add to this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the addition.
             * @return  {void}
             */
            DoAdd$1: function (other, result) {
                var $t, $t1, $t2, $t3, $t4, $t5;
                var otherSparse = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                if (otherSparse == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoAdd$1.call(this, other, result);
                    return;
                }

                var resultSparse = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                if (resultSparse == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoAdd$1.call(this, other, result);
                    return;
                }


                var otherStorage = otherSparse._storage;
                if (Bridge.referenceEquals(this, resultSparse)) {
                    var i = 0, j = 0;
                    while (j < otherStorage.ValueCount) {
                        if (i >= this._storage.ValueCount || ($t = this._storage.Indices)[System.Array.index(i, $t)] > otherStorage.Indices[System.Array.index(j, otherStorage.Indices)]) {
                            var otherValue = otherStorage.Values[System.Array.index(j, otherStorage.Values)];
                            if (otherValue !== 0.0) {
                                this._storage.InsertAtIndexUnchecked(Bridge.identity(i, ((i = (i + 1) | 0))), otherStorage.Indices[System.Array.index(j, otherStorage.Indices)], otherValue);
                            }
                            j = (j + 1) | 0;
                        } else if (($t1 = this._storage.Indices)[System.Array.index(i, $t1)] === otherStorage.Indices[System.Array.index(j, otherStorage.Indices)]) {
                            ($t2 = this._storage.Values)[System.Array.index(Bridge.identity(i, ((i = (i + 1) | 0))), $t2)] += otherStorage.Values[System.Array.index(Bridge.identity(j, ((j = (j + 1) | 0))), otherStorage.Values)];
                        } else {
                            i = (i + 1) | 0;
                        }
                    }
                } else {
                    result.clear();
                    var i1 = 0, j1 = 0, last = -1;
                    while (i1 < this._storage.ValueCount || j1 < otherStorage.ValueCount) {
                        if (j1 >= otherStorage.ValueCount || i1 < this._storage.ValueCount && ($t3 = this._storage.Indices)[System.Array.index(i1, $t3)] <= otherStorage.Indices[System.Array.index(j1, otherStorage.Indices)]) {
                            var next = ($t4 = this._storage.Indices)[System.Array.index(i1, $t4)];
                            if (next !== last) {
                                last = next;
                                result.At$1(next, ($t5 = this._storage.Values)[System.Array.index(i1, $t5)] + otherSparse.At(next));
                            }
                            i1 = (i1 + 1) | 0;
                        } else {
                            var next1 = otherStorage.Indices[System.Array.index(j1, otherStorage.Indices)];
                            if (next1 !== last) {
                                last = next1;
                                result.At$1(next1, this.At(next1) + otherStorage.Values[System.Array.index(j1, otherStorage.Values)]);
                            }
                            j1 = (j1 + 1) | 0;
                        }
                    }
                }
            },
            /**
             * Subtracts a scalar from each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @param   {number}                                     scalar    The scalar to subtract.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the subtraction.
             * @return  {void}
             */
            DoSubtract: function (scalar, result) {
                this.DoAdd(-scalar, result);
            },
            /**
             * Subtracts another vector to this vector and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector to subtract from this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the subtraction.
             * @return  {void}
             */
            DoSubtract$1: function (other, result) {
                var $t, $t1, $t2, $t3, $t4, $t5;
                if (Bridge.referenceEquals(this, other)) {
                    result.clear();
                    return;
                }

                var otherSparse = Bridge.as(other, MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                if (otherSparse == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoSubtract$1.call(this, other, result);
                    return;
                }

                var resultSparse = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                if (resultSparse == null) {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoSubtract$1.call(this, other, result);
                    return;
                }


                var otherStorage = otherSparse._storage;
                if (Bridge.referenceEquals(this, resultSparse)) {
                    var i = 0, j = 0;
                    while (j < otherStorage.ValueCount) {
                        if (i >= this._storage.ValueCount || ($t = this._storage.Indices)[System.Array.index(i, $t)] > otherStorage.Indices[System.Array.index(j, otherStorage.Indices)]) {
                            var otherValue = otherStorage.Values[System.Array.index(j, otherStorage.Values)];
                            if (otherValue !== 0.0) {
                                this._storage.InsertAtIndexUnchecked(Bridge.identity(i, ((i = (i + 1) | 0))), otherStorage.Indices[System.Array.index(j, otherStorage.Indices)], -otherValue);
                            }
                            j = (j + 1) | 0;
                        } else if (($t1 = this._storage.Indices)[System.Array.index(i, $t1)] === otherStorage.Indices[System.Array.index(j, otherStorage.Indices)]) {
                            ($t2 = this._storage.Values)[System.Array.index(Bridge.identity(i, ((i = (i + 1) | 0))), $t2)] -= otherStorage.Values[System.Array.index(Bridge.identity(j, ((j = (j + 1) | 0))), otherStorage.Values)];
                        } else {
                            i = (i + 1) | 0;
                        }
                    }
                } else {
                    result.clear();
                    var i1 = 0, j1 = 0, last = -1;
                    while (i1 < this._storage.ValueCount || j1 < otherStorage.ValueCount) {
                        if (j1 >= otherStorage.ValueCount || i1 < this._storage.ValueCount && ($t3 = this._storage.Indices)[System.Array.index(i1, $t3)] <= otherStorage.Indices[System.Array.index(j1, otherStorage.Indices)]) {
                            var next = ($t4 = this._storage.Indices)[System.Array.index(i1, $t4)];
                            if (next !== last) {
                                last = next;
                                result.At$1(next, ($t5 = this._storage.Values)[System.Array.index(i1, $t5)] - otherSparse.At(next));
                            }
                            i1 = (i1 + 1) | 0;
                        } else {
                            var next1 = otherStorage.Indices[System.Array.index(j1, otherStorage.Indices)];
                            if (next1 !== last) {
                                last = next1;
                                result.At$1(next1, this.At(next1) - otherStorage.Values[System.Array.index(j1, otherStorage.Values)]);
                            }
                            j1 = (j1 + 1) | 0;
                        }
                    }
                }
            },
            /**
             * Negates vector and saves result to <b />
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    Target vector
             * @return  {void}
             */
            DoNegate: function (result) {
                var $t, $t1;
                var sparseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                if (sparseResult == null) {
                    result.clear();
                    for (var index = 0; index < this._storage.ValueCount; index = (index + 1) | 0) {
                        result.At$1(($t = this._storage.Indices)[System.Array.index(index, $t)], -($t1 = this._storage.Values)[System.Array.index(index, $t1)]);
                    }
                    return;
                }

                if (!Bridge.referenceEquals(this, result)) {
                    sparseResult._storage.ValueCount = this._storage.ValueCount;
                    sparseResult._storage.Indices = System.Array.init(this._storage.ValueCount, 0, System.Int32);
                    var sourcebytes = System.Array.init(Bridge.Int.mul(this._storage.Indices.length, 8), 0, System.Byte);
                    sourcebytes = System.Linq.Enumerable.from(this._storage.Indices, System.Int32).selectMany(function (value) {
                            return System.BitConverter.getBytes$4(value);
                        }).ToArray(System.Byte);
                    System.Array.copy(this._storage.Indices, 0, sparseResult._storage.Indices, 0, this._storage.ValueCount);
                    sparseResult._storage.Values = System.Array.init(this._storage.ValueCount, 0, System.Double);
                    System.Array.copy(this._storage.Values, 0, sparseResult._storage.Values, 0, this._storage.ValueCount);
                }

                this.Map$1(function (x) {
                    return -x;
                }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
            },
            /**
             * Multiplies a scalar to each element of the vector and stores the result in the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @param   {number}                                     scalar    The scalar to multiply.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the multiplication.
             * @return  {void}
             */
            DoMultiply: function (scalar, result) {
                var $t, $t1;
                var sparseResult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.SparseVector);
                if (sparseResult == null) {
                    result.clear();
                    for (var index = 0; index < this._storage.ValueCount; index = (index + 1) | 0) {
                        result.At$1(($t = this._storage.Indices)[System.Array.index(index, $t)], scalar * ($t1 = this._storage.Values)[System.Array.index(index, $t1)]);
                    }
                } else {
                    if (!Bridge.referenceEquals(this, result)) {
                        sparseResult._storage.ValueCount = this._storage.ValueCount;
                        sparseResult._storage.Indices = System.Array.init(this._storage.ValueCount, 0, System.Int32);

                        System.Array.copy(this._storage.Indices, 0, sparseResult._storage.Indices, 0, this._storage.ValueCount);
                        sparseResult._storage.Values = System.Array.init(this._storage.ValueCount, 0, System.Double);
                        System.Array.copy(this._storage.Values, 0, sparseResult._storage.Values, 0, this._storage.ValueCount);
                    }

                    this.Map$1(function (x) {
                        return x * scalar;
                    }, result, MathNet.Numerics.LinearAlgebra.Zeros.AllowSkip);
                }
            },
            /**
             * Computes the dot product between this vector and another vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other    The other vector.
             * @return  {number}                                              The sum of a[i]*b[i] for all i.
             */
            DoDotProduct: function (other) {
                var $t, $t1, $t2, $t3;
                var result = 0.0;
                if (Bridge.referenceEquals(this, other)) {
                    for (var i = 0; i < this._storage.ValueCount; i = (i + 1) | 0) {
                        result += ($t = this._storage.Values)[System.Array.index(i, $t)] * ($t1 = this._storage.Values)[System.Array.index(i, $t1)];
                    }
                } else {
                    for (var i1 = 0; i1 < this._storage.ValueCount; i1 = (i1 + 1) | 0) {
                        result += ($t2 = this._storage.Values)[System.Array.index(i1, $t2)] * other.At(($t3 = this._storage.Indices)[System.Array.index(i1, $t3)]);
                    }
                }
                return result;
            },
            /**
             * Computes the canonical modulus, where the result has the sign of the divisor,
             for each element of the vector for the given divisor.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @param   {number}                                     divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     A vector to store the results in.
             * @return  {void}
             */
            DoModulus: function (divisor, result) {
                var $t, $t1, $t2, $t3;
                if (Bridge.referenceEquals(this, result)) {
                    for (var index = 0; index < this._storage.ValueCount; index = (index + 1) | 0) {
                        ($t = this._storage.Values)[System.Array.index(index, $t)] = MathNet.Numerics.Euclid.Modulus(($t1 = this._storage.Values)[System.Array.index(index, $t1)], divisor);
                    }
                } else {
                    result.clear();
                    for (var index1 = 0; index1 < this._storage.ValueCount; index1 = (index1 + 1) | 0) {
                        result.At$1(($t2 = this._storage.Indices)[System.Array.index(index1, $t2)], MathNet.Numerics.Euclid.Modulus(($t3 = this._storage.Values)[System.Array.index(index1, $t3)], divisor));
                    }
                }
            },
            /**
             * Computes the remainder (% operator), where the result has the sign of the dividend,
             for each element of the vector for the given divisor.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @param   {number}                                     divisor    The scalar denominator to use.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result     A vector to store the results in.
             * @return  {void}
             */
            DoRemainder: function (divisor, result) {
                var $t, $t1, $t2;
                if (Bridge.referenceEquals(this, result)) {
                    for (var index = 0; index < this._storage.ValueCount; index = (index + 1) | 0) {
                        ($t = this._storage.Values)[System.Array.index(index, $t)] %= divisor;
                    }
                } else {
                    result.clear();
                    for (var index1 = 0; index1 < this._storage.ValueCount; index1 = (index1 + 1) | 0) {
                        result.At$1(($t1 = this._storage.Indices)[System.Array.index(index1, $t1)], ($t2 = this._storage.Values)[System.Array.index(index1, $t2)] % divisor);
                    }
                }
            },
            /**
             * Returns the index of the absolute minimum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @return  {number}        The index of absolute minimum element.
             */
            AbsoluteMinimumIndex: function () {
                var $t, $t1, $t2;
                if (this._storage.ValueCount === 0) {
                    return 0;
                }

                var index = 0;
                var min = Math.abs(($t = this._storage.Values)[System.Array.index(index, $t)]);
                for (var i = 1; i < this._storage.ValueCount; i = (i + 1) | 0) {
                    var test = Math.abs(($t1 = this._storage.Values)[System.Array.index(i, $t1)]);
                    if (test < min) {
                        index = i;
                        min = test;
                    }
                }

                return ($t2 = this._storage.Indices)[System.Array.index(index, $t2)];
            },
            /**
             * Returns the index of the absolute maximum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @return  {number}        The index of absolute maximum element.
             */
            AbsoluteMaximumIndex: function () {
                var $t, $t1, $t2;
                if (this._storage.ValueCount === 0) {
                    return 0;
                }

                var index = 0;
                var max = Math.abs(($t = this._storage.Values)[System.Array.index(index, $t)]);
                for (var i = 1; i < this._storage.ValueCount; i = (i + 1) | 0) {
                    var test = Math.abs(($t1 = this._storage.Values)[System.Array.index(i, $t1)]);
                    if (test > max) {
                        index = i;
                        max = test;
                    }
                }

                return ($t2 = this._storage.Indices)[System.Array.index(index, $t2)];
            },
            /**
             * Returns the index of the maximum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @return  {number}        The index of maximum element.
             */
            MaximumIndex: function () {
                var $t, $t1, $t2, $t3;
                if (this._storage.ValueCount === 0) {
                    return 0;
                }

                var index = 0;
                var max = ($t = this._storage.Values)[System.Array.index(0, $t)];
                for (var i = 1; i < this._storage.ValueCount; i = (i + 1) | 0) {
                    if (max < ($t1 = this._storage.Values)[System.Array.index(i, $t1)]) {
                        index = i;
                        max = ($t2 = this._storage.Values)[System.Array.index(i, $t2)];
                    }
                }

                return ($t3 = this._storage.Indices)[System.Array.index(index, $t3)];
            },
            /**
             * Returns the index of the minimum element.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @return  {number}        The index of minimum element.
             */
            MinimumIndex: function () {
                var $t, $t1, $t2, $t3;
                if (this._storage.ValueCount === 0) {
                    return 0;
                }

                var index = 0;
                var min = ($t = this._storage.Values)[System.Array.index(0, $t)];
                for (var i = 1; i < this._storage.ValueCount; i = (i + 1) | 0) {
                    if (min > ($t1 = this._storage.Values)[System.Array.index(i, $t1)]) {
                        index = i;
                        min = ($t2 = this._storage.Values)[System.Array.index(i, $t2)];
                    }
                }

                return ($t3 = this._storage.Indices)[System.Array.index(index, $t3)];
            },
            /**
             * Computes the sum of the vector's elements.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @return  {number}        The sum of the vector's elements.
             */
            Sum: function () {
                var $t;
                var result = 0;
                for (var i = 0; i < this._storage.ValueCount; i = (i + 1) | 0) {
                    result += ($t = this._storage.Values)[System.Array.index(i, $t)];
                }
                return result;
            },
            /**
             * Calculates the L1 norm of the vector, also known as Manhattan norm.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @return  {number}        The sum of the absolute values.
             */
            L1Norm: function () {
                var $t;
                var result = 0.0;
                for (var i = 0; i < this._storage.ValueCount; i = (i + 1) | 0) {
                    result += Math.abs(($t = this._storage.Values)[System.Array.index(i, $t)]);
                }
                return result;
            },
            /**
             * Calculates the infinity norm of the vector.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @return  {number}        The maximum absolute value.
             */
            InfinityNorm: function () {
                var max = 0.0;
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (Math.abs(this.At(i)) > max) {
                        max = this.At(i);
                    }
                }
                return max;
            },
            /**
             * Computes the p-Norm.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @param   {number}    p    The p value.
             * @return  {number}         Scalar <pre><code>ret = ( â|this[i]|^p )^(1/p)</code></pre>
             */
            Norm: function (p) {
                var $t;
                if (p < 0.0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("p");
                }

                if (this._storage.ValueCount === 0) {
                    return 0.0;
                }

                if (p === 1.0) {
                    return this.L1Norm();
                }
                if (p === 2.0) {
                    return this.L2Norm();
                }
                if ((p === Number.POSITIVE_INFINITY)) {
                    return this.InfinityNorm();
                }

                var sum = 0.0;
                for (var index = 0; index < this._storage.ValueCount; index = (index + 1) | 0) {
                    sum += Math.pow(Math.abs(($t = this._storage.Values)[System.Array.index(index, $t)]), p);
                }
                return Math.pow(sum, 1.0 / p);
            },
            /**
             * Pointwise multiplies this vector with another vector and stores the result into the result vector.
             *
             * @instance
             * @protected
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    other     The vector to pointwise multiply with this one.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The vector to store the result of the pointwise multiplication.
             * @return  {void}
             */
            DoPointwiseMultiply: function (other, result) {
                var $t, $t1;
                if (Bridge.referenceEquals(this, other) && Bridge.referenceEquals(this, result)) {
                    for (var i = 0; i < this._storage.ValueCount; i = (i + 1) | 0) {
                        ($t = this._storage.Values)[System.Array.index(i, $t)] *= ($t1 = this._storage.Values)[System.Array.index(i, $t1)];
                    }
                } else {
                    MathNet.Numerics.LinearAlgebra.Double.Vector.prototype.DoPointwiseMultiply.call(this, other, result);
                }
            },
            /**
             * Creates a double sparse vector based on a string. The string can be in the following formats (without the
             quotes): 'n', 'n,n,..', '(n,n,..)', '[n,n,...]', where n is a double.
             * Converts the string representation of a real sparse vector to double-precision sparse vector equivalent.
             A return value indicates whether the conversion succeeded or failed.
             * Converts the string representation of a real sparse vector to double-precision sparse vector equivalent.
             A return value indicates whether the conversion succeeded or failed.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @memberof MathNet.Numerics.LinearAlgebra.Double.SparseVector
             * @return  {string}        If the conversion succeeds, the result will contain a complex number equivalent to value.
             Otherwise the result will be <pre><code>null</code></pre>.
             */
            ToTypeString: function () {
                return System.String.format("SparseVector {0}-Double {1:P2} Filled", Bridge.box(this.Count, System.Int32), Bridge.box(this.NonZerosCount / this.Count, System.Double, System.Double.format, System.Double.getHashCode));
            }
        }
    });

    /**
     * <p>A class which encapsulates the functionality of an LU factorization.</p><p>For a matrix A, the LU factorization is a pair of lower triangular matrix L and
     upper triangular matrix U so that A = L*U.</p>
     *
     * @class MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU
     * @augments MathNet.Numerics.LinearAlgebra.Double.Factorization.LU
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU", {
        inherits: [MathNet.Numerics.LinearAlgebra.Double.Factorization.LU],
        statics: {
            methods: {
                /**
                 * Initializes a new instance of the {@link } class. This object will compute the
                 LU factorization when the constructor is called and cache it's factorization.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU
                 * @throws If <b /> is <pre><code>null</code></pre>.
                 * @throws If <b /> is not a square matrix.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}              matrix    The matrix to factor.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU}
                 */
                Create: function (matrix) {
                    if (matrix == null) {
                        throw new System.ArgumentNullException.$ctor1("matrix");
                    }

                    if (matrix.RowCount !== matrix.ColumnCount) {
                        throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSquare");
                    }

                    var pivots = System.Array.init(matrix.RowCount, 0, System.Int32);

                    var factors = Bridge.cast(matrix.Clone(), MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);

                    return new MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU(factors, pivots);
                }
            }
        },
        alias: [
            "Solve$1", "MathNet$Numerics$LinearAlgebra$Factorization$ISolver$1$System$Double$Solve$2",
            "Solve$3", "MathNet$Numerics$LinearAlgebra$Factorization$ISolver$1$System$Double$Solve$3"
        ],
        ctors: {
            ctor: function (factors, pivots) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Double.Factorization.LU.ctor.call(this, factors, pivots);
            }
        },
        methods: {
            /**
             * Solves a system of linear equations, <pre><code>AX = B</code></pre>, with A LU factorized.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    input     The right hand side {@link }, <pre><code>B</code></pre>.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The left hand side {@link }, <pre><code>X</code></pre>.
             * @return  {void}
             */
            Solve$1: function (input, result) {
                if (input == null) {
                    throw new System.ArgumentNullException.$ctor1("input");
                }

                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (result.RowCount !== input.RowCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSameRowDimension");
                }

                if (result.ColumnCount !== input.ColumnCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSameColumnDimension");
                }

                if (input.RowCount !== this.Factors.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$2(System.ArgumentException, input, this.Factors);
                }

                var dinput = Bridge.as(input, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (dinput == null) {
                    throw new System.NotSupportedException.$ctor1("Can only do LU factorization for dense matrices at the moment.");
                }

                var dresult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (dresult == null) {
                    throw new System.NotSupportedException.$ctor1("Can only do LU factorization for dense matrices at the moment.");
                }

                System.Array.copy(dinput.Values, 0, dresult.Values, 0, dinput.Values.length);

                var dfactors = Bridge.cast(this.Factors, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
            },
            /**
             * Solves a system of linear equations, <pre><code>Ax = b</code></pre>, with A LU factorized.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    input     The right hand side vector, <pre><code>b</code></pre>.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The left hand side {@link }, <pre><code>x</code></pre>.
             * @return  {void}
             */
            Solve$3: function (input, result) {
                if (input == null) {
                    throw new System.ArgumentNullException.$ctor1("input");
                }

                if (result == null) {
                    throw new System.ArgumentNullException.$ctor1("result");
                }

                if (input.Count !== result.Count) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentVectorsSameLength");
                }

                if (input.Count !== this.Factors.RowCount) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$5(System.ArgumentException, input, this.Factors);
                }

                var dinput = Bridge.as(input, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                if (dinput == null) {
                    throw new System.NotSupportedException.$ctor1("Can only do LU factorization for dense vectors at the moment.");
                }

                var dresult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                if (dresult == null) {
                    throw new System.NotSupportedException.$ctor1("Can only do LU factorization for dense vectors at the moment.");
                }

                System.Array.copy(dinput.Values, 0, dresult.Values, 0, dinput.Values.length);

                var dfactors = Bridge.cast(this.Factors, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
            },
            /**
             * Returns the inverse of this matrix. The inverse is calculated using LU decomposition.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseLU
             * @return  {MathNet.Numerics.LinearAlgebra.Matrix$1}        The inverse of this matrix.
             */
            Inverse: function () {
                var result = Bridge.cast(this.Factors.Clone(), MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                return result;
            }
        }
    });

    /**
     * <p>A class which encapsulates the functionality of the singular value decomposition (SVD) for {@link }.</p><p>Suppose M is an m-by-n matrix whose entries are real numbers.
     Then there exists a factorization of the form M = UÎ£VT where:
     - U is an m-by-m unitary matrix;
     - Î£ is m-by-n diagonal matrix with nonnegative real numbers on the diagonal;
     - VT denotes transpose of V, an n-by-n unitary matrix;
     Such a factorization is called a singular-value decomposition of M. A common convention is to order the diagonal
     entries Î£(i,i) in descending order. In this case, the diagonal matrix Î£ is uniquely determined
     by M (though the matrices U and V are not). The diagonal entries of Î£ are known as the singular values of M.</p>
     *
     * @class MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseSvd
     * @augments MathNet.Numerics.LinearAlgebra.Double.Factorization.Svd
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseSvd", {
        inherits: [MathNet.Numerics.LinearAlgebra.Double.Factorization.Svd],
        statics: {
            methods: {
                /**
                 * Initializes a new instance of the {@link } class. This object will compute the
                 the singular value decomposition when the constructor is called and cache it's decomposition.
                 *
                 * @static
                 * @public
                 * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseSvd
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseSvd
                 * @throws If <b /> is <pre><code>null</code></pre>.
                 * @throws If SVD algorithm failed to converge with matrix <b />.
                 * @param   {MathNet.Numerics.LinearAlgebra.Double.DenseMatrix}               matrix            The matrix to factor.
                 * @param   {boolean}                                                         computeVectors    Compute the singular U and VT vectors or not.
                 * @return  {MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseSvd}
                 */
                Create: function (matrix, computeVectors) {
                    var nm = Math.min(matrix.RowCount, matrix.ColumnCount);
                    var s = new MathNet.Numerics.LinearAlgebra.Double.DenseVector.$ctor2(nm);
                    var u = new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.$ctor1(matrix.RowCount);
                    var vt = new MathNet.Numerics.LinearAlgebra.Double.DenseMatrix.$ctor1(matrix.ColumnCount);
                    var svder = new MathNetNumerics.ManagedLinearAlgebraProvider();
                    svder.SingularValueDecomposition(computeVectors, Bridge.cast(matrix.Clone(), MathNet.Numerics.LinearAlgebra.Double.DenseMatrix).Values, matrix.RowCount, matrix.ColumnCount, s.Values, u.Values, vt.Values);

                    return new MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseSvd(s, u, vt, computeVectors);
                }
            }
        },
        alias: [
            "Solve$1", "MathNet$Numerics$LinearAlgebra$Factorization$ISolver$1$System$Double$Solve$2",
            "Solve$3", "MathNet$Numerics$LinearAlgebra$Factorization$ISolver$1$System$Double$Solve$3"
        ],
        ctors: {
            ctor: function (s, u, vt, vectorsComputed) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Double.Factorization.Svd.ctor.call(this, s, u, vt, vectorsComputed);
            }
        },
        methods: {
            /**
             * Solves a system of linear equations, <b>AX = B</b>, with A SVD factorized.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseSvd
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseSvd
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    input     The right hand side {@link }, <b>B</b>.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The left hand side {@link }, <b>X</b>.
             * @return  {void}
             */
            Solve$1: function (input, result) {
                if (!this.VectorsComputed) {
                    throw new System.InvalidOperationException.$ctor1("Resources.SingularVectorsNotComputed");
                }

                if (input.ColumnCount !== result.ColumnCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSameColumnDimension");
                }

                if (this.U.RowCount !== input.RowCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSameRowDimension");
                }

                if (this.VT.ColumnCount !== result.RowCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSameColumnDimension");
                }

                var dinput = Bridge.as(input, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (dinput == null) {
                    throw new System.NotSupportedException.$ctor1("Can only do SVD factorization for dense matrices at the moment.");
                }

                var dresult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix);
                if (dresult == null) {
                    throw new System.NotSupportedException.$ctor1("Can only do SVD factorization for dense matrices at the moment.");
                }
                var svder = new MathNetNumerics.ManagedLinearAlgebraProvider();
                svder.SvdSolveFactored(this.U.RowCount, this.VT.ColumnCount, Bridge.cast(this.S, MathNet.Numerics.LinearAlgebra.Double.DenseVector).Values, Bridge.cast(this.U, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix).Values, Bridge.cast(this.VT, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix).Values, dinput.Values, input.ColumnCount, dresult.Values);
            },
            /**
             * Solves a system of linear equations, <b>Ax = b</b>, with A SVD factorized.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseSvd
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.DenseSvd
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    input     The right hand side vector, <b>b</b>.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The left hand side {@link }, <b>x</b>.
             * @return  {void}
             */
            Solve$3: function (input, result) {
                if (!this.VectorsComputed) {
                    throw new System.InvalidOperationException.$ctor1("Resources.SingularVectorsNotComputed");
                }

                if (this.U.RowCount !== input.Count) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentVectorsSameLength");
                }

                if (this.VT.ColumnCount !== result.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$4(System.ArgumentException, this.VT, result);
                }

                var dinput = Bridge.as(input, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                if (dinput == null) {
                    throw new System.NotSupportedException.$ctor1("Can only do SVD factorization for dense vectors at the moment.");
                }

                var dresult = Bridge.as(result, MathNet.Numerics.LinearAlgebra.Double.DenseVector);
                if (dresult == null) {
                    throw new System.NotSupportedException.$ctor1("Can only do SVD factorization for dense vectors at the moment.");
                }
                var svder = new MathNetNumerics.ManagedLinearAlgebraProvider();
                svder.SvdSolveFactored(this.U.RowCount, this.VT.ColumnCount, Bridge.cast(this.S, MathNet.Numerics.LinearAlgebra.Double.DenseVector).Values, Bridge.cast(this.U, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix).Values, Bridge.cast(this.VT, MathNet.Numerics.LinearAlgebra.Double.DenseMatrix).Values, dinput.Values, 1, dresult.Values);
            }
        }
    });

    /**
     * <p>A class which encapsulates the functionality of the singular value decomposition (SVD) for {@link }.</p><p>Suppose M is an m-by-n matrix whose entries are real numbers.
     Then there exists a factorization of the form M = UÎ£VT where:
     - U is an m-by-m unitary matrix;
     - Î£ is m-by-n diagonal matrix with nonnegative real numbers on the diagonal;
     - VT denotes transpose of V, an n-by-n unitary matrix;
     Such a factorization is called a singular-value decomposition of M. A common convention is to order the diagonal
     entries Î£(i,i) in descending order. In this case, the diagonal matrix Î£ is uniquely determined
     by M (though the matrices U and V are not). The diagonal entries of Î£ are known as the singular values of M.</p>
     *
     * @class MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
     * @augments MathNet.Numerics.LinearAlgebra.Double.Factorization.Svd
     */
    Bridge.define("MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd", {
        inherits: [MathNet.Numerics.LinearAlgebra.Double.Factorization.Svd],
        statics: {
            fields: {
                /**
                 * Initializes a new instance of the {@link } class. This object will compute the
                 the singular value decomposition when the constructor is called and cache it's decomposition.
                 *
                 * @static
                 * @private
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @type MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.VectorBuilder$1
                 * @throws If <b /> is <pre><code>null</code></pre>.
                 * @throws 
                 */
                v_builder: null,
                m_builder: null
            },
            ctors: {
                init: function () {
                    this.v_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(System.Double).Vector;
                    this.m_builder = MathNet.Numerics.LinearAlgebra.Double.MathNet.Numerics.LinearAlgebra.BuilderInstance$1(System.Double).Matrix;
                }
            },
            methods: {
                Create: function (matrix, computeVectors) {
                    var AlmostEquals = null;
                    var nm = Math.min(((matrix.RowCount + 1) | 0), matrix.ColumnCount);
                    var matrixCopy = matrix.Clone();

                    var s = MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.v_builder.SameAs$3(System.Double, matrixCopy, nm);
                    var u = MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.m_builder.SameAs$4(System.Double, matrixCopy, matrixCopy.RowCount, matrixCopy.RowCount, true);
                    var vt = MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.m_builder.SameAs$4(System.Double, matrixCopy, matrixCopy.ColumnCount, matrixCopy.ColumnCount, true);

                    var maxiter = 1000;
                    var e = System.Array.init(matrixCopy.ColumnCount, 0, System.Double);
                    var work = System.Array.init(matrixCopy.RowCount, 0, System.Double);
                    var i, j;
                    var l, lp1;
                    var t;

                    var ncu = matrixCopy.RowCount;

                    var nct = Math.min(((matrixCopy.RowCount - 1) | 0), matrixCopy.ColumnCount);
                    var nrt = Math.max(0, Math.min(((matrixCopy.ColumnCount - 2) | 0), matrixCopy.RowCount));
                    var lu = Math.max(nct, nrt);
                    for (l = 0; l < lu; l = (l + 1) | 0) {
                        lp1 = (l + 1) | 0;
                        if (l < nct) {
                            var xnorm = MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Dnrm2Column(matrixCopy, matrixCopy.RowCount, l, l);
                            s.setItem(l, xnorm);
                            if (s.getItem(l) !== 0.0) {
                                if (matrixCopy.At(l, l) !== 0.0) {
                                    s.setItem(l, MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Dsign(s.getItem(l), matrixCopy.At(l, l)));
                                }

                                MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.DscalColumn(matrixCopy, matrixCopy.RowCount, l, l, 1.0 / s.getItem(l));
                                matrixCopy.At$1(l, l, (1.0 + matrixCopy.At(l, l)));
                            }

                            s.setItem(l, -s.getItem(l));
                        }

                        for (j = lp1; j < matrixCopy.ColumnCount; j = (j + 1) | 0) {
                            if (l < nct) {
                                if (s.getItem(l) !== 0.0) {
                                    t = -MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Ddot(matrixCopy, matrixCopy.RowCount, l, j, l) / matrixCopy.At(l, l);
                                    for (var ii = l; ii < matrixCopy.RowCount; ii = (ii + 1) | 0) {
                                        matrixCopy.At$1(ii, j, matrixCopy.At(ii, j) + (t * matrixCopy.At(ii, l)));
                                    }
                                }
                            }

                            e[System.Array.index(j, e)] = matrixCopy.At(l, j);
                        }

                        if (computeVectors && l < nct) {
                            for (i = l; i < matrixCopy.RowCount; i = (i + 1) | 0) {
                                u.At$1(i, l, matrixCopy.At(i, l));
                            }
                        }

                        if (l >= nrt) {
                            continue;
                        }

                        var enorm = MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Dnrm2Vector(e, lp1);
                        e[System.Array.index(l, e)] = enorm;
                        if (e[System.Array.index(l, e)] !== 0.0) {
                            if (e[System.Array.index(lp1, e)] !== 0.0) {
                                e[System.Array.index(l, e)] = MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Dsign(e[System.Array.index(l, e)], e[System.Array.index(lp1, e)]);
                            }

                            MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.DscalVector(e, lp1, 1.0 / e[System.Array.index(l, e)]);
                            e[System.Array.index(lp1, e)] = 1.0 + e[System.Array.index(lp1, e)];
                        }

                        e[System.Array.index(l, e)] = -e[System.Array.index(l, e)];
                        if (lp1 < matrixCopy.RowCount && e[System.Array.index(l, e)] !== 0.0) {
                            for (i = lp1; i < matrixCopy.RowCount; i = (i + 1) | 0) {
                                work[System.Array.index(i, work)] = 0.0;
                            }

                            for (j = lp1; j < matrixCopy.ColumnCount; j = (j + 1) | 0) {
                                for (var ii1 = lp1; ii1 < matrixCopy.RowCount; ii1 = (ii1 + 1) | 0) {
                                    work[System.Array.index(ii1, work)] += e[System.Array.index(j, e)] * matrixCopy.At(ii1, j);
                                }
                            }

                            for (j = lp1; j < matrixCopy.ColumnCount; j = (j + 1) | 0) {
                                var ww = -e[System.Array.index(j, e)] / e[System.Array.index(lp1, e)];
                                for (var ii2 = lp1; ii2 < matrixCopy.RowCount; ii2 = (ii2 + 1) | 0) {
                                    matrixCopy.At$1(ii2, j, matrixCopy.At(ii2, j) + (ww * work[System.Array.index(ii2, work)]));
                                }
                            }
                        }

                        if (computeVectors) {
                            for (i = lp1; i < matrixCopy.ColumnCount; i = (i + 1) | 0) {
                                vt.At$1(i, l, e[System.Array.index(i, e)]);
                            }
                        }
                    }
                    var m = Math.min(matrixCopy.ColumnCount, ((matrixCopy.RowCount + 1) | 0));
                    var nctp1 = (nct + 1) | 0;
                    var nrtp1 = (nrt + 1) | 0;
                    if (nct < matrixCopy.ColumnCount) {
                        s.setItem(((nctp1 - 1) | 0), matrixCopy.At((((nctp1 - 1) | 0)), (((nctp1 - 1) | 0))));
                    }

                    if (matrixCopy.RowCount < m) {
                        s.setItem(((m - 1) | 0), 0.0);
                    }

                    if (nrtp1 < m) {
                        e[System.Array.index(((nrtp1 - 1) | 0), e)] = matrixCopy.At((((nrtp1 - 1) | 0)), (((m - 1) | 0)));
                    }

                    e[System.Array.index(((m - 1) | 0), e)] = 0.0;

                    if (computeVectors) {
                        for (j = (nctp1 - 1) | 0; j < ncu; j = (j + 1) | 0) {
                            for (i = 0; i < matrixCopy.RowCount; i = (i + 1) | 0) {
                                u.At$1(i, j, 0.0);
                            }

                            u.At$1(j, j, 1.0);
                        }

                        for (l = (nct - 1) | 0; l >= 0; l = (l - 1) | 0) {
                            if (s.getItem(l) !== 0.0) {
                                for (j = (l + 1) | 0; j < ncu; j = (j + 1) | 0) {
                                    t = -MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Ddot(u, matrixCopy.RowCount, l, j, l) / u.At(l, l);
                                    for (var ii3 = l; ii3 < matrixCopy.RowCount; ii3 = (ii3 + 1) | 0) {
                                        u.At$1(ii3, j, u.At(ii3, j) + (t * u.At(ii3, l)));
                                    }
                                }

                                MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.DscalColumn(u, matrixCopy.RowCount, l, l, -1.0);
                                u.At$1(l, l, 1.0 + u.At(l, l));
                                for (i = 0; i < l; i = (i + 1) | 0) {
                                    u.At$1(i, l, 0.0);
                                }
                            } else {
                                for (i = 0; i < matrixCopy.RowCount; i = (i + 1) | 0) {
                                    u.At$1(i, l, 0.0);
                                }

                                u.At$1(l, l, 1.0);
                            }
                        }
                    }

                    if (computeVectors) {
                        for (l = (matrixCopy.ColumnCount - 1) | 0; l >= 0; l = (l - 1) | 0) {
                            lp1 = (l + 1) | 0;
                            if (l < nrt) {
                                if (e[System.Array.index(l, e)] !== 0.0) {
                                    for (j = lp1; j < matrixCopy.ColumnCount; j = (j + 1) | 0) {
                                        t = -MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Ddot(vt, matrixCopy.ColumnCount, l, j, lp1) / vt.At(lp1, l);
                                        for (var ii4 = l; ii4 < matrixCopy.ColumnCount; ii4 = (ii4 + 1) | 0) {
                                            vt.At$1(ii4, j, vt.At(ii4, j) + (t * vt.At(ii4, l)));
                                        }
                                    }
                                }
                            }

                            for (i = 0; i < matrixCopy.ColumnCount; i = (i + 1) | 0) {
                                vt.At$1(i, l, 0.0);
                            }

                            vt.At$1(l, l, 1.0);
                        }
                    }

                    for (i = 0; i < m; i = (i + 1) | 0) {
                        var r;
                        if (s.getItem(i) !== 0.0) {
                            t = s.getItem(i);
                            r = s.getItem(i) / t;
                            s.setItem(i, t);
                            if (i < ((m - 1) | 0)) {
                                e[System.Array.index(i, e)] = e[System.Array.index(i, e)] / r;
                            }

                            if (computeVectors) {
                                MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.DscalColumn(u, matrixCopy.RowCount, i, 0, r);
                            }
                        }

                        if (i === ((m - 1) | 0)) {
                            break;
                        }

                        if (e[System.Array.index(i, e)] !== 0.0) {
                            t = e[System.Array.index(i, e)];
                            r = t / e[System.Array.index(i, e)];
                            e[System.Array.index(i, e)] = t;
                            s.setItem(((i + 1) | 0), s.getItem(((i + 1) | 0)) * r);
                            if (computeVectors) {
                                MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.DscalColumn(vt, matrixCopy.ColumnCount, ((i + 1) | 0), 0, r);
                            }
                        }
                    }

                    var mn = m;
                    var iter = 0;

                    AlmostEquals = function (val1, val2) {
                        if (Math.abs(val1 - val2) < 1E-08) {
                            return true;
                        }
                        return false;
                    };

                    while (m > 0) {
                        if (iter >= maxiter) {
                            throw new System.ArgumentException.$ctor1("NonConvergenceException()");
                        }

                        var ztest;
                        var test;
                        for (l = (m - 2) | 0; l >= 0; l = (l - 1) | 0) {
                            test = Math.abs(s.getItem(l)) + Math.abs(s.getItem(((l + 1) | 0)));
                            ztest = test + Math.abs(e[System.Array.index(l, e)]);
                            if (AlmostEquals(test, ztest)) {
                                e[System.Array.index(l, e)] = 0.0;
                                break;
                            }
                        }

                        var kase;
                        if (l === ((m - 2) | 0)) {
                            kase = 4;
                        } else {
                            var ls;
                            for (ls = (m - 1) | 0; ls > l; ls = (ls - 1) | 0) {
                                test = 0.0;
                                if (ls !== ((m - 1) | 0)) {
                                    test = test + Math.abs(e[System.Array.index(ls, e)]);
                                }

                                if (ls !== ((l + 1) | 0)) {
                                    test = test + Math.abs(e[System.Array.index(((ls - 1) | 0), e)]);
                                }

                                ztest = test + Math.abs(s.getItem(ls));
                                if (AlmostEquals(test, ztest)) {
                                    s.setItem(ls, 0.0);
                                    break;
                                }
                            }

                            if (ls === l) {
                                kase = 3;
                            } else if (ls === ((m - 1) | 0)) {
                                kase = 1;
                            } else {
                                kase = 2;
                                l = ls;
                            }
                        }

                        l = (l + 1) | 0;

                        var k;
                        var f = { };
                        var sn = { };
                        var cs = { };
                        var t1 = { };
                        switch (kase) {
                            case 1: 
                                f.v = e[System.Array.index(((m - 2) | 0), e)];
                                e[System.Array.index(((m - 2) | 0), e)] = 0.0;
                                for (var kk = l; kk < ((m - 1) | 0); kk = (kk + 1) | 0) {
                                    k = (((((m - 2) | 0) - kk) | 0) + l) | 0;
                                    t1.v = s.getItem(k);
                                    MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Drotg(t1, f, cs, sn);
                                    s.setItem(k, t1.v);
                                    if (k !== l) {
                                        f.v = -sn.v * e[System.Array.index(((k - 1) | 0), e)];
                                        e[System.Array.index(((k - 1) | 0), e)] = cs.v * e[System.Array.index(((k - 1) | 0), e)];
                                    }

                                    if (computeVectors) {
                                        MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Drot(vt, matrixCopy.ColumnCount, k, ((m - 1) | 0), cs.v, sn.v);
                                    }
                                }
                                break;
                            case 2: 
                                f.v = e[System.Array.index(((l - 1) | 0), e)];
                                e[System.Array.index(((l - 1) | 0), e)] = 0.0;
                                for (k = l; k < m; k = (k + 1) | 0) {
                                    t1.v = s.getItem(k);
                                    MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Drotg(t1, f, cs, sn);
                                    s.setItem(k, t1.v);
                                    f.v = -sn.v * e[System.Array.index(k, e)];
                                    e[System.Array.index(k, e)] = cs.v * e[System.Array.index(k, e)];
                                    if (computeVectors) {
                                        MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Drot(u, matrixCopy.RowCount, k, ((l - 1) | 0), cs.v, sn.v);
                                    }
                                }
                                break;
                            case 3: 
                                var scale = 0.0;
                                scale = Math.max(scale, Math.abs(s.getItem(((m - 1) | 0))));
                                scale = Math.max(scale, Math.abs(s.getItem(((m - 2) | 0))));
                                scale = Math.max(scale, Math.abs(e[System.Array.index(((m - 2) | 0), e)]));
                                scale = Math.max(scale, Math.abs(s.getItem(l)));
                                scale = Math.max(scale, Math.abs(e[System.Array.index(l, e)]));
                                var sm = s.getItem(((m - 1) | 0)) / scale;
                                var smm1 = s.getItem(((m - 2) | 0)) / scale;
                                var emm1 = e[System.Array.index(((m - 2) | 0), e)] / scale;
                                var sl = s.getItem(l) / scale;
                                var el = e[System.Array.index(l, e)] / scale;
                                var b = (((smm1 + sm) * (smm1 - sm)) + (emm1 * emm1)) / 2.0;
                                var c = (sm * emm1) * (sm * emm1);
                                var shift = 0.0;
                                if (b !== 0.0 || c !== 0.0) {
                                    shift = Math.sqrt((b * b) + c);
                                    if (b < 0.0) {
                                        shift = -shift;
                                    }

                                    shift = c / (b + shift);
                                }
                                f.v = ((sl + sm) * (sl - sm)) + shift;
                                var g = { v : sl * el };
                                for (k = l; k < ((m - 1) | 0); k = (k + 1) | 0) {
                                    MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Drotg(f, g, cs, sn);
                                    if (k !== l) {
                                        e[System.Array.index(((k - 1) | 0), e)] = f.v;
                                    }

                                    f.v = (cs.v * s.getItem(k)) + (sn.v * e[System.Array.index(k, e)]);
                                    e[System.Array.index(k, e)] = (cs.v * e[System.Array.index(k, e)]) - (sn.v * s.getItem(k));
                                    g.v = sn.v * s.getItem(((k + 1) | 0));
                                    s.setItem(((k + 1) | 0), cs.v * s.getItem(((k + 1) | 0)));
                                    if (computeVectors) {
                                        MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Drot(vt, matrixCopy.ColumnCount, k, ((k + 1) | 0), cs.v, sn.v);
                                    }

                                    MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Drotg(f, g, cs, sn);
                                    s.setItem(k, f.v);
                                    f.v = (cs.v * e[System.Array.index(k, e)]) + (sn.v * s.getItem(((k + 1) | 0)));
                                    s.setItem(((k + 1) | 0), (-sn.v * e[System.Array.index(k, e)]) + (cs.v * s.getItem(((k + 1) | 0))));
                                    g.v = sn.v * e[System.Array.index(((k + 1) | 0), e)];
                                    e[System.Array.index(((k + 1) | 0), e)] = cs.v * e[System.Array.index(((k + 1) | 0), e)];
                                    if (computeVectors && k < matrixCopy.RowCount) {
                                        MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Drot(u, matrixCopy.RowCount, k, ((k + 1) | 0), cs.v, sn.v);
                                    }
                                }
                                e[System.Array.index(((m - 2) | 0), e)] = f.v;
                                iter = (iter + 1) | 0;
                                break;
                            case 4: 
                                if (s.getItem(l) < 0.0) {
                                    s.setItem(l, -s.getItem(l));
                                    if (computeVectors) {
                                        MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.DscalColumn(vt, matrixCopy.ColumnCount, l, 0, -1.0);
                                    }
                                }
                                while (l !== ((mn - 1) | 0)) {
                                    if (s.getItem(l) >= s.getItem(((l + 1) | 0))) {
                                        break;
                                    }

                                    t = s.getItem(l);
                                    s.setItem(l, s.getItem(((l + 1) | 0)));
                                    s.setItem(((l + 1) | 0), t);
                                    if (computeVectors && l < matrixCopy.ColumnCount) {
                                        MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Dswap(vt, matrixCopy.ColumnCount, l, ((l + 1) | 0));
                                    }

                                    if (computeVectors && l < matrixCopy.RowCount) {
                                        MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.Dswap(u, matrixCopy.RowCount, l, ((l + 1) | 0));
                                    }

                                    l = (l + 1) | 0;
                                }
                                iter = 0;
                                m = (m - 1) | 0;
                                break;
                        }
                    }


                    if (computeVectors) {
                        vt = vt.Transpose();
                    }

                    if (matrixCopy.RowCount < matrixCopy.ColumnCount) {
                        nm = (nm - 1) | 0;
                        var tmp = MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd.v_builder.SameAs$3(System.Double, matrixCopy, nm);
                        for (i = 0; i < nm; i = (i + 1) | 0) {
                            tmp.setItem(i, s.getItem(i));
                        }

                        s = tmp;
                    }

                    return new MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd(s, u, vt, computeVectors);
                },
                /**
                 * Calculates absolute value of <b /> multiplied on signum function of <b />
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @param   {number}    z1    Double value z1
                 * @param   {number}    z2    Double value z2
                 * @return  {number}          Result multiplication of signum function and absolute value
                 */
                Dsign: function (z1, z2) {
                    return Math.abs(z1) * (z2 / Math.abs(z2));
                },
                /**
                 * Swap column  <b />  and  <b />
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    a           Source matrix
                 * @param   {number}                                     rowCount    The number of rows in <b>rowCount</b>
                 * @param   {number}                                     columnA     Column A index to swap
                 * @param   {number}                                     columnB     Column B index to swap
                 * @return  {void}
                 */
                Dswap: function (a, rowCount, columnA, columnB) {
                    for (var i = 0; i < rowCount; i = (i + 1) | 0) {
                        var z = a.At(i, columnA);
                        a.At$1(i, columnA, a.At(i, columnB));
                        a.At$1(i, columnB, z);
                    }
                },
                /**
                 * Scale column <b /> by <b /> starting from row <b />
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    a           Source matrix
                 * @param   {number}                                     rowCount    The number of rows in <b>rowCount</b>
                 * @param   {number}                                     column      Column to scale
                 * @param   {number}                                     rowStart    Row to scale from
                 * @param   {number}                                     z           Scale value
                 * @return  {void}
                 */
                DscalColumn: function (a, rowCount, column, rowStart, z) {
                    for (var i = rowStart; i < rowCount; i = (i + 1) | 0) {
                        a.At$1(i, column, a.At(i, column) * z);
                    }
                },
                /**
                 * Scale vector <b /> by <b /> starting from index <b />
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @param   {Array.<number>}    a        Source vector
                 * @param   {number}            start    Row to scale from
                 * @param   {number}            z        Scale value
                 * @return  {void}
                 */
                DscalVector: function (a, start, z) {
                    for (var i = start; i < a.length; i = (i + 1) | 0) {
                        a[System.Array.index(i, a)] = a[System.Array.index(i, a)] * z;
                    }
                },
                /**
                 * Given the Cartesian coordinates (da, db) of a point p, these function return the parameters da, db, c, and s
                 associated with the Givens rotation that zeros the y-coordinate of the point.
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @param   {System.Double}    da    Provides the x-coordinate of the point p. On exit contains the parameter r associated with the Givens rotation
                 * @param   {System.Double}    db    Provides the y-coordinate of the point p. On exit contains the parameter z associated with the Givens rotation
                 * @param   {System.Double}    c     Contains the parameter c associated with the Givens rotation
                 * @param   {System.Double}    s     Contains the parameter s associated with the Givens rotation
                 * @return  {void}
                 */
                Drotg: function (da, db, c, s) {
                    var r, z;
                    var roe = db.v;
                    var absda = Math.abs(da.v);
                    var absdb = Math.abs(db.v);
                    if (absda > absdb) {
                        roe = da.v;
                    }

                    var scale = absda + absdb;
                    if (scale === 0.0) {
                        c.v = 1.0;
                        s.v = 0.0;
                        r = 0.0;
                        z = 0.0;
                    } else {
                        var sda = da.v / scale;
                        var sdb = db.v / scale;
                        r = scale * Math.sqrt((sda * sda) + (sdb * sdb));
                        if (roe < 0.0) {
                            r = -r;
                        }

                        c.v = da.v / r;
                        s.v = db.v / r;
                        z = 1.0;
                        if (absda > absdb) {
                            z = s.v;
                        }

                        if (absdb >= absda && c.v !== 0.0) {
                            z = 1.0 / c.v;
                        }
                    }

                    da.v = r;
                    db.v = z;
                },
                /**
                 * Calculate Norm 2 of the column <b /> in matrix <b /> starting from row <b />
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    a           Source matrix
                 * @param   {number}                                     rowCount    The number of rows in <b>rowCount</b>
                 * @param   {number}                                     column      Column index
                 * @param   {number}                                     rowStart    Start row index
                 * @return  {number}                                                 Norm2 (Euclidean norm) of the column
                 */
                Dnrm2Column: function (a, rowCount, column, rowStart) {
                    var s = 0;
                    for (var i = rowStart; i < rowCount; i = (i + 1) | 0) {
                        s += a.At(i, column) * a.At(i, column);
                    }

                    return Math.sqrt(s);
                },
                /**
                 * Calculate Norm 2 of the vector <b /> starting from index <b />
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @param   {Array.<number>}    a           Source vector
                 * @param   {number}            rowStart    Start index
                 * @return  {number}                        Norm2 (Euclidean norm) of the vector
                 */
                Dnrm2Vector: function (a, rowStart) {
                    var s = 0;
                    for (var i = rowStart; i < a.length; i = (i + 1) | 0) {
                        s += a[System.Array.index(i, a)] * a[System.Array.index(i, a)];
                    }

                    return Math.sqrt(s);
                },
                /**
                 * Calculate dot product of <b /> and <b />
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    a           Source matrix
                 * @param   {number}                                     rowCount    The number of rows in <b>rowCount</b>
                 * @param   {number}                                     columnA     Index of column A
                 * @param   {number}                                     columnB     Index of column B
                 * @param   {number}                                     rowStart    Starting row index
                 * @return  {number}                                                 Dot product value
                 */
                Ddot: function (a, rowCount, columnA, columnB, rowStart) {
                    var z = 0.0;
                    for (var i = rowStart; i < rowCount; i = (i + 1) | 0) {
                        z += a.At(i, columnB) * a.At(i, columnA);
                    }

                    return z;
                },
                /**
                 * Performs rotation of points in the plane. Given two vectors x <b /> and y <b />,
                 each vector element of these vectors is replaced as follows: x(i) = c*x(i) + s*y(i); y(i) = c*y(i) - s*x(i)
                 *
                 * @static
                 * @private
                 * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
                 * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    a           Source matrix
                 * @param   {number}                                     rowCount    The number of rows in <b>rowCount</b>
                 * @param   {number}                                     columnA     Index of column A
                 * @param   {number}                                     columnB     Index of column B
                 * @param   {number}                                     c           Scalar "c" value
                 * @param   {number}                                     s           Scalar "s" value
                 * @return  {void}
                 */
                Drot: function (a, rowCount, columnA, columnB, c, s) {
                    for (var i = 0; i < rowCount; i = (i + 1) | 0) {
                        var z = (c * a.At(i, columnA)) + (s * a.At(i, columnB));
                        var tmp = (c * a.At(i, columnB)) - (s * a.At(i, columnA));
                        a.At$1(i, columnB, tmp);
                        a.At$1(i, columnA, z);
                    }
                }
            }
        },
        alias: [
            "Solve$1", "MathNet$Numerics$LinearAlgebra$Factorization$ISolver$1$System$Double$Solve$2",
            "Solve$3", "MathNet$Numerics$LinearAlgebra$Factorization$ISolver$1$System$Double$Solve$3"
        ],
        ctors: {
            ctor: function (s, u, vt, vectorsComputed) {
                this.$initialize();
                MathNet.Numerics.LinearAlgebra.Double.Factorization.Svd.ctor.call(this, s, u, vt, vectorsComputed);
            }
        },
        methods: {
            /**
             * Solves a system of linear equations, <b>AX = B</b>, with A SVD factorized.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    input     The right hand side {@link }, <b>B</b>.
             * @param   {MathNet.Numerics.LinearAlgebra.Matrix$1}    result    The left hand side {@link }, <b>X</b>.
             * @return  {void}
             */
            Solve$1: function (input, result) {
                if (!this.VectorsComputed) {
                    throw new System.InvalidOperationException.$ctor1("Resources.SingularVectorsNotComputed");
                }

                if (input.ColumnCount !== result.ColumnCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSameColumnDimension");
                }

                if (this.U.RowCount !== input.RowCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSameRowDimension");


                }

                if (this.VT.ColumnCount !== result.RowCount) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentMatrixSameColumnDimension");

                }

                var mn = Math.min(this.U.RowCount, this.VT.ColumnCount);
                var bn = input.ColumnCount;

                var tmp = System.Array.init(this.VT.ColumnCount, 0, System.Double);

                for (var k = 0; k < bn; k = (k + 1) | 0) {
                    for (var j = 0; j < this.VT.ColumnCount; j = (j + 1) | 0) {
                        var value = 0;
                        if (j < mn) {
                            for (var i = 0; i < this.U.RowCount; i = (i + 1) | 0) {
                                value += this.U.At(i, j) * input.At(i, k);
                            }

                            value /= this.S.getItem(j);
                        }

                        tmp[System.Array.index(j, tmp)] = value;
                    }

                    for (var j1 = 0; j1 < this.VT.ColumnCount; j1 = (j1 + 1) | 0) {
                        var value1 = 0;
                        for (var i1 = 0; i1 < this.VT.ColumnCount; i1 = (i1 + 1) | 0) {
                            value1 += this.VT.At(i1, j1) * tmp[System.Array.index(i1, tmp)];
                        }

                        result.At$1(j1, k, value1);
                    }
                }
            },
            /**
             * Solves a system of linear equations, <b>Ax = b</b>, with A SVD factorized.
             *
             * @instance
             * @public
             * @override
             * @this MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
             * @memberof MathNet.Numerics.LinearAlgebra.Double.Factorization.UserSvd
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    input     The right hand side vector, <b>b</b>.
             * @param   {MathNet.Numerics.LinearAlgebra.Vector$1}    result    The left hand side {@link }, <b>x</b>.
             * @return  {void}
             */
            Solve$3: function (input, result) {
                if (!this.VectorsComputed) {
                    throw new System.InvalidOperationException.$ctor1("Resources.SingularVectorsNotComputed");
                }

                if (this.U.RowCount !== input.Count) {
                    throw new System.ArgumentException.$ctor1("Resources.ArgumentVectorsSameLength");
                }

                if (this.VT.ColumnCount !== result.Count) {
                    throw MathNet.Numerics.LinearAlgebra.Matrix$1(System.Double).DimensionsDontMatch$4(System.ArgumentException, this.VT, result);
                }

                var mn = Math.min(this.U.RowCount, this.VT.ColumnCount);
                var tmp = System.Array.init(this.VT.ColumnCount, 0, System.Double);
                var value;
                for (var j = 0; j < this.VT.ColumnCount; j = (j + 1) | 0) {
                    value = 0;
                    if (j < mn) {
                        for (var i = 0; i < this.U.RowCount; i = (i + 1) | 0) {
                            value += this.U.At(i, j) * input.getItem(i);
                        }

                        value /= this.S.getItem(j);
                    }

                    tmp[System.Array.index(j, tmp)] = value;
                }

                for (var j1 = 0; j1 < this.VT.ColumnCount; j1 = (j1 + 1) | 0) {
                    value = 0;
                    for (var i1 = 0; i1 < this.VT.ColumnCount; i1 = (i1 + 1) | 0) {
                        value += this.VT.At(i1, j1) * tmp[System.Array.index(i1, tmp)];
                    }

                    result.setItem(j1, value);
                }
            }
        }
    });
});

//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAiZmlsZSI6ICJNYXRoTmV0TnVtZXJpY3MuanMiLAogICJzb3VyY2VSb290IjogIiIsCiAgInNvdXJjZXMiOiBbIkV1Y2xpZC5jcyIsIkNyZWF0ZU1hdHJpeC5jcyIsIkNyZWF0ZVZlY3Rvci5jcyIsIk1hdHJpeC5Bcml0aG1ldGljLmNzIiwiTWF0cml4LkJDTC5jcyIsIk1hdHJpeC5PcGVyYXRvcnMuY3MiLCJNYXRyaXguY3MiLCJWZWN0b3IuQXJpdGhtZXRpYy5jcyIsIlZlY3Rvci5CQ0wuY3MiLCJWZWN0b3IuT3BlcmF0b3JzLmNzIiwiVmVjdG9yLmNzIiwiQnVpbGRlci5jcyIsIk1hdHJpeEV4dGVuc2lvbnMuY3MiLCJTdG9yYWdlL01hdHJpeFN0b3JhZ2UuY3MiLCJTdG9yYWdlL01hdHJpeFN0b3JhZ2UuVmFsaWRhdGlvbi5jcyIsIlN0b3JhZ2UvVmVjdG9yU3RvcmFnZS5jcyIsIlN0b3JhZ2UvVmVjdG9yU3RvcmFnZS5WYWxpZGF0aW9uLmNzIiwiVmVjdG9yRXh0ZW5zaW9ucy5jcyIsIlBlcm11dGF0aW9uLmNzIiwiU29ydGluZy5jcyIsIkFwcC5jcyIsIkJ1ZmZlci5jcyIsIk1hbmFnZWRMaW5lYXJBbGdlYnJhUHJvdmlkZXIuY3MiLCJDb21wbGV4LmNzIiwiQ29tcGxleDMyLmNzIiwiRG91YmxlL01hdHJpeC5jcyIsIkRvdWJsZS9WZWN0b3IuY3MiLCJGYWN0b3JpemF0aW9uL0xVLmNzIiwiRmFjdG9yaXphdGlvbi9TdmQuY3MiLCJGYWN0b3JpemF0aW9uL0V2ZC5jcyIsIlN0b3JhZ2UvRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2UuY3MiLCJTdG9yYWdlL0RlbnNlVmVjdG9yU3RvcmFnZS5jcyIsIlN0b3JhZ2UvRGlhZ29uYWxNYXRyaXhTdG9yYWdlLmNzIiwiU3RvcmFnZS9TcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZS5jcyIsIlN0b3JhZ2UvU3BhcnNlVmVjdG9yU3RvcmFnZS5jcyIsIkRvdWJsZS9EZW5zZU1hdHJpeC5jcyIsIkRvdWJsZS9EZW5zZVZlY3Rvci5jcyIsIkRvdWJsZS9EaWFnb25hbE1hdHJpeC5jcyIsIkRvdWJsZS9GYWN0b3JpemF0aW9uL0xVLmNzIiwiRG91YmxlL0ZhY3Rvcml6YXRpb24vU3ZkLmNzIiwiRG91YmxlL1NwYXJzZU1hdHJpeC5jcyIsIkRvdWJsZS9TcGFyc2VWZWN0b3IuY3MiLCJEb3VibGUvRmFjdG9yaXphdGlvbi9EZW5zZUxVLmNzIiwiRG91YmxlL0ZhY3Rvcml6YXRpb24vRGVuc2VTdmQuY3MiLCJEb3VibGUvRmFjdG9yaXphdGlvbi9Vc2VyU3ZkLmNzIl0sCiAgIm5hbWVzIjogWyIiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VEQTZUNERBOzs7Ozs7Ozs7Ozs7Ozs7bUNBOVF2QkEsVUFBaUJBO29CQUUxQ0EsT0FBT0EsQ0FBQ0EsQ0FBQ0EsV0FBU0EsV0FBV0EsV0FBU0E7Ozs7Ozs7Ozs7Ozs7cUNBU2RBLFVBQWdCQTtvQkFFeENBLE9BQU9BLENBQUNBLENBQUNBLFdBQVNBLFdBQVdBLFdBQVNBOzs7Ozs7Ozs7Ozs7O3FDQVNoQkEsVUFBY0E7b0JBRXBDQSxPQUFPQSxDQUFDQSxHQUFDQSxXQUFTQSxXQUFXQSxpQkFBU0E7Ozs7Ozs7Ozs7Ozs7cUNBU2ZBLFVBQWVBO29CQUV0Q0EsT0FBT0EsQ0FBQ0EsQ0FBQ0EsYUFBU0EsY0FBV0EsY0FBU0E7Ozs7Ozs7Ozs7Ozs7O3FDQWNYQSxVQUFpQkE7b0JBRTVDQSxPQUFPQSxXQUFTQTs7Ozs7Ozs7Ozs7Ozt1Q0FTVUEsVUFBZ0JBO29CQUUxQ0EsT0FBT0EsV0FBU0E7Ozs7Ozs7Ozs7Ozs7dUNBU1FBLFVBQWNBO29CQUV0Q0EsT0FBT0EsV0FBU0E7Ozs7Ozs7Ozs7Ozs7dUNBU1NBLFVBQWVBO29CQUV4Q0EsT0FBT0EsYUFBU0E7Ozs7Ozs7Ozs7Ozs7a0NBZU1BO29CQUV0QkEsT0FBT0EsQ0FBQ0E7Ozs7Ozs7Ozs7OztvQ0FXY0E7b0JBRXRCQSxPQUFPQSxDQUFDQTs7Ozs7Ozs7Ozs7O2lDQVdhQTtvQkFFckJBLE9B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OiBbIi8vIDxjb3B5cmlnaHQgZmlsZT1cIkV1Y2xpZC5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDE0IE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uUnVudGltZS5Db21waWxlclNlcnZpY2VzO1xyXG4vL3VzaW5nIEJpZ0ludGVnZXIgPSA7XHJcblxyXG5uYW1lc3BhY2UgTWF0aE5ldC5OdW1lcmljc1xyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gSW50ZWdlciBudW1iZXIgdGhlb3J5IGZ1bmN0aW9ucy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIEV1Y2xpZFxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2Fub25pY2FsIE1vZHVsdXMuIFRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpc29yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiNpZiAhTkVUNDBcclxuICAgICAgICBbTWV0aG9kSW1wbChNZXRob2RJbXBsT3B0aW9ucy5BZ2dyZXNzaXZlSW5saW5pbmcpXVxyXG4jZW5kaWZcclxuICAgICAgICBwdWJsaWMgc3RhdGljIGRvdWJsZSBNb2R1bHVzKGRvdWJsZSBkaXZpZGVuZCwgZG91YmxlIGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKChkaXZpZGVuZCVkaXZpc29yKSArIGRpdmlzb3IpJWRpdmlzb3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbm9uaWNhbCBNb2R1bHVzLiBUaGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aXNvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4jaWYgIU5FVDQwXHJcbiAgICAgICAgW01ldGhvZEltcGwoTWV0aG9kSW1wbE9wdGlvbnMuQWdncmVzc2l2ZUlubGluaW5nKV1cclxuI2VuZGlmXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBmbG9hdCBNb2R1bHVzKGZsb2F0IGRpdmlkZW5kLCBmbG9hdCBkaXZpc29yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICgoZGl2aWRlbmQlZGl2aXNvcikgKyBkaXZpc29yKSVkaXZpc29yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYW5vbmljYWwgTW9kdWx1cy4gVGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlzb3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuI2lmICFORVQ0MFxyXG4gICAgICAgIFtNZXRob2RJbXBsKE1ldGhvZEltcGxPcHRpb25zLkFnZ3Jlc3NpdmVJbmxpbmluZyldXHJcbiNlbmRpZlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgaW50IE1vZHVsdXMoaW50IGRpdmlkZW5kLCBpbnQgZGl2aXNvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKGRpdmlkZW5kJWRpdmlzb3IpICsgZGl2aXNvciklZGl2aXNvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2Fub25pY2FsIE1vZHVsdXMuIFRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpc29yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiNpZiAhTkVUNDBcclxuICAgICAgICBbTWV0aG9kSW1wbChNZXRob2RJbXBsT3B0aW9ucy5BZ2dyZXNzaXZlSW5saW5pbmcpXVxyXG4jZW5kaWZcclxuICAgICAgICBwdWJsaWMgc3RhdGljIGxvbmcgTW9kdWx1cyhsb25nIGRpdmlkZW5kLCBsb25nIGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKChkaXZpZGVuZCVkaXZpc29yKSArIGRpdmlzb3IpJWRpdmlzb3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbm9uaWNhbCBNb2R1bHVzLiBUaGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aXNvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG5cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZW1haW5kZXIgKCUgb3BlcmF0b3IpLiBUaGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aWRlbmQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuI2lmICFORVQ0MFxyXG4gICAgICAgIFtNZXRob2RJbXBsKE1ldGhvZEltcGxPcHRpb25zLkFnZ3Jlc3NpdmVJbmxpbmluZyldXHJcbiNlbmRpZlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZG91YmxlIFJlbWFpbmRlcihkb3VibGUgZGl2aWRlbmQsIGRvdWJsZSBkaXZpc29yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdmlkZW5kJWRpdmlzb3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlbWFpbmRlciAoJSBvcGVyYXRvcikuIFRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4jaWYgIU5FVDQwXHJcbiAgICAgICAgW01ldGhvZEltcGwoTWV0aG9kSW1wbE9wdGlvbnMuQWdncmVzc2l2ZUlubGluaW5nKV1cclxuI2VuZGlmXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBmbG9hdCBSZW1haW5kZXIoZmxvYXQgZGl2aWRlbmQsIGZsb2F0IGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2aWRlbmQlZGl2aXNvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVtYWluZGVyICglIG9wZXJhdG9yKS4gVGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlkZW5kLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiNpZiAhTkVUNDBcclxuICAgICAgICBbTWV0aG9kSW1wbChNZXRob2RJbXBsT3B0aW9ucy5BZ2dyZXNzaXZlSW5saW5pbmcpXVxyXG4jZW5kaWZcclxuICAgICAgICBwdWJsaWMgc3RhdGljIGludCBSZW1haW5kZXIoaW50IGRpdmlkZW5kLCBpbnQgZGl2aXNvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXZpZGVuZCVkaXZpc29yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZW1haW5kZXIgKCUgb3BlcmF0b3IpLiBUaGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aWRlbmQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuI2lmICFORVQ0MFxyXG4gICAgICAgIFtNZXRob2RJbXBsKE1ldGhvZEltcGxPcHRpb25zLkFnZ3Jlc3NpdmVJbmxpbmluZyldXHJcbiNlbmRpZlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgbG9uZyBSZW1haW5kZXIobG9uZyBkaXZpZGVuZCwgbG9uZyBkaXZpc29yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdmlkZW5kJWRpdmlzb3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlbWFpbmRlciAoJSBvcGVyYXRvcikuIFRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpbmQgb3V0IHdoZXRoZXIgdGhlIHByb3ZpZGVkIDMyIGJpdCBpbnRlZ2VyIGlzIGFuIGV2ZW4gbnVtYmVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibnVtYmVyXCI+VGhlIG51bWJlciB0byB2ZXJ5IHdoZXRoZXIgaXQncyBldmVuLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgYW5kIG9ubHkgaWYgaXQgaXMgYW4gZXZlbiBudW1iZXIuPC9yZXR1cm5zPlxyXG4jaWYgIU5FVDQwXHJcbiAgICAgICAgW01ldGhvZEltcGwoTWV0aG9kSW1wbE9wdGlvbnMuQWdncmVzc2l2ZUlubGluaW5nKV1cclxuI2VuZGlmXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIElzRXZlbih0aGlzIGludCBudW1iZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKG51bWJlciAmIDB4MSkgPT0gMHgwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaW5kIG91dCB3aGV0aGVyIHRoZSBwcm92aWRlZCA2NCBiaXQgaW50ZWdlciBpcyBhbiBldmVuIG51bWJlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm51bWJlclwiPlRoZSBudW1iZXIgdG8gdmVyeSB3aGV0aGVyIGl0J3MgZXZlbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIGFuZCBvbmx5IGlmIGl0IGlzIGFuIGV2ZW4gbnVtYmVyLjwvcmV0dXJucz5cclxuI2lmICFORVQ0MFxyXG4gICAgICAgIFtNZXRob2RJbXBsKE1ldGhvZEltcGxPcHRpb25zLkFnZ3Jlc3NpdmVJbmxpbmluZyldXHJcbiNlbmRpZlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBJc0V2ZW4odGhpcyBsb25nIG51bWJlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAobnVtYmVyICYgMHgxKSA9PSAweDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpbmQgb3V0IHdoZXRoZXIgdGhlIHByb3ZpZGVkIDMyIGJpdCBpbnRlZ2VyIGlzIGFuIG9kZCBudW1iZXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJudW1iZXJcIj5UaGUgbnVtYmVyIHRvIHZlcnkgd2hldGhlciBpdCdzIG9kZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIGFuZCBvbmx5IGlmIGl0IGlzIGFuIG9kZCBudW1iZXIuPC9yZXR1cm5zPlxyXG4jaWYgIU5FVDQwXHJcbiAgICAgICAgW01ldGhvZEltcGwoTWV0aG9kSW1wbE9wdGlvbnMuQWdncmVzc2l2ZUlubGluaW5nKV1cclxuI2VuZGlmXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIElzT2RkKHRoaXMgaW50IG51bWJlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAobnVtYmVyICYgMHgxKSA9PSAweDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpbmQgb3V0IHdoZXRoZXIgdGhlIHByb3ZpZGVkIDY0IGJpdCBpbnRlZ2VyIGlzIGFuIG9kZCBudW1iZXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJudW1iZXJcIj5UaGUgbnVtYmVyIHRvIHZlcnkgd2hldGhlciBpdCdzIG9kZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIGFuZCBvbmx5IGlmIGl0IGlzIGFuIG9kZCBudW1iZXIuPC9yZXR1cm5zPlxyXG4jaWYgIU5FVDQwXHJcbiAgICAgICAgW01ldGhvZEltcGwoTWV0aG9kSW1wbE9wdGlvbnMuQWdncmVzc2l2ZUlubGluaW5nKV1cclxuI2VuZGlmXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIElzT2RkKHRoaXMgbG9uZyBudW1iZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKG51bWJlciAmIDB4MSkgPT0gMHgxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaW5kIG91dCB3aGV0aGVyIHRoZSBwcm92aWRlZCAzMiBiaXQgaW50ZWdlciBpcyBhIHBlcmZlY3QgcG93ZXIgb2YgdHdvLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibnVtYmVyXCI+VGhlIG51bWJlciB0byB2ZXJ5IHdoZXRoZXIgaXQncyBhIHBvd2VyIG9mIHR3by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIGFuZCBvbmx5IGlmIGl0IGlzIGEgcG93ZXIgb2YgdHdvLjwvcmV0dXJucz5cclxuI2lmICFORVQ0MFxyXG4gICAgICAgIFtNZXRob2RJbXBsKE1ldGhvZEltcGxPcHRpb25zLkFnZ3Jlc3NpdmVJbmxpbmluZyldXHJcbiNlbmRpZlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBJc1Bvd2VyT2ZUd28odGhpcyBpbnQgbnVtYmVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciA+IDAgJiYgKG51bWJlciAmIChudW1iZXIgLSAxKSkgPT0gMHgwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaW5kIG91dCB3aGV0aGVyIHRoZSBwcm92aWRlZCA2NCBiaXQgaW50ZWdlciBpcyBhIHBlcmZlY3QgcG93ZXIgb2YgdHdvLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibnVtYmVyXCI+VGhlIG51bWJlciB0byB2ZXJ5IHdoZXRoZXIgaXQncyBhIHBvd2VyIG9mIHR3by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIGFuZCBvbmx5IGlmIGl0IGlzIGEgcG93ZXIgb2YgdHdvLjwvcmV0dXJucz5cclxuI2lmICFORVQ0MFxyXG4gICAgICAgIFtNZXRob2RJbXBsKE1ldGhvZEltcGxPcHRpb25zLkFnZ3Jlc3NpdmVJbmxpbmluZyldXHJcbiNlbmRpZlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBJc1Bvd2VyT2ZUd28odGhpcyBsb25nIG51bWJlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgPiAwICYmIChudW1iZXIgJiAobnVtYmVyIC0gMSkpID09IDB4MDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmluZCBvdXQgd2hldGhlciB0aGUgcHJvdmlkZWQgMzIgYml0IGludGVnZXIgaXMgYSBwZXJmZWN0IHNxdWFyZSwgaS5lLiBhIHNxdWFyZSBvZiBhbiBpbnRlZ2VyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibnVtYmVyXCI+VGhlIG51bWJlciB0byB2ZXJ5IHdoZXRoZXIgaXQncyBhIHBlcmZlY3Qgc3F1YXJlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgYW5kIG9ubHkgaWYgaXQgaXMgYSBwZXJmZWN0IHNxdWFyZS48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIElzUGVyZmVjdFNxdWFyZSh0aGlzIGludCBudW1iZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobnVtYmVyIDwgMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpbnQgbGFzdEhleERpZ2l0ID0gbnVtYmVyICYgMHhGO1xyXG4gICAgICAgICAgICBpZiAobGFzdEhleERpZ2l0ID4gOSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyByZXR1cm4gaW1tZWRpYXRlbHkgaW4gNiBjYXNlcyBvdXQgb2YgMTYuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsYXN0SGV4RGlnaXQgPT0gMCB8fCBsYXN0SGV4RGlnaXQgPT0gMSB8fCBsYXN0SGV4RGlnaXQgPT0gNCB8fCBsYXN0SGV4RGlnaXQgPT0gOSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IHQgPSAoaW50KU1hdGguRmxvb3IoTWF0aC5TcXJ0KG51bWJlcikgKyAwLjUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0ICogdCkgPT0gbnVtYmVyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpbmQgb3V0IHdoZXRoZXIgdGhlIHByb3ZpZGVkIDY0IGJpdCBpbnRlZ2VyIGlzIGEgcGVyZmVjdCBzcXVhcmUsIGkuZS4gYSBzcXVhcmUgb2YgYW4gaW50ZWdlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm51bWJlclwiPlRoZSBudW1iZXIgdG8gdmVyeSB3aGV0aGVyIGl0J3MgYSBwZXJmZWN0IHNxdWFyZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIGFuZCBvbmx5IGlmIGl0IGlzIGEgcGVyZmVjdCBzcXVhcmUuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBJc1BlcmZlY3RTcXVhcmUodGhpcyBsb25nIG51bWJlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgPCAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludCBsYXN0SGV4RGlnaXQgPSAoaW50KShudW1iZXIgJiAweEYpO1xyXG4gICAgICAgICAgICBpZiAobGFzdEhleERpZ2l0ID4gOSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyByZXR1cm4gaW1tZWRpYXRlbHkgaW4gNiBjYXNlcyBvdXQgb2YgMTYuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsYXN0SGV4RGlnaXQgPT0gMCB8fCBsYXN0SGV4RGlnaXQgPT0gMSB8fCBsYXN0SGV4RGlnaXQgPT0gNCB8fCBsYXN0SGV4RGlnaXQgPT0gOSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbG9uZyB0ID0gKGxvbmcpTWF0aC5GbG9vcihNYXRoLlNxcnQobnVtYmVyKSArIDAuNSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHQgKiB0KSA9PSBudW1iZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmFpc2VzIDIgdG8gdGhlIHByb3ZpZGVkIGludGVnZXIgZXhwb25lbnQgKDAgJmx0Oz0gZXhwb25lbnQgJmx0OyAzMSkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJleHBvbmVudFwiPlRoZSBleHBvbmVudCB0byByYWlzZSAyIHVwIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjIgXiBleHBvbmVudC48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiLz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGludCBQb3dlck9mVHdvKHRoaXMgaW50IGV4cG9uZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGV4cG9uZW50IDwgMCB8fCBleHBvbmVudCA+PSAzMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImV4cG9uZW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gMSA8PCBleHBvbmVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmFpc2VzIDIgdG8gdGhlIHByb3ZpZGVkIGludGVnZXIgZXhwb25lbnQgKDAgJmx0Oz0gZXhwb25lbnQgJmx0OyA2MykuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJleHBvbmVudFwiPlRoZSBleHBvbmVudCB0byByYWlzZSAyIHVwIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjIgXiBleHBvbmVudC48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiLz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGxvbmcgUG93ZXJPZlR3byh0aGlzIGxvbmcgZXhwb25lbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZXhwb25lbnQgPCAwIHx8IGV4cG9uZW50ID49IDYzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiZXhwb25lbnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKGxvbmcpMSkgPDwgKGludClleHBvbmVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRXZhbHVhdGUgdGhlIGJpbmFyeSBsb2dhcml0aG0gb2YgYW4gaW50ZWdlciBudW1iZXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+VHdvLXN0ZXAgbWV0aG9kIHVzaW5nIGEgRGUgQnJ1aWpuLWxpa2Ugc2VxdWVuY2UgdGFibGUgbG9va3VwLjwvcmVtYXJrcz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGludCBMb2cyKHRoaXMgaW50IG51bWJlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG51bWJlciB8PSBudW1iZXIgPj4gMTtcclxuICAgICAgICAgICAgbnVtYmVyIHw9IG51bWJlciA+PiAyO1xyXG4gICAgICAgICAgICBudW1iZXIgfD0gbnVtYmVyID4+IDQ7XHJcbiAgICAgICAgICAgIG51bWJlciB8PSBudW1iZXIgPj4gODtcclxuICAgICAgICAgICAgbnVtYmVyIHw9IG51bWJlciA+PiAxNjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aXBseURlQnJ1aWpuQml0UG9zaXRpb25bKHVpbnQpKG51bWJlciAqIDB4MDdDNEFDRERVKSA+PiAyN107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgcmVhZG9ubHkgaW50W10gTXVsdGlwbHlEZUJydWlqbkJpdFBvc2l0aW9uID0gbmV3IGludFszMl1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIDAsIDksIDEsIDEwLCAxMywgMjEsIDIsIDI5LCAxMSwgMTQsIDE2LCAxOCwgMjIsIDI1LCAzLCAzMCxcclxuICAgICAgICAgICAgOCwgMTIsIDIwLCAyOCwgMTUsIDE3LCAyNCwgNywgMTksIDI3LCAyMywgNiwgMjYsIDUsIDQsIDMxXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaW5kIHRoZSBjbG9zZXN0IHBlcmZlY3QgcG93ZXIgb2YgdHdvIHRoYXQgaXMgbGFyZ2VyIG9yIGVxdWFsIHRvIHRoZSBwcm92aWRlZFxyXG4gICAgICAgIC8vLyAzMiBiaXQgaW50ZWdlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm51bWJlclwiPlRoZSBudW1iZXIgb2Ygd2hpY2ggdG8gZmluZCB0aGUgY2xvc2VzdCB1cHBlciBwb3dlciBvZiB0d28uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBwb3dlciBvZiB0d28uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIi8+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbnQgQ2VpbGluZ1RvUG93ZXJPZlR3byh0aGlzIGludCBudW1iZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09IEludDMyLk1pblZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgaW50IG1heFBvd2VyT2ZUd28gPSAweDQwMDAwMDAwO1xyXG4gICAgICAgICAgICBpZiAobnVtYmVyID4gbWF4UG93ZXJPZlR3bylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcIm51bWJlclwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbnVtYmVyLS07XHJcbiAgICAgICAgICAgIG51bWJlciB8PSBudW1iZXIgPj4gMTtcclxuICAgICAgICAgICAgbnVtYmVyIHw9IG51bWJlciA+PiAyO1xyXG4gICAgICAgICAgICBudW1iZXIgfD0gbnVtYmVyID4+IDQ7XHJcbiAgICAgICAgICAgIG51bWJlciB8PSBudW1iZXIgPj4gODtcclxuICAgICAgICAgICAgbnVtYmVyIHw9IG51bWJlciA+PiAxNjtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpbmQgdGhlIGNsb3Nlc3QgcGVyZmVjdCBwb3dlciBvZiB0d28gdGhhdCBpcyBsYXJnZXIgb3IgZXF1YWwgdG8gdGhlIHByb3ZpZGVkXHJcbiAgICAgICAgLy8vIDY0IGJpdCBpbnRlZ2VyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibnVtYmVyXCI+VGhlIG51bWJlciBvZiB3aGljaCB0byBmaW5kIHRoZSBjbG9zZXN0IHVwcGVyIHBvd2VyIG9mIHR3by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIHBvd2VyIG9mIHR3by48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiLz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGxvbmcgQ2VpbGluZ1RvUG93ZXJPZlR3byh0aGlzIGxvbmcgbnVtYmVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKG51bWJlciA9PSBJbnQ2NC5NaW5WYWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxvbmcgbWF4UG93ZXJPZlR3byA9IDB4NDAwMDAwMDAwMDAwMDAwMDtcclxuICAgICAgICAgICAgaWYgKG51bWJlciA+IG1heFBvd2VyT2ZUd28pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJudW1iZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG51bWJlci0tO1xyXG4gICAgICAgICAgICBudW1iZXIgfD0gbnVtYmVyID4+IDE7XHJcbiAgICAgICAgICAgIG51bWJlciB8PSBudW1iZXIgPj4gMjtcclxuICAgICAgICAgICAgbnVtYmVyIHw9IG51bWJlciA+PiA0O1xyXG4gICAgICAgICAgICBudW1iZXIgfD0gbnVtYmVyID4+IDg7XHJcbiAgICAgICAgICAgIG51bWJlciB8PSBudW1iZXIgPj4gMTY7XHJcbiAgICAgICAgICAgIG51bWJlciB8PSBudW1iZXIgPj4gMzI7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvciAoPGM+Z2NkPC9jPikgb2YgdHdvIGludGVnZXJzIHVzaW5nIEV1Y2xpZCdzIGFsZ29yaXRobS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFcIj5GaXJzdCBJbnRlZ2VyOiBhLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYlwiPlNlY29uZCBJbnRlZ2VyOiBiLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIDxjPmdjZDwvYz4oYSxiKTwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGxvbmcgR3JlYXRlc3RDb21tb25EaXZpc29yKGxvbmcgYSwgbG9uZyBiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgd2hpbGUgKGIgIT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IGElYjtcclxuICAgICAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICAgICAgYiA9IHJlbWFpbmRlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguQWJzKGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvciAoPGM+Z2NkPC9jPikgb2YgYSBzZXQgb2YgaW50ZWdlcnMgdXNpbmcgRXVjbGlkJ3NcclxuICAgICAgICAvLy8gYWxnb3JpdGhtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW50ZWdlcnNcIj5MaXN0IG9mIEludGVnZXJzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIDxjPmdjZDwvYz4obGlzdCBvZiBpbnRlZ2Vycyk8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBsb25nIEdyZWF0ZXN0Q29tbW9uRGl2aXNvcihJTGlzdDxsb25nPiBpbnRlZ2VycylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChudWxsID09IGludGVnZXJzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwiaW50ZWdlcnNcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbnRlZ2Vycy5Db3VudCA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGdjZCA9IE1hdGguQWJzKGludGVnZXJzWzBdKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyAoaSA8IGludGVnZXJzLkNvdW50KSAmJiAoZ2NkID4gMSk7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2NkID0gR3JlYXRlc3RDb21tb25EaXZpc29yKGdjZCwgaW50ZWdlcnNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZ2NkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvciAoPGM+Z2NkPC9jPikgb2YgYSBzZXQgb2YgaW50ZWdlcnMgdXNpbmcgRXVjbGlkJ3MgYWxnb3JpdGhtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW50ZWdlcnNcIj5MaXN0IG9mIEludGVnZXJzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIDxjPmdjZDwvYz4obGlzdCBvZiBpbnRlZ2Vycyk8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBsb25nIEdyZWF0ZXN0Q29tbW9uRGl2aXNvcihwYXJhbXMgbG9uZ1tdIGludGVnZXJzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEdyZWF0ZXN0Q29tbW9uRGl2aXNvcigoSUxpc3Q8bG9uZz4paW50ZWdlcnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgZXh0ZW5kZWQgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3IsIHN1Y2ggdGhhdCBhKnggKyBiKnkgPSA8Yz5nY2Q8L2M+KGEsYikuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhXCI+Rmlyc3QgSW50ZWdlcjogYS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJcIj5TZWNvbmQgSW50ZWdlcjogYi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5SZXN1bHRpbmcgeCwgc3VjaCB0aGF0IGEqeCArIGIqeSA9IDxjPmdjZDwvYz4oYSxiKS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInlcIj5SZXN1bHRpbmcgeSwgc3VjaCB0aGF0IGEqeCArIGIqeSA9IDxjPmdjZDwvYz4oYSxiKTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIDxjPmdjZDwvYz4oYSxiKTwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4YW1wbGU+XHJcbiAgICAgICAgLy8vIDxjb2RlPlxyXG4gICAgICAgIC8vLyBsb25nIHgseSxkO1xyXG4gICAgICAgIC8vLyBkID0gRm4uR3JlYXRlc3RDb21tb25EaXZpc29yKDQ1LDE4LG91dCB4LCBvdXQgeSk7XHJcbiAgICAgICAgLy8vIC0+IGQgPT0gOSAmYW1wOyZhbXA7IHggPT0gMSAmYW1wOyZhbXA7IHkgPT0gLTJcclxuICAgICAgICAvLy8gPC9jb2RlPlxyXG4gICAgICAgIC8vLyBUaGUgPGM+Z2NkPC9jPiBvZiA0NSBhbmQgMTggaXMgOTogMTggPSAyKjksIDQ1ID0gNSo5LiA5ID0gMSo0NSAtMioxOCwgdGhlcmVmb3JlIHg9MSBhbmQgeT0tMi5cclxuICAgICAgICAvLy8gPC9leGFtcGxlPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgbG9uZyBFeHRlbmRlZEdyZWF0ZXN0Q29tbW9uRGl2aXNvcihsb25nIGEsIGxvbmcgYiwgb3V0IGxvbmcgeCwgb3V0IGxvbmcgeSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxvbmcgbXAgPSAxLCBucCA9IDAsIG0gPSAwLCBuID0gMTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChiICE9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxvbmcgcmVtO1xyXG4jaWYgTkVUU1RBTkRBUkQxXzNcclxuICAgICAgICAgICAgICAgIHJlbSA9IGEgJSBiO1xyXG4gICAgICAgICAgICAgICAgdmFyIHF1b3QgPSBhIC8gYjtcclxuI2Vsc2VcclxuICAgICAgICAgICAgICAgIGxvbmcgcXVvdCA9IE1hdGguRGl2UmVtKGEsIGIsIG91dCByZW0pO1xyXG4jZW5kaWZcclxuICAgICAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICAgICAgYiA9IHJlbTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gbTtcclxuICAgICAgICAgICAgICAgIG0gPSBtcCAtIChxdW90Km0pO1xyXG4gICAgICAgICAgICAgICAgbXAgPSB0bXA7XHJcblxyXG4gICAgICAgICAgICAgICAgdG1wID0gbjtcclxuICAgICAgICAgICAgICAgIG4gPSBucCAtIChxdW90Km4pO1xyXG4gICAgICAgICAgICAgICAgbnAgPSB0bXA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhID49IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHggPSBtcDtcclxuICAgICAgICAgICAgICAgIHkgPSBucDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4ID0gLW1wO1xyXG4gICAgICAgICAgICB5ID0gLW5wO1xyXG4gICAgICAgICAgICByZXR1cm4gLWE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIGxlYXN0IGNvbW1vbiBtdWx0aXBsZSAoPGM+bGNtPC9jPikgb2YgdHdvIGludGVnZXJzIHVzaW5nIEV1Y2xpZCdzIGFsZ29yaXRobS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFcIj5GaXJzdCBJbnRlZ2VyOiBhLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYlwiPlNlY29uZCBJbnRlZ2VyOiBiLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkxlYXN0IGNvbW1vbiBtdWx0aXBsZSA8Yz5sY208L2M+KGEsYik8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBsb25nIExlYXN0Q29tbW9uTXVsdGlwbGUobG9uZyBhLCBsb25nIGIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoKGEgPT0gMCkgfHwgKGIgPT0gMCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5BYnMoKGEvR3JlYXRlc3RDb21tb25EaXZpc29yKGEsIGIpKSpiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgbGVhc3QgY29tbW9uIG11bHRpcGxlICg8Yz5sY208L2M+KSBvZiBhIHNldCBvZiBpbnRlZ2VycyB1c2luZyBFdWNsaWQncyBhbGdvcml0aG0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnRlZ2Vyc1wiPkxpc3Qgb2YgSW50ZWdlcnMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+TGVhc3QgY29tbW9uIG11bHRpcGxlIDxjPmxjbTwvYz4obGlzdCBvZiBpbnRlZ2Vycyk8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBsb25nIExlYXN0Q29tbW9uTXVsdGlwbGUoSUxpc3Q8bG9uZz4gaW50ZWdlcnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobnVsbCA9PSBpbnRlZ2VycylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImludGVnZXJzXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaW50ZWdlcnMuQ291bnQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBsY20gPSBNYXRoLkFicyhpbnRlZ2Vyc1swXSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGludGVnZXJzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxjbSA9IExlYXN0Q29tbW9uTXVsdGlwbGUobGNtLCBpbnRlZ2Vyc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBsY207XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIGxlYXN0IGNvbW1vbiBtdWx0aXBsZSAoPGM+bGNtPC9jPikgb2YgYSBzZXQgb2YgaW50ZWdlcnMgdXNpbmcgRXVjbGlkJ3MgYWxnb3JpdGhtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW50ZWdlcnNcIj5MaXN0IG9mIEludGVnZXJzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkxlYXN0IGNvbW1vbiBtdWx0aXBsZSA8Yz5sY208L2M+KGxpc3Qgb2YgaW50ZWdlcnMpPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgbG9uZyBMZWFzdENvbW1vbk11bHRpcGxlKHBhcmFtcyBsb25nW10gaW50ZWdlcnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTGVhc3RDb21tb25NdWx0aXBsZSgoSUxpc3Q8bG9uZz4paW50ZWdlcnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvciAoPGM+Z2NkPC9jPikgb2YgdHdvIGJpZyBpbnRlZ2Vycy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFcIj5GaXJzdCBJbnRlZ2VyOiBhLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYlwiPlNlY29uZCBJbnRlZ2VyOiBiLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIDxjPmdjZDwvYz4oYSxiKTwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGRvdWJsZSBHcmVhdGVzdENvbW1vbkRpdmlzb3IoZG91YmxlIGEsIGRvdWJsZSBiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGIgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRvdWJsZSByID0gYSAlIGI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gR3JlYXRlc3RDb21tb25EaXZpc29yKGIsIHIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvciAoPGM+Z2NkPC9jPikgb2YgYSBzZXQgb2YgYmlnIGludGVnZXJzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW50ZWdlcnNcIj5MaXN0IG9mIEludGVnZXJzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIDxjPmdjZDwvYz4obGlzdCBvZiBpbnRlZ2Vycyk8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBkb3VibGUgR3JlYXRlc3RDb21tb25EaXZpc29yKElMaXN0PGRvdWJsZT4gaW50ZWdlcnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobnVsbCA9PSBpbnRlZ2VycylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImludGVnZXJzXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaW50ZWdlcnMuQ291bnQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBnY2QgPSBNYXRoLkFicyhpbnRlZ2Vyc1swXSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMTsgKGkgPCBpbnRlZ2Vycy5Db3VudCkgJiYgKGdjZCA+IDEuMCk7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2NkID0gR3JlYXRlc3RDb21tb25EaXZpc29yKGdjZCwgaW50ZWdlcnNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZ2NkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvciAoPGM+Z2NkPC9jPikgb2YgYSBzZXQgb2YgYmlnIGludGVnZXJzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW50ZWdlcnNcIj5MaXN0IG9mIEludGVnZXJzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIDxjPmdjZDwvYz4obGlzdCBvZiBpbnRlZ2Vycyk8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBkb3VibGUgR3JlYXRlc3RDb21tb25EaXZpc29yKHBhcmFtcyBkb3VibGVbXSBpbnRlZ2VycylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBHcmVhdGVzdENvbW1vbkRpdmlzb3IoKElMaXN0PGRvdWJsZT4paW50ZWdlcnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgZXh0ZW5kZWQgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3IsIHN1Y2ggdGhhdCBhKnggKyBiKnkgPSA8Yz5nY2Q8L2M+KGEsYikuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhXCI+Rmlyc3QgSW50ZWdlcjogYS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJcIj5TZWNvbmQgSW50ZWdlcjogYi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5SZXN1bHRpbmcgeCwgc3VjaCB0aGF0IGEqeCArIGIqeSA9IDxjPmdjZDwvYz4oYSxiKS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInlcIj5SZXN1bHRpbmcgeSwgc3VjaCB0aGF0IGEqeCArIGIqeSA9IDxjPmdjZDwvYz4oYSxiKTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIDxjPmdjZDwvYz4oYSxiKTwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4YW1wbGU+XHJcbiAgICAgICAgLy8vIDxjb2RlPlxyXG4gICAgICAgIC8vLyBsb25nIHgseSxkO1xyXG4gICAgICAgIC8vLyBkID0gRm4uR3JlYXRlc3RDb21tb25EaXZpc29yKDQ1LDE4LG91dCB4LCBvdXQgeSk7XHJcbiAgICAgICAgLy8vIC0+IGQgPT0gOSAmYW1wOyZhbXA7IHggPT0gMSAmYW1wOyZhbXA7IHkgPT0gLTJcclxuICAgICAgICAvLy8gPC9jb2RlPlxyXG4gICAgICAgIC8vLyBUaGUgPGM+Z2NkPC9jPiBvZiA0NSBhbmQgMTggaXMgOTogMTggPSAyKjksIDQ1ID0gNSo5LiA5ID0gMSo0NSAtMioxOCwgdGhlcmVmb3JlIHg9MSBhbmQgeT0tMi5cclxuICAgICAgICAvLy8gPC9leGFtcGxlPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZG91YmxlIEV4dGVuZGVkR3JlYXRlc3RDb21tb25EaXZpc29yKGRvdWJsZSBhLCBkb3VibGUgYiwgb3V0IGRvdWJsZSB4LCBvdXQgZG91YmxlIHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkb3VibGUgbXAgPSAxLjAsIG5wID0gMC4wLCBtID0gMC4wLCBuID0gMS4wO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKGIhPTApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRvdWJsZSByZW09YSViO1xyXG4gICAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAgICAgZG91YmxlIHF1b3QgPSBhL2I7XHJcbiAgICAgICAgICAgICAgICBhID0gYjtcclxuICAgICAgICAgICAgICAgIGIgPSByZW07XHJcblxyXG4gICAgICAgICAgICAgICAgZG91YmxlIHRtcCA9IG07XHJcbiAgICAgICAgICAgICAgICBtID0gbXAgLSAocXVvdCptKTtcclxuICAgICAgICAgICAgICAgIG1wID0gdG1wO1xyXG5cclxuICAgICAgICAgICAgICAgIHRtcCA9IG47XHJcbiAgICAgICAgICAgICAgICBuID0gbnAgLSAocXVvdCpuKTtcclxuICAgICAgICAgICAgICAgIG5wID0gdG1wO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYSA+PSAwLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHggPSBtcDtcclxuICAgICAgICAgICAgICAgIHkgPSBucDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4ID0gLW1wO1xyXG4gICAgICAgICAgICB5ID0gLW5wO1xyXG4gICAgICAgICAgICByZXR1cm4gLWE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIGxlYXN0IGNvbW1vbiBtdWx0aXBsZSAoPGM+bGNtPC9jPikgb2YgdHdvIGJpZyBpbnRlZ2Vycy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFcIj5GaXJzdCBJbnRlZ2VyOiBhLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYlwiPlNlY29uZCBJbnRlZ2VyOiBiLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkxlYXN0IGNvbW1vbiBtdWx0aXBsZSA8Yz5sY208L2M+KGEsYik8L3JldHVybnM+XHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZG91YmxlIExlYXN0Q29tbW9uTXVsdGlwbGUoZG91YmxlIGEsIGRvdWJsZSBiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGE9PTAuMCB8fCBiPT0wLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLkFicygoYSAvIEdyZWF0ZXN0Q29tbW9uRGl2aXNvcihhLGIpKmIpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgbGVhc3QgY29tbW9uIG11bHRpcGxlICg8Yz5sY208L2M+KSBvZiBhIHNldCBvZiBiaWcgaW50ZWdlcnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnRlZ2Vyc1wiPkxpc3Qgb2YgSW50ZWdlcnMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+TGVhc3QgY29tbW9uIG11bHRpcGxlIDxjPmxjbTwvYz4obGlzdCBvZiBpbnRlZ2Vycyk8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBkb3VibGUgTGVhc3RDb21tb25NdWx0aXBsZShJTGlzdDxkb3VibGU+IGludGVnZXJzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKG51bGwgPT0gaW50ZWdlcnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJpbnRlZ2Vyc1wiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGludGVnZXJzLkNvdW50ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbGNtID0gTWF0aC5BYnMoaW50ZWdlcnNbMF0pO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBpbnRlZ2Vycy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsY20gPSBMZWFzdENvbW1vbk11bHRpcGxlKGxjbSwgaW50ZWdlcnNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbGNtO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBsZWFzdCBjb21tb24gbXVsdGlwbGUgKDxjPmxjbTwvYz4pIG9mIGEgc2V0IG9mIGJpZyBpbnRlZ2Vycy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImludGVnZXJzXCI+TGlzdCBvZiBJbnRlZ2Vycy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5MZWFzdCBjb21tb24gbXVsdGlwbGUgPGM+bGNtPC9jPihsaXN0IG9mIGludGVnZXJzKTwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGRvdWJsZSBMZWFzdENvbW1vbk11bHRpcGxlKHBhcmFtcyBkb3VibGVbXSBpbnRlZ2VycylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBMZWFzdENvbW1vbk11bHRpcGxlKChJTGlzdDxkb3VibGU+KWludGVnZXJzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiQ3JlYXRlTWF0cml4LmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTUgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcblxyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuU3RvcmFnZTtcclxudXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkRvdWJsZS5NYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmE7XHJcblxyXG5uYW1lc3BhY2UgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhXHJcbntcclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgQ3JlYXRlTWF0cml4XHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgbWF0cml4IHN0cmFpZ2h0IGZyb20gYW4gaW5pdGlhbGl6ZWQgbWF0cml4IHN0b3JhZ2UgaW5zdGFuY2UuXHJcbiAgICAgICAgLy8vIElmIHlvdSBoYXZlIGFuIGluc3RhbmNlIG9mIGEgZGlzY3JldGUgc3RvcmFnZSB0eXBlIGluc3RlYWQsIHVzZSB0aGVpciBkaXJlY3QgbWV0aG9kcyBpbnN0ZWFkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gV2l0aFN0b3JhZ2U8VD4oTWF0cml4U3RvcmFnZTxUPiBzdG9yYWdlKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5PZlN0b3JhZ2Uoc3RvcmFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBtYXRyaXggd2l0aCB0aGUgc2FtZSBraW5kIG9mIHRoZSBwcm92aWRlZCBleGFtcGxlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gU2FtZUFzPFQsVFU+KE1hdHJpeDxUVT4gZXhhbXBsZSwgaW50IHJvd3MsIGludCBjb2x1bW5zLCBib29sIGZ1bGx5TXV0YWJsZSA9IGZhbHNlKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICAgICAgd2hlcmUgVFUgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VFU+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TYW1lQXM8VFU+KGV4YW1wbGUsIHJvd3MsIGNvbHVtbnMsIGZ1bGx5TXV0YWJsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBtYXRyaXggd2l0aCB0aGUgc2FtZSBraW5kIGFuZCBkaW1lbnNpb25zIG9mIHRoZSBwcm92aWRlZCBleGFtcGxlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gU2FtZUFzPFQsVFU+KE1hdHJpeDxUVT4gZXhhbXBsZSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuU2FtZUFzPFRVPihleGFtcGxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IG1hdHJpeCB3aXRoIHRoZSBzYW1lIGtpbmQgb2YgdGhlIHByb3ZpZGVkIGV4YW1wbGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTYW1lQXM8VD4oVmVjdG9yPFQ+IGV4YW1wbGUsIGludCByb3dzLCBpbnQgY29sdW1ucylcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuU2FtZUFzKGV4YW1wbGUsIHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgbWF0cml4IHdpdGggYSB0eXBlIHRoYXQgY2FuIHJlcHJlc2VudCBhbmQgaXMgY2xvc2VzdCB0byBib3RoIHByb3ZpZGVkIHNhbXBsZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTYW1lQXM8VD4oTWF0cml4PFQ+IGV4YW1wbGUsIE1hdHJpeDxUPiBvdGhlckV4YW1wbGUsIGludCByb3dzLCBpbnQgY29sdW1ucywgYm9vbCBmdWxseU11dGFibGUgPSBmYWxzZSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuU2FtZUFzKGV4YW1wbGUsIG90aGVyRXhhbXBsZSwgcm93cywgY29sdW1ucywgZnVsbHlNdXRhYmxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IG1hdHJpeCB3aXRoIGEgdHlwZSB0aGF0IGNhbiByZXByZXNlbnQgYW5kIGlzIGNsb3Nlc3QgdG8gYm90aCBwcm92aWRlZCBzYW1wbGVzIGFuZCB0aGUgZGltZW5zaW9ucyBvZiBleGFtcGxlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gU2FtZUFzPFQ+KE1hdHJpeDxUPiBleGFtcGxlLCBNYXRyaXg8VD4gb3RoZXJFeGFtcGxlKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TYW1lQXMoZXhhbXBsZSwgb3RoZXJFeGFtcGxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCB3aXRoIHZhbHVlcyBzYW1wbGVkIGZyb20gdGhlIHByb3ZpZGVkIHJhbmRvbSBkaXN0cmlidXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IHdpdGggdmFsdWVzIHNhbXBsZWQgZnJvbSB0aGUgc3RhbmRhcmQgZGlzdHJpYnV0aW9uIHdpdGggYSBzeXN0ZW0gcmFuZG9tIHNvdXJjZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBwb3NpdGl2ZSBkZWZpbml0ZSBkZW5zZSBtYXRyaXggd2hlcmUgZWFjaCB2YWx1ZSBpcyB0aGUgcHJvZHVjdFxyXG4gICAgICAgIC8vLyBvZiB0d28gc2FtcGxlcyBmcm9tIHRoZSBzdGFuZGFyZCBkaXN0cmlidXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgIFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggc3RyYWlnaHQgZnJvbSBhbiBpbml0aWFsaXplZCBtYXRyaXggc3RvcmFnZSBpbnN0YW5jZS5cclxuICAgICAgICAvLy8gVGhlIHN0b3JhZ2UgaXMgdXNlZCBkaXJlY3RseSB3aXRob3V0IGNvcHlpbmcuXHJcbiAgICAgICAgLy8vIEludGVuZGVkIGZvciBhZHZhbmNlZCBzY2VuYXJpb3Mgd2hlcmUgeW91J3JlIHdvcmtpbmcgZGlyZWN0bHkgd2l0aFxyXG4gICAgICAgIC8vLyBzdG9yYWdlIGZvciBwZXJmb3JtYW5jZSBvciBpbnRlcm9wIHJlYXNvbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBEZW5zZTxUPihEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPiBzdG9yYWdlKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EZW5zZShzdG9yYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucy5cclxuICAgICAgICAvLy8gQWxsIGNlbGxzIG9mIHRoZSBtYXRyaXggd2lsbCBiZSBpbml0aWFsaXplZCB0byB6ZXJvLlxyXG4gICAgICAgIC8vLyBaZXJvLWxlbmd0aCBtYXRyaWNlcyBhcmUgbm90IHN1cHBvcnRlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlPFQ+KGludCByb3dzLCBpbnQgY29sdW1ucylcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuRGVuc2Uocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgZGlyZWN0bHkgYmluZGluZyB0byBhIHJhdyBhcnJheS5cclxuICAgICAgICAvLy8gVGhlIGFycmF5IGlzIGFzc3VtZWQgdG8gYmUgaW4gY29sdW1uLW1ham9yIG9yZGVyIChjb2x1bW4gYnkgY29sdW1uKSBhbmQgaXMgdXNlZCBkaXJlY3RseSB3aXRob3V0IGNvcHlpbmcuXHJcbiAgICAgICAgLy8vIFZlcnkgZWZmaWNpZW50LCBidXQgY2hhbmdlcyB0byB0aGUgYXJyYXkgYW5kIHRoZSBtYXRyaXggd2lsbCBhZmZlY3QgZWFjaCBvdGhlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8c2VlYWxzbyBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb3ctbWFqb3Jfb3JkZXJcIi8+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGVuc2U8VD4oaW50IHJvd3MsIGludCBjb2x1bW5zLCBUW10gc3RvcmFnZSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuRGVuc2Uocm93cywgY29sdW1ucywgc3RvcmFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCB2YWx1ZSB0byB0aGUgc2FtZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlPFQ+KGludCByb3dzLCBpbnQgY29sdW1ucywgVCB2YWx1ZSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuRGVuc2Uocm93cywgY29sdW1ucywgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFuZCBpbml0aWFsaXplIGVhY2ggdmFsdWUgdXNpbmcgdGhlIHByb3ZpZGVkIGluaXQgZnVuY3Rpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBEZW5zZTxUPihpbnQgcm93cywgaW50IGNvbHVtbnMsIEZ1bmM8aW50LCBpbnQsIFQ+IGluaXQpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLkRlbnNlKHJvd3MsIGNvbHVtbnMsIChGdW5jPGludCxpbnQsVD4paW5pdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBkZW5zZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCBkaWFnb25hbCB2YWx1ZSB0byB0aGUgc2FtZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlRGlhZ29uYWw8VD4oaW50IHJvd3MsIGludCBjb2x1bW5zLCBUIHZhbHVlKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EZW5zZURpYWdvbmFsKHJvd3MsIGNvbHVtbnMsIHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIGRlbnNlIG1hdHJpeCBhbmQgaW5pdGlhbGl6ZSBlYWNoIGRpYWdvbmFsIHZhbHVlIHRvIHRoZSBzYW1lIHByb3ZpZGVkIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGVuc2VEaWFnb25hbDxUPihpbnQgb3JkZXIsIFQgdmFsdWUpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLkRlbnNlRGlhZ29uYWwob3JkZXIsIHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIGRlbnNlIG1hdHJpeCBhbmQgaW5pdGlhbGl6ZSBlYWNoIGRpYWdvbmFsIHZhbHVlIHVzaW5nIHRoZSBwcm92aWRlZCBpbml0IGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGVuc2VEaWFnb25hbDxUPihpbnQgcm93cywgaW50IGNvbHVtbnMsIEZ1bmM8aW50LCBUPiBpbml0KVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EZW5zZURpYWdvbmFsKHJvd3MsIGNvbHVtbnMsIChGdW5jPGludCxUPilpbml0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIGRlbnNlIGlkZW50aXR5IG1hdHJpeCB3aXRoIGEgb25lLWRpYWdvbmFsLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGVuc2VJZGVudGl0eTxUPihpbnQgcm93cywgaW50IGNvbHVtbnMpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLkRlbnNlSWRlbnRpdHkocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBkZW5zZSBpZGVudGl0eSBtYXRyaXggd2l0aCBhIG9uZS1kaWFnb25hbC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlSWRlbnRpdHk8VD4oaW50IG9yZGVyKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EZW5zZUlkZW50aXR5KG9yZGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIG90aGVyIG1hdHJpeC5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgb3RoZXIgbWF0cml4LlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlT2ZNYXRyaXg8VD4oTWF0cml4PFQ+IG1hdHJpeClcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuRGVuc2VPZk1hdHJpeChtYXRyaXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdHdvLWRpbWVuc2lvbmFsIGFycmF5LlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBwcm92aWRlZCBhcnJheS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBEZW5zZU9mQXJyYXk8VD4oVFssXSBhcnJheSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuRGVuc2VPZkFycmF5KGFycmF5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGluZGV4ZWQgZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gS2V5cyBtdXN0IGJlIHByb3ZpZGVkIGF0IG1vc3Qgb25jZSwgemVybyBpcyBhc3N1bWVkIGlmIGEga2V5IGlzIG9taXR0ZWQuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGVudW1lcmFibGUuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGVuc2VPZkluZGV4ZWQ8VD4oaW50IHJvd3MsIGludCBjb2x1bW5zLCBJRW51bWVyYWJsZTxUdXBsZTxpbnQsIGludCwgVD4+IGVudW1lcmFibGUpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLkRlbnNlT2ZJbmRleGVkKHJvd3MsIGNvbHVtbnMsIGVudW1lcmFibGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gVGhlIGVudW1lcmFibGUgaXMgYXNzdW1lZCB0byBiZSBpbiBjb2x1bW4tbWFqb3Igb3JkZXIgKGNvbHVtbiBieSBjb2x1bW4pLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlT2ZDb2x1bW5NYWpvcjxUPihpbnQgcm93cywgaW50IGNvbHVtbnMsIElFbnVtZXJhYmxlPFQ+IGNvbHVtbk1ham9yKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EZW5zZU9mQ29sdW1uTWFqb3Iocm93cywgY29sdW1ucywgY29sdW1uTWFqb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gZW51bWVyYWJsZSBvZiBlbnVtZXJhYmxlIGNvbHVtbnMuXHJcbiAgICAgICAgLy8vIEVhY2ggZW51bWVyYWJsZSBpbiB0aGUgbWFzdGVyIGVudW1lcmFibGUgc3BlY2lmaWVzIGEgY29sdW1uLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlcy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBEZW5zZU9mQ29sdW1uczxUPihJRW51bWVyYWJsZTxJRW51bWVyYWJsZTxUPj4gZGF0YSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuRGVuc2VPZkNvbHVtbnMoZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlIG9mIGVudW1lcmFibGUgY29sdW1ucy5cclxuICAgICAgICAvLy8gRWFjaCBlbnVtZXJhYmxlIGluIHRoZSBtYXN0ZXIgZW51bWVyYWJsZSBzcGVjaWZpZXMgYSBjb2x1bW4uXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGVudW1lcmFibGVzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlT2ZDb2x1bW5zPFQ+KGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8SUVudW1lcmFibGU8VD4+IGRhdGEpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLkRlbnNlT2ZDb2x1bW5zKHJvd3MsIGNvbHVtbnMsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IG9mIFQgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBjb2x1bW4gYXJyYXlzLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheXMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGVuc2VPZkNvbHVtbkFycmF5czxUPihwYXJhbXMgVFtdW10gY29sdW1ucylcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuRGVuc2VPZkNvbHVtbkFycmF5cyhjb2x1bW5zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBvZiBUIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gY29sdW1uIGFycmF5cy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXlzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlT2ZDb2x1bW5BcnJheXM8VD4oSUVudW1lcmFibGU8VFtdPiBjb2x1bW5zKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EZW5zZU9mQ29sdW1uQXJyYXlzKGNvbHVtbnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gY29sdW1uIHZlY3RvcnMuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIHZlY3RvcnMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGVuc2VPZkNvbHVtblZlY3RvcnM8VD4ocGFyYW1zIFZlY3RvcjxUPltdIGNvbHVtbnMpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLkRlbnNlT2ZDb2x1bW5WZWN0b3JzKGNvbHVtbnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gY29sdW1uIHZlY3RvcnMuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIHZlY3RvcnMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGVuc2VPZkNvbHVtblZlY3RvcnM8VD4oSUVudW1lcmFibGU8VmVjdG9yPFQ+PiBjb2x1bW5zKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EZW5zZU9mQ29sdW1uVmVjdG9ycyhjb2x1bW5zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGVudW1lcmFibGUgb2YgZW51bWVyYWJsZSByb3dzLlxyXG4gICAgICAgIC8vLyBFYWNoIGVudW1lcmFibGUgaW4gdGhlIG1hc3RlciBlbnVtZXJhYmxlIHNwZWNpZmllcyBhIHJvdy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZXMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGVuc2VPZlJvd3M8VD4oSUVudW1lcmFibGU8SUVudW1lcmFibGU8VD4+IGRhdGEpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLkRlbnNlT2ZSb3dzKGRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gZW51bWVyYWJsZSBvZiBlbnVtZXJhYmxlIHJvd3MuXHJcbiAgICAgICAgLy8vIEVhY2ggZW51bWVyYWJsZSBpbiB0aGUgbWFzdGVyIGVudW1lcmFibGUgc3BlY2lmaWVzIGEgcm93LlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlcy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBEZW5zZU9mUm93czxUPihpbnQgcm93cywgaW50IGNvbHVtbnMsIElFbnVtZXJhYmxlPElFbnVtZXJhYmxlPFQ+PiBkYXRhKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EZW5zZU9mUm93cyhyb3dzLCBjb2x1bW5zLCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBvZiBUIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gcm93IGFycmF5cy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXlzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlT2ZSb3dBcnJheXM8VD4ocGFyYW1zIFRbXVtdIHJvd3MpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLkRlbnNlT2ZSb3dBcnJheXMocm93cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggb2YgVCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHJvdyBhcnJheXMuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGFycmF5cy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBEZW5zZU9mUm93QXJyYXlzPFQ+KElFbnVtZXJhYmxlPFRbXT4gcm93cylcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuRGVuc2VPZlJvd0FycmF5cyhyb3dzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHJvdyB2ZWN0b3JzLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3JzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlT2ZSb3dWZWN0b3JzPFQ+KHBhcmFtcyBWZWN0b3I8VD5bXSByb3dzKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EZW5zZU9mUm93VmVjdG9ycyhyb3dzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHJvdyB2ZWN0b3JzLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3JzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlT2ZSb3dWZWN0b3JzPFQ+KElFbnVtZXJhYmxlPFZlY3RvcjxUPj4gcm93cylcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuRGVuc2VPZlJvd1ZlY3RvcnMocm93cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggd2l0aCB0aGUgZGlhZ29uYWwgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBEZW5zZU9mRGlhZ29uYWxWZWN0b3I8VD4oVmVjdG9yPFQ+IGRpYWdvbmFsKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EZW5zZU9mRGlhZ29uYWxWZWN0b3IoZGlhZ29uYWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IHdpdGggdGhlIGRpYWdvbmFsIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGVuc2VPZkRpYWdvbmFsVmVjdG9yPFQ+KGludCByb3dzLCBpbnQgY29sdW1ucywgVmVjdG9yPFQ+IGRpYWdvbmFsKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EZW5zZU9mRGlhZ29uYWxWZWN0b3Iocm93cywgY29sdW1ucywgZGlhZ29uYWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IHdpdGggdGhlIGRpYWdvbmFsIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gYXJyYXkuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGFycmF5LlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlT2ZEaWFnb25hbEFycmF5PFQ+KFRbXSBkaWFnb25hbClcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuRGVuc2VPZkRpYWdvbmFsQXJyYXkoZGlhZ29uYWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IHdpdGggdGhlIGRpYWdvbmFsIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gYXJyYXkuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGFycmF5LlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlT2ZEaWFnb25hbEFycmF5PFQ+KGludCByb3dzLCBpbnQgY29sdW1ucywgVFtdIGRpYWdvbmFsKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EZW5zZU9mRGlhZ29uYWxBcnJheShyb3dzLCBjb2x1bW5zLCBkaWFnb25hbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggZnJvbSBhIDJEIGFycmF5IG9mIGV4aXN0aW5nIG1hdHJpY2VzLlxyXG4gICAgICAgIC8vLyBUaGUgbWF0cmljZXMgaW4gdGhlIGFycmF5IGFyZSBub3QgcmVxdWlyZWQgdG8gYmUgZGVuc2UgYWxyZWFkeS5cclxuICAgICAgICAvLy8gSWYgdGhlIG1hdHJpY2VzIGRvIG5vdCBhbGlnbiBwcm9wZXJseSwgdGhleSBhcmUgcGxhY2VkIG9uIHRoZSB0b3AgbGVmdFxyXG4gICAgICAgIC8vLyBjb3JuZXIgb2YgdGhlaXIgY2VsbCB3aXRoIHRoZSByZW1haW5pbmcgZmllbGRzIGxlZnQgemVyby5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERlbnNlT2ZNYXRyaXhBcnJheTxUPihNYXRyaXg8VD5bLF0gbWF0cmljZXMpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLkRlbnNlT2ZNYXRyaXhBcnJheShtYXRyaWNlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IHN0cmFpZ2h0IGZyb20gYW4gaW5pdGlhbGl6ZWQgbWF0cml4IHN0b3JhZ2UgaW5zdGFuY2UuXHJcbiAgICAgICAgLy8vIFRoZSBzdG9yYWdlIGlzIHVzZWQgZGlyZWN0bHkgd2l0aG91dCBjb3B5aW5nLlxyXG4gICAgICAgIC8vLyBJbnRlbmRlZCBmb3IgYWR2YW5jZWQgc2NlbmFyaW9zIHdoZXJlIHlvdSdyZSB3b3JraW5nIGRpcmVjdGx5IHdpdGhcclxuICAgICAgICAvLy8gc3RvcmFnZSBmb3IgcGVyZm9ybWFuY2Ugb3IgaW50ZXJvcCByZWFzb25zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gU3BhcnNlPFQ+KFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+IHN0b3JhZ2UpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLlNwYXJzZShzdG9yYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgc3BhcnNlIG1hdHJpeCBvZiBUIHdpdGggdGhlIGdpdmVuIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm93c1wiPlRoZSBudW1iZXIgb2Ygcm93cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtbnNcIj5UaGUgbnVtYmVyIG9mIGNvbHVtbnMuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcGFyc2U8VD4oaW50IHJvd3MsIGludCBjb2x1bW5zKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TcGFyc2Uocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFuZCBpbml0aWFsaXplIGVhY2ggdmFsdWUgdG8gdGhlIHNhbWUgcHJvdmlkZWQgdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcGFyc2U8VD4oaW50IHJvd3MsIGludCBjb2x1bW5zLCBUIHZhbHVlKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TcGFyc2Uocm93cywgY29sdW1ucywgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhbmQgaW5pdGlhbGl6ZSBlYWNoIHZhbHVlIHVzaW5nIHRoZSBwcm92aWRlZCBpbml0IGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gU3BhcnNlPFQ+KGludCByb3dzLCBpbnQgY29sdW1ucywgRnVuYzxpbnQsIGludCwgVD4gaW5pdClcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuU3BhcnNlKHJvd3MsIGNvbHVtbnMsIChGdW5jPGludCxpbnQsVD4paW5pdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBzcGFyc2UgbWF0cml4IGFuZCBpbml0aWFsaXplIGVhY2ggZGlhZ29uYWwgdmFsdWUgdG8gdGhlIHNhbWUgcHJvdmlkZWQgdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcGFyc2VEaWFnb25hbDxUPihpbnQgcm93cywgaW50IGNvbHVtbnMsIFQgdmFsdWUpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLlNwYXJzZURpYWdvbmFsKHJvd3MsIGNvbHVtbnMsIHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIHNwYXJzZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCBkaWFnb25hbCB2YWx1ZSB0byB0aGUgc2FtZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IFNwYXJzZURpYWdvbmFsPFQ+KGludCBvcmRlciwgVCB2YWx1ZSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuU3BhcnNlRGlhZ29uYWwob3JkZXIsIHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIHNwYXJzZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCBkaWFnb25hbCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgaW5pdCBmdW5jdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IFNwYXJzZURpYWdvbmFsPFQ+KGludCByb3dzLCBpbnQgY29sdW1ucywgRnVuYzxpbnQsIFQ+IGluaXQpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLlNwYXJzZURpYWdvbmFsKHJvd3MsIGNvbHVtbnMsIChGdW5jPGludCxUPilpbml0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIGRlbnNlIGlkZW50aXR5IG1hdHJpeCB3aXRoIGEgb25lLWRpYWdvbmFsLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gU3BhcnNlSWRlbnRpdHk8VD4oaW50IHJvd3MsIGludCBjb2x1bW5zKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TcGFyc2VJZGVudGl0eShyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIGRlbnNlIGlkZW50aXR5IG1hdHJpeCB3aXRoIGEgb25lLWRpYWdvbmFsLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gU3BhcnNlSWRlbnRpdHk8VD4oaW50IG9yZGVyKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TcGFyc2VJZGVudGl0eShvcmRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gb3RoZXIgbWF0cml4LlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBvdGhlciBtYXRyaXguXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gU3BhcnNlT2ZNYXRyaXg8VD4oTWF0cml4PFQ+IG1hdHJpeClcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuU3BhcnNlT2ZNYXRyaXgobWF0cml4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiB0d28tZGltZW5zaW9uYWwgYXJyYXkuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIHByb3ZpZGVkIGFycmF5LlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IFNwYXJzZU9mQXJyYXk8VD4oVFssXSBhcnJheSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuU3BhcnNlT2ZBcnJheShhcnJheSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gaW5kZXhlZCBlbnVtZXJhYmxlLlxyXG4gICAgICAgIC8vLyBLZXlzIG11c3QgYmUgcHJvdmlkZWQgYXQgbW9zdCBvbmNlLCB6ZXJvIGlzIGFzc3VtZWQgaWYgYSBrZXkgaXMgb21pdHRlZC5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcGFyc2VPZkluZGV4ZWQ8VD4oaW50IHJvd3MsIGludCBjb2x1bW5zLCBJRW51bWVyYWJsZTxUdXBsZTxpbnQsIGludCwgVD4+IGVudW1lcmFibGUpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLlNwYXJzZU9mSW5kZXhlZChyb3dzLCBjb2x1bW5zLCBlbnVtZXJhYmxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlLlxyXG4gICAgICAgIC8vLyBUaGUgZW51bWVyYWJsZSBpcyBhc3N1bWVkIHRvIGJlIGluIHJvdy1tYWpvciBvcmRlciAocm93IGJ5IHJvdykuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGVudW1lcmFibGUuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxzZWVhbHNvIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jvdy1tYWpvcl9vcmRlclwiLz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcGFyc2VPZlJvd01ham9yPFQ+KGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8VD4gcm93TWFqb3IpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLlNwYXJzZU9mUm93TWFqb3Iocm93cywgY29sdW1ucywgcm93TWFqb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICAgIC8vLyBUaGUgYXJyYXkgaXMgYXNzdW1lZCB0byBiZSBpbiBjb2x1bW4tbWFqb3Igb3JkZXIgKGNvbHVtbiBieSBjb2x1bW4pLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBwcm92aWRlZCBhcnJheS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHNlZWFsc28gaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm93LW1ham9yX29yZGVyXCIvPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IFNwYXJzZU9mQ29sdW1uTWFqb3I8VD4oaW50IHJvd3MsIGludCBjb2x1bW5zLCBJTGlzdDxUPiBjb2x1bW5NYWpvcilcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuU3BhcnNlT2ZDb2x1bW5NYWpvcihyb3dzLCBjb2x1bW5zLCBjb2x1bW5NYWpvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gZW51bWVyYWJsZSBvZiBlbnVtZXJhYmxlIGNvbHVtbnMuXHJcbiAgICAgICAgLy8vIEVhY2ggZW51bWVyYWJsZSBpbiB0aGUgbWFzdGVyIGVudW1lcmFibGUgc3BlY2lmaWVzIGEgY29sdW1uLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlcy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcGFyc2VPZkNvbHVtbnM8VD4oSUVudW1lcmFibGU8SUVudW1lcmFibGU8VD4+IGRhdGEpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLlNwYXJzZU9mQ29sdW1ucyhkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlIG9mIGVudW1lcmFibGUgY29sdW1ucy5cclxuICAgICAgICAvLy8gRWFjaCBlbnVtZXJhYmxlIGluIHRoZSBtYXN0ZXIgZW51bWVyYWJsZSBzcGVjaWZpZXMgYSBjb2x1bW4uXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGVudW1lcmFibGVzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IFNwYXJzZU9mQ29sdW1uczxUPihpbnQgcm93cywgaW50IGNvbHVtbnMsIElFbnVtZXJhYmxlPElFbnVtZXJhYmxlPFQ+PiBkYXRhKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TcGFyc2VPZkNvbHVtbnMocm93cywgY29sdW1ucywgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gY29sdW1uIGFycmF5cy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXlzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IFNwYXJzZU9mQ29sdW1uQXJyYXlzPFQ+KHBhcmFtcyBUW11bXSBjb2x1bW5zKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TcGFyc2VPZkNvbHVtbkFycmF5cyhjb2x1bW5zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBjb2x1bW4gYXJyYXlzLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheXMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gU3BhcnNlT2ZDb2x1bW5BcnJheXM8VD4oSUVudW1lcmFibGU8VFtdPiBjb2x1bW5zKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TcGFyc2VPZkNvbHVtbkFycmF5cyhjb2x1bW5zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBjb2x1bW4gdmVjdG9ycy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9ycy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcGFyc2VPZkNvbHVtblZlY3RvcnM8VD4ocGFyYW1zIFZlY3RvcjxUPltdIGNvbHVtbnMpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLlNwYXJzZU9mQ29sdW1uVmVjdG9ycyhjb2x1bW5zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBjb2x1bW4gdmVjdG9ycy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9ycy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcGFyc2VPZkNvbHVtblZlY3RvcnM8VD4oSUVudW1lcmFibGU8VmVjdG9yPFQ+PiBjb2x1bW5zKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TcGFyc2VPZkNvbHVtblZlY3RvcnMoY29sdW1ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gZW51bWVyYWJsZSBvZiBlbnVtZXJhYmxlIHJvd3MuXHJcbiAgICAgICAgLy8vIEVhY2ggZW51bWVyYWJsZSBpbiB0aGUgbWFzdGVyIGVudW1lcmFibGUgc3BlY2lmaWVzIGEgcm93LlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlcy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcGFyc2VPZlJvd3M8VD4oSUVudW1lcmFibGU8SUVudW1lcmFibGU8VD4+IGRhdGEpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLlNwYXJzZU9mUm93cyhkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlIG9mIGVudW1lcmFibGUgcm93cy5cclxuICAgICAgICAvLy8gRWFjaCBlbnVtZXJhYmxlIGluIHRoZSBtYXN0ZXIgZW51bWVyYWJsZSBzcGVjaWZpZXMgYSByb3cuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGVudW1lcmFibGVzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IFNwYXJzZU9mUm93czxUPihpbnQgcm93cywgaW50IGNvbHVtbnMsIElFbnVtZXJhYmxlPElFbnVtZXJhYmxlPFQ+PiBkYXRhKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TcGFyc2VPZlJvd3Mocm93cywgY29sdW1ucywgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gcm93IGFycmF5cy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXlzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IFNwYXJzZU9mUm93QXJyYXlzPFQ+KHBhcmFtcyBUW11bXSByb3dzKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TcGFyc2VPZlJvd0FycmF5cyhyb3dzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiByb3cgYXJyYXlzLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheXMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gU3BhcnNlT2ZSb3dBcnJheXM8VD4oSUVudW1lcmFibGU8VFtdPiByb3dzKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TcGFyc2VPZlJvd0FycmF5cyhyb3dzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiByb3cgdmVjdG9ycy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9ycy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcGFyc2VPZlJvd1ZlY3RvcnM8VD4ocGFyYW1zIFZlY3RvcjxUPltdIHJvd3MpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLlNwYXJzZU9mUm93VmVjdG9ycyhyb3dzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiByb3cgdmVjdG9ycy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9ycy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcGFyc2VPZlJvd1ZlY3RvcnM8VD4oSUVudW1lcmFibGU8VmVjdG9yPFQ+PiByb3dzKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TcGFyc2VPZlJvd1ZlY3RvcnMocm93cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IHdpdGggdGhlIGRpYWdvbmFsIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gU3BhcnNlT2ZEaWFnb25hbFZlY3RvcjxUPihWZWN0b3I8VD4gZGlhZ29uYWwpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLlNwYXJzZU9mRGlhZ29uYWxWZWN0b3IoZGlhZ29uYWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCB3aXRoIHRoZSBkaWFnb25hbCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHZlY3Rvci5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IFNwYXJzZU9mRGlhZ29uYWxWZWN0b3I8VD4oaW50IHJvd3MsIGludCBjb2x1bW5zLCBWZWN0b3I8VD4gZGlhZ29uYWwpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLlNwYXJzZU9mRGlhZ29uYWxWZWN0b3Iocm93cywgY29sdW1ucywgZGlhZ29uYWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCB3aXRoIHRoZSBkaWFnb25hbCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcGFyc2VPZkRpYWdvbmFsQXJyYXk8VD4oVFtdIGRpYWdvbmFsKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5TcGFyc2VPZkRpYWdvbmFsQXJyYXkoZGlhZ29uYWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCB3aXRoIHRoZSBkaWFnb25hbCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcGFyc2VPZkRpYWdvbmFsQXJyYXk8VD4oaW50IHJvd3MsIGludCBjb2x1bW5zLCBUW10gZGlhZ29uYWwpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLlNwYXJzZU9mRGlhZ29uYWxBcnJheShyb3dzLCBjb2x1bW5zLCBkaWFnb25hbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGZyb20gYSAyRCBhcnJheSBvZiBleGlzdGluZyBtYXRyaWNlcy5cclxuICAgICAgICAvLy8gVGhlIG1hdHJpY2VzIGluIHRoZSBhcnJheSBhcmUgbm90IHJlcXVpcmVkIHRvIGJlIHNwYXJzZSBhbHJlYWR5LlxyXG4gICAgICAgIC8vLyBJZiB0aGUgbWF0cmljZXMgZG8gbm90IGFsaWduIHByb3Blcmx5LCB0aGV5IGFyZSBwbGFjZWQgb24gdGhlIHRvcCBsZWZ0XHJcbiAgICAgICAgLy8vIGNvcm5lciBvZiB0aGVpciBjZWxsIHdpdGggdGhlIHJlbWFpbmluZyBmaWVsZHMgbGVmdCB6ZXJvLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gU3BhcnNlT2ZNYXRyaXhBcnJheTxUPihNYXRyaXg8VD5bLF0gbWF0cmljZXMpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLlNwYXJzZU9mTWF0cml4QXJyYXkobWF0cmljZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgbWF0cml4IHN0cmFpZ2h0IGZyb20gYW4gaW5pdGlhbGl6ZWQgbWF0cml4IHN0b3JhZ2UgaW5zdGFuY2UuXHJcbiAgICAgICAgLy8vIFRoZSBzdG9yYWdlIGlzIHVzZWQgZGlyZWN0bHkgd2l0aG91dCBjb3B5aW5nLlxyXG4gICAgICAgIC8vLyBJbnRlbmRlZCBmb3IgYWR2YW5jZWQgc2NlbmFyaW9zIHdoZXJlIHlvdSdyZSB3b3JraW5nIGRpcmVjdGx5IHdpdGhcclxuICAgICAgICAvLy8gc3RvcmFnZSBmb3IgcGVyZm9ybWFuY2Ugb3IgaW50ZXJvcCByZWFzb25zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGlhZ29uYWw8VD4oRGlhZ29uYWxNYXRyaXhTdG9yYWdlPFQ+IHN0b3JhZ2UpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLkRpYWdvbmFsKHN0b3JhZ2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgbWF0cml4IHdpdGggdGhlIGdpdmVuIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zLlxyXG4gICAgICAgIC8vLyBBbGwgY2VsbHMgb2YgdGhlIG1hdHJpeCB3aWxsIGJlIGluaXRpYWxpemVkIHRvIHplcm8uXHJcbiAgICAgICAgLy8vIFplcm8tbGVuZ3RoIG1hdHJpY2VzIGFyZSBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGlhZ29uYWw8VD4oaW50IHJvd3MsIGludCBjb2x1bW5zKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EaWFnb25hbChyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBkaXJlY3RseSBiaW5kaW5nIHRvIGEgcmF3IGFycmF5LlxyXG4gICAgICAgIC8vLyBUaGUgYXJyYXkgaXMgYXNzdW1lZCB0byByZXByZXNlbnQgdGhlIGRpYWdvbmFsIHZhbHVlcyBhbmQgaXMgdXNlZCBkaXJlY3RseSB3aXRob3V0IGNvcHlpbmcuXHJcbiAgICAgICAgLy8vIFZlcnkgZWZmaWNpZW50LCBidXQgY2hhbmdlcyB0byB0aGUgYXJyYXkgYW5kIHRoZSBtYXRyaXggd2lsbCBhZmZlY3QgZWFjaCBvdGhlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERpYWdvbmFsPFQ+KGludCByb3dzLCBpbnQgY29sdW1ucywgVFtdIHN0b3JhZ2UpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLkRpYWdvbmFsKHJvd3MsIGNvbHVtbnMsIHN0b3JhZ2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3F1YXJlIGRpYWdvbmFsIG1hdHJpeCBkaXJlY3RseSBiaW5kaW5nIHRvIGEgcmF3IGFycmF5LlxyXG4gICAgICAgIC8vLyBUaGUgYXJyYXkgaXMgYXNzdW1lZCB0byByZXByZXNlbnQgdGhlIGRpYWdvbmFsIHZhbHVlcyBhbmQgaXMgdXNlZCBkaXJlY3RseSB3aXRob3V0IGNvcHlpbmcuXHJcbiAgICAgICAgLy8vIFZlcnkgZWZmaWNpZW50LCBidXQgY2hhbmdlcyB0byB0aGUgYXJyYXkgYW5kIHRoZSBtYXRyaXggd2lsbCBhZmZlY3QgZWFjaCBvdGhlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERpYWdvbmFsPFQ+KFRbXSBzdG9yYWdlKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EaWFnb25hbChzdG9yYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIG1hdHJpeCBhbmQgaW5pdGlhbGl6ZSBlYWNoIGRpYWdvbmFsIHZhbHVlIHRvIHRoZSBzYW1lIHByb3ZpZGVkIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGlhZ29uYWw8VD4oaW50IHJvd3MsIGludCBjb2x1bW5zLCBUIHZhbHVlKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EaWFnb25hbChyb3dzLCBjb2x1bW5zLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCBkaWFnb25hbCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgaW5pdCBmdW5jdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERpYWdvbmFsPFQ+KGludCByb3dzLCBpbnQgY29sdW1ucywgRnVuYzxpbnQsIFQ+IGluaXQpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLkRpYWdvbmFsKHJvd3MsIGNvbHVtbnMsIChGdW5jPGludCxUPilpbml0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIGlkZW50aXR5IG1hdHJpeCB3aXRoIGEgb25lLWRpYWdvbmFsLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGlhZ29uYWxJZGVudGl0eTxUPihpbnQgcm93cywgaW50IGNvbHVtbnMpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4QnVpbGRlcjxUPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4O1xyXG4gICAgICAgICAgICByZXR1cm4gbV9idWlsZGVyLkRpYWdvbmFsSWRlbnRpdHkocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBpZGVudGl0eSBtYXRyaXggd2l0aCBhIG9uZS1kaWFnb25hbC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERpYWdvbmFsSWRlbnRpdHk8VD4oaW50IG9yZGVyKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EaWFnb25hbElkZW50aXR5KG9yZGVyKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBtYXRyaXggd2l0aCB0aGUgZGlhZ29uYWwgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBEaWFnb25hbE9mRGlhZ29uYWxWZWN0b3I8VD4oVmVjdG9yPFQ+IGRpYWdvbmFsKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EaWFnb25hbE9mRGlhZ29uYWxWZWN0b3IoZGlhZ29uYWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgbWF0cml4IHdpdGggdGhlIGRpYWdvbmFsIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gRGlhZ29uYWxPZkRpYWdvbmFsVmVjdG9yPFQ+KGludCByb3dzLCBpbnQgY29sdW1ucywgVmVjdG9yPFQ+IGRpYWdvbmFsKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EaWFnb25hbE9mRGlhZ29uYWxWZWN0b3Iocm93cywgY29sdW1ucywgZGlhZ29uYWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgbWF0cml4IHdpdGggdGhlIGRpYWdvbmFsIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gYXJyYXkuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGFycmF5LlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERpYWdvbmFsT2ZEaWFnb25hbEFycmF5PFQ+KFRbXSBkaWFnb25hbClcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcbiAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuRGlhZ29uYWxPZkRpYWdvbmFsQXJyYXkoZGlhZ29uYWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgbWF0cml4IHdpdGggdGhlIGRpYWdvbmFsIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gYXJyYXkuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGFycmF5LlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IERpYWdvbmFsT2ZEaWFnb25hbEFycmF5PFQ+KGludCByb3dzLCBpbnQgY29sdW1ucywgVFtdIGRpYWdvbmFsKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAgICAgcmV0dXJuIG1fYnVpbGRlci5EaWFnb25hbE9mRGlhZ29uYWxBcnJheShyb3dzLCBjb2x1bW5zLCBkaWFnb25hbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiQ3JlYXRlVmVjdG9yLmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTUgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGUuTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhO1xyXG5cclxubmFtZXNwYWNlIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYVxyXG57XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIENyZWF0ZVZlY3RvclxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHZlY3RvciBzdHJhaWdodCBmcm9tIGFuIGluaXRpYWxpemVkIG1hdHJpeCBzdG9yYWdlIGluc3RhbmNlLlxyXG4gICAgICAgIC8vLyBJZiB5b3UgaGF2ZSBhbiBpbnN0YW5jZSBvZiBhIGRpc2NyZXRlIHN0b3JhZ2UgdHlwZSBpbnN0ZWFkLCB1c2UgdGhlaXIgZGlyZWN0IG1ldGhvZHMgaW5zdGVhZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyB2ZWN0b3Igd2l0aCB0aGUgc2FtZSBraW5kIG9mIHRoZSBwcm92aWRlZCBleGFtcGxlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gU2FtZUFzPFQsVFU+KFZlY3RvcjxUVT4gZXhhbXBsZSwgaW50IGxlbmd0aClcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3JCdWlsZGVyPFQ+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiB2X2J1aWxkZXIuU2FtZUFzPFRVPihleGFtcGxlLCBsZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgdmVjdG9yIHdpdGggdGhlIHNhbWUga2luZCBhbmQgZGltZW5zaW9uIG9mIHRoZSBwcm92aWRlZCBleGFtcGxlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gU2FtZUFzPFQsVFU+KFZlY3RvcjxUVT4gZXhhbXBsZSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3JCdWlsZGVyPFQ+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiB2X2J1aWxkZXIuU2FtZUFzPFRVPihleGFtcGxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHZlY3RvciB3aXRoIHRoZSBzYW1lIGtpbmQgb2YgdGhlIHByb3ZpZGVkIGV4YW1wbGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljICBWZWN0b3I8VD4gU2FtZUFzPFQsVFU+KE1hdHJpeDxUVT4gZXhhbXBsZSwgaW50IGxlbmd0aClcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3JCdWlsZGVyPFQ+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3I7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdl9idWlsZGVyLlNhbWVBczxUVT4oZXhhbXBsZSwgbGVuZ3RoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHZlY3RvciB3aXRoIGEgdHlwZSB0aGF0IGNhbiByZXByZXNlbnQgYW5kIGlzIGNsb3Nlc3QgdG8gYm90aCBwcm92aWRlZCBzYW1wbGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gU2FtZUFzPFQ+KFZlY3RvcjxUPiBleGFtcGxlLCBWZWN0b3I8VD4gb3RoZXJFeGFtcGxlLCBpbnQgbGVuZ3RoKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvckJ1aWxkZXI8VD4gdl9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+LlZlY3RvcjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2X2J1aWxkZXIuU2FtZUFzKGV4YW1wbGUsIG90aGVyRXhhbXBsZSwgbGVuZ3RoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHZlY3RvciB3aXRoIGEgdHlwZSB0aGF0IGNhbiByZXByZXNlbnQgYW5kIGlzIGNsb3Nlc3QgdG8gYm90aCBwcm92aWRlZCBzYW1wbGVzIGFuZCB0aGUgZGltZW5zaW9ucyBvZiBleGFtcGxlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gU2FtZUFzPFQ+KFZlY3RvcjxUPiBleGFtcGxlLCBWZWN0b3I8VD4gb3RoZXJFeGFtcGxlKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvckJ1aWxkZXI8VD4gdl9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+LlZlY3RvcjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2X2J1aWxkZXIuU2FtZUFzKGV4YW1wbGUsIG90aGVyRXhhbXBsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyB2ZWN0b3Igd2l0aCBhIHR5cGUgdGhhdCBjYW4gcmVwcmVzZW50IGFuZCBpcyBjbG9zZXN0IHRvIGJvdGggcHJvdmlkZWQgc2FtcGxlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IFNhbWVBczxUPihNYXRyaXg8VD4gbWF0cml4LCBWZWN0b3I8VD4gdmVjdG9yLCBpbnQgbGVuZ3RoKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvckJ1aWxkZXI8VD4gdl9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+LlZlY3RvcjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2X2J1aWxkZXIuU2FtZUFzKG1hdHJpeCwgdmVjdG9yLCBsZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgdmVjdG9yIHdpdGggdmFsdWVzIHNhbXBsZWQgZnJvbSB0aGUgcHJvdmlkZWQgcmFuZG9tIGRpc3RyaWJ1dGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIHZlY3RvciB3aXRoIHZhbHVlcyBzYW1wbGVkIGZyb20gdGhlIHN0YW5kYXJkIGRpc3RyaWJ1dGlvbiB3aXRoIGEgc3lzdGVtIHJhbmRvbSBzb3VyY2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgdmVjdG9yIHdpdGggdmFsdWVzIHNhbXBsZWQgZnJvbSB0aGUgc3RhbmRhcmQgZGlzdHJpYnV0aW9uIHdpdGggYSBzeXN0ZW0gcmFuZG9tIHNvdXJjZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3Igc3RyYWlnaHQgZnJvbSBhbiBpbml0aWFsaXplZCB2ZWN0b3Igc3RvcmFnZSBpbnN0YW5jZS5cclxuICAgICAgICAvLy8gVGhlIHN0b3JhZ2UgaXMgdXNlZCBkaXJlY3RseSB3aXRob3V0IGNvcHlpbmcuXHJcbiAgICAgICAgLy8vIEludGVuZGVkIGZvciBhZHZhbmNlZCBzY2VuYXJpb3Mgd2hlcmUgeW91J3JlIHdvcmtpbmcgZGlyZWN0bHkgd2l0aFxyXG4gICAgICAgIC8vLyBzdG9yYWdlIGZvciBwZXJmb3JtYW5jZSBvciBpbnRlcm9wIHJlYXNvbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBkZW5zZSB2ZWN0b3Igb2YgVCB3aXRoIHRoZSBnaXZlbiBzaXplLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2l6ZVwiPlRoZSBzaXplIG9mIHRoZSB2ZWN0b3IuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBEZW5zZTxUPihpbnQgc2l6ZSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3JCdWlsZGVyPFQ+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3I7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdl9idWlsZGVyLkRlbnNlKHNpemUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBkZW5zZSB2ZWN0b3Igb2YgVCB0aGF0IGlzIGRpcmVjdGx5IGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgYXJyYXkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBEZW5zZTxUPihUW10gYXJyYXkpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yQnVpbGRlcjxUPiB2X2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uVmVjdG9yO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZfYnVpbGRlci5EZW5zZShhcnJheSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3IgYW5kIGluaXRpYWxpemUgZWFjaCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBEZW5zZTxUPihpbnQgbGVuZ3RoLCBUIHZhbHVlKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvckJ1aWxkZXI8VD4gdl9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+LlZlY3RvcjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2X2J1aWxkZXIuRGVuc2UobGVuZ3RoLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3IgYW5kIGluaXRpYWxpemUgZWFjaCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgaW5pdCBmdW5jdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IERlbnNlPFQ+KGludCBsZW5ndGgsIEZ1bmM8aW50LCBUPiBpbml0KVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvckJ1aWxkZXI8VD4gdl9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+LlZlY3RvcjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2X2J1aWxkZXIuRGVuc2UobGVuZ3RoLCAoRnVuYzxpbnQsVD4paW5pdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3IgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBvdGhlciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IHZlY3RvciB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIG90aGVyIHZlY3Rvci5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBEZW5zZU9mVmVjdG9yPFQ+KFZlY3RvcjxUPiB2ZWN0b3IpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yQnVpbGRlcjxUPiB2X2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uVmVjdG9yO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZfYnVpbGRlci5EZW5zZU9mVmVjdG9yKHZlY3Rvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3IgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBhcnJheS5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgdmVjdG9yIHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXkuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gRGVuc2VPZkFycmF5PFQ+KFRbXSBhcnJheSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3JCdWlsZGVyPFQ+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3I7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdl9idWlsZGVyLkRlbnNlT2ZBcnJheShhcnJheSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3IgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyB2ZWN0b3Igd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IERlbnNlT2ZFbnVtZXJhYmxlPFQ+KElFbnVtZXJhYmxlPFQ+IGVudW1lcmFibGUpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yQnVpbGRlcjxUPiB2X2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uVmVjdG9yO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZfYnVpbGRlci5EZW5zZU9mRW51bWVyYWJsZShlbnVtZXJhYmxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIHZlY3RvciBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGluZGV4ZWQgZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gS2V5cyBtdXN0IGJlIHByb3ZpZGVkIGF0IG1vc3Qgb25jZSwgemVybyBpcyBhc3N1bWVkIGlmIGEga2V5IGlzIG9taXR0ZWQuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IHZlY3RvciB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGVudW1lcmFibGUuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gRGVuc2VPZkluZGV4ZWQ8VD4oaW50IGxlbmd0aCwgSUVudW1lcmFibGU8VHVwbGU8aW50LCBUPj4gZW51bWVyYWJsZSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3JCdWlsZGVyPFQ+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3I7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdl9idWlsZGVyLkRlbnNlT2ZJbmRleGVkKGxlbmd0aCwgZW51bWVyYWJsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgdmVjdG9yIHN0cmFpZ2h0IGZyb20gYW4gaW5pdGlhbGl6ZWQgdmVjdG9yIHN0b3JhZ2UgaW5zdGFuY2UuXHJcbiAgICAgICAgLy8vIFRoZSBzdG9yYWdlIGlzIHVzZWQgZGlyZWN0bHkgd2l0aG91dCBjb3B5aW5nLlxyXG4gICAgICAgIC8vLyBJbnRlbmRlZCBmb3IgYWR2YW5jZWQgc2NlbmFyaW9zIHdoZXJlIHlvdSdyZSB3b3JraW5nIGRpcmVjdGx5IHdpdGhcclxuICAgICAgICAvLy8gc3RvcmFnZSBmb3IgcGVyZm9ybWFuY2Ugb3IgaW50ZXJvcCByZWFzb25zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgc3BhcnNlIHZlY3RvciBvZiBUIHdpdGggdGhlIGdpdmVuIHNpemUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzaXplXCI+VGhlIHNpemUgb2YgdGhlIHZlY3Rvci48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IFNwYXJzZTxUPihpbnQgc2l6ZSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3JCdWlsZGVyPFQ+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3I7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdl9idWlsZGVyLlNwYXJzZShzaXplKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSB2ZWN0b3IgYW5kIGluaXRpYWxpemUgZWFjaCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBTcGFyc2U8VD4oaW50IGxlbmd0aCwgVCB2YWx1ZSlcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3JCdWlsZGVyPFQ+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3I7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdl9idWlsZGVyLlNwYXJzZShsZW5ndGgsIHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSB2ZWN0b3IgYW5kIGluaXRpYWxpemUgZWFjaCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgaW5pdCBmdW5jdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IFNwYXJzZTxUPihpbnQgbGVuZ3RoLCBGdW5jPGludCwgVD4gaW5pdClcclxuICAgICAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3JCdWlsZGVyPFQ+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3I7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdl9idWlsZGVyLlNwYXJzZShsZW5ndGgsIChGdW5jPGludCxUPilpbml0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSB2ZWN0b3IgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBvdGhlciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IHZlY3RvciB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIG90aGVyIHZlY3Rvci5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBTcGFyc2VPZlZlY3RvcjxUPihWZWN0b3I8VD4gdmVjdG9yKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvckJ1aWxkZXI8VD4gdl9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+LlZlY3RvcjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2X2J1aWxkZXIuU3BhcnNlT2ZWZWN0b3IodmVjdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSB2ZWN0b3IgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBhcnJheS5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgdmVjdG9yIHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXkuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gU3BhcnNlT2ZBcnJheTxUPihUW10gYXJyYXkpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yQnVpbGRlcjxUPiB2X2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uVmVjdG9yO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZfYnVpbGRlci5TcGFyc2VPZkFycmF5KGFycmF5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSB2ZWN0b3IgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyB2ZWN0b3Igd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IFNwYXJzZU9mRW51bWVyYWJsZTxUPihJRW51bWVyYWJsZTxUPiBlbnVtZXJhYmxlKVxyXG4gICAgICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvckJ1aWxkZXI8VD4gdl9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+LlZlY3RvcjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2X2J1aWxkZXIuU3BhcnNlT2ZFbnVtZXJhYmxlKGVudW1lcmFibGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIHZlY3RvciBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGluZGV4ZWQgZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gS2V5cyBtdXN0IGJlIHByb3ZpZGVkIGF0IG1vc3Qgb25jZSwgemVybyBpcyBhc3N1bWVkIGlmIGEga2V5IGlzIG9taXR0ZWQuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IHZlY3RvciB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGVudW1lcmFibGUuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gU3BhcnNlT2ZJbmRleGVkPFQ+KGludCBsZW5ndGgsIElFbnVtZXJhYmxlPFR1cGxlPGludCwgVD4+IGVudW1lcmFibGUpXHJcbiAgICAgICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yQnVpbGRlcjxUPiB2X2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uVmVjdG9yO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZfYnVpbGRlci5TcGFyc2VPZkluZGV4ZWQobGVuZ3RoLCBlbnVtZXJhYmxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiTWF0cml4LkFyaXRobWV0aWMuY3NcIiBjb21wYW55PVwiTWF0aC5ORVRcIj5cclxuLy8gTWF0aC5ORVQgTnVtZXJpY3MsIHBhcnQgb2YgdGhlIE1hdGguTkVUIFByb2plY3RcclxuLy8gaHR0cDovL251bWVyaWNzLm1hdGhkb3RuZXQuY29tXHJcbi8vIGh0dHA6Ly9naXRodWIuY29tL21hdGhuZXQvbWF0aG5ldC1udW1lcmljc1xyXG4vL1xyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNiBNYXRoLk5FVFxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxyXG4vLyBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4vLyBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuLy8gcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXHJcbi8vIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4vLyBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xyXG4vLyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4vLyBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXHJcbi8vIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbi8vIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXHJcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxyXG4vLyBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4vLyBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbi8vIDwvY29weXJpZ2h0PlxyXG5cclxudXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkRvdWJsZS5GYWN0b3JpemF0aW9uO1xyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5MaW5xO1xyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRmFjdG9yaXphdGlvbjtcclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmFcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIERlZmluZXMgdGhlIGJhc2UgY2xhc3MgZm9yIDxjPk1hdHJpeDwvYz4gY2xhc3Nlcy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgcGFydGlhbCBjbGFzcyBNYXRyaXg8VD5cclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSB2YWx1ZSBvZiAxLjAuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFQgT25lID0gRG91YmxlLk1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5CdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4Lk9uZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgdmFsdWUgb2YgMC4wLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyByZWFkb25seSBUIFplcm8gPSBEb3VibGUuTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXguWmVybztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOZWdhdGUgZWFjaCBlbGVtZW50IG9mIHRoaXMgbWF0cml4IGFuZCBwbGFjZSB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbmVnYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb05lZ2F0ZShNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wbGV4IGNvbmp1Z2F0ZXMgZWFjaCBlbGVtZW50IG9mIHRoaXMgbWF0cml4IGFuZCBwbGFjZSB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgY29uanVnYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb0Nvbmp1Z2F0ZShNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGQgYSBzY2FsYXIgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBhZGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9BZGQoVCBzY2FsYXIsIE1hdHJpeDxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgYW5vdGhlciBtYXRyaXggdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gYWRkIHRvIHRoaXMgbWF0cml4LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiB0aGUgdHdvIG1hdHJpY2VzIGRvbid0IGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucy48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb0FkZChNYXRyaXg8VD4gb3RoZXIsIE1hdHJpeDxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN1YnRyYWN0cyBhIHNjYWxhciBmcm9tIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdG8gc3VidHJhY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9TdWJ0cmFjdChUIHNjYWxhciwgTWF0cml4PFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3VidHJhY3RzIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGZyb20gYSBzY2FsYXIgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBzdWJ0cmFjdCBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCB2b2lkIERvU3VidHJhY3RGcm9tKFQgc2NhbGFyLCBNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRG9OZWdhdGUocmVzdWx0KTtcclxuICAgICAgICAgICAgcmVzdWx0LkRvQWRkKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3VidHJhY3RzIGFub3RoZXIgbWF0cml4IGZyb20gdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gc3VidHJhY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9TdWJ0cmFjdChNYXRyaXg8VD4gb3RoZXIsIE1hdHJpeDxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIgYW5kIHBsYWNlcyByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIG11bHRpcGx5IHRoZSBtYXRyaXggd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb011bHRpcGx5KFQgc2NhbGFyLCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoaXMgbWF0cml4IHdpdGggYSB2ZWN0b3IgYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb011bHRpcGx5KFZlY3RvcjxUPiByaWdodFNpZGUsIFZlY3RvcjxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9NdWx0aXBseShNYXRyaXg8VD4gb3RoZXIsIE1hdHJpeDxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhpcyBtYXRyaXggd2l0aCB0aGUgdHJhbnNwb3NlIG9mIGFub3RoZXIgbWF0cml4IGFuZCBwbGFjZXMgdGhlIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1RyYW5zcG9zZUFuZE11bHRpcGx5KE1hdHJpeDxUPiBvdGhlciwgTWF0cml4PFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyB0aGlzIG1hdHJpeCB3aXRoIHRoZSBjb25qdWdhdGUgdHJhbnNwb3NlIG9mIGFub3RoZXIgbWF0cml4IGFuZCBwbGFjZXMgdGhlIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb0Nvbmp1Z2F0ZVRyYW5zcG9zZUFuZE11bHRpcGx5KE1hdHJpeDxUPiBvdGhlciwgTWF0cml4PFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyB0aGUgdHJhbnNwb3NlIG9mIHRoaXMgbWF0cml4IHdpdGggYSB2ZWN0b3IgYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1RyYW5zcG9zZVRoaXNBbmRNdWx0aXBseShWZWN0b3I8VD4gcmlnaHRTaWRlLCBWZWN0b3I8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoZSBjb25qdWdhdGUgdHJhbnNwb3NlIG9mIHRoaXMgbWF0cml4IHdpdGggYSB2ZWN0b3IgYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb0Nvbmp1Z2F0ZVRyYW5zcG9zZVRoaXNBbmRNdWx0aXBseShWZWN0b3I8VD4gcmlnaHRTaWRlLCBWZWN0b3I8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9UcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkoTWF0cml4PFQ+IG90aGVyLCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Db25qdWdhdGVUcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkoTWF0cml4PFQ+IG90aGVyLCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEaXZpZGVzIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyIGFuZCBwbGFjZXMgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBzY2FsYXIgZGVub21pbmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvRGl2aWRlKFQgZGl2aXNvciwgTWF0cml4PFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGl2aWRlcyBhIHNjYWxhciBieSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpZGVuZFwiPlRoZSBzY2FsYXIgbnVtZXJhdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgZGl2aXNpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb0RpdmlkZUJ5VGhpcyhUIGRpdmlkZW5kLCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgY2Fub25pY2FsIG1vZHVsdXMsIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpc29yLFxyXG4gICAgICAgIC8vLyBmb3IgdGhlIGdpdmVuIGRpdmlzb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHNjYWxhciBkZW5vbWluYXRvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5NYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb01vZHVsdXMoVCBkaXZpc29yLCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgY2Fub25pY2FsIG1vZHVsdXMsIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpc29yLFxyXG4gICAgICAgIC8vLyBmb3IgdGhlIGdpdmVuIGRpdmlkZW5kIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHNjYWxhciBudW1lcmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+QSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb01vZHVsdXNCeVRoaXMoVCBkaXZpZGVuZCwgTWF0cml4PFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gZm9yIHRoZSBnaXZlbiBkaXZpc29yIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBzY2FsYXIgZGVub21pbmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+TWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9SZW1haW5kZXIoVCBkaXZpc29yLCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgcmVtYWluZGVyICglIG9wZXJhdG9yKSwgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlkZW5kLFxyXG4gICAgICAgIC8vLyBmb3IgdGhlIGdpdmVuIGRpdmlkZW5kIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHNjYWxhciBudW1lcmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+QSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1JlbWFpbmRlckJ5VGhpcyhUIGRpdmlkZW5kLCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgbXVsdGlwbGllcyB0aGlzIG1hdHJpeCB3aXRoIGFub3RoZXIgbWF0cml4IGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIHBvaW50d2lzZSBtdWx0aXBseSB3aXRoIHRoaXMgb25lLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludHdpc2UgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZU11bHRpcGx5KE1hdHJpeDxUPiBvdGhlciwgTWF0cml4PFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGRpdmlkZSB0aGlzIG1hdHJpeCBieSBhbm90aGVyIG1hdHJpeCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgcG9pbnR3aXNlIGRlbm9taW5hdG9yIG1hdHJpeCB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50d2lzZSBkaXZpc2lvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlRGl2aWRlKE1hdHJpeDxUPiBkaXZpc29yLCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgcmFpc2UgdGhpcyBtYXRyaXggdG8gYW4gZXhwb25lbnQgYW5kIHN0b3JlIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImV4cG9uZW50XCI+VGhlIGV4cG9uZW50IHRvIHJhaXNlIHRoaXMgbWF0cml4IHZhbHVlcyB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgcG9pbnR3aXNlIHBvd2VyLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VQb3dlcihUIGV4cG9uZW50LCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgcmFpc2UgdGhpcyBtYXRyaXggdG8gYW4gZXhwb25lbnQgbWF0cml4IGFuZCBzdG9yZSB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJleHBvbmVudFwiPlRoZSBleHBvbmVudCBtYXRyaXggdG8gcmFpc2UgdGhpcyBtYXRyaXggdmFsdWVzIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludHdpc2UgcG93ZXIuPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZVBvd2VyKE1hdHJpeDxUPiBleHBvbmVudCwgTWF0cml4PFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGNhbm9uaWNhbCBtb2R1bHVzLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aXNvcixcclxuICAgICAgICAvLy8gb2YgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgcG9pbnR3aXNlIGRlbm9taW5hdG9yIG1hdHJpeCB0byB1c2U8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG1vZHVsdXMuPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZU1vZHVsdXMoTWF0cml4PFQ+IGRpdmlzb3IsIE1hdHJpeDxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSByZW1haW5kZXIgKCUgb3BlcmF0b3IpLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aWRlbmQsXHJcbiAgICAgICAgLy8vIG9mIHRoaXMgbWF0cml4IHdpdGggYW5vdGhlciBtYXRyaXggYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHBvaW50d2lzZSBkZW5vbWluYXRvciBtYXRyaXggdG8gdXNlPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtb2R1bHVzLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VSZW1haW5kZXIoTWF0cml4PFQ+IGRpdmlzb3IsIE1hdHJpeDxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBleHBvbmVudGlhbCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0LjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VFeHAoTWF0cml4PFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQuPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZUxvZyhNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VBYnMoTWF0cml4PFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VBY29zKE1hdHJpeDxUPiByZXN1bHQpO1xyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlQXNpbihNYXRyaXg8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZUF0YW4oTWF0cml4PFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VDZWlsaW5nKE1hdHJpeDxUPiByZXN1bHQpO1xyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlQ29zKE1hdHJpeDxUPiByZXN1bHQpO1xyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlQ29zaChNYXRyaXg8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZUZsb29yKE1hdHJpeDxUPiByZXN1bHQpO1xyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlTG9nMTAoTWF0cml4PFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VSb3VuZChNYXRyaXg8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZVNpZ24oTWF0cml4PFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VTaW4oTWF0cml4PFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VTaW5oKE1hdHJpeDxUPiByZXN1bHQpO1xyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlU3FydChNYXRyaXg8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZVRhbihNYXRyaXg8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZVRhbmgoTWF0cml4PFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VBdGFuMihNYXRyaXg8VD4gb3RoZXIsIE1hdHJpeDxUPiByZXN1bHQpO1xyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlTWluaW11bShUIHNjYWxhciwgTWF0cml4PFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VNaW5pbXVtKE1hdHJpeDxUPiBvdGhlciwgTWF0cml4PFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VNYXhpbXVtKFQgc2NhbGFyLCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZU1heGltdW0oTWF0cml4PFQ+IG90aGVyLCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZUFic29sdXRlTWluaW11bShUIHNjYWxhciwgTWF0cml4PFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VBYnNvbHV0ZU1pbmltdW0oTWF0cml4PFQ+IG90aGVyLCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZUFic29sdXRlTWF4aW11bShUIHNjYWxhciwgTWF0cml4PFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VBYnNvbHV0ZU1heGltdW0oTWF0cml4PFQ+IG90aGVyLCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGRzIGEgc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBhZGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiB0aGUgdHdvIG1hdHJpY2VzIGRvbid0IGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucy48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IEFkZChUIHNjYWxhcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzY2FsYXIuRXF1YWxzKFplcm8pKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvQWRkKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkcyBhIHNjYWxhciB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIGFkZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgdGhlIHR3byBtYXRyaWNlcyBkb24ndCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkKFQgc2NhbGFyLCBNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uPih0aGlzLCByZXN1bHQsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2NhbGFyLkVxdWFscyhaZXJvKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvQWRkKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkcyBhbm90aGVyIG1hdHJpeCB0byB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB0byBhZGQgdG8gdGhpcyBtYXRyaXguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiB0aGUgdHdvIG1hdHJpY2VzIGRvbid0IGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucy48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IEFkZChNYXRyaXg8VD4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAob3RoZXIuUm93Q291bnQgIT0gUm93Q291bnQgfHwgb3RoZXIuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uPih0aGlzLCBvdGhlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzKHRoaXMsIG90aGVyLCBSb3dDb3VudCwgQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICBEb0FkZChvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkcyBhbm90aGVyIG1hdHJpeCB0byB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB0byBhZGQgdG8gdGhpcyBtYXRyaXguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIHRoZSB0d28gbWF0cmljZXMgZG9uJ3QgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZChNYXRyaXg8VD4gb3RoZXIsIE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAob3RoZXIuUm93Q291bnQgIT0gUm93Q291bnQgfHwgb3RoZXIuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uPih0aGlzLCBvdGhlciwgXCJvdGhlclwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uPih0aGlzLCByZXN1bHQsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb0FkZChvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3VidHJhY3RzIGEgc2NhbGFyIGZyb20gZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIHN1YnRyYWN0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgbmV3IG1hdHJpeCBjb250YWluaW5nIHRoZSBzdWJ0cmFjdGlvbiBvZiB0aGlzIG1hdHJpeCBhbmQgdGhlIHNjYWxhci48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTdWJ0cmFjdChUIHNjYWxhcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzY2FsYXIuRXF1YWxzKFplcm8pKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvU3VidHJhY3Qoc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgYSBzY2FsYXIgZnJvbSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIHN1YnRyYWN0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgbWF0cml4IGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFN1YnRyYWN0KFQgc2NhbGFyLCBNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uPih0aGlzLCByZXN1bHQsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2NhbGFyLkVxdWFscyhaZXJvKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvU3VidHJhY3Qoc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggZnJvbSBhIHNjYWxhci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdG8gc3VidHJhY3QgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIG5ldyBtYXRyaXggY29udGFpbmluZyB0aGUgc3VidHJhY3Rpb24gb2YgdGhlIHNjYWxhciBhbmQgdGhpcyBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3VidHJhY3RGcm9tKFQgc2NhbGFyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvU3VidHJhY3RGcm9tKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3VidHJhY3RzIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGZyb20gYSBzY2FsYXIgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBzdWJ0cmFjdCBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgbWF0cml4IGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFN1YnRyYWN0RnJvbShUIHNjYWxhciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuUm93Q291bnQgIT0gUm93Q291bnQgfHwgcmVzdWx0LkNvbHVtbkNvdW50ICE9IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbj4odGhpcywgcmVzdWx0LCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9TdWJ0cmFjdEZyb20oc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgYW5vdGhlciBtYXRyaXggZnJvbSB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB0byBzdWJ0cmFjdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIHRoZSB0d28gbWF0cmljZXMgZG9uJ3QgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3VidHJhY3QoTWF0cml4PFQ+IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKG90aGVyLlJvd0NvdW50ICE9IFJvd0NvdW50IHx8IG90aGVyLkNvbHVtbkNvdW50ICE9IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbj4odGhpcywgb3RoZXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBcyh0aGlzLCBvdGhlciwgUm93Q291bnQsIENvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgRG9TdWJ0cmFjdChvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3VidHJhY3RzIGFub3RoZXIgbWF0cml4IGZyb20gdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gc3VidHJhY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIHRoZSB0d28gbWF0cmljZXMgZG9uJ3QgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFN1YnRyYWN0KE1hdHJpeDxUPiBvdGhlciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlci5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCBvdGhlci5Db2x1bW5Db3VudCAhPSBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24+KHRoaXMsIG90aGVyLCBcIm90aGVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0LlJvd0NvdW50ICE9IFJvd0NvdW50IHx8IHJlc3VsdC5Db2x1bW5Db3VudCAhPSBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvU3VidHJhY3Qob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgZWFjaCBlbGVtZW50IG9mIHRoaXMgbWF0cml4IHdpdGggYSBzY2FsYXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gTXVsdGlwbHkoVCBzY2FsYXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoc2NhbGFyLkVxdWFscyhPbmUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNjYWxhci5FcXVhbHMoWmVybykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtX2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9NdWx0aXBseShzY2FsYXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIgYW5kIHBsYWNlcyByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIG11bHRpcGx5IHRoZSBtYXRyaXggd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgcmVzdWx0IG1hdHJpeCdzIGRpbWVuc2lvbnMgYXJlIG5vdCB0aGUgc2FtZSBhcyB0aGlzIG1hdHJpeC48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNdWx0aXBseShUIHNjYWxhciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuUm93Q291bnQgIT0gUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeFNhbWVSb3dEaW1lbnNpb25cIiwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeFNhbWVDb2x1bW5EaW1lbnNpb25cIiwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzY2FsYXIuRXF1YWxzKE9uZSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvcHlUbyhyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2NhbGFyLkVxdWFscyhaZXJvKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvTXVsdGlwbHkoc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEaXZpZGVzIGVhY2ggZWxlbWVudCBvZiB0aGlzIG1hdHJpeCB3aXRoIGEgc2NhbGFyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBkaXZpZGUgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbi48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEaXZpZGUoVCBzY2FsYXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoc2NhbGFyLkVxdWFscyhPbmUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNjYWxhci5FcXVhbHMoWmVybykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEaXZpZGVCeVplcm9FeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvRGl2aWRlKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGl2aWRlcyBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhciBhbmQgcGxhY2VzIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdG8gZGl2aWRlIHRoZSBtYXRyaXggd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgZGl2aXNpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgcmVzdWx0IG1hdHJpeCdzIGRpbWVuc2lvbnMgYXJlIG5vdCB0aGUgc2FtZSBhcyB0aGlzIG1hdHJpeC48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBEaXZpZGUoVCBzY2FsYXIsIE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LlJvd0NvdW50ICE9IFJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRNYXRyaXhTYW1lUm93RGltZW5zaW9uXCIsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0LkNvbHVtbkNvdW50ICE9IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRNYXRyaXhTYW1lQ29sdW1uRGltZW5zaW9uXCIsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2NhbGFyLkVxdWFscyhPbmUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb3B5VG8ocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNjYWxhci5FcXVhbHMoWmVybykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEaXZpZGVCeVplcm9FeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9EaXZpZGUoc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEaXZpZGVzIGEgc2NhbGFyIGJ5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBkaXZpZGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgZGl2aXNpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gRGl2aWRlQnlUaGlzKFQgc2NhbGFyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvRGl2aWRlQnlUaGlzKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGl2aWRlcyBhIHNjYWxhciBieSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBhbmQgcGxhY2VzIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdG8gZGl2aWRlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSByZXN1bHQgbWF0cml4J3MgZGltZW5zaW9ucyBhcmUgbm90IHRoZSBzYW1lIGFzIHRoaXMgbWF0cml4LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIERpdmlkZUJ5VGhpcyhUIHNjYWxhciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuUm93Q291bnQgIT0gUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeFNhbWVSb3dEaW1lbnNpb25cIiwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeFNhbWVDb2x1bW5EaW1lbnNpb25cIiwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvRGl2aWRlQnlUaGlzKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyB0aGlzIG1hdHJpeCBieSBhIHZlY3RvciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8Yz50aGlzLkNvbHVtbkNvdW50ICE9IHJpZ2h0U2lkZS5Db3VudDwvYz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBNdWx0aXBseShWZWN0b3I8VD4gcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ICE9IHJpZ2h0U2lkZS5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4odGhpcywgcmlnaHRTaWRlLCBcInJpZ2h0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJldCA9IHZfYnVpbGRlci5TYW1lQXModGhpcywgcmlnaHRTaWRlLCBSb3dDb3VudCk7XHJcbiAgICAgICAgICAgIERvTXVsdGlwbHkocmlnaHRTaWRlLCByZXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoaXMgbWF0cml4IHdpdGggYSB2ZWN0b3IgYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8c3Ryb25nPnJlc3VsdC5Db3VudCAhPSB0aGlzLlJvd0NvdW50PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzdHJvbmc+dGhpcy5Db2x1bW5Db3VudCAhPSA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4uQ291bnQ8L3N0cm9uZz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgTXVsdGlwbHkoVmVjdG9yPFQ+IHJpZ2h0U2lkZSwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb2x1bW5Db3VudCAhPSByaWdodFNpZGUuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJpZ2h0U2lkZSwgXCJyaWdodFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChSb3dDb3VudCAhPSByZXN1bHQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHMocmlnaHRTaWRlLCByZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gdl9idWlsZGVyLlNhbWVBczxUPihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgRG9NdWx0aXBseShyaWdodFNpZGUsIHRtcCk7XHJcbiAgICAgICAgICAgICAgICB0bXAuQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEb011bHRpcGx5KHJpZ2h0U2lkZSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBMZWZ0IG11bHRpcGx5IGEgbWF0cml4IHdpdGggYSB2ZWN0b3IgKCA9IHZlY3RvciAqIG1hdHJpeCApLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgdmVjdG9yIHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzdHJvbmc+dGhpcy5Sb3dDb3VudCAhPSA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPi5Db3VudDwvc3Ryb25nPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IExlZnRNdWx0aXBseShWZWN0b3I8VD4gbGVmdFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gbGVmdFNpZGUuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIGxlZnRTaWRlLCBcImxlZnRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmV0ID0gdl9idWlsZGVyLlNhbWVBcyh0aGlzLCBsZWZ0U2lkZSwgQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICBEb0xlZnRNdWx0aXBseShsZWZ0U2lkZSwgcmV0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTGVmdCBtdWx0aXBseSBhIG1hdHJpeCB3aXRoIGEgdmVjdG9yICggPSB2ZWN0b3IgKiBtYXRyaXggKSBhbmQgcGxhY2UgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8c3Ryb25nPnJlc3VsdC5Db3VudCAhPSB0aGlzLkNvbHVtbkNvdW50PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzdHJvbmc+dGhpcy5Sb3dDb3VudCAhPSA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPi5Db3VudDwvc3Ryb25nPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBMZWZ0TXVsdGlwbHkoVmVjdG9yPFQ+IGxlZnRTaWRlLCBWZWN0b3I8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFJvd0NvdW50ICE9IGxlZnRTaWRlLkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCBsZWZ0U2lkZSwgXCJsZWZ0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ICE9IHJlc3VsdC5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4odGhpcywgcmVzdWx0LCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyhsZWZ0U2lkZSwgcmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IHZfYnVpbGRlci5TYW1lQXM8VD4ocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIERvTGVmdE11bHRpcGx5KGxlZnRTaWRlLCB0bXApO1xyXG4gICAgICAgICAgICAgICAgdG1wLkNvcHlUbyhyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRG9MZWZ0TXVsdGlwbHkobGVmdFNpZGUsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTGVmdCBtdWx0aXBseSBhIG1hdHJpeCB3aXRoIGEgdmVjdG9yICggPSB2ZWN0b3IgKiBtYXRyaXggKSBhbmQgcGxhY2UgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgdm9pZCBEb0xlZnRNdWx0aXBseShWZWN0b3I8VD4gbGVmdFNpZGUsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEb1RyYW5zcG9zZVRoaXNBbmRNdWx0aXBseShsZWZ0U2lkZSwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyB0aGlzIG1hdHJpeCB3aXRoIGFub3RoZXIgbWF0cml4IGFuZCBwbGFjZXMgdGhlIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8c3Ryb25nPnRoaXMuQ29sdW1ucyAhPSBvdGhlci5Sb3dzPC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSByZXN1bHQgbWF0cml4J3MgZGltZW5zaW9ucyBhcmUgbm90IHRoZSB0aGlzLlJvd3MgeCBvdGhlci5Db2x1bW5zLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE11bHRpcGx5KE1hdHJpeDxUPiBvdGhlciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb2x1bW5Db3VudCAhPSBvdGhlci5Sb3dDb3VudCB8fCByZXN1bHQuUm93Q291bnQgIT0gUm93Q291bnQgfHwgcmVzdWx0LkNvbHVtbkNvdW50ICE9IG90aGVyLkNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCBvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCByZXN1bHQpIHx8IFJlZmVyZW5jZUVxdWFscyhvdGhlciwgcmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IG1fYnVpbGRlci5TYW1lQXM8VD4ocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIERvTXVsdGlwbHkob3RoZXIsIHRtcCk7XHJcbiAgICAgICAgICAgICAgICB0bXAuQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEb011bHRpcGx5KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8c3Ryb25nPnRoaXMuQ29sdW1ucyAhPSBvdGhlci5Sb3dzPC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBNdWx0aXBseShNYXRyaXg8VD4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gb3RoZXIuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIG90aGVyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXModGhpcywgb3RoZXIsIFJvd0NvdW50LCBvdGhlci5Db2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIERvTXVsdGlwbHkob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhpcyBtYXRyaXggd2l0aCB0cmFuc3Bvc2Ugb2YgYW5vdGhlciBtYXRyaXggYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzdHJvbmc+dGhpcy5Db2x1bW5zICE9IG90aGVyLkNvbHVtbkNvdW50PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSByZXN1bHQgbWF0cml4J3MgZGltZW5zaW9ucyBhcmUgbm90IHRoZSB0aGlzLlJvd0NvdW50IHggb3RoZXIuUm93Q291bnQuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgVHJhbnNwb3NlQW5kTXVsdGlwbHkoTWF0cml4PFQ+IG90aGVyLCBNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ICE9IG90aGVyLkNvbHVtbkNvdW50IHx8IHJlc3VsdC5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gb3RoZXIuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoUmVmZXJlbmNlRXF1YWxzKHRoaXMsIHJlc3VsdCkgfHwgUmVmZXJlbmNlRXF1YWxzKG90aGVyLCByZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gbV9idWlsZGVyLlNhbWVBczxUPihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgRG9UcmFuc3Bvc2VBbmRNdWx0aXBseShvdGhlciwgdG1wKTtcclxuICAgICAgICAgICAgICAgIHRtcC5Db3B5VG8ocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERvVHJhbnNwb3NlQW5kTXVsdGlwbHkob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyB0aGlzIG1hdHJpeCB3aXRoIHRyYW5zcG9zZSBvZiBhbm90aGVyIG1hdHJpeCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8c3Ryb25nPnRoaXMuQ29sdW1ucyAhPSBvdGhlci5Db2x1bW5Db3VudDwvc3Ryb25nPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gVHJhbnNwb3NlQW5kTXVsdGlwbHkoTWF0cml4PFQ+IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ICE9IG90aGVyLkNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCBvdGhlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzKHRoaXMsIG90aGVyLCBSb3dDb3VudCwgb3RoZXIuUm93Q291bnQpO1xyXG4gICAgICAgICAgICBEb1RyYW5zcG9zZUFuZE11bHRpcGx5KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhpcyBtYXRyaXggYnkgYSB2ZWN0b3IgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSB2ZWN0b3IgdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgPGM+dGhpcy5Sb3dDb3VudCAhPSByaWdodFNpZGUuQ291bnQ8L2M+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gVHJhbnNwb3NlVGhpc0FuZE11bHRpcGx5KFZlY3RvcjxUPiByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gcmlnaHRTaWRlLkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCByaWdodFNpZGUsIFwicmlnaHRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBcyh0aGlzLCByaWdodFNpZGUsIENvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgRG9UcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkocmlnaHRTaWRlLCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhpcyBtYXRyaXggd2l0aCBhIHZlY3RvciBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgdmVjdG9yIHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzdHJvbmc+cmVzdWx0LkNvdW50ICE9IHRoaXMuQ29sdW1uQ291bnQ8L3N0cm9uZz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgPHN0cm9uZz50aGlzLlJvd0NvdW50ICE9IDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPi5Db3VudDwvc3Ryb25nPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBUcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkoVmVjdG9yPFQ+IHJpZ2h0U2lkZSwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChSb3dDb3VudCAhPSByaWdodFNpZGUuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJpZ2h0U2lkZSwgXCJyaWdodFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChDb2x1bW5Db3VudCAhPSByZXN1bHQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHMocmlnaHRTaWRlLCByZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gdl9idWlsZGVyLlNhbWVBczxUPihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgRG9UcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkocmlnaHRTaWRlLCB0bXApO1xyXG4gICAgICAgICAgICAgICAgdG1wLkNvcHlUbyhyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRG9UcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkocmlnaHRTaWRlLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhlIHRyYW5zcG9zZSBvZiB0aGlzIG1hdHJpeCB3aXRoIGFub3RoZXIgbWF0cml4IGFuZCBwbGFjZXMgdGhlIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8c3Ryb25nPnRoaXMuUm93cyAhPSBvdGhlci5Sb3dDb3VudDwvc3Ryb25nPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgcmVzdWx0IG1hdHJpeCdzIGRpbWVuc2lvbnMgYXJlIG5vdCB0aGUgdGhpcy5Db2x1bW5Db3VudCB4IG90aGVyLkNvbHVtbkNvdW50LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFRyYW5zcG9zZVRoaXNBbmRNdWx0aXBseShNYXRyaXg8VD4gb3RoZXIsIE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gb3RoZXIuUm93Q291bnQgfHwgcmVzdWx0LlJvd0NvdW50ICE9IENvbHVtbkNvdW50IHx8IHJlc3VsdC5Db2x1bW5Db3VudCAhPSBvdGhlci5Db2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4odGhpcywgb3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHModGhpcywgcmVzdWx0KSB8fCBSZWZlcmVuY2VFcXVhbHMob3RoZXIsIHJlc3VsdCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBtX2J1aWxkZXIuU2FtZUFzPFQ+KHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBEb1RyYW5zcG9zZVRoaXNBbmRNdWx0aXBseShvdGhlciwgdG1wKTtcclxuICAgICAgICAgICAgICAgIHRtcC5Db3B5VG8ocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERvVHJhbnNwb3NlVGhpc0FuZE11bHRpcGx5KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhlIHRyYW5zcG9zZSBvZiB0aGlzIG1hdHJpeCB3aXRoIGFub3RoZXIgbWF0cml4IGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzdHJvbmc+dGhpcy5Sb3dzICE9IG90aGVyLlJvd0NvdW50PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBUcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkoTWF0cml4PFQ+IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFJvd0NvdW50ICE9IG90aGVyLlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCBvdGhlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzKHRoaXMsIG90aGVyLCBDb2x1bW5Db3VudCwgb3RoZXIuQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICBEb1RyYW5zcG9zZVRoaXNBbmRNdWx0aXBseShvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoaXMgbWF0cml4IHdpdGggdGhlIGNvbmp1Z2F0ZSB0cmFuc3Bvc2Ugb2YgYW5vdGhlciBtYXRyaXggYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzdHJvbmc+dGhpcy5Db2x1bW5zICE9IG90aGVyLkNvbHVtbkNvdW50PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSByZXN1bHQgbWF0cml4J3MgZGltZW5zaW9ucyBhcmUgbm90IHRoZSB0aGlzLlJvd0NvdW50IHggb3RoZXIuUm93Q291bnQuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQ29uanVnYXRlVHJhbnNwb3NlQW5kTXVsdGlwbHkoTWF0cml4PFQ+IG90aGVyLCBNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ICE9IG90aGVyLkNvbHVtbkNvdW50IHx8IHJlc3VsdC5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gb3RoZXIuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoUmVmZXJlbmNlRXF1YWxzKHRoaXMsIHJlc3VsdCkgfHwgUmVmZXJlbmNlRXF1YWxzKG90aGVyLCByZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gbV9idWlsZGVyLlNhbWVBczxUPihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgRG9Db25qdWdhdGVUcmFuc3Bvc2VBbmRNdWx0aXBseShvdGhlciwgdG1wKTtcclxuICAgICAgICAgICAgICAgIHRtcC5Db3B5VG8ocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERvQ29uanVnYXRlVHJhbnNwb3NlQW5kTXVsdGlwbHkob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyB0aGlzIG1hdHJpeCB3aXRoIHRoZSBjb25qdWdhdGUgdHJhbnNwb3NlIG9mIGFub3RoZXIgbWF0cml4IGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzdHJvbmc+dGhpcy5Db2x1bW5zICE9IG90aGVyLkNvbHVtbkNvdW50PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBDb25qdWdhdGVUcmFuc3Bvc2VBbmRNdWx0aXBseShNYXRyaXg8VD4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gb3RoZXIuQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIG90aGVyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXModGhpcywgb3RoZXIsIFJvd0NvdW50LCBvdGhlci5Sb3dDb3VudCk7XHJcbiAgICAgICAgICAgIERvQ29uanVnYXRlVHJhbnNwb3NlQW5kTXVsdGlwbHkob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhlIGNvbmp1Z2F0ZSB0cmFuc3Bvc2Ugb2YgdGhpcyBtYXRyaXggYnkgYSB2ZWN0b3IgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSB2ZWN0b3IgdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgPGM+dGhpcy5Sb3dDb3VudCAhPSByaWdodFNpZGUuQ291bnQ8L2M+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gQ29uanVnYXRlVHJhbnNwb3NlVGhpc0FuZE11bHRpcGx5KFZlY3RvcjxUPiByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gcmlnaHRTaWRlLkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCByaWdodFNpZGUsIFwicmlnaHRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBcyh0aGlzLCByaWdodFNpZGUsIENvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgRG9Db25qdWdhdGVUcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkocmlnaHRTaWRlLCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoZSBjb25qdWdhdGUgdHJhbnNwb3NlIG9mIHRoaXMgbWF0cml4IHdpdGggYSB2ZWN0b3IgYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8c3Ryb25nPnJlc3VsdC5Db3VudCAhPSB0aGlzLkNvbHVtbkNvdW50PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzdHJvbmc+dGhpcy5Sb3dDb3VudCAhPSA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4uQ291bnQ8L3N0cm9uZz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQ29uanVnYXRlVHJhbnNwb3NlVGhpc0FuZE11bHRpcGx5KFZlY3RvcjxUPiByaWdodFNpZGUsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gcmlnaHRTaWRlLkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCByaWdodFNpZGUsIFwicmlnaHRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCByZXN1bHQsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoUmVmZXJlbmNlRXF1YWxzKHJpZ2h0U2lkZSwgcmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IHZfYnVpbGRlci5TYW1lQXM8VD4ocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIERvQ29uanVnYXRlVHJhbnNwb3NlVGhpc0FuZE11bHRpcGx5KHJpZ2h0U2lkZSwgdG1wKTtcclxuICAgICAgICAgICAgICAgIHRtcC5Db3B5VG8ocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERvQ29uanVnYXRlVHJhbnNwb3NlVGhpc0FuZE11bHRpcGx5KHJpZ2h0U2lkZSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoZSBjb25qdWdhdGUgdHJhbnNwb3NlIG9mIHRoaXMgbWF0cml4IHdpdGggYW5vdGhlciBtYXRyaXggYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzdHJvbmc+dGhpcy5Sb3dzICE9IG90aGVyLlJvd0NvdW50PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSByZXN1bHQgbWF0cml4J3MgZGltZW5zaW9ucyBhcmUgbm90IHRoZSB0aGlzLkNvbHVtbkNvdW50IHggb3RoZXIuQ29sdW1uQ291bnQuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQ29uanVnYXRlVHJhbnNwb3NlVGhpc0FuZE11bHRpcGx5KE1hdHJpeDxUPiBvdGhlciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChSb3dDb3VudCAhPSBvdGhlci5Sb3dDb3VudCB8fCByZXN1bHQuUm93Q291bnQgIT0gQ29sdW1uQ291bnQgfHwgcmVzdWx0LkNvbHVtbkNvdW50ICE9IG90aGVyLkNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCBvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCByZXN1bHQpIHx8IFJlZmVyZW5jZUVxdWFscyhvdGhlciwgcmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IG1fYnVpbGRlci5TYW1lQXM8VD4ocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIERvQ29uanVnYXRlVHJhbnNwb3NlVGhpc0FuZE11bHRpcGx5KG90aGVyLCB0bXApO1xyXG4gICAgICAgICAgICAgICAgdG1wLkNvcHlUbyhyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRG9Db25qdWdhdGVUcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyB0aGUgY29uanVnYXRlIHRyYW5zcG9zZSBvZiB0aGlzIG1hdHJpeCB3aXRoIGFub3RoZXIgbWF0cml4IGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzdHJvbmc+dGhpcy5Sb3dzICE9IG90aGVyLlJvd0NvdW50PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBDb25qdWdhdGVUcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkoTWF0cml4PFQ+IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFJvd0NvdW50ICE9IG90aGVyLlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCBvdGhlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzKHRoaXMsIG90aGVyLCBDb2x1bW5Db3VudCwgb3RoZXIuQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICBEb0Nvbmp1Z2F0ZVRyYW5zcG9zZVRoaXNBbmRNdWx0aXBseShvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIE1hdHJpeDxUPiBJbnRQb3dlcihpbnQgZXhwb25lbnQsIE1hdHJpeDxUPiB4LCBNYXRyaXg8VD4geSwgTWF0cml4PFQ+IHdvcmspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBXZSB0cnkgdG8gYmUgc21hcnQgYWJvdXQgbm90IGFsbG9jYXRpbmcgbW9yZSBtYXRyaWNlcyB0aGFuIG5lZWRlZFxyXG4gICAgICAgICAgICAvLyBhbmQgdG8gbWluaW1pemUgdGhlIG51bWJlciBvZiBtdWx0aXBsaWNhdGlvbnMgKG5vdCBvcHRpbWFsIG9uIGVpdGhlciB0aG91Z2gpXHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBGb3IgbGFyZ2Ugb3Igbm9uLWludGVnZXIgZXhwb25lbnRzIHdlIGNvdWxkIGRpYWdvbmFsaXplIHRoZSBtYXRyaXggd2l0aFxyXG4gICAgICAgICAgICAvLyBhIHNpbWlsYXJpdHkgdHJhbnNmb3JtIChlaWdlbnZhbHVlIGRlY29tcG9zaXRpb24pXHJcblxyXG4gICAgICAgICAgICAvLyByZXR1cm4geSp4XHJcbiAgICAgICAgICAgIGlmIChleHBvbmVudCA9PSAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4geFxyXG4gICAgICAgICAgICAgICAgaWYgKHkgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAod29yayA9PSBudWxsKSB3b3JrID0geS5NdWx0aXBseSh4KTsgZWxzZSB5Lk11bHRpcGx5KHgsIHdvcmspO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcms7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHJldHVybiB5KnheMlxyXG4gICAgICAgICAgICBpZiAoZXhwb25lbnQgPT0gMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdvcmsgPT0gbnVsbCkgd29yayA9IHguTXVsdGlwbHkoeCk7IGVsc2UgeC5NdWx0aXBseSh4LCB3b3JrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4geF4yXHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3b3JrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHkuTXVsdGlwbHkod29yaywgeCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gcmVjdXJzaXZlIG4gPC0tIG4vMiwgeSA8LS0geSwgeCA8LS0geF4yXHJcbiAgICAgICAgICAgIGlmIChleHBvbmVudC5Jc0V2ZW4oKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gd2Ugc3RvcmUgdGhlIG5ldyB4IGluIHdvcmssIGtlZXAgdGhlIHkgYXMgaXMgYW5kIHJldXNlIHRoZSBvbGQgeCBhcyBuZXcgd29yayBtYXRyaXguXHJcbiAgICAgICAgICAgICAgICBpZiAod29yayA9PSBudWxsKSB3b3JrID0geC5NdWx0aXBseSh4KTsgZWxzZSB4Lk11bHRpcGx5KHgsIHdvcmspO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEludFBvd2VyKGV4cG9uZW50LzIsIHdvcmssIHksIHgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyByZWN1cnNpdmUgbiA8LS0gKG4tMSkvMiwgeSA8LS0geCwgeCA8LS0geF4yXHJcbiAgICAgICAgICAgIGlmICh5ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIHdlIHN0b3JlIHRoZSBuZXcgeCBpbiB3b3JrLCBkaXJlY3RseSB1c2UgdGhlIG9sZCB4IGFzIHkuIG5vIHdvcmsgbWF0cml4LlxyXG4gICAgICAgICAgICAgICAgaWYgKHdvcmsgPT0gbnVsbCkgd29yayA9IHguTXVsdGlwbHkoeCk7IGVsc2UgeC5NdWx0aXBseSh4LCB3b3JrKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBJbnRQb3dlcigoZXhwb25lbnQgLSAxKS8yLCB3b3JrLCB4LCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gcmVjdXJzaXZlIG4gPC0tIChuLTEpLzIsIHkgPC0tIHkqeCwgeCA8LS0geF4yXHJcbiAgICAgICAgICAgIC8vIHdlIHN0b3JlIHRoZSBuZXcgeSBpbiB3b3JrLCB0aGUgbmV3IHggaW4geSwgYW5kIHJldXNlIHRoZSBvbGQgeCBhcyB3b3JrXHJcbiAgICAgICAgICAgIGlmICh3b3JrID09IG51bGwpIHdvcmsgPSB5Lk11bHRpcGx5KHgpOyBlbHNlIHkuTXVsdGlwbHkoeCwgd29yayk7XHJcbiAgICAgICAgICAgIHguTXVsdGlwbHkoeCwgeSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJbnRQb3dlcigoZXhwb25lbnQgLSAxKS8yLCB5LCB3b3JrLCB4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmFpc2VzIHRoaXMgc3F1YXJlIG1hdHJpeCB0byBhIHBvc2l0aXZlIGludGVnZXIgZXhwb25lbnQgYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXhwb25lbnRcIj5UaGUgcG9zaXRpdmUgaW50ZWdlciBleHBvbmVudCB0byByYWlzZSB0aGUgbWF0cml4IHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgcG93ZXIuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb3dlcihpbnQgZXhwb25lbnQsIE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gQ29sdW1uQ291bnQgfHwgcmVzdWx0LlJvd0NvdW50ICE9IFJvd0NvdW50IHx8IHJlc3VsdC5Db2x1bW5Db3VudCAhPSBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4odGhpcywgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXhwb25lbnQgPCAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnROb3ROZWdhdGl2ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXhwb25lbnQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbV9idWlsZGVyLkRpYWdvbmFsSWRlbnRpdHkoUm93Q291bnQsIENvbHVtbkNvdW50KS5Db3B5VG8ocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXhwb25lbnQgPT0gMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09IDIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE11bHRpcGx5KHRoaXMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXMgPSBJbnRQb3dlcihleHBvbmVudCwgQ2xvbmUoKSwgbnVsbCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgaWYgKCFSZWZlcmVuY2VFcXVhbHMocmVzLCByZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXMuQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyB0aGlzIHNxdWFyZSBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXhwb25lbnRcIj5UaGUgcG9zaXRpdmUgaW50ZWdlciBleHBvbmVudCB0byByYWlzZSB0aGUgbWF0cml4IHRvLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBQb3dlcihpbnQgZXhwb25lbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gQ29sdW1uQ291bnQpIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeFNxdWFyZVwiKTtcclxuICAgICAgICAgICAgaWYgKGV4cG9uZW50IDwgMCkgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50Tm90TmVnYXRpdmVcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXhwb25lbnQgPT0gMCkgcmV0dXJuIG1fYnVpbGRlci5EaWFnb25hbElkZW50aXR5KFJvd0NvdW50LCBDb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIGlmIChleHBvbmVudCA9PSAxKSByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09IDIpIHJldHVybiBNdWx0aXBseSh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBJbnRQb3dlcihleHBvbmVudCwgQ2xvbmUoKSwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE5lZ2F0ZSBlYWNoIGVsZW1lbnQgb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBtYXRyaXggY29udGFpbmluZyB0aGUgbmVnYXRlZCB2YWx1ZXMuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gTmVnYXRlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBEb05lZ2F0ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOZWdhdGUgZWFjaCBlbGVtZW50IG9mIHRoaXMgbWF0cml4IGFuZCBwbGFjZSB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbmVnYXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5pZiB0aGUgcmVzdWx0IG1hdHJpeCdzIGRpbWVuc2lvbnMgYXJlIG5vdCB0aGUgc2FtZSBhcyB0aGlzIG1hdHJpeC48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBOZWdhdGUoTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuUm93Q291bnQgIT0gUm93Q291bnQgfHwgcmVzdWx0LkNvbHVtbkNvdW50ICE9IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb05lZ2F0ZShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wbGV4IGNvbmp1Z2F0ZSBlYWNoIGVsZW1lbnQgb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBtYXRyaXggY29udGFpbmluZyB0aGUgY29uanVnYXRlZCB2YWx1ZXMuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gQ29uanVnYXRlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBEb0Nvbmp1Z2F0ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wbGV4IGNvbmp1Z2F0ZSBlYWNoIGVsZW1lbnQgb2YgdGhpcyBtYXRyaXggYW5kIHBsYWNlIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBjb25qdWdhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPmlmIHRoZSByZXN1bHQgbWF0cml4J3MgZGltZW5zaW9ucyBhcmUgbm90IHRoZSBzYW1lIGFzIHRoaXMgbWF0cml4LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENvbmp1Z2F0ZShNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvQ29uanVnYXRlKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBjYW5vbmljYWwgbW9kdWx1cywgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlzb3IsXHJcbiAgICAgICAgLy8vIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgc2NhbGFyIGRlbm9taW5hdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIG1hdHJpeCBjb250YWluaW5nIHRoZSByZXN1bHRzLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IE1vZHVsdXMoVCBkaXZpc29yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvTW9kdWx1cyhkaXZpc29yLCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgY2Fub25pY2FsIG1vZHVsdXMsIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpc29yLFxyXG4gICAgICAgIC8vLyBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHNjYWxhciBkZW5vbWluYXRvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5NYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNb2R1bHVzKFQgZGl2aXNvciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb2x1bW5Db3VudCAhPSByZXN1bHQuQ29sdW1uQ291bnQgfHwgUm93Q291bnQgIT0gcmVzdWx0LlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb01vZHVsdXMoZGl2aXNvciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGNhbm9uaWNhbCBtb2R1bHVzLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aXNvcixcclxuICAgICAgICAvLy8gZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aWRlbmRcIj5UaGUgc2NhbGFyIG51bWVyYXRvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBtYXRyaXggY29udGFpbmluZyB0aGUgcmVzdWx0cy48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBNb2R1bHVzQnlUaGlzKFQgZGl2aWRlbmQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9Nb2R1bHVzQnlUaGlzKGRpdmlkZW5kLCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgY2Fub25pY2FsIG1vZHVsdXMsIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpc29yLFxyXG4gICAgICAgIC8vLyBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpZGVuZFwiPlRoZSBzY2FsYXIgbnVtZXJhdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPk1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1vZHVsdXNCeVRoaXMoVCBkaXZpZGVuZCwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb2x1bW5Db3VudCAhPSByZXN1bHQuQ29sdW1uQ291bnQgfHwgUm93Q291bnQgIT0gcmVzdWx0LlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb01vZHVsdXNCeVRoaXMoZGl2aWRlbmQsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSByZW1haW5kZXIgKG1hdHJpeCAlIGRpdmlzb3IpLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aWRlbmQsXHJcbiAgICAgICAgLy8vIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgc2NhbGFyIGRlbm9taW5hdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIG1hdHJpeCBjb250YWluaW5nIHRoZSByZXN1bHRzLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFJlbWFpbmRlcihUIGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9SZW1haW5kZXIoZGl2aXNvciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciAobWF0cml4ICUgZGl2aXNvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBzY2FsYXIgZGVub21pbmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+TWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtYWluZGVyKFQgZGl2aXNvciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb2x1bW5Db3VudCAhPSByZXN1bHQuQ29sdW1uQ291bnQgfHwgUm93Q291bnQgIT0gcmVzdWx0LlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1JlbWFpbmRlcihkaXZpc29yLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgcmVtYWluZGVyIChkaXZpZGVuZCAlIG1hdHJpeCksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aWRlbmRcIj5UaGUgc2NhbGFyIG51bWVyYXRvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBtYXRyaXggY29udGFpbmluZyB0aGUgcmVzdWx0cy48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBSZW1haW5kZXJCeVRoaXMoVCBkaXZpZGVuZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBEb1JlbWFpbmRlckJ5VGhpcyhkaXZpZGVuZCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciAoZGl2aWRlbmQgJSBtYXRyaXgpLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aWRlbmQsXHJcbiAgICAgICAgLy8vIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHNjYWxhciBudW1lcmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+TWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtYWluZGVyQnlUaGlzKFQgZGl2aWRlbmQsIE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gcmVzdWx0LkNvbHVtbkNvdW50IHx8IFJvd0NvdW50ICE9IHJlc3VsdC5Sb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4odGhpcywgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9SZW1haW5kZXJCeVRoaXMoZGl2aWRlbmQsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBtdWx0aXBsaWVzIHRoaXMgbWF0cml4IHdpdGggYW5vdGhlciBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gcG9pbnR3aXNlIG11bHRpcGx5IHdpdGggdGhpcyBvbmUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIG1hdHJpeCBhbmQgPHBhcmFtcmVmIG5hbWU9XCJvdGhlclwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIG5ldyBtYXRyaXggdGhhdCBpcyB0aGUgcG9pbnR3aXNlIG11bHRpcGxpY2F0aW9uIG9mIHRoaXMgbWF0cml4IGFuZCA8cGFyYW1yZWYgbmFtZT1cIm90aGVyXCIvPi48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBQb2ludHdpc2VNdWx0aXBseShNYXRyaXg8VD4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gb3RoZXIuQ29sdW1uQ291bnQgfHwgUm93Q291bnQgIT0gb3RoZXIuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIG90aGVyLCBcIm90aGVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBcyh0aGlzLCBvdGhlcik7XHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlTXVsdGlwbHkob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBtdWx0aXBsaWVzIHRoaXMgbWF0cml4IHdpdGggYW5vdGhlciBtYXRyaXggYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gcG9pbnR3aXNlIG11bHRpcGx5IHdpdGggdGhpcyBvbmUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50d2lzZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgbWF0cml4IGFuZCA8cGFyYW1yZWYgbmFtZT1cIm90aGVyXCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyBtYXRyaXggYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlTXVsdGlwbHkoTWF0cml4PFQ+IG90aGVyLCBNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ICE9IHJlc3VsdC5Db2x1bW5Db3VudCB8fCBSb3dDb3VudCAhPSByZXN1bHQuUm93Q291bnQgfHwgQ29sdW1uQ291bnQgIT0gb3RoZXIuQ29sdW1uQ291bnQgfHwgUm93Q291bnQgIT0gb3RoZXIuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1BvaW50d2lzZU11bHRpcGx5KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgZGl2aWRlIHRoaXMgbWF0cml4IGJ5IGFub3RoZXIgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBwb2ludHdpc2UgZGVub21pbmF0b3IgbWF0cml4IHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgbWF0cml4IGFuZCA8cGFyYW1yZWYgbmFtZT1cImRpdmlzb3JcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBuZXcgbWF0cml4IHRoYXQgaXMgdGhlIHBvaW50d2lzZSBkaXZpc2lvbiBvZiB0aGlzIG1hdHJpeCBhbmQgPHBhcmFtcmVmIG5hbWU9XCJkaXZpc29yXCIvPi48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBQb2ludHdpc2VEaXZpZGUoTWF0cml4PFQ+IGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gZGl2aXNvci5Db2x1bW5Db3VudCB8fCBSb3dDb3VudCAhPSBkaXZpc29yLlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCBkaXZpc29yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXModGhpcywgZGl2aXNvcik7XHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlRGl2aWRlKGRpdmlzb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBkaXZpZGUgdGhpcyBtYXRyaXggYnkgYW5vdGhlciBtYXRyaXggYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHBvaW50d2lzZSBkZW5vbWluYXRvciBtYXRyaXggdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludHdpc2UgZGl2aXNpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIG1hdHJpeCBhbmQgPHBhcmFtcmVmIG5hbWU9XCJkaXZpc29yXCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyBtYXRyaXggYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlRGl2aWRlKE1hdHJpeDxUPiBkaXZpc29yLCBNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ICE9IHJlc3VsdC5Db2x1bW5Db3VudCB8fCBSb3dDb3VudCAhPSByZXN1bHQuUm93Q291bnQgfHwgQ29sdW1uQ291bnQgIT0gZGl2aXNvci5Db2x1bW5Db3VudCB8fCBSb3dDb3VudCAhPSBkaXZpc29yLlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCBkaXZpc29yLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1BvaW50d2lzZURpdmlkZShkaXZpc29yLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgcmFpc2UgdGhpcyBtYXRyaXggdG8gYW4gZXhwb25lbnQgYW5kIHN0b3JlIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImV4cG9uZW50XCI+VGhlIGV4cG9uZW50IHRvIHJhaXNlIHRoaXMgbWF0cml4IHZhbHVlcyB0by48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gUG9pbnR3aXNlUG93ZXIoVCBleHBvbmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBEb1BvaW50d2lzZVBvd2VyKGV4cG9uZW50LCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgcmFpc2UgdGhpcyBtYXRyaXggdG8gYW4gZXhwb25lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJleHBvbmVudFwiPlRoZSBleHBvbmVudCB0byByYWlzZSB0aGlzIG1hdHJpeCB2YWx1ZXMgdG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgaW50by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgbWF0cml4IGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZVBvd2VyKFQgZXhwb25lbnQsIE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gcmVzdWx0LkNvbHVtbkNvdW50IHx8IFJvd0NvdW50ICE9IHJlc3VsdC5Sb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4odGhpcywgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VQb3dlcihleHBvbmVudCwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIHJhaXNlIHRoaXMgbWF0cml4IHRvIGFuIGV4cG9uZW50IGFuZCBzdG9yZSB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJleHBvbmVudFwiPlRoZSBleHBvbmVudCB0byByYWlzZSB0aGlzIG1hdHJpeCB2YWx1ZXMgdG8uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZVBvd2VyKE1hdHJpeDxUPiBleHBvbmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb2x1bW5Db3VudCAhPSBleHBvbmVudC5Db2x1bW5Db3VudCB8fCBSb3dDb3VudCAhPSBleHBvbmVudC5Sb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4odGhpcywgZXhwb25lbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VQb3dlcihleHBvbmVudCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIHJhaXNlIHRoaXMgbWF0cml4IHRvIGFuIGV4cG9uZW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXhwb25lbnRcIj5UaGUgZXhwb25lbnQgdG8gcmFpc2UgdGhpcyBtYXRyaXggdmFsdWVzIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IGludG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIG1hdHJpeCBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VQb3dlcihNYXRyaXg8VD4gZXhwb25lbnQsIE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gcmVzdWx0LkNvbHVtbkNvdW50IHx8IFJvd0NvdW50ICE9IHJlc3VsdC5Sb3dDb3VudCB8fCBDb2x1bW5Db3VudCAhPSBleHBvbmVudC5Db2x1bW5Db3VudCB8fCBSb3dDb3VudCAhPSBleHBvbmVudC5Sb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4odGhpcywgZXhwb25lbnQsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlUG93ZXIoZXhwb25lbnQsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBjYW5vbmljYWwgbW9kdWx1cywgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlzb3IsXHJcbiAgICAgICAgLy8vIG9mIHRoaXMgbWF0cml4IGJ5IGFub3RoZXIgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBwb2ludHdpc2UgZGVub21pbmF0b3IgbWF0cml4IHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgbWF0cml4IGFuZCA8cGFyYW1yZWYgbmFtZT1cImRpdmlzb3JcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZU1vZHVsdXMoTWF0cml4PFQ+IGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gZGl2aXNvci5Db2x1bW5Db3VudCB8fCBSb3dDb3VudCAhPSBkaXZpc29yLlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCBkaXZpc29yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXModGhpcywgZGl2aXNvcik7XHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlTW9kdWx1cyhkaXZpc29yLCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgY2Fub25pY2FsIG1vZHVsdXMsIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpc29yLFxyXG4gICAgICAgIC8vLyBvZiB0aGlzIG1hdHJpeCBieSBhbm90aGVyIG1hdHJpeCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgcG9pbnR3aXNlIGRlbm9taW5hdG9yIG1hdHJpeCB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50d2lzZSBtb2R1bHVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyBtYXRyaXggYW5kIDxwYXJhbXJlZiBuYW1lPVwiZGl2aXNvclwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgbWF0cml4IGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZU1vZHVsdXMoTWF0cml4PFQ+IGRpdmlzb3IsIE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gcmVzdWx0LkNvbHVtbkNvdW50IHx8IFJvd0NvdW50ICE9IHJlc3VsdC5Sb3dDb3VudCB8fCBDb2x1bW5Db3VudCAhPSBkaXZpc29yLkNvbHVtbkNvdW50IHx8IFJvd0NvdW50ICE9IGRpdmlzb3IuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIGRpdmlzb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlTW9kdWx1cyhkaXZpc29yLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgcmVtYWluZGVyICglIG9wZXJhdG9yKSwgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlkZW5kLFxyXG4gICAgICAgIC8vLyBvZiB0aGlzIG1hdHJpeCBieSBhbm90aGVyIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgcG9pbnR3aXNlIGRlbm9taW5hdG9yIG1hdHJpeCB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIG1hdHJpeCBhbmQgPHBhcmFtcmVmIG5hbWU9XCJkaXZpc29yXCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBQb2ludHdpc2VSZW1haW5kZXIoTWF0cml4PFQ+IGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gZGl2aXNvci5Db2x1bW5Db3VudCB8fCBSb3dDb3VudCAhPSBkaXZpc29yLlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCBkaXZpc29yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXModGhpcywgZGl2aXNvcik7XHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlUmVtYWluZGVyKGRpdmlzb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSByZW1haW5kZXIgKCUgb3BlcmF0b3IpLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aWRlbmQsXHJcbiAgICAgICAgLy8vIG9mIHRoaXMgbWF0cml4IGJ5IGFub3RoZXIgbWF0cml4IGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBwb2ludHdpc2UgZGVub21pbmF0b3IgbWF0cml4IHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgcG9pbnR3aXNlIHJlbWFpbmRlci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgbWF0cml4IGFuZCA8cGFyYW1yZWYgbmFtZT1cImRpdmlzb3JcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIG1hdHJpeCBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VSZW1haW5kZXIoTWF0cml4PFQ+IGRpdmlzb3IsIE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gcmVzdWx0LkNvbHVtbkNvdW50IHx8IFJvd0NvdW50ICE9IHJlc3VsdC5Sb3dDb3VudCB8fCBDb2x1bW5Db3VudCAhPSBkaXZpc29yLkNvbHVtbkNvdW50IHx8IFJvd0NvdW50ICE9IGRpdmlzb3IuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIGRpdmlzb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlUmVtYWluZGVyKGRpdmlzb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEhlbHBlciBmdW5jdGlvbiB0byBhcHBseSBhIHVuYXJ5IGZ1bmN0aW9uIHRvIGEgbWF0cml4LiBUaGUgZnVuY3Rpb25cclxuICAgICAgICAvLy8gZiBtb2RpZmllcyB0aGUgbWF0cml4IGdpdmVuIHRvIGl0IGluIHBsYWNlLiAgQmVmb3JlIGl0c1xyXG4gICAgICAgIC8vLyBjYWxsZWQsIGEgY29weSBvZiB0aGUgJ3RoaXMnIG1hdHJpeCBpcyBmaXJzdCBjcmVhdGVkLCB0aGVuIHBhc3NlZCB0b1xyXG4gICAgICAgIC8vLyBmLiAgVGhlIGNvcHkgaXMgdGhlbiByZXR1cm5lZCBhcyB0aGUgcmVzdWx0XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmXCI+RnVuY3Rpb24gd2hpY2ggdGFrZXMgYSBtYXRyaXgsIG1vZGlmaWVzIGl0IGluIHBsYWNlIGFuZCByZXR1cm5zIHZvaWQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5OZXcgaW5zdGFuY2Ugb2YgbWF0cml4IHdoaWNoIGlzIHRoZSByZXN1bHQ8L3JldHVybnM+XHJcbiAgICAgICAgcHJvdGVjdGVkIE1hdHJpeDxUPiBQb2ludHdpc2VVbmFyeShBY3Rpb248TWF0cml4PFQ+PiBmKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIGYocmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFwcGx5IGEgdW5hcnkgZnVuY3Rpb24gd2hpY2ggbW9kaWZpZXMgYSBtYXRyaXhcclxuICAgICAgICAvLy8gaW4gcGxhY2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmXCI+RnVuY3Rpb24gd2hpY2ggdGFrZXMgYSBtYXRyaXgsIG1vZGlmaWVzIGl0IGluIHBsYWNlIGFuZCByZXR1cm5zIHZvaWQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gYmUgcGFzc2VkIHRvIGYgYW5kIHdoZXJlIHRoZSByZXN1bHQgaXMgdG8gYmUgc3RvcmVkPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwcm90ZWN0ZWQgdm9pZCBQb2ludHdpc2VVbmFyeShBY3Rpb248TWF0cml4PFQ+PiBmLCBNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ICE9IHJlc3VsdC5Db2x1bW5Db3VudCB8fCBSb3dDb3VudCAhPSByZXN1bHQuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZihyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBIZWxwZXIgZnVuY3Rpb24gdG8gYXBwbHkgYSBiaW5hcnkgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIG1hdHJpY2VzXHJcbiAgICAgICAgLy8vIGFuZCBtb2RpZmllcyB0aGUgbGF0dGVyIGluIHBsYWNlLiAgQSBjb3B5IG9mIHRoZSBcInRoaXNcIiBtYXRyaXggaXNcclxuICAgICAgICAvLy8gZmlyc3QgbWFkZSBhbmQgdGhlbiBwYXNzZWQgdG8gZiB0b2dldGhlciB3aXRoIHRoZSBvdGhlciBtYXRyaXguIFRoZVxyXG4gICAgICAgIC8vLyBjb3B5IGlzIHRoZW4gcmV0dXJuZWQgYXMgdGhlIHJlc3VsdFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZlwiPkZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBtYXRyaWNlcywgbW9kaWZpZXMgdGhlIHNlY29uZCBpbiBwbGFjZSBhbmQgcmV0dXJucyB2b2lkPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBvdGhlciBtYXRyaXggdG8gYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiBhcyBhcmd1bWVudC4gSXQgaXMgbm90IG1vZGlmaWVkPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdGluZyBtYXRyaXg8L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyBtYXRyaXggYW5kIDxwYXJhbXJlZiBuYW1lPVwib3RoZXJcIi8+IGFyZSBub3QgdGhlIHNhbWUgZGltZW5zaW9uLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHByb3RlY3RlZCBNYXRyaXg8VD4gUG9pbnR3aXNlQmluYXJ5KEFjdGlvbjxNYXRyaXg8VD4sIE1hdHJpeDxUPj4gZiwgTWF0cml4PFQ+IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ICE9IG90aGVyLkNvbHVtbkNvdW50IHx8IFJvd0NvdW50ICE9IG90aGVyLlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCBvdGhlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzKHRoaXMsIG90aGVyKTtcclxuICAgICAgICAgICAgZihvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFwcGx5IGEgYmluYXJ5IGZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBtYXRyaWNlc1xyXG4gICAgICAgIC8vLyBhbmQgbW9kaWZpZXMgdGhlIHNlY29uZCBvbmUgaW4gcGxhY2VcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZcIj5GdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gbWF0cmljZXMsIG1vZGlmaWVzIHRoZSBzZWNvbmQgaW4gcGxhY2UgYW5kIHJldHVybnMgdm9pZDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgb3RoZXIgbWF0cml4IHRvIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24gYXMgYXJndW1lbnQuIEl0IGlzIG5vdCBtb2RpZmllZDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHRpbmcgbWF0cml4PC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgbWF0cml4IGFuZCA8cGFyYW1yZWYgbmFtZT1cIm90aGVyXCIvPiBhcmUgbm90IHRoZSBzYW1lIGRpbWVuc2lvbi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwcm90ZWN0ZWQgdm9pZCBQb2ludHdpc2VCaW5hcnkoQWN0aW9uPE1hdHJpeDxUPixNYXRyaXg8VD4+IGYsIE1hdHJpeDxUPiBvdGhlciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb2x1bW5Db3VudCAhPSByZXN1bHQuQ29sdW1uQ291bnQgfHwgUm93Q291bnQgIT0gcmVzdWx0LlJvd0NvdW50IHx8IENvbHVtbkNvdW50ICE9IG90aGVyLkNvbHVtbkNvdW50IHx8IFJvd0NvdW50ICE9IG90aGVyLlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCBvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZihvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGV4cG9uZW50IGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZUV4cCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnR3aXNlVW5hcnkoKEFjdGlvbjxNYXRyaXg8VD4+KURvUG9pbnR3aXNlRXhwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGV4cG9uZW50IGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIG1hdHJpeCBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VFeHAoTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZUV4cCwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZUxvZygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnR3aXNlVW5hcnkoKEFjdGlvbjxNYXRyaXg8VD4+KURvUG9pbnR3aXNlTG9nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIG1hdHJpeCBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VMb2coTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZUxvZywgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGFicyBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZUFicygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnR3aXNlVW5hcnkoKEFjdGlvbjxNYXRyaXg8VD4+KURvUG9pbnR3aXNlQWJzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGFicyBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZUFicyhNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnR3aXNlVW5hcnkoKEFjdGlvbjxNYXRyaXg8VD4+KURvUG9pbnR3aXNlQWJzLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgYWNvcyBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZUFjb3MoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZUFjb3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgYWNvcyBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZUFjb3MoTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZUFjb3MsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBhc2luIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gUG9pbnR3aXNlQXNpbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnR3aXNlVW5hcnkoKEFjdGlvbjxNYXRyaXg8VD4+KURvUG9pbnR3aXNlQXNpbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBhc2luIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdDwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlQXNpbihNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnR3aXNlVW5hcnkoKEFjdGlvbjxNYXRyaXg8VD4+KURvUG9pbnR3aXNlQXNpbiwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGF0YW4gZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBQb2ludHdpc2VBdGFuKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPE1hdHJpeDxUPj4pRG9Qb2ludHdpc2VBdGFuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGF0YW4gZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VBdGFuKE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPE1hdHJpeDxUPj4pRG9Qb2ludHdpc2VBdGFuLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgYXRhbjIgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBvZiB0aGUgY3VycmVudFxyXG4gICAgICAgIC8vLyBtYXRyaXggYW5kIGEgZ2l2ZW4gb3RoZXIgbWF0cml4IGJlaW5nIHRoZSAneCcgb2YgYXRhbjIgYW5kIHRoZVxyXG4gICAgICAgIC8vLyAndGhpcycgbWF0cml4IGJlaW5nIHRoZSAneSdcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gUG9pbnR3aXNlQXRhbjIoTWF0cml4PFQ+IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZUJpbmFyeSgoQWN0aW9uPE1hdHJpeDxUPixNYXRyaXg8VD4+KURvUG9pbnR3aXNlQXRhbjIsIG90aGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGF0YW4yIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgb2YgdGhlIGN1cnJlbnRcclxuICAgICAgICAvLy8gbWF0cml4IGFuZCBhIGdpdmVuIG90aGVyIG1hdHJpeCBiZWluZyB0aGUgJ3gnIG9mIGF0YW4yIGFuZCB0aGVcclxuICAgICAgICAvLy8gJ3RoaXMnIG1hdHJpeCBiZWluZyB0aGUgJ3knXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBvdGhlciBtYXRyaXggJ3knPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHdpdGggdGhlIHJlc3VsdCBhbmQgJ3gnPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZUF0YW4yKE1hdHJpeDxUPiBvdGhlciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZUJpbmFyeSgoQWN0aW9uPE1hdHJpeDxUPixNYXRyaXg8VD4+KURvUG9pbnR3aXNlQXRhbjIsIG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgY2VpbGluZyBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZUNlaWxpbmcoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZUNlaWxpbmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgY2VpbGluZyBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZUNlaWxpbmcoTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZUNlaWxpbmcsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBjb3MgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBQb2ludHdpc2VDb3MoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZUNvcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBjb3MgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VDb3MoTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZUNvcywgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGNvc2ggZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBQb2ludHdpc2VDb3NoKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPE1hdHJpeDxUPj4pRG9Qb2ludHdpc2VDb3NoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGNvc2ggZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VDb3NoKE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPE1hdHJpeDxUPj4pRG9Qb2ludHdpc2VDb3NoLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgZmxvb3IgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBQb2ludHdpc2VGbG9vcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnR3aXNlVW5hcnkoKEFjdGlvbjxNYXRyaXg8VD4+KURvUG9pbnR3aXNlRmxvb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgZmxvb3IgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VGbG9vcihNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnR3aXNlVW5hcnkoKEFjdGlvbjxNYXRyaXg8VD4+KURvUG9pbnR3aXNlRmxvb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBsb2cxMCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZUxvZzEwKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPE1hdHJpeDxUPj4pRG9Qb2ludHdpc2VMb2cxMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBsb2cxMCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZUxvZzEwKE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPE1hdHJpeDxUPj4pRG9Qb2ludHdpc2VMb2cxMCwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIHJvdW5kIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gUG9pbnR3aXNlUm91bmQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZVJvdW5kKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIHJvdW5kIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdDwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlUm91bmQoTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZVJvdW5kLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgc2lnbiBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZVNpZ24oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZVNpZ24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgc2lnbiBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZVNpZ24oTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZVNpZ24sIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBzaW4gZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBQb2ludHdpc2VTaW4oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZVNpbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBzaW4gZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VTaW4oTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZVNpbiwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIHNpbmggZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBQb2ludHdpc2VTaW5oKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPE1hdHJpeDxUPj4pRG9Qb2ludHdpc2VTaW5oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIHNpbmggZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VTaW5oKE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPE1hdHJpeDxUPj4pRG9Qb2ludHdpc2VTaW5oLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgc3FydCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZVNxcnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZVNxcnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgc3FydCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZVNxcnQoTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZVNxcnQsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSB0YW4gZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBQb2ludHdpc2VUYW4oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZVRhbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSB0YW4gZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VUYW4oTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248TWF0cml4PFQ+PilEb1BvaW50d2lzZVRhbiwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIHRhbmggZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBQb2ludHdpc2VUYW5oKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPE1hdHJpeDxUPj4pRG9Qb2ludHdpc2VUYW5oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIHRhbmggZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VUYW5oKE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPE1hdHJpeDxUPj4pRG9Qb2ludHdpc2VUYW5oLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgdHJhY2Ugb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHRyYWNlIG9mIHRoaXMgbWF0cml4PC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZTwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBUIFRyYWNlKCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsY3VsYXRlcyB0aGUgcmFuayBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPmVmZmVjdGl2ZSBudW1lcmljYWwgcmFuaywgb2J0YWluZWQgZnJvbSBTVkQ8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgaW50IFJhbmsoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN2ZChmYWxzZSkuUmFuaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIG51bGxpdHkgb2YgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5lZmZlY3RpdmUgbnVtZXJpY2FsIG51bGxpdHksIG9idGFpbmVkIGZyb20gU1ZEPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBpbnQgTnVsbGl0eSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sdW1uQ291bnQgLSBSYW5rKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+Q2FsY3VsYXRlcyB0aGUgY29uZGl0aW9uIG51bWJlciBvZiB0aGlzIG1hdHJpeC48L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBjb25kaXRpb24gbnVtYmVyIG9mIHRoZSBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5UaGUgY29uZGl0aW9uIG51bWJlciBpcyBjYWxjdWxhdGVkIHVzaW5nIHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24uPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIFQgQ29uZGl0aW9uTnVtYmVyKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdmQoZmFsc2UpLkNvbmRpdGlvbk51bWJlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5Db21wdXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhpcyBtYXRyaXguPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgZGV0ZXJtaW5hbnQgb2YgdGhpcyBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIFQgRGV0ZXJtaW5hbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFJvd0NvdW50ICE9IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRNYXRyaXhTcXVhcmVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBMVSgpLkRldGVybWluYW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyBhbiBvcnRob25vcm1hbCBiYXNpcyBmb3IgdGhlIG51bGwgc3BhY2Ugb2YgdGhpcyBtYXRyaXgsXHJcbiAgICAgICAgLy8vIGFsc28ga25vd24gYXMgdGhlIGtlcm5lbCBvZiB0aGUgY29ycmVzcG9uZGluZyBtYXRyaXggdHJhbnNmb3JtYXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBWZWN0b3I8VD5bXSBLZXJuZWwoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN2ZCA9IFN2ZCh0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIFN5c3RlbS5MaW5xLkVudW1lcmFibGUuVG9BcnJheTxWZWN0b3I8VD4+KHN2ZC5WVC5FbnVtZXJhdGVSb3dzKHN2ZC5SYW5rLCBDb2x1bW5Db3VudCAtIHN2ZC5SYW5rKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIGFuIG9ydGhvbm9ybWFsIGJhc2lzIGZvciB0aGUgY29sdW1uIHNwYWNlIG9mIHRoaXMgbWF0cml4LFxyXG4gICAgICAgIC8vLyBhbHNvIGtub3duIGFzIHRoZSByYW5nZSBvciBpbWFnZSBvZiB0aGUgY29ycmVzcG9uZGluZyBtYXRyaXggdHJhbnNmb3JtYXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBWZWN0b3I8VD5bXSBSYW5nZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3ZkID0gU3ZkKHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5Ub0FycmF5PFZlY3RvcjxUPj4oc3ZkLlUuRW51bWVyYXRlQ29sdW1ucygwLCBzdmQuUmFuaykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PkNvbXB1dGVzIHRoZSBpbnZlcnNlIG9mIHRoaXMgbWF0cml4Ljwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGludmVyc2Ugb2YgdGhpcyBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIE1hdHJpeDxUPiBJbnZlcnNlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChSb3dDb3VudCAhPSBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4U3F1YXJlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgIHJldHVybiBMVSgpLkludmVyc2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5Db21wdXRlcyB0aGUgTW9vcmUtUGVucm9zZSBQc2V1ZG8tSW52ZXJzZSBvZiB0aGlzIG1hdHJpeC48L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IE1hdHJpeDxUPiBQc2V1ZG9JbnZlcnNlKCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIEtyb25lY2tlciBwcm9kdWN0IG9mIHRoaXMgbWF0cml4IHdpdGggdGhlIGdpdmVuIG1hdHJpeC4gVGhlIG5ldyBtYXRyaXggaXMgTS1ieS1OXHJcbiAgICAgICAgLy8vIHdpdGggTSA9IHRoaXMuUm93cyAqIGxvd2VyLlJvd3MgYW5kIE4gPSB0aGlzLkNvbHVtbnMgKiBsb3dlci5Db2x1bW5zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgb3RoZXIgbWF0cml4LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBLcm9uZWNrZXIgcHJvZHVjdCBvZiB0aGUgdHdvIG1hdHJpY2VzLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IEtyb25lY2tlclByb2R1Y3QoTWF0cml4PFQ+IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXModGhpcywgb3RoZXIsIFJvd0NvdW50Km90aGVyLlJvd0NvdW50LCBDb2x1bW5Db3VudCpvdGhlci5Db2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIEtyb25lY2tlclByb2R1Y3Qob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBLcm9uZWNrZXIgcHJvZHVjdCBvZiB0aGlzIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBtYXRyaXguIFRoZSBuZXcgbWF0cml4IGlzIE0tYnktTlxyXG4gICAgICAgIC8vLyB3aXRoIE0gPSB0aGlzLlJvd3MgKiBsb3dlci5Sb3dzIGFuZCBOID0gdGhpcy5Db2x1bW5zICogbG93ZXIuQ29sdW1ucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG90aGVyIG1hdHJpeC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBLcm9uZWNrZXIgcHJvZHVjdCBvZiB0aGUgdHdvIG1hdHJpY2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHJlc3VsdCBtYXRyaXgncyBkaW1lbnNpb25zIGFyZSBub3QgKHRoaXMuUm93cyAqIGxvd2VyLnJvd3MpIHggKHRoaXMuQ29sdW1ucyAqIGxvd2VyLkNvbHVtbnMpLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIHZvaWQgS3JvbmVja2VyUHJvZHVjdChNYXRyaXg8VD4gb3RoZXIsIE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LlJvd0NvdW50ICE9IChSb3dDb3VudCpvdGhlci5Sb3dDb3VudCkgfHwgcmVzdWx0LkNvbHVtbkNvdW50ICE9IChDb2x1bW5Db3VudCpvdGhlci5Db2x1bW5Db3VudCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uPih0aGlzLCBvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LlNldFN1Yk1hdHJpeChpKm90aGVyLlJvd0NvdW50LCBvdGhlci5Sb3dDb3VudCwgaipvdGhlci5Db2x1bW5Db3VudCwgb3RoZXIuQ29sdW1uQ291bnQsIEF0KGksIGopKm90aGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgbWluaW11bSB3aXRoIGEgc2NhbGFyIHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHZhbHVlIHRvIGNvbXBhcmUgdG8uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZU1pbmltdW0oVCBzY2FsYXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VNaW5pbXVtKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIG1pbmltdW0gd2l0aCBhIHNjYWxhciB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB2YWx1ZSB0byBjb21wYXJlIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlTWluaW11bShUIHNjYWxhciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb2x1bW5Db3VudCAhPSByZXN1bHQuQ29sdW1uQ291bnQgfHwgUm93Q291bnQgIT0gcmVzdWx0LlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1BvaW50d2lzZU1pbmltdW0oc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgbWF4aW11bSB3aXRoIGEgc2NhbGFyIHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHZhbHVlIHRvIGNvbXBhcmUgdG8uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZU1heGltdW0oVCBzY2FsYXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VNYXhpbXVtKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIG1heGltdW0gd2l0aCBhIHNjYWxhciB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB2YWx1ZSB0byBjb21wYXJlIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyBtYXRyaXggYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlTWF4aW11bShUIHNjYWxhciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb2x1bW5Db3VudCAhPSByZXN1bHQuQ29sdW1uQ291bnQgfHwgUm93Q291bnQgIT0gcmVzdWx0LlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1BvaW50d2lzZU1heGltdW0oc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgYWJzb2x1dGUgbWluaW11bSB3aXRoIGEgc2NhbGFyIHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHZhbHVlIHRvIGNvbXBhcmUgdG8uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZUFic29sdXRlTWluaW11bShUIHNjYWxhcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBEb1BvaW50d2lzZUFic29sdXRlTWluaW11bShzY2FsYXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBhYnNvbHV0ZSBtaW5pbXVtIHdpdGggYSBzY2FsYXIgdG8gZWFjaCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdmFsdWUgdG8gY29tcGFyZSB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgbWF0cml4IGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZUFic29sdXRlTWluaW11bShUIHNjYWxhciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb2x1bW5Db3VudCAhPSByZXN1bHQuQ29sdW1uQ291bnQgfHwgUm93Q291bnQgIT0gcmVzdWx0LlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1BvaW50d2lzZUFic29sdXRlTWluaW11bShzY2FsYXIsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBhYnNvbHV0ZSBtYXhpbXVtIHdpdGggYSBzY2FsYXIgdG8gZWFjaCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdmFsdWUgdG8gY29tcGFyZSB0by48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gUG9pbnR3aXNlQWJzb2x1dGVNYXhpbXVtKFQgc2NhbGFyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlQWJzb2x1dGVNYXhpbXVtKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGFic29sdXRlIG1heGltdW0gd2l0aCBhIHNjYWxhciB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB2YWx1ZSB0byBjb21wYXJlIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyBtYXRyaXggYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlQWJzb2x1dGVNYXhpbXVtKFQgc2NhbGFyLCBNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ICE9IHJlc3VsdC5Db2x1bW5Db3VudCB8fCBSb3dDb3VudCAhPSByZXN1bHQuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlQWJzb2x1dGVNYXhpbXVtKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIG1pbmltdW0gd2l0aCB0aGUgdmFsdWVzIG9mIGFub3RoZXIgbWF0cml4IHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggd2l0aCB0aGUgdmFsdWVzIHRvIGNvbXBhcmUgdG8uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFBvaW50d2lzZU1pbmltdW0oTWF0cml4PFQ+IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlTWluaW11bShvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIG1pbmltdW0gd2l0aCB0aGUgdmFsdWVzIG9mIGFub3RoZXIgbWF0cml4IHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggd2l0aCB0aGUgdmFsdWVzIHRvIGNvbXBhcmUgdG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIG1hdHJpeCBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VNaW5pbXVtKE1hdHJpeDxUPiBvdGhlciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb2x1bW5Db3VudCAhPSByZXN1bHQuQ29sdW1uQ291bnQgfHwgUm93Q291bnQgIT0gcmVzdWx0LlJvd0NvdW50IHx8IENvbHVtbkNvdW50ICE9IG90aGVyLkNvbHVtbkNvdW50IHx8IFJvd0NvdW50ICE9IG90aGVyLlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCBvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VNaW5pbXVtKG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgbWF4aW11bSB3aXRoIHRoZSB2YWx1ZXMgb2YgYW5vdGhlciBtYXRyaXggdG8gZWFjaCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB3aXRoIHRoZSB2YWx1ZXMgdG8gY29tcGFyZSB0by48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gUG9pbnR3aXNlTWF4aW11bShNYXRyaXg8VD4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VNYXhpbXVtKG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgbWF4aW11bSB3aXRoIHRoZSB2YWx1ZXMgb2YgYW5vdGhlciBtYXRyaXggdG8gZWFjaCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB3aXRoIHRoZSB2YWx1ZXMgdG8gY29tcGFyZSB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgbWF0cml4IGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZU1heGltdW0oTWF0cml4PFQ+IG90aGVyLCBNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ICE9IHJlc3VsdC5Db2x1bW5Db3VudCB8fCBSb3dDb3VudCAhPSByZXN1bHQuUm93Q291bnQgfHwgQ29sdW1uQ291bnQgIT0gb3RoZXIuQ29sdW1uQ291bnQgfHwgUm93Q291bnQgIT0gb3RoZXIuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1BvaW50d2lzZU1heGltdW0ob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBhYnNvbHV0ZSBtaW5pbXVtIHdpdGggdGhlIHZhbHVlcyBvZiBhbm90aGVyIG1hdHJpeCB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHdpdGggdGhlIHZhbHVlcyB0byBjb21wYXJlIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBQb2ludHdpc2VBYnNvbHV0ZU1pbmltdW0oTWF0cml4PFQ+IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlQWJzb2x1dGVNaW5pbXVtKG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgYWJzb2x1dGUgbWluaW11bSB3aXRoIHRoZSB2YWx1ZXMgb2YgYW5vdGhlciBtYXRyaXggdG8gZWFjaCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB3aXRoIHRoZSB2YWx1ZXMgdG8gY29tcGFyZSB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgbWF0cml4IGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZUFic29sdXRlTWluaW11bShNYXRyaXg8VD4gb3RoZXIsIE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gcmVzdWx0LkNvbHVtbkNvdW50IHx8IFJvd0NvdW50ICE9IHJlc3VsdC5Sb3dDb3VudCB8fCBDb2x1bW5Db3VudCAhPSBvdGhlci5Db2x1bW5Db3VudCB8fCBSb3dDb3VudCAhPSBvdGhlci5Sb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4odGhpcywgb3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlQWJzb2x1dGVNaW5pbXVtKG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgYWJzb2x1dGUgbWF4aW11bSB3aXRoIHRoZSB2YWx1ZXMgb2YgYW5vdGhlciBtYXRyaXggdG8gZWFjaCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB3aXRoIHRoZSB2YWx1ZXMgdG8gY29tcGFyZSB0by48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gUG9pbnR3aXNlQWJzb2x1dGVNYXhpbXVtKE1hdHJpeDxUPiBvdGhlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBEb1BvaW50d2lzZUFic29sdXRlTWF4aW11bShvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGFic29sdXRlIG1heGltdW0gd2l0aCB0aGUgdmFsdWVzIG9mIGFub3RoZXIgbWF0cml4IHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggd2l0aCB0aGUgdmFsdWVzIHRvIGNvbXBhcmUgdG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIG1hdHJpeCBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VBYnNvbHV0ZU1heGltdW0oTWF0cml4PFQ+IG90aGVyLCBNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ICE9IHJlc3VsdC5Db2x1bW5Db3VudCB8fCBSb3dDb3VudCAhPSByZXN1bHQuUm93Q291bnQgfHwgQ29sdW1uQ291bnQgIT0gb3RoZXIuQ29sdW1uQ291bnQgfHwgUm93Q291bnQgIT0gb3RoZXIuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1BvaW50d2lzZUFic29sdXRlTWF4aW11bShvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5DYWxjdWxhdGVzIHRoZSBpbmR1Y2VkIEwxIG5vcm0gb2YgdGhpcyBtYXRyaXguPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbWF4aW11bSBhYnNvbHV0ZSBjb2x1bW4gc3VtIG9mIHRoZSBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBkb3VibGUgTDFOb3JtKCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5DYWxjdWxhdGVzIHRoZSBpbmR1Y2VkIEwyIG5vcm0gb2YgdGhlIG1hdHJpeC48L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBsYXJnZXN0IHNpbmd1bGFyIHZhbHVlIG9mIHRoZSBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5cclxuICAgICAgICAvLy8gRm9yIHNwYXJzZSBtYXRyaWNlcywgdGhlIEwyIG5vcm0gaXMgY29tcHV0ZWQgdXNpbmcgYSBkZW5zZSBpbXBsZW1lbnRhdGlvbiBvZiBzaW5ndWxhciB2YWx1ZSBkZWNvbXBvc2l0aW9uLlxyXG4gICAgICAgIC8vLyBJbiBhIGxhdGVyIHJlbGVhc2UsIGl0IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIHNwYXJzZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAvLy8gPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIGRvdWJsZSBMMk5vcm0oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN2ZChmYWxzZSkuTDJOb3JtO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PkNhbGN1bGF0ZXMgdGhlIGluZHVjZWQgaW5maW5pdHkgbm9ybSBvZiB0aGlzIG1hdHJpeC48L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBtYXhpbXVtIGFic29sdXRlIHJvdyBzdW0gb2YgdGhlIG1hdHJpeC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGRvdWJsZSBJbmZpbml0eU5vcm0oKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PkNhbGN1bGF0ZXMgdGhlIGVudHJ5LXdpc2UgRnJvYmVuaXVzIG5vcm0gb2YgdGhpcyBtYXRyaXguPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHN1bSBvZiB0aGUgc3F1YXJlZCB2YWx1ZXMuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBkb3VibGUgRnJvYmVuaXVzTm9ybSgpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIHAtbm9ybXMgb2YgYWxsIHJvdyB2ZWN0b3JzLlxyXG4gICAgICAgIC8vLyBUeXBpY2FsIHZhbHVlcyBmb3IgcCBhcmUgMS4wIChMMSwgTWFuaGF0dGFuIG5vcm0pLCAyLjAgKEwyLCBFdWNsaWRlYW4gbm9ybSkgYW5kIHBvc2l0aXZlIGluZmluaXR5IChpbmZpbml0eSBub3JtKVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IFZlY3Rvcjxkb3VibGU+IFJvd05vcm1zKGRvdWJsZSBub3JtKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYWxjdWxhdGVzIHRoZSBwLW5vcm1zIG9mIGFsbCBjb2x1bW4gdmVjdG9ycy5cclxuICAgICAgICAvLy8gVHlwaWNhbCB2YWx1ZXMgZm9yIHAgYXJlIDEuMCAoTDEsIE1hbmhhdHRhbiBub3JtKSwgMi4wIChMMiwgRXVjbGlkZWFuIG5vcm0pIGFuZCBwb3NpdGl2ZSBpbmZpbml0eSAoaW5maW5pdHkgbm9ybSlcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBWZWN0b3I8ZG91YmxlPiBDb2x1bW5Ob3Jtcyhkb3VibGUgbm9ybSk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTm9ybWFsaXplcyBhbGwgcm93IHZlY3RvcnMgdG8gYSB1bml0IHAtbm9ybS5cclxuICAgICAgICAvLy8gVHlwaWNhbCB2YWx1ZXMgZm9yIHAgYXJlIDEuMCAoTDEsIE1hbmhhdHRhbiBub3JtKSwgMi4wIChMMiwgRXVjbGlkZWFuIG5vcm0pIGFuZCBwb3NpdGl2ZSBpbmZpbml0eSAoaW5maW5pdHkgbm9ybSlcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBNYXRyaXg8VD4gTm9ybWFsaXplUm93cyhkb3VibGUgbm9ybSk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTm9ybWFsaXplcyBhbGwgY29sdW1uIHZlY3RvcnMgdG8gYSB1bml0IHAtbm9ybS5cclxuICAgICAgICAvLy8gVHlwaWNhbCB2YWx1ZXMgZm9yIHAgYXJlIDEuMCAoTDEsIE1hbmhhdHRhbiBub3JtKSwgMi4wIChMMiwgRXVjbGlkZWFuIG5vcm0pIGFuZCBwb3NpdGl2ZSBpbmZpbml0eSAoaW5maW5pdHkgbm9ybSlcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBNYXRyaXg8VD4gTm9ybWFsaXplQ29sdW1ucyhkb3VibGUgbm9ybSk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsY3VsYXRlcyB0aGUgdmFsdWUgc3VtIG9mIGVhY2ggcm93IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBWZWN0b3I8VD4gUm93U3VtcygpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIHZhbHVlIHN1bSBvZiBlYWNoIGNvbHVtbiB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3QgVmVjdG9yPFQ+IENvbHVtblN1bXMoKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYWxjdWxhdGVzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBzdW0gb2YgZWFjaCByb3cgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IFZlY3RvcjxUPiBSb3dBYnNvbHV0ZVN1bXMoKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYWxjdWxhdGVzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBzdW0gb2YgZWFjaCBjb2x1bW4gdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IFZlY3RvcjxUPiBDb2x1bW5BYnNvbHV0ZVN1bXMoKTtcclxuXHJcbiAgICAgICAgI3JlZ2lvbiBFeGNlcHRpb25zIC0gcG9zc2libHkgbW92ZSBlbHNld2hlcmU/XHJcblxyXG4gICAgICAgIGludGVybmFsIHN0YXRpYyBFeGNlcHRpb24gRGltZW5zaW9uc0RvbnRNYXRjaDxURXhjZXB0aW9uPihNYXRyaXg8VD4gbGVmdCwgTWF0cml4PFQ+IHJpZ2h0LCBNYXRyaXg8VD4gcmVzdWx0LCBzdHJpbmcgcGFyYW1OYW1lID0gbnVsbClcclxuICAgICAgICAgICAgd2hlcmUgVEV4Y2VwdGlvbiA6IEV4Y2VwdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBzdHJpbmcuRm9ybWF0KFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4RGltZW5zaW9uczNcIiwgbGVmdC5Sb3dDb3VudCArIFwieFwiICsgbGVmdC5Db2x1bW5Db3VudCwgcmlnaHQuUm93Q291bnQgKyBcInhcIiArIHJpZ2h0LkNvbHVtbkNvdW50LCByZXN1bHQuUm93Q291bnQgKyBcInhcIiArIHJlc3VsdC5Db2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVFeGNlcHRpb248VEV4Y2VwdGlvbj4obWVzc2FnZSwgcGFyYW1OYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHN0YXRpYyBFeGNlcHRpb24gRGltZW5zaW9uc0RvbnRNYXRjaDxURXhjZXB0aW9uPihNYXRyaXg8VD4gbGVmdCwgTWF0cml4PFQ+IHJpZ2h0LCBzdHJpbmcgcGFyYW1OYW1lID0gbnVsbClcclxuICAgICAgICAgICAgd2hlcmUgVEV4Y2VwdGlvbiA6IEV4Y2VwdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBzdHJpbmcuRm9ybWF0KFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4RGltZW5zaW9uczJcIiwgbGVmdC5Sb3dDb3VudCArIFwieFwiICsgbGVmdC5Db2x1bW5Db3VudCwgcmlnaHQuUm93Q291bnQgKyBcInhcIiArIHJpZ2h0LkNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUV4Y2VwdGlvbjxURXhjZXB0aW9uPihtZXNzYWdlLCBwYXJhbU5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgc3RhdGljIEV4Y2VwdGlvbiBEaW1lbnNpb25zRG9udE1hdGNoPFRFeGNlcHRpb24+KE1hdHJpeDxUPiBtYXRyaXgpXHJcbiAgICAgICAgICAgIHdoZXJlIFRFeGNlcHRpb24gOiBFeGNlcHRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gc3RyaW5nLkZvcm1hdChcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeERpbWVuc2lvbnMxXCIsIG1hdHJpeC5Sb3dDb3VudCArIFwieFwiICsgbWF0cml4LkNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUV4Y2VwdGlvbjxURXhjZXB0aW9uPihtZXNzYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHN0YXRpYyBFeGNlcHRpb24gRGltZW5zaW9uc0RvbnRNYXRjaDxURXhjZXB0aW9uPihNYXRyaXg8VD4gbGVmdCwgVmVjdG9yPFQ+IHJpZ2h0LCBWZWN0b3I8VD4gcmVzdWx0LCBzdHJpbmcgcGFyYW1OYW1lID0gbnVsbClcclxuICAgICAgICAgICAgd2hlcmUgVEV4Y2VwdGlvbiA6IEV4Y2VwdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIERpbWVuc2lvbnNEb250TWF0Y2g8VEV4Y2VwdGlvbj4obGVmdCwgcmlnaHQuVG9Db2x1bW5NYXRyaXgoKSwgcmVzdWx0LlRvQ29sdW1uTWF0cml4KCksIHBhcmFtTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBzdGF0aWMgRXhjZXB0aW9uIERpbWVuc2lvbnNEb250TWF0Y2g8VEV4Y2VwdGlvbj4oTWF0cml4PFQ+IGxlZnQsIFZlY3RvcjxUPiByaWdodCwgc3RyaW5nIHBhcmFtTmFtZSA9IG51bGwpXHJcbiAgICAgICAgICAgIHdoZXJlIFRFeGNlcHRpb24gOiBFeGNlcHRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBEaW1lbnNpb25zRG9udE1hdGNoPFRFeGNlcHRpb24+KGxlZnQsIHJpZ2h0LlRvQ29sdW1uTWF0cml4KCksIHBhcmFtTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBzdGF0aWMgRXhjZXB0aW9uIERpbWVuc2lvbnNEb250TWF0Y2g8VEV4Y2VwdGlvbj4oVmVjdG9yPFQ+IGxlZnQsIE1hdHJpeDxUPiByaWdodCwgc3RyaW5nIHBhcmFtTmFtZSA9IG51bGwpXHJcbiAgICAgICAgICAgIHdoZXJlIFRFeGNlcHRpb24gOiBFeGNlcHRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBEaW1lbnNpb25zRG9udE1hdGNoPFRFeGNlcHRpb24+KGxlZnQuVG9Db2x1bW5NYXRyaXgoKSwgcmlnaHQsIHBhcmFtTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBzdGF0aWMgRXhjZXB0aW9uIERpbWVuc2lvbnNEb250TWF0Y2g8VEV4Y2VwdGlvbj4oVmVjdG9yPFQ+IGxlZnQsIFZlY3RvcjxUPiByaWdodCwgc3RyaW5nIHBhcmFtTmFtZSA9IG51bGwpXHJcbiAgICAgICAgICAgIHdoZXJlIFRFeGNlcHRpb24gOiBFeGNlcHRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBEaW1lbnNpb25zRG9udE1hdGNoPFRFeGNlcHRpb24+KGxlZnQuVG9Db2x1bW5NYXRyaXgoKSwgcmlnaHQuVG9Db2x1bW5NYXRyaXgoKSwgcGFyYW1OYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBFeGNlcHRpb24gQ3JlYXRlRXhjZXB0aW9uPFRFeGNlcHRpb24+KHN0cmluZyBtZXNzYWdlLCBzdHJpbmcgcGFyYW1OYW1lID0gbnVsbClcclxuICAgICAgICAgICAgd2hlcmUgVEV4Y2VwdGlvbiA6IEV4Y2VwdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoVEV4Y2VwdGlvbikgPT0gdHlwZW9mIChBcmd1bWVudEV4Y2VwdGlvbikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJndW1lbnRFeGNlcHRpb24obWVzc2FnZSwgcGFyYW1OYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChURXhjZXB0aW9uKSA9PSB0eXBlb2YgKEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKHBhcmFtTmFtZSwgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeGNlcHRpb24obWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiTWF0cml4LkJDTC5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDE0IE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIFN5c3RlbS5MaW5xO1xyXG51c2luZyBTeXN0ZW0uVGV4dDtcclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmFcclxue1xyXG4gICAgW0RlYnVnZ2VyRGlzcGxheShcIk1hdHJpeCB7Um93Q291bnR9eHtDb2x1bW5Db3VudH1cIildXHJcblxyXG4gICAgcHVibGljIGFic3RyYWN0IHBhcnRpYWwgY2xhc3MgTWF0cml4PFQ+XHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY3VycmVudCBvYmplY3QgaXMgZXF1YWwgdG8gYW5vdGhlciBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+XHJcbiAgICAgICAgLy8vIEFuIG9iamVjdCB0byBjb21wYXJlIHdpdGggdGhpcyBvYmplY3QuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8Yz50cnVlPC9jPiBpZiB0aGUgY3VycmVudCBvYmplY3QgaXMgZXF1YWwgdG8gdGhlIDxwYXJhbXJlZiBuYW1lPVwib3RoZXJcIi8+IHBhcmFtZXRlcjsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYm9vbCBFcXVhbHMoTWF0cml4PFQ+IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG90aGVyICE9IG51bGwgJiYgU3RvcmFnZS5FcXVhbHMob3RoZXIuU3RvcmFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIDxzZWUgY3JlZj1cIlN5c3RlbS5PYmplY3RcIi8+IGlzIGVxdWFsIHRvIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvYmpcIj5UaGUgPHNlZSBjcmVmPVwiU3lzdGVtLk9iamVjdFwiLz4gdG8gY29tcGFyZSB3aXRoIHRoaXMgaW5zdGFuY2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vICAgICA8Yz50cnVlPC9jPiBpZiB0aGUgc3BlY2lmaWVkIDxzZWUgY3JlZj1cIlN5c3RlbS5PYmplY3RcIi8+IGlzIGVxdWFsIHRvIHRoaXMgaW5zdGFuY2U7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgRXF1YWxzKG9iamVjdCBvYmopXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBvYmogYXMgTWF0cml4PFQ+O1xyXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgIT0gbnVsbCAmJiBTdG9yYWdlLkVxdWFscyhvdGhlci5TdG9yYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIGhhc2ggY29kZSBmb3IgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gQSBoYXNoIGNvZGUgZm9yIHRoaXMgaW5zdGFuY2UsIHN1aXRhYmxlIGZvciB1c2UgaW4gaGFzaGluZyBhbGdvcml0aG1zIGFuZCBkYXRhIHN0cnVjdHVyZXMgbGlrZSBhIGhhc2ggdGFibGUuXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IEdldEhhc2hDb2RlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdG9yYWdlLkdldEhhc2hDb2RlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuI2lmICFORVRTVEFOREFSRDFfM1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaXMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGluc3RhbmNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBBIG5ldyBvYmplY3QgdGhhdCBpcyBhIGNvcHkgb2YgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIG9iamVjdCBJQ2xvbmVhYmxlLkNsb25lKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDbG9uZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiNlbmRpZlxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBkZXNjcmliZXMgdGhlIHR5cGUsIGRpbWVuc2lvbnMgYW5kIHNoYXBlIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgc3RyaW5nIFRvVHlwZVN0cmluZygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLkZvcm1hdChcInswfSB7MX14ezJ9LXszfVwiLCBHZXRUeXBlKCkuTmFtZSwgUm93Q291bnQsIENvbHVtbkNvdW50LCB0eXBlb2YgKFQpLk5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgc3RyaW5nIDJEIGFycmF5IHRoYXQgc3VtbWFyaXplcyB0aGUgY29udGVudCBvZiB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdHJpbmdbLF0gVG9NYXRyaXhTdHJpbmdBcnJheShpbnQgdXBwZXJSb3dzLCBpbnQgbG93ZXJSb3dzLCBpbnQgbGVmdENvbHVtbnMsIGludCByaWdodENvbHVtbnMsXHJcbiAgICAgICAgICAgIHN0cmluZyBob3Jpem9udGFsRWxsaXBzaXMsIHN0cmluZyB2ZXJ0aWNhbEVsbGlwc2lzLCBzdHJpbmcgZGlhZ29uYWxFbGxpcHNpcywgRnVuYzxULCBzdHJpbmc+IGZvcm1hdFZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdXBwZXJSb3dzID0gTWF0aC5NYXgodXBwZXJSb3dzLCAxKTtcclxuICAgICAgICAgICAgbG93ZXJSb3dzID0gTWF0aC5NYXgobG93ZXJSb3dzLCAwKTtcclxuICAgICAgICAgICAgbGVmdENvbHVtbnMgPSBNYXRoLk1heChsZWZ0Q29sdW1ucywgMSk7XHJcbiAgICAgICAgICAgIHJpZ2h0Q29sdW1ucyA9IE1hdGguTWF4KHJpZ2h0Q29sdW1ucywgMCk7XHJcblxyXG4gICAgICAgICAgICBpbnQgdXBwZXIgPSBSb3dDb3VudCA8PSB1cHBlclJvd3MgPyBSb3dDb3VudCA6IHVwcGVyUm93cztcclxuICAgICAgICAgICAgaW50IGxvd2VyID0gUm93Q291bnQgPD0gdXBwZXJSb3dzID8gMCA6IFJvd0NvdW50IDw9IHVwcGVyUm93cyArIGxvd2VyUm93cyA/IFJvd0NvdW50IC0gdXBwZXJSb3dzIDogbG93ZXJSb3dzO1xyXG4gICAgICAgICAgICBib29sIHJvd0VsbGlwc2lzID0gUm93Q291bnQgPiB1cHBlciArIGxvd2VyO1xyXG4gICAgICAgICAgICBpbnQgcm93cyA9IHJvd0VsbGlwc2lzID8gdXBwZXIgKyBsb3dlciArIDEgOiB1cHBlciArIGxvd2VyO1xyXG5cclxuICAgICAgICAgICAgaW50IGxlZnQgPSBDb2x1bW5Db3VudCA8PSBsZWZ0Q29sdW1ucyA/IENvbHVtbkNvdW50IDogbGVmdENvbHVtbnM7XHJcbiAgICAgICAgICAgIGludCByaWdodCA9IENvbHVtbkNvdW50IDw9IGxlZnRDb2x1bW5zID8gMCA6IENvbHVtbkNvdW50IDw9IGxlZnRDb2x1bW5zICsgcmlnaHRDb2x1bW5zID8gQ29sdW1uQ291bnQgLSBsZWZ0Q29sdW1ucyA6IHJpZ2h0Q29sdW1ucztcclxuICAgICAgICAgICAgYm9vbCBjb2xFbGxpcHNpcyA9IENvbHVtbkNvdW50ID4gbGVmdCArIHJpZ2h0O1xyXG4gICAgICAgICAgICBpbnQgY29scyA9IGNvbEVsbGlwc2lzID8gbGVmdCArIHJpZ2h0ICsgMSA6IGxlZnQgKyByaWdodDtcclxuXHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBzdHJpbmdbcm93cywgY29sc107XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdXBwZXI7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBsZWZ0OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbaSwgal0gPSBmb3JtYXRWYWx1ZShBdChpLCBqKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnQgY29sT2Zmc2V0ID0gbGVmdDtcclxuICAgICAgICAgICAgICAgIGlmIChjb2xFbGxpcHNpcylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVtpLCBsZWZ0XSA9IGhvcml6b250YWxFbGxpcHNpcztcclxuICAgICAgICAgICAgICAgICAgICBjb2xPZmZzZXQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgcmlnaHQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVtpLCBjb2xPZmZzZXQgKyBqXSA9IGZvcm1hdFZhbHVlKEF0KGksIENvbHVtbkNvdW50IC0gcmlnaHQgKyBqKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW50IHJvd09mZnNldCA9IHVwcGVyO1xyXG4gICAgICAgICAgICBpZiAocm93RWxsaXBzaXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbGVmdDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3VwcGVyLCBqXSA9IHZlcnRpY2FsRWxsaXBzaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnQgY29sT2Zmc2V0ID0gbGVmdDtcclxuICAgICAgICAgICAgICAgIGlmIChjb2xFbGxpcHNpcylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVt1cHBlciwgbGVmdF0gPSBkaWFnb25hbEVsbGlwc2lzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbE9mZnNldCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCByaWdodDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3VwcGVyLCBjb2xPZmZzZXQgKyBqXSA9IHZlcnRpY2FsRWxsaXBzaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByb3dPZmZzZXQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGxvd2VyOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbGVmdDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3Jvd09mZnNldCArIGksIGpdID0gZm9ybWF0VmFsdWUoQXQoUm93Q291bnQgLSBsb3dlciArIGksIGopKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGludCBjb2xPZmZzZXQgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbEVsbGlwc2lzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3Jvd09mZnNldCArIGksIGxlZnRdID0gaG9yaXpvbnRhbEVsbGlwc2lzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbE9mZnNldCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCByaWdodDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3Jvd09mZnNldCArIGksIGNvbE9mZnNldCArIGpdID0gZm9ybWF0VmFsdWUoQXQoUm93Q291bnQgLSBsb3dlciArIGksIENvbHVtbkNvdW50IC0gcmlnaHQgKyBqKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgc3RyaW5nIDJEIGFycmF5IHRoYXQgc3VtbWFyaXplcyB0aGUgY29udGVudCBvZiB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdHJpbmdbLF0gVG9NYXRyaXhTdHJpbmdBcnJheShpbnQgdXBwZXJSb3dzLCBpbnQgbG93ZXJSb3dzLCBpbnQgbWluTGVmdENvbHVtbnMsIGludCByaWdodENvbHVtbnMsIGludCBtYXhXaWR0aCwgaW50IHBhZGRpbmcsXHJcbiAgICAgICAgICAgIHN0cmluZyBob3Jpem9udGFsRWxsaXBzaXMsIHN0cmluZyB2ZXJ0aWNhbEVsbGlwc2lzLCBzdHJpbmcgZGlhZ29uYWxFbGxpcHNpcywgRnVuYzxULCBzdHJpbmc+IGZvcm1hdFZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdXBwZXJSb3dzID0gTWF0aC5NYXgodXBwZXJSb3dzLCAxKTtcclxuICAgICAgICAgICAgbG93ZXJSb3dzID0gTWF0aC5NYXgobG93ZXJSb3dzLCAwKTtcclxuICAgICAgICAgICAgbWluTGVmdENvbHVtbnMgPSBNYXRoLk1heChtaW5MZWZ0Q29sdW1ucywgMSk7XHJcbiAgICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5NYXgobWF4V2lkdGgsIDEyKTtcclxuXHJcbiAgICAgICAgICAgIGludCB1cHBlciA9IFJvd0NvdW50IDw9IHVwcGVyUm93cyA/IFJvd0NvdW50IDogdXBwZXJSb3dzO1xyXG4gICAgICAgICAgICBpbnQgbG93ZXIgPSBSb3dDb3VudCA8PSB1cHBlclJvd3MgPyAwIDogUm93Q291bnQgPD0gdXBwZXJSb3dzICsgbG93ZXJSb3dzID8gUm93Q291bnQgLSB1cHBlclJvd3MgOiBsb3dlclJvd3M7XHJcbiAgICAgICAgICAgIGJvb2wgcm93RWxsaXBzaXMgPSBSb3dDb3VudCA+IHVwcGVyICsgbG93ZXI7XHJcbiAgICAgICAgICAgIGludCByb3dzID0gcm93RWxsaXBzaXMgPyB1cHBlciArIGxvd2VyICsgMSA6IHVwcGVyICsgbG93ZXI7XHJcblxyXG4gICAgICAgICAgICBpbnQgbGVmdCA9IENvbHVtbkNvdW50IDw9IG1pbkxlZnRDb2x1bW5zID8gQ29sdW1uQ291bnQgOiBtaW5MZWZ0Q29sdW1ucztcclxuICAgICAgICAgICAgaW50IHJpZ2h0ID0gQ29sdW1uQ291bnQgPD0gbWluTGVmdENvbHVtbnMgPyAwIDogQ29sdW1uQ291bnQgPD0gbWluTGVmdENvbHVtbnMgKyByaWdodENvbHVtbnMgPyBDb2x1bW5Db3VudCAtIG1pbkxlZnRDb2x1bW5zIDogcmlnaHRDb2x1bW5zO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbHVtbnNMZWZ0ID0gbmV3IExpc3Q8VHVwbGU8aW50LCBzdHJpbmdbXT4+KCk7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbGVmdDsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5zTGVmdC5BZGQoRm9ybWF0Q29sdW1uKGosIHJvd3MsIHVwcGVyLCBsb3dlciwgcm93RWxsaXBzaXMsIHZlcnRpY2FsRWxsaXBzaXMsIChGdW5jPFQsc3RyaW5nPilmb3JtYXRWYWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgY29sdW1uc1JpZ2h0ID0gbmV3IExpc3Q8VHVwbGU8aW50LCBzdHJpbmdbXT4+KCk7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgcmlnaHQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29sdW1uc1JpZ2h0LkFkZChGb3JtYXRDb2x1bW4oQ29sdW1uQ291bnQgLSByaWdodCArIGosIHJvd3MsIHVwcGVyLCBsb3dlciwgcm93RWxsaXBzaXMsIHZlcnRpY2FsRWxsaXBzaXMsIChGdW5jPFQsc3RyaW5nPilmb3JtYXRWYWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpbnQgY2hhcnMgPSBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlN1bTxUdXBsZTxpbnQsc3RyaW5nW10+Pihjb2x1bW5zTGVmdCwoRnVuYzxUdXBsZTxpbnQsc3RyaW5nW10+LGludD4pKHQgPT4gdC5JdGVtMSArIHBhZGRpbmcpKSArIFN5c3RlbS5MaW5xLkVudW1lcmFibGUuU3VtPFR1cGxlPGludCxzdHJpbmdbXT4+KGNvbHVtbnNSaWdodCwoRnVuYzxUdXBsZTxpbnQsc3RyaW5nW10+LGludD4pKHQgPT4gdC5JdGVtMSArIHBhZGRpbmcpKTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IGxlZnQ7IGogPCBDb2x1bW5Db3VudCAtIHJpZ2h0OyBqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSBGb3JtYXRDb2x1bW4oaiwgcm93cywgdXBwZXIsIGxvd2VyLCByb3dFbGxpcHNpcywgdmVydGljYWxFbGxpcHNpcywgKEZ1bmM8VCxzdHJpbmc+KWZvcm1hdFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNoYXJzICs9IGNhbmRpZGF0ZS5JdGVtMSArIHBhZGRpbmc7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnMgPiBtYXhXaWR0aClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbHVtbnNMZWZ0LkFkZChjYW5kaWRhdGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpbnQgY29scyA9IGNvbHVtbnNMZWZ0LkNvdW50ICsgY29sdW1uc1JpZ2h0LkNvdW50O1xyXG4gICAgICAgICAgICBib29sIGNvbEVsbGlwc2lzID0gQ29sdW1uQ291bnQgPiBjb2xzO1xyXG4gICAgICAgICAgICBpZiAoY29sRWxsaXBzaXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbHMrKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGFycmF5ID0gbmV3IHN0cmluZ1tyb3dzLCBjb2xzXTtcclxuICAgICAgICAgICAgaW50IGNvbEluZGV4ID0gMDtcclxuICAgICAgICAgICAgZm9yZWFjaCAodmFyIGNvbHVtbiBpbiBjb2x1bW5zTGVmdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBjb2x1bW4uSXRlbTIuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbaSwgY29sSW5kZXhdID0gY29sdW1uLkl0ZW0yW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29sSW5kZXgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29sRWxsaXBzaXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCByb3dJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCB1cHBlcjsgcm93KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbcm93SW5kZXgrKywgY29sSW5kZXhdID0gaG9yaXpvbnRhbEVsbGlwc2lzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJvd0VsbGlwc2lzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3Jvd0luZGV4KyssIGNvbEluZGV4XSA9IGRpYWdvbmFsRWxsaXBzaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByb3cgPSBSb3dDb3VudCAtIGxvd2VyOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbcm93SW5kZXgrKywgY29sSW5kZXhdID0gaG9yaXpvbnRhbEVsbGlwc2lzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29sSW5kZXgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3JlYWNoICh2YXIgY29sdW1uIGluIGNvbHVtbnNSaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBjb2x1bW4uSXRlbTIuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbaSwgY29sSW5kZXhdID0gY29sdW1uLkl0ZW0yW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29sSW5kZXgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBUdXBsZTxpbnQsIHN0cmluZ1tdPiBGb3JtYXRDb2x1bW4oaW50IGNvbHVtbiwgaW50IGhlaWdodCwgaW50IHVwcGVyLCBpbnQgbG93ZXIsIGJvb2wgd2l0aEVsbGlwc2lzLCBzdHJpbmcgZWxsaXBzaXMsIEZ1bmM8VCwgc3RyaW5nPiBmb3JtYXRWYWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjID0gbmV3IHN0cmluZ1toZWlnaHRdO1xyXG4gICAgICAgICAgICBpbnQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCB1cHBlcjsgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNbaW5kZXgrK10gPSBmb3JtYXRWYWx1ZShBdChyb3csIGNvbHVtbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh3aXRoRWxsaXBzaXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNbaW5kZXgrK10gPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IFJvd0NvdW50IC0gbG93ZXI7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY1tpbmRleCsrXSA9IGZvcm1hdFZhbHVlKEF0KHJvdywgY29sdW1uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW50IHcgPSBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLk1heDxzdHJpbmc+KGMsKEZ1bmM8c3RyaW5nLGludD4pKHggPT4geC5MZW5ndGgpKTtcclxuICAgICAgICAgICAgaWYgKHdpdGhFbGxpcHNpcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY1t1cHBlcl0gPSBlbGxpcHNpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgc3RyaW5nW10+KHcsIGMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIHN0cmluZyBGb3JtYXRTdHJpbmdBcnJheVRvU3RyaW5nKHN0cmluZ1ssXSBhcnJheSwgc3RyaW5nIGNvbHVtblNlcGFyYXRvciwgc3RyaW5nIHJvd1NlcGFyYXRvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByb3dzID0gYXJyYXkuR2V0TGVuZ3RoKDApO1xyXG4gICAgICAgICAgICB2YXIgY29scyA9IGFycmF5LkdldExlbmd0aCgxKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB3aWR0aHMgPSBuZXcgaW50W2NvbHNdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHJvd3M7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBjb2xzOyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhzW2pdID0gTWF0aC5NYXgod2lkdGhzW2pdLCBhcnJheVtpLCBqXS5MZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHJvd3M7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2IuQXBwZW5kKGFycmF5W2ksIDBdLlBhZExlZnQod2lkdGhzWzBdKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMTsgaiA8IGNvbHM7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoY29sdW1uU2VwYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoYXJyYXlbaSwgal0uUGFkTGVmdCh3aWR0aHNbal0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNiLkFwcGVuZChyb3dTZXBhcmF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzYi5Ub1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0cmluZyBUb01hdHJpeFN0cmluZyhpbnQgdXBwZXJSb3dzLCBpbnQgbG93ZXJSb3dzLCBpbnQgbGVmdENvbHVtbnMsIGludCByaWdodENvbHVtbnMsXHJcbiAgICAgICAgICAgIHN0cmluZyBob3Jpem9udGFsRWxsaXBzaXMsIHN0cmluZyB2ZXJ0aWNhbEVsbGlwc2lzLCBzdHJpbmcgZGlhZ29uYWxFbGxpcHNpcyxcclxuICAgICAgICAgICAgc3RyaW5nIGNvbHVtblNlcGFyYXRvciwgc3RyaW5nIHJvd1NlcGFyYXRvciwgRnVuYzxULCBzdHJpbmc+IGZvcm1hdFZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEZvcm1hdFN0cmluZ0FycmF5VG9TdHJpbmcoXHJcbiAgICAgICAgICAgICAgICBUb01hdHJpeFN0cmluZ0FycmF5KHVwcGVyUm93cywgbG93ZXJSb3dzLCBsZWZ0Q29sdW1ucywgcmlnaHRDb2x1bW5zLCBob3Jpem9udGFsRWxsaXBzaXMsIHZlcnRpY2FsRWxsaXBzaXMsIGRpYWdvbmFsRWxsaXBzaXMsIChGdW5jPFQsc3RyaW5nPilmb3JtYXRWYWx1ZSksXHJcbiAgICAgICAgICAgICAgICBjb2x1bW5TZXBhcmF0b3IsIHJvd1NlcGFyYXRvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RyaW5nIFRvTWF0cml4U3RyaW5nKGludCB1cHBlclJvd3MsIGludCBsb3dlclJvd3MsIGludCBtaW5MZWZ0Q29sdW1ucywgaW50IHJpZ2h0Q29sdW1ucywgaW50IG1heFdpZHRoLFxyXG4gICAgICAgICAgICBzdHJpbmcgaG9yaXpvbnRhbEVsbGlwc2lzLCBzdHJpbmcgdmVydGljYWxFbGxpcHNpcywgc3RyaW5nIGRpYWdvbmFsRWxsaXBzaXMsXHJcbiAgICAgICAgICAgIHN0cmluZyBjb2x1bW5TZXBhcmF0b3IsIHN0cmluZyByb3dTZXBhcmF0b3IsIEZ1bmM8VCwgc3RyaW5nPiBmb3JtYXRWYWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBGb3JtYXRTdHJpbmdBcnJheVRvU3RyaW5nKFxyXG4gICAgICAgICAgICAgICAgVG9NYXRyaXhTdHJpbmdBcnJheSh1cHBlclJvd3MsIGxvd2VyUm93cywgbWluTGVmdENvbHVtbnMsIHJpZ2h0Q29sdW1ucywgbWF4V2lkdGgsIGNvbHVtblNlcGFyYXRvci5MZW5ndGgsIGhvcml6b250YWxFbGxpcHNpcywgdmVydGljYWxFbGxpcHNpcywgZGlhZ29uYWxFbGxpcHNpcywgKEZ1bmM8VCxzdHJpbmc+KWZvcm1hdFZhbHVlKSxcclxuICAgICAgICAgICAgICAgIGNvbHVtblNlcGFyYXRvciwgcm93U2VwYXJhdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IHN1bW1hcml6ZXMgdGhlIGNvbnRlbnQgb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RyaW5nIFRvTWF0cml4U3RyaW5nKGludCBtYXhSb3dzLCBpbnQgbWF4Q29sdW1ucywgc3RyaW5nIGZvcm1hdCA9IG51bGwsIElGb3JtYXRQcm92aWRlciBwcm92aWRlciA9IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdCA9IFwiRzZcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW50IGJvdHRvbSA9IG1heFJvd3MgPiA0ID8gMiA6IDA7XHJcbiAgICAgICAgICAgIGludCByaWdodCA9IG1heENvbHVtbnMgPiA0ID8gMiA6IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBUb01hdHJpeFN0cmluZyhtYXhSb3dzIC0gYm90dG9tLCBib3R0b20sIG1heENvbHVtbnMgLSByaWdodCwgcmlnaHQsIFwiLi5cIiwgXCIuLlwiLCBcIi4uXCIsIFwiICBcIiwgRW52aXJvbm1lbnQuTmV3TGluZSwgKEZ1bmM8VCxzdHJpbmc+KSh4ID0+IHguVG9TdHJpbmcoZm9ybWF0LCBwcm92aWRlcikpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IHN1bW1hcml6ZXMgdGhlIGNvbnRlbnQgb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RyaW5nIFRvTWF0cml4U3RyaW5nKHN0cmluZyBmb3JtYXQgPSBudWxsLCBJRm9ybWF0UHJvdmlkZXIgcHJvdmlkZXIgPSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBcIkc2XCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBUb01hdHJpeFN0cmluZyg4LCA0LCA1LCAyLCA3NiwgXCIuLlwiLCBcIi4uXCIsIFwiLi5cIiwgXCIgIFwiLCBFbnZpcm9ubWVudC5OZXdMaW5lLCAoRnVuYzxULHN0cmluZz4pKHggPT4geC5Ub1N0cmluZyhmb3JtYXQsIHByb3ZpZGVyKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgc3VtbWFyaXplcyB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdHJpbmcgVG9TdHJpbmcoaW50IG1heFJvd3MsIGludCBtYXhDb2x1bW5zLCBzdHJpbmcgZm9ybWF0ID0gbnVsbCwgSUZvcm1hdFByb3ZpZGVyIGZvcm1hdFByb3ZpZGVyID0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcuQ29uY2F0KFRvVHlwZVN0cmluZygpLCBFbnZpcm9ubWVudC5OZXdMaW5lLCBUb01hdHJpeFN0cmluZyhtYXhSb3dzLCBtYXhDb2x1bW5zLCBmb3JtYXQsIGZvcm1hdFByb3ZpZGVyKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBzdW1tYXJpemVzIHRoaXMgbWF0cml4LlxyXG4gICAgICAgIC8vLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgY2VsbHMgY2FuIGJlIGNvbmZpZ3VyZWQgaW4gdGhlIDxzZWUgY3JlZj1cIkNvbnRyb2xcIi8+IGNsYXNzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHNlYWxlZCBvdmVycmlkZSBzdHJpbmcgVG9TdHJpbmcoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5Db25jYXQoVG9UeXBlU3RyaW5nKCksIEVudmlyb25tZW50Lk5ld0xpbmUsIFRvTWF0cml4U3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgc3VtbWFyaXplcyB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGNlbGxzIGNhbiBiZSBjb25maWd1cmVkIGluIHRoZSA8c2VlIGNyZWY9XCJDb250cm9sXCIvPiBjbGFzcy5cclxuICAgICAgICAvLy8gVGhlIGZvcm1hdCBzdHJpbmcgaXMgaWdub3JlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdHJpbmcgVG9TdHJpbmcoc3RyaW5nIGZvcm1hdCA9IG51bGwsIElGb3JtYXRQcm92aWRlciBmb3JtYXRQcm92aWRlciA9IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLkNvbmNhdChUb1R5cGVTdHJpbmcoKSwgRW52aXJvbm1lbnQuTmV3TGluZSwgVG9NYXRyaXhTdHJpbmcoZm9ybWF0LCBmb3JtYXRQcm92aWRlcikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvLyA8Y29weXJpZ2h0IGZpbGU9XCJNYXRyaXguQXJpdGhtZXRpYy5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDEzIE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5SdW50aW1lLkNvbXBpbGVyU2VydmljZXM7XHJcblxyXG5uYW1lc3BhY2UgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBEZWZpbmVzIHRoZSBiYXNlIGNsYXNzIGZvciA8Yz5NYXRyaXg8L2M+IGNsYXNzZXMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGFic3RyYWN0IHBhcnRpYWwgY2xhc3MgTWF0cml4PFQ+XHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgPHN0cm9uZz5NYXRyaXg8L3N0cm9uZz4gY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgb2YgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIG1hdHJpeCB0byBnZXQgdGhlIHZhbHVlcyBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgbWF0cml4IGNvbnRhaW5pbmcgYSB0aGUgc2FtZSB2YWx1ZXMgYXMgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+LjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gb3BlcmF0b3IgKyhNYXRyaXg8VD4gcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0U2lkZS5DbG9uZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOZWdhdGVzIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIG1hdHJpeCB0byBuZWdhdGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBtYXRyaXggY29udGFpbmluZyB0aGUgbmVnYXRlZCB2YWx1ZXMuPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBvcGVyYXRvciAtKE1hdHJpeDxUPiByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gcmlnaHRTaWRlLk5lZ2F0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGRzIHR3byBtYXRyaWNlcyB0b2dldGhlciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5UaGlzIG9wZXJhdG9yIHdpbGwgYWxsb2NhdGUgbmV3IG1lbW9yeSBmb3IgdGhlIHJlc3VsdC4gSXQgd2lsbFxyXG4gICAgICAgIC8vLyBjaG9vc2UgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGVpdGhlciA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gZGVwZW5kaW5nIG9uIHdoaWNoXHJcbiAgICAgICAgLy8vIGlzIGRlbnNlci48L3JlbWFya3M+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgbGVmdCBtYXRyaXggdG8gYWRkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHJpZ2h0IG1hdHJpeCB0byBhZGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGRvbid0IGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucy48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gb3IgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gb3BlcmF0b3IgKyhNYXRyaXg8VD4gbGVmdFNpZGUsIE1hdHJpeDxUPiByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdFNpZGUuQWRkKHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgYSBzY2FsYXIgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+VGhpcyBvcGVyYXRvciB3aWxsIGFsbG9jYXRlIG5ldyBtZW1vcnkgZm9yIHRoZSByZXN1bHQuIEl0IHdpbGxcclxuICAgICAgICAvLy8gY2hvb3NlIHRoZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJvdmlkZWQgbWF0cml4LjwvcmVtYXJrcz5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSBsZWZ0IG1hdHJpeCB0byBhZGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgc2NhbGFyIHZhbHVlIHRvIGFkZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gb3BlcmF0b3IgKyhNYXRyaXg8VD4gbGVmdFNpZGUsIFQgcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnRTaWRlLkFkZChyaWdodFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGRzIGEgc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlRoaXMgb3BlcmF0b3Igd2lsbCBhbGxvY2F0ZSBuZXcgbWVtb3J5IGZvciB0aGUgcmVzdWx0LiBJdCB3aWxsXHJcbiAgICAgICAgLy8vIGNob29zZSB0aGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByb3ZpZGVkIG1hdHJpeC48L3JlbWFya3M+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgc2NhbGFyIHZhbHVlIHRvIGFkZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSByaWdodCBtYXRyaXggdG8gYWRkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gb3BlcmF0b3IgKyhUIGxlZnRTaWRlLCBNYXRyaXg8VD4gcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0U2lkZS5BZGQobGVmdFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgdHdvIG1hdHJpY2VzIHRvZ2V0aGVyIGFuZCByZXR1cm5zIHRoZSByZXN1bHRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlRoaXMgb3BlcmF0b3Igd2lsbCBhbGxvY2F0ZSBuZXcgbWVtb3J5IGZvciB0aGUgcmVzdWx0LiBJdCB3aWxsXHJcbiAgICAgICAgLy8vIGNob29zZSB0aGUgcmVwcmVzZW50YXRpb24gb2YgZWl0aGVyIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBkZXBlbmRpbmcgb24gd2hpY2hcclxuICAgICAgICAvLy8gaXMgZGVuc2VyLjwvcmVtYXJrcz5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSBsZWZ0IG1hdHJpeCB0byBzdWJ0cmFjdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSByaWdodCBtYXRyaXggdG8gc3VidHJhY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGRvbid0IGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucy48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gb3IgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gb3BlcmF0b3IgLShNYXRyaXg8VD4gbGVmdFNpZGUsIE1hdHJpeDxUPiByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdFNpZGUuU3VidHJhY3QocmlnaHRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3VidHJhY3RzIGEgc2NhbGFyIGZyb20gZWFjaCBlbGVtZW50IG9mIGEgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlRoaXMgb3BlcmF0b3Igd2lsbCBhbGxvY2F0ZSBuZXcgbWVtb3J5IGZvciB0aGUgcmVzdWx0LiBJdCB3aWxsXHJcbiAgICAgICAgLy8vIGNob29zZSB0aGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByb3ZpZGVkIG1hdHJpeC48L3JlbWFya3M+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgbGVmdCBtYXRyaXggdG8gc3VidHJhY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgc2NhbGFyIHZhbHVlIHRvIHN1YnRyYWN0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gYW5kIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBkb24ndCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IG9wZXJhdG9yIC0oTWF0cml4PFQ+IGxlZnRTaWRlLCBUIHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0U2lkZS5TdWJ0cmFjdChyaWdodFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgZWFjaCBlbGVtZW50IG9mIGEgbWF0cml4IGZyb20gYSBzY2FsYXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+VGhpcyBvcGVyYXRvciB3aWxsIGFsbG9jYXRlIG5ldyBtZW1vcnkgZm9yIHRoZSByZXN1bHQuIEl0IHdpbGxcclxuICAgICAgICAvLy8gY2hvb3NlIHRoZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJvdmlkZWQgbWF0cml4LjwvcmVtYXJrcz5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSBzY2FsYXIgdmFsdWUgdG8gc3VidHJhY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgcmlnaHQgbWF0cml4IHRvIHN1YnRyYWN0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gYW5kIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBkb24ndCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IG9wZXJhdG9yIC0oVCBsZWZ0U2lkZSwgTWF0cml4PFQ+IHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiByaWdodFNpZGUuU3VidHJhY3RGcm9tKGxlZnRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyBhIDxzdHJvbmc+TWF0cml4PC9zdHJvbmc+IGJ5IGEgY29uc3RhbnQgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIG1hdHJpeCB0byBtdWx0aXBseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSBjb25zdGFudCB0byBtdWx0aXBseSB0aGUgbWF0cml4IGJ5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBvcGVyYXRvciAqKE1hdHJpeDxUPiBsZWZ0U2lkZSwgVCByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdFNpZGUuTXVsdGlwbHkocmlnaHRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyBhIDxzdHJvbmc+TWF0cml4PC9zdHJvbmc+IGJ5IGEgY29uc3RhbnQgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIG1hdHJpeCB0byBtdWx0aXBseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSBjb25zdGFudCB0byBtdWx0aXBseSB0aGUgbWF0cml4IGJ5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gb3BlcmF0b3IgKihUIGxlZnRTaWRlLCBNYXRyaXg8VD4gcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0U2lkZS5NdWx0aXBseShsZWZ0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdHdvIG1hdHJpY2VzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlRoaXMgb3BlcmF0b3Igd2lsbCBhbGxvY2F0ZSBuZXcgbWVtb3J5IGZvciB0aGUgcmVzdWx0LiBJdCB3aWxsXHJcbiAgICAgICAgLy8vIGNob29zZSB0aGUgcmVwcmVzZW50YXRpb24gb2YgZWl0aGVyIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBkZXBlbmRpbmcgb24gd2hpY2hcclxuICAgICAgICAvLy8gaXMgZGVuc2VyLjwvcmVtYXJrcz5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSBsZWZ0IG1hdHJpeCB0byBtdWx0aXBseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSByaWdodCBtYXRyaXggdG8gbXVsdGlwbHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSBkaW1lbnNpb25zIG9mIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBkb24ndCBjb25mb3JtLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IG9wZXJhdG9yICooTWF0cml4PFQ+IGxlZnRTaWRlLCBNYXRyaXg8VD4gcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnRTaWRlLk11bHRpcGx5KHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgYSA8c3Ryb25nPk1hdHJpeDwvc3Ryb25nPiBhbmQgYSBWZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgdmVjdG9yIHRvIG11bHRpcGx5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBvcGVyYXRvciAqKE1hdHJpeDxUPiBsZWZ0U2lkZSwgVmVjdG9yPFQ+IHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0U2lkZS5NdWx0aXBseShyaWdodFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIGEgVmVjdG9yIGFuZCBhIDxzdHJvbmc+TWF0cml4PC9zdHJvbmc+LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgdmVjdG9yIHRvIG11bHRpcGx5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIG1hdHJpeCB0byBtdWx0aXBseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gb3IgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gb3BlcmF0b3IgKihWZWN0b3I8VD4gbGVmdFNpZGUsIE1hdHJpeDxUPiByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gcmlnaHRTaWRlLkxlZnRNdWx0aXBseShsZWZ0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERpdmlkZXMgYSBzY2FsYXIgd2l0aCBhIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHNjYWxhciB0byBkaXZpZGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIG1hdHJpeC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwiZGl2aXNvclwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBvcGVyYXRvciAvKFQgZGl2aWRlbmQsIE1hdHJpeDxUPiBkaXZpc29yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuRGl2aWRlQnlUaGlzKGRpdmlkZW5kKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGl2aWRlcyBhIG1hdHJpeCB3aXRoIGEgc2NhbGFyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aWRlbmRcIj5UaGUgbWF0cml4IHRvIGRpdmlkZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgc2NhbGFyIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIGRpdmlzaW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJkaXZpZGVuZFwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBvcGVyYXRvciAvKE1hdHJpeDxUPiBkaXZpZGVuZCwgVCBkaXZpc29yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdmlkZW5kLkRpdmlkZShkaXZpc29yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHBvaW50d2lzZSByZW1haW5kZXIgKCUgb3BlcmF0b3IpLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aWRlbmQsXHJcbiAgICAgICAgLy8vIG9mIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IG9mIHRoZSBnaXZlbiBkaXZpc29yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aWRlbmRcIj5UaGUgbWF0cml4IHdob3NlIGVsZW1lbnRzIHdlIHdhbnQgdG8gY29tcHV0ZSB0aGUgbW9kdWx1cyBvZi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgZGl2aXNvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgY2FsY3VsYXRpb248L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwiZGl2aWRlbmRcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gb3BlcmF0b3IgJShNYXRyaXg8VD4gZGl2aWRlbmQsIFQgZGl2aXNvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXZpZGVuZC5SZW1haW5kZXIoZGl2aXNvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBwb2ludHdpc2UgcmVtYWluZGVyICglIG9wZXJhdG9yKSwgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlkZW5kLFxyXG4gICAgICAgIC8vLyBvZiB0aGUgZ2l2ZW4gZGl2aWRlbmQgb2YgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpZGVuZFwiPlRoZSBkaXZpZGVuZCB3ZSB3YW50IHRvIGNvbXB1dGUgdGhlIG1vZHVsdXMgb2YuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIG1hdHJpeCB3aG9zZSBlbGVtZW50cyB3ZSB3YW50IHRvIHVzZSBhcyBkaXZpc29yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIGNhbGN1bGF0aW9uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImRpdmlzb3JcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gb3BlcmF0b3IgJShUIGRpdmlkZW5kLCBNYXRyaXg8VD4gZGl2aXNvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXZpc29yLlJlbWFpbmRlckJ5VGhpcyhkaXZpZGVuZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBwb2ludHdpc2UgcmVtYWluZGVyICglIG9wZXJhdG9yKSwgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlkZW5kLFxyXG4gICAgICAgIC8vLyBvZiBlYWNoIGVsZW1lbnQgb2YgdHdvIG1hdHJpY2VzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aWRlbmRcIj5UaGUgbWF0cml4IHdob3NlIGVsZW1lbnRzIHdlIHdhbnQgdG8gY29tcHV0ZSB0aGUgcmVtYWluZGVyIG9mLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBkaXZpc29yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwiZGl2aWRlbmRcIi8+IGFuZCA8cGFyYW1yZWYgbmFtZT1cImRpdmlzb3JcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJkaXZpZGVuZFwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBvcGVyYXRvciAlKE1hdHJpeDxUPiBkaXZpZGVuZCwgTWF0cml4PFQ+IGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2aWRlbmQuUG9pbnR3aXNlUmVtYWluZGVyKGRpdmlzb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gb3BfRG90TXVsdGlwbHkoTWF0cml4PFQ+IHgsIE1hdHJpeDxUPiB5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlTXVsdGlwbHkoeSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBcclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBvcF9Eb3REaXZpZGUoTWF0cml4PFQ+IGRpdmlkZW5kLCBNYXRyaXg8VD4gZGl2aXNvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXZpZGVuZC5Qb2ludHdpc2VEaXZpZGUoZGl2aXNvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBcclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBvcF9Eb3RQZXJjZW50KE1hdHJpeDxUPiBkaXZpZGVuZCwgTWF0cml4PFQ+IGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2aWRlbmQuUG9pbnR3aXNlUmVtYWluZGVyKGRpdmlzb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gb3BfRG90SGF0KE1hdHJpeDxUPiBtYXRyaXgsIE1hdHJpeDxUPiBleHBvbmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRyaXguUG9pbnR3aXNlUG93ZXIoZXhwb25lbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gb3BfRG90SGF0KE1hdHJpeDxUPiBtYXRyaXgsIFQgZXhwb25lbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0cml4LlBvaW50d2lzZVBvd2VyKGV4cG9uZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHNxcnQgb2YgYSBtYXRyaXggcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IG1hdHJpeDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTcXJ0KE1hdHJpeDxUPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlU3FydCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgZXhwb25lbnRpYWwgb2YgYSBtYXRyaXggcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IG1hdHJpeDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBFeHAoTWF0cml4PFQ+IHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4geC5Qb2ludHdpc2VFeHAoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGxvZyBvZiBhIG1hdHJpeCBwb2ludHdpc2VcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgaW5wdXQgbWF0cml4PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IExvZyhNYXRyaXg8VD4geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4LlBvaW50d2lzZUxvZygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgbG9nMTAgb2YgYSBtYXRyaXggcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IG1hdHJpeDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBMb2cxMChNYXRyaXg8VD4geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4LlBvaW50d2lzZUxvZzEwKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBzaW4gb2YgYSBtYXRyaXggcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IG1hdHJpeDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBTaW4oTWF0cml4PFQ+IHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4geC5Qb2ludHdpc2VTaW4oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGNvcyBvZiBhIG1hdHJpeCBwb2ludHdpc2VcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgaW5wdXQgbWF0cml4PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IENvcyhNYXRyaXg8VD4geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4LlBvaW50d2lzZUNvcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgdGFuIG9mIGEgbWF0cml4IHBvaW50d2lzZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieFwiPlRoZSBpbnB1dCBtYXRyaXg8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gVGFuKE1hdHJpeDxUPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlVGFuKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBhc2luIG9mIGEgbWF0cml4IHBvaW50d2lzZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieFwiPlRoZSBpbnB1dCBtYXRyaXg8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gQXNpbihNYXRyaXg8VD4geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4LlBvaW50d2lzZUFzaW4oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGFjb3Mgb2YgYSBtYXRyaXggcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IG1hdHJpeDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBBY29zKE1hdHJpeDxUPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlQWNvcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgYXRhbiBvZiBhIG1hdHJpeCBwb2ludHdpc2VcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgaW5wdXQgbWF0cml4PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IEF0YW4oTWF0cml4PFQ+IHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4geC5Qb2ludHdpc2VBdGFuKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBzaW5oIG9mIGEgbWF0cml4IHBvaW50d2lzZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieFwiPlRoZSBpbnB1dCBtYXRyaXg8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gU2luaChNYXRyaXg8VD4geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4LlBvaW50d2lzZVNpbmgoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGNvc2ggb2YgYSBtYXRyaXggcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IG1hdHJpeDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBDb3NoKE1hdHJpeDxUPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlQ29zaCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgdGFuaCBvZiBhIG1hdHJpeCBwb2ludHdpc2VcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgaW5wdXQgbWF0cml4PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IFRhbmgoTWF0cml4PFQ+IHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4geC5Qb2ludHdpc2VUYW5oKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBhIG1hdHJpeCBwb2ludHdpc2VcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgaW5wdXQgbWF0cml4PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PFQ+IEFicyhNYXRyaXg8VD4geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4LlBvaW50d2lzZUFicygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgZmxvb3Igb2YgYSBtYXRyaXggcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IG1hdHJpeDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBGbG9vcihNYXRyaXg8VD4geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4LlBvaW50d2lzZUZsb29yKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBjZWlsaW5nIG9mIGEgbWF0cml4IHBvaW50d2lzZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieFwiPlRoZSBpbnB1dCBtYXRyaXg8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gQ2VpbGluZyhNYXRyaXg8VD4geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4LlBvaW50d2lzZUNlaWxpbmcoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJvdW5kZWQgdmFsdWUgb2YgYSBtYXRyaXggcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IG1hdHJpeDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxUPiBSb3VuZChNYXRyaXg8VD4geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4LlBvaW50d2lzZVJvdW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8vIDxjb3B5cmlnaHQgZmlsZT1cIk1hdHJpeC5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDEzIE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uTGlucTtcclxudXNpbmcgU3lzdGVtLlJ1bnRpbWU7XHJcbnVzaW5nIFN5c3RlbS5SdW50aW1lLkNvbXBpbGVyU2VydmljZXM7XHJcbi8vdXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkRvdWJsZS5NYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmE7XHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGU7XHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5TdG9yYWdlO1xyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlLk1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYTtcclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmFcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIERlZmluZXMgdGhlIGJhc2UgY2xhc3MgZm9yIDxjPk1hdHJpeDwvYz4gY2xhc3Nlcy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAvLy8gPHR5cGVwYXJhbSBuYW1lPVwiVFwiPlN1cHBvcnRlZCBkYXRhIHR5cGVzIGFyZSA8Yz5kb3VibGU8L2M+LCA8Yz5zaW5nbGU8L2M+LCA8c2VlIGNyZWY9XCJDb21wbGV4XCIvPiwgYW5kIDxzZWUgY3JlZj1cIkNvbXBsZXgzMlwiLz4uPC90eXBlcGFyYW0+XHJcbiAgICBbU2VyaWFsaXphYmxlXVxyXG4gICAgcHVibGljIGFic3RyYWN0IHBhcnRpYWwgY2xhc3MgTWF0cml4PFQ+IDpcclxuICAgICAgICBJRm9ybWF0dGFibGUsIElFcXVhdGFibGU8TWF0cml4PFQ+PlxyXG4jaWYgIU5FVFNUQU5EQVJEMV8zXHJcbiAgICAgICAgLCBJQ2xvbmVhYmxlXHJcbiNlbmRpZlxyXG4gICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAge1xyXG4gICAgICAgIFZlY3RvckJ1aWxkZXI8VD4gdl9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+LlZlY3RvcjtcclxuICAgICAgICBNYXRyaXhCdWlsZGVyPFQ+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5NYXRyaXg7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIE1hdHJpeCBjbGFzcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByb3RlY3RlZCBNYXRyaXgoTWF0cml4U3RvcmFnZTxUPiBzdG9yYWdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU3RvcmFnZSA9IHN0b3JhZ2U7XHJcbiAgICAgICAgICAgIFJvd0NvdW50ID0gc3RvcmFnZS5Sb3dDb3VudDtcclxuICAgICAgICAgICAgQ29sdW1uQ291bnQgPSBzdG9yYWdlLkNvbHVtbkNvdW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIHJhdyBtYXRyaXggZGF0YSBzdG9yYWdlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeFN0b3JhZ2U8VD4gU3RvcmFnZSB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBudW1iZXIgb2YgY29sdW1ucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIG51bWJlciBvZiBjb2x1bW5zLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGludCBDb2x1bW5Db3VudCB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBudW1iZXIgb2Ygcm93cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIG51bWJlciBvZiByb3dzLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGludCBSb3dDb3VudCB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIG9yIHNldHMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiByb3cgYW5kIGNvbHVtbiwgd2l0aCByYW5nZSBjaGVja2luZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd1wiPlxyXG4gICAgICAgIC8vLyBUaGUgcm93IG9mIHRoZSBlbGVtZW50LlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtblwiPlxyXG4gICAgICAgIC8vLyBUaGUgY29sdW1uIG9mIHRoZSBlbGVtZW50LlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIHZhbHVlIHRvIGdldCBvciBzZXQuPC92YWx1ZT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+VGhpcyBtZXRob2QgaXMgcmFuZ2VkIGNoZWNrZWQuIDxzZWUgY3JlZj1cIkF0KGludCxpbnQpXCIvPiBhbmQgPHNlZSBjcmVmPVwiQXQoaW50LGludCxUKVwiLz5cclxuICAgICAgICAvLy8gdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIHdpdGhvdXQgcmFuZ2UgY2hlY2tpbmcuPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyBUIHRoaXNbaW50IHJvdywgaW50IGNvbHVtbl1cclxuICAgICAgICB7XHJcbiNpZiAhTkVUNDBcclxuICAgICAgICAgICAgW01ldGhvZEltcGwoTWV0aG9kSW1wbE9wdGlvbnMuQWdncmVzc2l2ZUlubGluaW5nKV1cclxuI2VuZGlmXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gU3RvcmFnZVtyb3csIGNvbHVtbl07IH1cclxuXHJcbiNpZiAhTkVUNDBcclxuICAgICAgICAgICAgW01ldGhvZEltcGwoTWV0aG9kSW1wbE9wdGlvbnMuQWdncmVzc2l2ZUlubGluaW5nKV1cclxuI2VuZGlmXHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHNldCB7IFN0b3JhZ2Vbcm93LCBjb2x1bW5dID0gdmFsdWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0cmlldmVzIHRoZSByZXF1ZXN0ZWQgZWxlbWVudCB3aXRob3V0IHJhbmdlIGNoZWNraW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm93XCI+XHJcbiAgICAgICAgLy8vIFRoZSByb3cgb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uXCI+XHJcbiAgICAgICAgLy8vIFRoZSBjb2x1bW4gb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBUaGUgcmVxdWVzdGVkIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuI2lmICFORVQ0MFxyXG4gICAgICAgIFtNZXRob2RJbXBsKE1ldGhvZEltcGxPcHRpb25zLkFnZ3Jlc3NpdmVJbmxpbmluZyldXHJcbiNlbmRpZlxyXG4gICAgICAgIFxyXG4gICAgICAgIHB1YmxpYyBUIEF0KGludCByb3csIGludCBjb2x1bW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5BdChyb3csIGNvbHVtbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IHdpdGhvdXQgcmFuZ2UgY2hlY2tpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dcIj5cclxuICAgICAgICAvLy8gVGhlIHJvdyBvZiB0aGUgZWxlbWVudC5cclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb2x1bW5cIj5cclxuICAgICAgICAvLy8gVGhlIGNvbHVtbiBvZiB0aGUgZWxlbWVudC5cclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2YWx1ZVwiPlxyXG4gICAgICAgIC8vLyBUaGUgdmFsdWUgdG8gc2V0IHRoZSBlbGVtZW50IHRvLlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4jaWYgIU5FVDQwXHJcbiAgICAgICAgW01ldGhvZEltcGwoTWV0aG9kSW1wbE9wdGlvbnMuQWdncmVzc2l2ZUlubGluaW5nKV1cclxuI2VuZGlmXHJcbiAgICAgICAgXHJcbiAgICAgICAgcHVibGljIHZvaWQgQXQoaW50IHJvdywgaW50IGNvbHVtbiwgVCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQXQocm93LCBjb2x1bW4sIHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0cyBhbGwgdmFsdWVzIHRvIHplcm8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTdG9yYWdlLkNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldHMgYWxsIHZhbHVlcyBvZiBhIHJvdyB0byB6ZXJvLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXJSb3coaW50IHJvd0luZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCh1aW50KXJvd0luZGV4ID49ICh1aW50KVJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwicm93SW5kZXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ2xlYXJVbmNoZWNrZWQocm93SW5kZXgsIDEsIDAsIENvbHVtbkNvdW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0cyBhbGwgdmFsdWVzIG9mIGEgY29sdW1uIHRvIHplcm8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhckNvbHVtbihpbnQgY29sdW1uSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoKHVpbnQpY29sdW1uSW5kZXggPj0gKHVpbnQpQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJjb2x1bW5JbmRleFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgU3RvcmFnZS5DbGVhclVuY2hlY2tlZCgwLCBSb3dDb3VudCwgY29sdW1uSW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXRzIGFsbCB2YWx1ZXMgZm9yIGFsbCBvZiB0aGUgY2hvc2VuIHJvd3MgdG8gemVyby5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENsZWFyUm93cyhwYXJhbXMgaW50W10gcm93SW5kaWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ2xlYXJSb3dzKHJvd0luZGljZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXRzIGFsbCB2YWx1ZXMgZm9yIGFsbCBvZiB0aGUgY2hvc2VuIGNvbHVtbnMgdG8gemVyby5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENsZWFyQ29sdW1ucyhwYXJhbXMgaW50W10gY29sdW1uSW5kaWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ2xlYXJDb2x1bW5zKGNvbHVtbkluZGljZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXRzIGFsbCB2YWx1ZXMgb2YgYSBzdWItbWF0cml4IHRvIHplcm8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhclN1Yk1hdHJpeChpbnQgcm93SW5kZXgsIGludCByb3dDb3VudCwgaW50IGNvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTdG9yYWdlLkNsZWFyKHJvd0luZGV4LCByb3dDb3VudCwgY29sdW1uSW5kZXgsIGNvbHVtbkNvdW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IGFsbCB2YWx1ZXMgd2hvc2UgYWJzb2x1dGUgdmFsdWUgaXMgc21hbGxlciB0aGFuIHRoZSB0aHJlc2hvbGQgdG8gemVybywgaW4tcGxhY2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3Qgdm9pZCBDb2VyY2VaZXJvKGRvdWJsZSB0aHJlc2hvbGQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCBhbGwgdmFsdWVzIHRoYXQgbWVldCB0aGUgcHJlZGljYXRlIHRvIHplcm8sIGluLXBsYWNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQ29lcmNlWmVybyhGdW5jPFQsIGJvb2w+IHplcm9QcmVkaWNhdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXBJbnBsYWNlKChGdW5jPFQsVD4pKHggPT4gemVyb1ByZWRpY2F0ZSh4KSA/IFplcm8gOiB4KSwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIEEgY2xvbmUgb2YgdGhlIGluc3RhbmNlLlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBDbG9uZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgU3RvcmFnZS5Db3B5VG9VbmNoZWNrZWQocmVzdWx0LlN0b3JhZ2UsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvcGllcyB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggdG8gdGhlIGdpdmVuIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRhcmdldFwiPlxyXG4gICAgICAgIC8vLyBUaGUgbWF0cml4IHRvIGNvcHkgdmFsdWVzIGludG8uXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPlxyXG4gICAgICAgIC8vLyBJZiB0YXJnZXQgaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIi8+LlxyXG4gICAgICAgIC8vLyA8L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5cclxuICAgICAgICAvLy8gSWYgdGhpcyBhbmQgdGhlIHRhcmdldCBtYXRyaXggZG8gbm90IGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucy4uXHJcbiAgICAgICAgLy8vIDwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENvcHlUbyhNYXRyaXg8VD4gdGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBTdG9yYWdlLkNvcHlUbyh0YXJnZXQuU3RvcmFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvcGllcyBhIHJvdyBpbnRvIGFuIFZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluZGV4XCI+VGhlIHJvdyB0byBjb3B5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgVmVjdG9yIGNvbnRhaW5pbmcgdGhlIGNvcGllZCBlbGVtZW50cy48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwiaW5kZXhcIi8+IGlzIG5lZ2F0aXZlLFxyXG4gICAgICAgIC8vLyBvciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiByb3dzLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gUm93KGludCBpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICgodWludClpbmRleCA+PSAodWludClSb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImluZGV4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmV0ID0gdl9idWlsZGVyLlNhbWVBczxUPih0aGlzLCBDb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ29weVN1YlJvd1RvVW5jaGVja2VkKHJldC5TdG9yYWdlLCBpbmRleCwgMCwgMCwgQ29sdW1uQ291bnQsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvcGllcyBhIHJvdyBpbnRvIHRvIHRoZSBnaXZlbiBWZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmRleFwiPlRoZSByb3cgdG8gY29weS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBWZWN0b3IgdG8gY29weSB0aGUgcm93IGludG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgdGhlIHJlc3VsdCB2ZWN0b3IgaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJpbmRleFwiLz4gaXMgbmVnYXRpdmUsXHJcbiAgICAgICAgLy8vIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJvd3MuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIDxiPnRoaXMuQ29sdW1ucyAhPSByZXN1bHQuQ291bnQ8L2I+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJvdyhpbnQgaW5kZXgsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ29weVJvd1RvKHJlc3VsdC5TdG9yYWdlLCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvcGllcyB0aGUgcmVxdWVzdGVkIHJvdyBlbGVtZW50cyBpbnRvIGEgbmV3IFZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd0luZGV4XCI+VGhlIHJvdyB0byBjb3B5IGVsZW1lbnRzIGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb2x1bW5JbmRleFwiPlRoZSBjb2x1bW4gdG8gc3RhcnQgY29weWluZyBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVuZ3RoXCI+VGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjb3B5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgVmVjdG9yIGNvbnRhaW5pbmcgdGhlIHJlcXVlc3RlZCBlbGVtZW50cy48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmOlxyXG4gICAgICAgIC8vLyA8bGlzdD48aXRlbT48cGFyYW1yZWYgbmFtZT1cInJvd0luZGV4XCIvPiBpcyBuZWdhdGl2ZSxcclxuICAgICAgICAvLy8gb3IgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBudW1iZXIgb2Ygcm93cy48L2l0ZW0+XHJcbiAgICAgICAgLy8vIDxpdGVtPjxwYXJhbXJlZiBuYW1lPVwiY29sdW1uSW5kZXhcIi8+IGlzIG5lZ2F0aXZlLFxyXG4gICAgICAgIC8vLyBvciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBjb2x1bW5zLjwvaXRlbT5cclxuICAgICAgICAvLy8gPGl0ZW0+PGM+KGNvbHVtbkluZGV4ICsgbGVuZ3RoKSAmZ3Q7PSBDb2x1bW5zLjwvYz48L2l0ZW0+PC9saXN0PjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlbmd0aFwiLz4gaXMgbm90IHBvc2l0aXZlLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gUm93KGludCByb3dJbmRleCwgaW50IGNvbHVtbkluZGV4LCBpbnQgbGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJldCA9IHZfYnVpbGRlci5TYW1lQXM8VD4odGhpcywgbGVuZ3RoKTtcclxuICAgICAgICAgICAgU3RvcmFnZS5Db3B5U3ViUm93VG8ocmV0LlN0b3JhZ2UsIHJvd0luZGV4LCBjb2x1bW5JbmRleCwgMCwgbGVuZ3RoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29waWVzIHRoZSByZXF1ZXN0ZWQgcm93IGVsZW1lbnRzIGludG8gYSBuZXcgVmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm93SW5kZXhcIj5UaGUgcm93IHRvIGNvcHkgZWxlbWVudHMgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtbkluZGV4XCI+VGhlIGNvbHVtbiB0byBzdGFydCBjb3B5aW5nIGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZW5ndGhcIj5UaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGNvcHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgVmVjdG9yIHRvIGNvcHkgdGhlIGNvbHVtbiBpbnRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIHRoZSByZXN1bHQgVmVjdG9yIGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicm93SW5kZXhcIi8+IGlzIG5lZ2F0aXZlLFxyXG4gICAgICAgIC8vLyBvciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBjb2x1bW5zLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImNvbHVtbkluZGV4XCIvPiBpcyBuZWdhdGl2ZSxcclxuICAgICAgICAvLy8gb3IgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBudW1iZXIgb2Ygcm93cy48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5JbmRleFwiLz4gKyA8cGFyYW1yZWYgbmFtZT1cImxlbmd0aFwiLz5cclxuICAgICAgICAvLy8gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBudW1iZXIgb2Ygcm93cy48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZW5ndGhcIi8+IGlzIG5vdCBwb3NpdGl2ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHN0cm9uZz5yZXN1bHQuQ291bnQgJmx0OyBsZW5ndGg8L3N0cm9uZz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUm93KGludCByb3dJbmRleCwgaW50IGNvbHVtbkluZGV4LCBpbnQgbGVuZ3RoLCBWZWN0b3I8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBTdG9yYWdlLkNvcHlTdWJSb3dUbyhyZXN1bHQuU3RvcmFnZSwgcm93SW5kZXgsIGNvbHVtbkluZGV4LCAwLCBsZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb3BpZXMgYSBjb2x1bW4gaW50byBhIG5ldyBWZWN0b3I+LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5kZXhcIj5UaGUgY29sdW1uIHRvIGNvcHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBWZWN0b3IgY29udGFpbmluZyB0aGUgY29waWVkIGVsZW1lbnRzLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJpbmRleFwiLz4gaXMgbmVnYXRpdmUsXHJcbiAgICAgICAgLy8vIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGNvbHVtbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBDb2x1bW4oaW50IGluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCh1aW50KWluZGV4ID49ICh1aW50KUNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiaW5kZXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXQgPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMsIFJvd0NvdW50KTtcclxuICAgICAgICAgICAgU3RvcmFnZS5Db3B5U3ViQ29sdW1uVG9VbmNoZWNrZWQocmV0LlN0b3JhZ2UsIGluZGV4LCAwLCAwLCBSb3dDb3VudCwgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29waWVzIGEgY29sdW1uIGludG8gdG8gdGhlIGdpdmVuIFZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluZGV4XCI+VGhlIGNvbHVtbiB0byBjb3B5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIFZlY3RvciB0byBjb3B5IHRoZSBjb2x1bW4gaW50by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiB0aGUgcmVzdWx0IFZlY3RvciBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImluZGV4XCIvPiBpcyBuZWdhdGl2ZSxcclxuICAgICAgICAvLy8gb3IgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgY29sdW1ucy48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPGI+dGhpcy5Sb3dzICE9IHJlc3VsdC5Db3VudDwvYj4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQ29sdW1uKGludCBpbmRleCwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgU3RvcmFnZS5Db3B5Q29sdW1uVG8ocmVzdWx0LlN0b3JhZ2UsIGluZGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29waWVzIHRoZSByZXF1ZXN0ZWQgY29sdW1uIGVsZW1lbnRzIGludG8gYSBuZXcgVmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uSW5kZXhcIj5UaGUgY29sdW1uIHRvIGNvcHkgZWxlbWVudHMgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd0luZGV4XCI+VGhlIHJvdyB0byBzdGFydCBjb3B5aW5nIGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZW5ndGhcIj5UaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGNvcHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBWZWN0b3IgY29udGFpbmluZyB0aGUgcmVxdWVzdGVkIGVsZW1lbnRzLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWY6XHJcbiAgICAgICAgLy8vIDxsaXN0PjxpdGVtPjxwYXJhbXJlZiBuYW1lPVwiY29sdW1uSW5kZXhcIi8+IGlzIG5lZ2F0aXZlLFxyXG4gICAgICAgIC8vLyBvciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBjb2x1bW5zLjwvaXRlbT5cclxuICAgICAgICAvLy8gPGl0ZW0+PHBhcmFtcmVmIG5hbWU9XCJyb3dJbmRleFwiLz4gaXMgbmVnYXRpdmUsXHJcbiAgICAgICAgLy8vIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJvd3MuPC9pdGVtPlxyXG4gICAgICAgIC8vLyA8aXRlbT48Yz4ocm93SW5kZXggKyBsZW5ndGgpICZndDs9IFJvd3MuPC9jPjwvaXRlbT48L2xpc3Q+XHJcbiAgICAgICAgLy8vIDwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlbmd0aFwiLz4gaXMgbm90IHBvc2l0aXZlLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gQ29sdW1uKGludCBjb2x1bW5JbmRleCwgaW50IHJvd0luZGV4LCBpbnQgbGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJldCA9IHZfYnVpbGRlci5TYW1lQXM8VD4odGhpcywgbGVuZ3RoKTtcclxuICAgICAgICAgICAgU3RvcmFnZS5Db3B5U3ViQ29sdW1uVG8ocmV0LlN0b3JhZ2UsIGNvbHVtbkluZGV4LCByb3dJbmRleCwgMCwgbGVuZ3RoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29waWVzIHRoZSByZXF1ZXN0ZWQgY29sdW1uIGVsZW1lbnRzIGludG8gdGhlIGdpdmVuIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtbkluZGV4XCI+VGhlIGNvbHVtbiB0byBjb3B5IGVsZW1lbnRzIGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dJbmRleFwiPlRoZSByb3cgdG8gc3RhcnQgY29weWluZyBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVuZ3RoXCI+VGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjb3B5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIFZlY3RvciB0byBjb3B5IHRoZSBjb2x1bW4gaW50by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiB0aGUgcmVzdWx0IFZlY3RvciBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImNvbHVtbkluZGV4XCIvPiBpcyBuZWdhdGl2ZSxcclxuICAgICAgICAvLy8gb3IgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgY29sdW1ucy48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyb3dJbmRleFwiLz4gaXMgbmVnYXRpdmUsXHJcbiAgICAgICAgLy8vIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJvd3MuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicm93SW5kZXhcIi8+ICsgPHBhcmFtcmVmIG5hbWU9XCJsZW5ndGhcIi8+XHJcbiAgICAgICAgLy8vIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJvd3MuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVuZ3RoXCIvPiBpcyBub3QgcG9zaXRpdmUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIDxzdHJvbmc+cmVzdWx0LkNvdW50ICZsdDsgbGVuZ3RoPC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENvbHVtbihpbnQgY29sdW1uSW5kZXgsIGludCByb3dJbmRleCwgaW50IGxlbmd0aCwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgU3RvcmFnZS5Db3B5U3ViQ29sdW1uVG8ocmVzdWx0LlN0b3JhZ2UsIGNvbHVtbkluZGV4LCByb3dJbmRleCwgMCwgbGVuZ3RoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIG5ldyBtYXRyaXggY29udGFpbmluZyB0aGUgdXBwZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHVwcGVyIHRyaWFuZ2xlIG9mIHRoaXMgbWF0cml4LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBNYXRyaXg8VD4gVXBwZXJUcmlhbmdsZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gPSByb3c7IGNvbHVtbiA8IENvbHVtbkNvdW50OyBjb2x1bW4rKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQocm93LCBjb2x1bW4sIEF0KHJvdywgY29sdW1uKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIG5ldyBtYXRyaXggY29udGFpbmluZyB0aGUgbG93ZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGxvd2VyIHRyaWFuZ2xlIG9mIHRoaXMgbWF0cml4LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBNYXRyaXg8VD4gTG93ZXJUcmlhbmdsZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gPSAwOyBjb2x1bW4gPD0gcm93ICYmIGNvbHVtbiA8IENvbHVtbkNvdW50OyBjb2x1bW4rKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQocm93LCBjb2x1bW4sIEF0KHJvdywgY29sdW1uKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUHV0cyB0aGUgbG93ZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXggaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPldoZXJlIHRvIHN0b3JlIHRoZSBsb3dlciB0cmlhbmdsZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgcmVzdWx0IG1hdHJpeCdzIGRpbWVuc2lvbnMgYXJlIG5vdCB0aGUgc2FtZSBhcyB0aGlzIG1hdHJpeC48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCB2b2lkIExvd2VyVHJpYW5nbGUoTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDwgQ29sdW1uQ291bnQ7IGNvbHVtbisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChyb3csIGNvbHVtbiwgcm93ID49IGNvbHVtbiA/IEF0KHJvdywgY29sdW1uKSA6IFplcm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFB1dHMgdGhlIHVwcGVyIHRyaWFuZ2xlIG9mIHRoaXMgbWF0cml4IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5XaGVyZSB0byBzdG9yZSB0aGUgbG93ZXIgdHJpYW5nbGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHJlc3VsdCBtYXRyaXgncyBkaW1lbnNpb25zIGFyZSBub3QgdGhlIHNhbWUgYXMgdGhpcyBtYXRyaXguPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgdm9pZCBVcHBlclRyaWFuZ2xlKE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuUm93Q291bnQgIT0gUm93Q291bnQgfHwgcmVzdWx0LkNvbHVtbkNvdW50ICE9IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCByZXN1bHQsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8IENvbHVtbkNvdW50OyBjb2x1bW4rKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQocm93LCBjb2x1bW4sIHJvdyA8PSBjb2x1bW4gPyBBdChyb3csIGNvbHVtbikgOiBaZXJvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgbWF0cml4IHRoYXQgY29udGFpbnMgdGhlIHZhbHVlcyBmcm9tIHRoZSByZXF1ZXN0ZWQgc3ViLW1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd0luZGV4XCI+VGhlIHJvdyB0byBzdGFydCBjb3B5aW5nIGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dDb3VudFwiPlRoZSBudW1iZXIgb2Ygcm93cyB0byBjb3B5LiBNdXN0IGJlIHBvc2l0aXZlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uSW5kZXhcIj5UaGUgY29sdW1uIHRvIHN0YXJ0IGNvcHlpbmcgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtbkNvdW50XCI+VGhlIG51bWJlciBvZiBjb2x1bW5zIHRvIGNvcHkuIE11c3QgYmUgcG9zaXRpdmUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlcXVlc3RlZCBzdWItbWF0cml4LjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWY6IDxsaXN0PjxpdGVtPjxwYXJhbXJlZiBuYW1lPVwicm93SW5kZXhcIi8+IGlzXHJcbiAgICAgICAgLy8vIG5lZ2F0aXZlLCBvciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiByb3dzLjwvaXRlbT5cclxuICAgICAgICAvLy8gPGl0ZW0+PHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5JbmRleFwiLz4gaXMgbmVnYXRpdmUsIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyXHJcbiAgICAgICAgLy8vIG9mIGNvbHVtbnMuPC9pdGVtPlxyXG4gICAgICAgIC8vLyA8aXRlbT48Yz4oY29sdW1uSW5kZXggKyBjb2x1bW5MZW5ndGgpICZndDs9IENvbHVtbnM8L2M+PC9pdGVtPlxyXG4gICAgICAgIC8vLyA8aXRlbT48Yz4ocm93SW5kZXggKyByb3dMZW5ndGgpICZndDs9IFJvd3M8L2M+PC9pdGVtPjwvbGlzdD48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyb3dDb3VudFwiLz4gb3IgPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5Db3VudFwiLz5cclxuICAgICAgICAvLy8gaXMgbm90IHBvc2l0aXZlLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIE1hdHJpeDxUPiBTdWJNYXRyaXgoaW50IHJvd0luZGV4LCBpbnQgcm93Q291bnQsIGludCBjb2x1bW5JbmRleCwgaW50IGNvbHVtbkNvdW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcywgcm93Q291bnQsIGNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgU3RvcmFnZS5Db3B5U3ViTWF0cml4VG8ocmVzdWx0LlN0b3JhZ2UsIHJvd0luZGV4LCAwLCByb3dDb3VudCwgY29sdW1uSW5kZXgsIDAsIGNvbHVtbkNvdW50LCBFeGlzdGluZ0RhdGEuQXNzdW1lWmVyb3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBlbGVtZW50cyBvZiB0aGUgZGlhZ29uYWwgaW4gYSBWZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGVsZW1lbnRzIG9mIHRoZSBkaWFnb25hbC48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPkZvciBub24tc3F1YXJlIG1hdHJpY2VzLCB0aGUgbWV0aG9kIHJldHVybnMgTWluKFJvd3MsIENvbHVtbnMpIGVsZW1lbnRzIHdoZXJlXHJcbiAgICAgICAgLy8vIGkgPT0gaiAoaSBpcyB0aGUgcm93IGluZGV4LCBhbmQgaiBpcyB0aGUgY29sdW1uIGluZGV4KS48L3JlbWFya3M+XHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgVmVjdG9yPFQ+IERpYWdvbmFsKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLk1pbihSb3dDb3VudCwgQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICB2YXIgZGlhZ29uYWwgPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMsIG1pbik7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbjsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaWFnb25hbC5BdChpLCBBdChpLCBpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkaWFnb25hbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIG5ldyBtYXRyaXggY29udGFpbmluZyB0aGUgbG93ZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXguIFRoZSBuZXcgbWF0cml4XHJcbiAgICAgICAgLy8vIGRvZXMgbm90IGNvbnRhaW4gdGhlIGRpYWdvbmFsIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBsb3dlciB0cmlhbmdsZSBvZiB0aGlzIG1hdHJpeC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgTWF0cml4PFQ+IFN0cmljdGx5TG93ZXJUcmlhbmdsZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IE1hdGguTWluKHJvdywgQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDwgY29sdW1uczsgY29sdW1uKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KHJvdywgY29sdW1uLCBBdChyb3csIGNvbHVtbikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFB1dHMgdGhlIHN0cmljdGx5IGxvd2VyIHRyaWFuZ2xlIG9mIHRoaXMgbWF0cml4IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5XaGVyZSB0byBzdG9yZSB0aGUgbG93ZXIgdHJpYW5nbGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHJlc3VsdCBtYXRyaXgncyBkaW1lbnNpb25zIGFyZSBub3QgdGhlIHNhbWUgYXMgdGhpcyBtYXRyaXguPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgdm9pZCBTdHJpY3RseUxvd2VyVHJpYW5nbGUoTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDwgQ29sdW1uQ291bnQ7IGNvbHVtbisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChyb3csIGNvbHVtbiwgcm93ID4gY29sdW1uID8gQXQocm93LCBjb2x1bW4pIDogWmVybyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIG5ldyBtYXRyaXggY29udGFpbmluZyB0aGUgdXBwZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXguIFRoZSBuZXcgbWF0cml4XHJcbiAgICAgICAgLy8vIGRvZXMgbm90IGNvbnRhaW4gdGhlIGRpYWdvbmFsIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSB1cHBlciB0cmlhbmdsZSBvZiB0aGlzIG1hdHJpeC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgTWF0cml4PFQ+IFN0cmljdGx5VXBwZXJUcmlhbmdsZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gPSByb3cgKyAxOyBjb2x1bW4gPCBDb2x1bW5Db3VudDsgY29sdW1uKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KHJvdywgY29sdW1uLCBBdChyb3csIGNvbHVtbikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFB1dHMgdGhlIHN0cmljdGx5IHVwcGVyIHRyaWFuZ2xlIG9mIHRoaXMgbWF0cml4IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5XaGVyZSB0byBzdG9yZSB0aGUgbG93ZXIgdHJpYW5nbGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHJlc3VsdCBtYXRyaXgncyBkaW1lbnNpb25zIGFyZSBub3QgdGhlIHNhbWUgYXMgdGhpcyBtYXRyaXguPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgdm9pZCBTdHJpY3RseVVwcGVyVHJpYW5nbGUoTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDwgQ29sdW1uQ291bnQ7IGNvbHVtbisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChyb3csIGNvbHVtbiwgcm93IDwgY29sdW1uID8gQXQocm93LCBjb2x1bW4pIDogWmVybyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIG5ldyBtYXRyaXggYW5kIGluc2VydHMgdGhlIGdpdmVuIGNvbHVtbiBhdCB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb2x1bW5JbmRleFwiPlRoZSBpbmRleCBvZiB3aGVyZSB0byBpbnNlcnQgdGhlIGNvbHVtbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtblwiPlRoZSBjb2x1bW4gdG8gaW5zZXJ0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgbmV3IG1hdHJpeCB3aXRoIHRoZSBpbnNlcnRlZCBjb2x1bW4uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImNvbHVtbiBcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uIDwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImNvbHVtbkluZGV4XCIvPiBpcyAmbHQ7IHplcm8gb3IgJmd0OyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHNpemUgb2YgPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5cIi8+ICE9IHRoZSBudW1iZXIgb2Ygcm93cy48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IEluc2VydENvbHVtbihpbnQgY29sdW1uSW5kZXgsIFZlY3RvcjxUPiBjb2x1bW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoY29sdW1uID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJjb2x1bW5cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICgodWludCljb2x1bW5JbmRleCA+ICh1aW50KUNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiY29sdW1uSW5kZXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb2x1bW4uQ291bnQgIT0gUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeFNhbWVSb3dEaW1lbnNpb257MH1cIiwgXCJjb2x1bW5cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMsIFJvd0NvdW50LCBDb2x1bW5Db3VudCArIDEsIGZ1bGx5TXV0YWJsZTogdHJ1ZSk7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvKHJlc3VsdC5TdG9yYWdlLCAwLCAwLCBSb3dDb3VudCwgMCwgMCwgY29sdW1uSW5kZXgsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5TZXRDb2x1bW4oY29sdW1uSW5kZXgsIGNvbHVtbik7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvKHJlc3VsdC5TdG9yYWdlLCAwLCAwLCBSb3dDb3VudCwgY29sdW1uSW5kZXgsIGNvbHVtbkluZGV4ICsgMSwgQ29sdW1uQ291bnQgLSBjb2x1bW5JbmRleCwgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIG5ldyBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gY29sdW1uIHJlbW92ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb2x1bW5JbmRleFwiPlRoZSBpbmRleCBvZiB0aGUgY29sdW1uIHRvIHJlbW92ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIG5ldyBtYXRyaXggd2l0aG91dCB0aGUgY2hvc2VuIGNvbHVtbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwiY29sdW1uSW5kZXhcIi8+IGlzICZsdDsgemVybyBvciAmZ3Q7PSB0aGUgbnVtYmVyIG9mIGNvbHVtbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBSZW1vdmVDb2x1bW4oaW50IGNvbHVtbkluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCh1aW50KWNvbHVtbkluZGV4ID49ICh1aW50KUNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiY29sdW1uSW5kZXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMsIFJvd0NvdW50LCBDb2x1bW5Db3VudCAtIDEsIGZ1bGx5TXV0YWJsZTogdHJ1ZSk7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvKHJlc3VsdC5TdG9yYWdlLCAwLCAwLCBSb3dDb3VudCwgMCwgMCwgY29sdW1uSW5kZXgsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvKHJlc3VsdC5TdG9yYWdlLCAwLCAwLCBSb3dDb3VudCwgY29sdW1uSW5kZXggKyAxLCBjb2x1bW5JbmRleCwgQ29sdW1uQ291bnQgLSBjb2x1bW5JbmRleCAtIDEsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBWZWN0b3IgdG8gdGhlIHNwZWNpZmllZCBjb2x1bW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb2x1bW5JbmRleFwiPlRoZSBjb2x1bW4gdG8gY29weSB0aGUgdmFsdWVzIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uXCI+VGhlIHZlY3RvciB0byBjb3B5IHRoZSB2YWx1ZXMgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImNvbHVtblwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5JbmRleFwiLz4gaXMgbGVzcyB0aGFuIHplcm8sXHJcbiAgICAgICAgLy8vIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGNvbHVtbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHNpemUgb2YgPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5cIi8+IGRvZXMgbm90XHJcbiAgICAgICAgLy8vIGVxdWFsIHRoZSBudW1iZXIgb2Ygcm93cyBvZiB0aGlzIDxzdHJvbmc+TWF0cml4PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldENvbHVtbihpbnQgY29sdW1uSW5kZXgsIFZlY3RvcjxUPiBjb2x1bW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoY29sdW1uID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJjb2x1bW5cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbHVtbi5TdG9yYWdlLkNvcHlUb0NvbHVtbihTdG9yYWdlLCBjb2x1bW5JbmRleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBWZWN0b3IgdG8gdGhlIHNwZWNpZmllZCBzdWItY29sdW1uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uSW5kZXhcIj5UaGUgY29sdW1uIHRvIGNvcHkgdGhlIHZhbHVlcyB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd0luZGV4XCI+VGhlIHJvdyB0byBzdGFydCBjb3B5aW5nIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVuZ3RoXCI+VGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjb3B5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uXCI+VGhlIHZlY3RvciB0byBjb3B5IHRoZSB2YWx1ZXMgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImNvbHVtblwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5JbmRleFwiLz4gaXMgbGVzcyB0aGFuIHplcm8sXHJcbiAgICAgICAgLy8vIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGNvbHVtbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHNpemUgb2YgPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5cIi8+IGRvZXMgbm90XHJcbiAgICAgICAgLy8vIGVxdWFsIHRoZSBudW1iZXIgb2Ygcm93cyBvZiB0aGlzIDxzdHJvbmc+TWF0cml4PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldENvbHVtbihpbnQgY29sdW1uSW5kZXgsIGludCByb3dJbmRleCwgaW50IGxlbmd0aCwgVmVjdG9yPFQ+IGNvbHVtbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChjb2x1bW4gPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImNvbHVtblwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29sdW1uLlN0b3JhZ2UuQ29weVRvU3ViQ29sdW1uKFN0b3JhZ2UsIGNvbHVtbkluZGV4LCAwLCByb3dJbmRleCwgbGVuZ3RoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29waWVzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIGFycmF5IHRvIHRoZSBzcGVjaWZpZWQgY29sdW1uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uSW5kZXhcIj5UaGUgY29sdW1uIHRvIGNvcHkgdGhlIHZhbHVlcyB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtblwiPlRoZSBhcnJheSB0byBjb3B5IHRoZSB2YWx1ZXMgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImNvbHVtblwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5JbmRleFwiLz4gaXMgbGVzcyB0aGFuIHplcm8sXHJcbiAgICAgICAgLy8vIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGNvbHVtbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHNpemUgb2YgPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5cIi8+IGRvZXMgbm90XHJcbiAgICAgICAgLy8vIGVxdWFsIHRoZSBudW1iZXIgb2Ygcm93cyBvZiB0aGlzIDxzdHJvbmc+TWF0cml4PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSBzaXplIG9mIDxwYXJhbXJlZiBuYW1lPVwiY29sdW1uXCIvPiBkb2VzIG5vdFxyXG4gICAgICAgIC8vLyBlcXVhbCB0aGUgbnVtYmVyIG9mIHJvd3Mgb2YgdGhpcyA8c3Ryb25nPk1hdHJpeDwvc3Ryb25nPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXRDb2x1bW4oaW50IGNvbHVtbkluZGV4LCBUW10gY29sdW1uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGNvbHVtbiA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwiY29sdW1uXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBuZXcgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+KGNvbHVtbi5MZW5ndGgsIGNvbHVtbikuQ29weVRvQ29sdW1uKFN0b3JhZ2UsIGNvbHVtbkluZGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIG5ldyBtYXRyaXggYW5kIGluc2VydHMgdGhlIGdpdmVuIHJvdyBhdCB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dJbmRleFwiPlRoZSBpbmRleCBvZiB3aGVyZSB0byBpbnNlcnQgdGhlIHJvdy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd1wiPlRoZSByb3cgdG8gaW5zZXJ0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgbmV3IG1hdHJpeCB3aXRoIHRoZSBpbnNlcnRlZCBjb2x1bW4uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cInJvd1wiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi4gPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicm93SW5kZXhcIi8+IGlzICZsdDsgemVybyBvciAmZ3Q7IHRoZSBudW1iZXIgb2Ygcm93cy48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgc2l6ZSBvZiA8cGFyYW1yZWYgbmFtZT1cInJvd1wiLz4gIT0gdGhlIG51bWJlciBvZiBjb2x1bW5zLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gSW5zZXJ0Um93KGludCByb3dJbmRleCwgVmVjdG9yPFQ+IHJvdylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyb3cgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJvd1wiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCh1aW50KXJvd0luZGV4ID4gKHVpbnQpUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJyb3dJbmRleFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJvdy5Db3VudCAhPSBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4U2FtZVJvd0RpbWVuc2lvbnswfVwiLCBcInJvd1wiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcywgUm93Q291bnQgKyAxLCBDb2x1bW5Db3VudCwgZnVsbHlNdXRhYmxlOiB0cnVlKTtcclxuICAgICAgICAgICAgU3RvcmFnZS5Db3B5U3ViTWF0cml4VG8ocmVzdWx0LlN0b3JhZ2UsIDAsIDAsIHJvd0luZGV4LCAwLCAwLCBDb2x1bW5Db3VudCwgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgcmVzdWx0LlNldFJvdyhyb3dJbmRleCwgcm93KTtcclxuICAgICAgICAgICAgU3RvcmFnZS5Db3B5U3ViTWF0cml4VG8ocmVzdWx0LlN0b3JhZ2UsIHJvd0luZGV4LCByb3dJbmRleCsxLCBSb3dDb3VudCAtIHJvd0luZGV4LCAwLCAwLCBDb2x1bW5Db3VudCwgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIG5ldyBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gcm93IHJlbW92ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dJbmRleFwiPlRoZSBpbmRleCBvZiB0aGUgcm93IHRvIHJlbW92ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIG5ldyBtYXRyaXggd2l0aG91dCB0aGUgY2hvc2VuIHJvdy48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicm93SW5kZXhcIi8+IGlzICZsdDsgemVybyBvciAmZ3Q7PSB0aGUgbnVtYmVyIG9mIHJvd3MuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBSZW1vdmVSb3coaW50IHJvd0luZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCh1aW50KXJvd0luZGV4ID49ICh1aW50KVJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwicm93SW5kZXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMsIFJvd0NvdW50IC0gMSwgQ29sdW1uQ291bnQsIGZ1bGx5TXV0YWJsZTogdHJ1ZSk7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvKHJlc3VsdC5TdG9yYWdlLCAwLCAwLCByb3dJbmRleCwgMCwgMCwgQ29sdW1uQ291bnQsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvKHJlc3VsdC5TdG9yYWdlLCByb3dJbmRleCArIDEsIHJvd0luZGV4LCBSb3dDb3VudCAtIHJvd0luZGV4IC0gMSwgMCwgMCwgQ29sdW1uQ291bnQsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBWZWN0b3IgdG8gdGhlIHNwZWNpZmllZCByb3cuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dJbmRleFwiPlRoZSByb3cgdG8gY29weSB0aGUgdmFsdWVzIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm93XCI+VGhlIHZlY3RvciB0byBjb3B5IHRoZSB2YWx1ZXMgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cInJvd1wiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyb3dJbmRleFwiLz4gaXMgbGVzcyB0aGFuIHplcm8sXHJcbiAgICAgICAgLy8vIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJvd3MuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHNpemUgb2YgPHBhcmFtcmVmIG5hbWU9XCJyb3dcIi8+IGRvZXMgbm90XHJcbiAgICAgICAgLy8vIGVxdWFsIHRoZSBudW1iZXIgb2YgY29sdW1ucyBvZiB0aGlzIDxzdHJvbmc+TWF0cml4PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldFJvdyhpbnQgcm93SW5kZXgsIFZlY3RvcjxUPiByb3cpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocm93ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJyb3dcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJvdy5TdG9yYWdlLkNvcHlUb1JvdyhTdG9yYWdlLCByb3dJbmRleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBWZWN0b3IgdG8gdGhlIHNwZWNpZmllZCBzdWItcm93LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm93SW5kZXhcIj5UaGUgcm93IHRvIGNvcHkgdGhlIHZhbHVlcyB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtbkluZGV4XCI+VGhlIGNvbHVtbiB0byBzdGFydCBjb3B5aW5nIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVuZ3RoXCI+VGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjb3B5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm93XCI+VGhlIHZlY3RvciB0byBjb3B5IHRoZSB2YWx1ZXMgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cInJvd1wiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyb3dJbmRleFwiLz4gaXMgbGVzcyB0aGFuIHplcm8sXHJcbiAgICAgICAgLy8vIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJvd3MuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHNpemUgb2YgPHBhcmFtcmVmIG5hbWU9XCJyb3dcIi8+IGRvZXMgbm90XHJcbiAgICAgICAgLy8vIGVxdWFsIHRoZSBudW1iZXIgb2YgY29sdW1ucyBvZiB0aGlzIDxzdHJvbmc+TWF0cml4PC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldFJvdyhpbnQgcm93SW5kZXgsIGludCBjb2x1bW5JbmRleCwgaW50IGxlbmd0aCwgVmVjdG9yPFQ+IHJvdylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyb3cgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJvd1wiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcm93LlN0b3JhZ2UuQ29weVRvU3ViUm93KFN0b3JhZ2UsIHJvd0luZGV4LCAwLCBjb2x1bW5JbmRleCwgbGVuZ3RoKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBhcnJheSB0byB0aGUgc3BlY2lmaWVkIHJvdy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd0luZGV4XCI+VGhlIHJvdyB0byBjb3B5IHRoZSB2YWx1ZXMgdG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dcIj5UaGUgYXJyYXkgdG8gY29weSB0aGUgdmFsdWVzIGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyb3dcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicm93SW5kZXhcIi8+IGlzIGxlc3MgdGhhbiB6ZXJvLFxyXG4gICAgICAgIC8vLyBvciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiByb3dzLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSBzaXplIG9mIDxwYXJhbXJlZiBuYW1lPVwicm93XCIvPiBkb2VzIG5vdFxyXG4gICAgICAgIC8vLyBlcXVhbCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgb2YgdGhpcyA8c3Ryb25nPk1hdHJpeDwvc3Ryb25nPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXRSb3coaW50IHJvd0luZGV4LCBUW10gcm93KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJvdyA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicm93XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBuZXcgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+KHJvdy5MZW5ndGgsIHJvdykuQ29weVRvUm93KFN0b3JhZ2UsIHJvd0luZGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29waWVzIHRoZSB2YWx1ZXMgb2YgYSBnaXZlbiBtYXRyaXggaW50byBhIHJlZ2lvbiBpbiB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd0luZGV4XCI+VGhlIHJvdyB0byBzdGFydCBjb3B5aW5nIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uSW5kZXhcIj5UaGUgY29sdW1uIHRvIHN0YXJ0IGNvcHlpbmcgdG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdWJNYXRyaXhcIj5UaGUgc3ViLW1hdHJpeCB0byBjb3B5IGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWY6IDxsaXN0PjxpdGVtPjxwYXJhbXJlZiBuYW1lPVwicm93SW5kZXhcIi8+IGlzXHJcbiAgICAgICAgLy8vIG5lZ2F0aXZlLCBvciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiByb3dzLjwvaXRlbT5cclxuICAgICAgICAvLy8gPGl0ZW0+PHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5JbmRleFwiLz4gaXMgbmVnYXRpdmUsIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyXHJcbiAgICAgICAgLy8vIG9mIGNvbHVtbnMuPC9pdGVtPlxyXG4gICAgICAgIC8vLyA8aXRlbT48Yz4oY29sdW1uSW5kZXggKyBjb2x1bW5MZW5ndGgpICZndDs9IENvbHVtbnM8L2M+PC9pdGVtPlxyXG4gICAgICAgIC8vLyA8aXRlbT48Yz4ocm93SW5kZXggKyByb3dMZW5ndGgpICZndDs9IFJvd3M8L2M+PC9pdGVtPjwvbGlzdD48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXRTdWJNYXRyaXgoaW50IHJvd0luZGV4LCBpbnQgY29sdW1uSW5kZXgsIE1hdHJpeDxUPiBzdWJNYXRyaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzdWJNYXRyaXguU3RvcmFnZS5Db3B5U3ViTWF0cml4VG8oU3RvcmFnZSwgMCwgcm93SW5kZXgsIHN1Yk1hdHJpeC5Sb3dDb3VudCwgMCwgY29sdW1uSW5kZXgsIHN1Yk1hdHJpeC5Db2x1bW5Db3VudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvcGllcyB0aGUgdmFsdWVzIG9mIGEgZ2l2ZW4gbWF0cml4IGludG8gYSByZWdpb24gaW4gdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dJbmRleFwiPlRoZSByb3cgdG8gc3RhcnQgY29weWluZyB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd0NvdW50XCI+VGhlIG51bWJlciBvZiByb3dzIHRvIGNvcHkuIE11c3QgYmUgcG9zaXRpdmUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb2x1bW5JbmRleFwiPlRoZSBjb2x1bW4gdG8gc3RhcnQgY29weWluZyB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtbkNvdW50XCI+VGhlIG51bWJlciBvZiBjb2x1bW5zIHRvIGNvcHkuIE11c3QgYmUgcG9zaXRpdmUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdWJNYXRyaXhcIj5UaGUgc3ViLW1hdHJpeCB0byBjb3B5IGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWY6IDxsaXN0PjxpdGVtPjxwYXJhbXJlZiBuYW1lPVwicm93SW5kZXhcIi8+IGlzXHJcbiAgICAgICAgLy8vIG5lZ2F0aXZlLCBvciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiByb3dzLjwvaXRlbT5cclxuICAgICAgICAvLy8gPGl0ZW0+PHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5JbmRleFwiLz4gaXMgbmVnYXRpdmUsIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyXHJcbiAgICAgICAgLy8vIG9mIGNvbHVtbnMuPC9pdGVtPlxyXG4gICAgICAgIC8vLyA8aXRlbT48Yz4oY29sdW1uSW5kZXggKyBjb2x1bW5MZW5ndGgpICZndDs9IENvbHVtbnM8L2M+PC9pdGVtPlxyXG4gICAgICAgIC8vLyA8aXRlbT48Yz4ocm93SW5kZXggKyByb3dMZW5ndGgpICZndDs9IFJvd3M8L2M+PC9pdGVtPjwvbGlzdD48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGl0ZW0+dGhlIHNpemUgb2YgPHBhcmFtcmVmIG5hbWU9XCJzdWJNYXRyaXhcIi8+IGlzIG5vdCBhdCBsZWFzdCA8cGFyYW1yZWYgbmFtZT1cInJvd0NvdW50XCIvPiB4IDxwYXJhbXJlZiBuYW1lPVwiY29sdW1uQ291bnRcIi8+LjwvaXRlbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyb3dDb3VudFwiLz4gb3IgPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5Db3VudFwiLz5cclxuICAgICAgICAvLy8gaXMgbm90IHBvc2l0aXZlLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldFN1Yk1hdHJpeChpbnQgcm93SW5kZXgsIGludCByb3dDb3VudCwgaW50IGNvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQsIE1hdHJpeDxUPiBzdWJNYXRyaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzdWJNYXRyaXguU3RvcmFnZS5Db3B5U3ViTWF0cml4VG8oU3RvcmFnZSwgMCwgcm93SW5kZXgsIHJvd0NvdW50LCAwLCBjb2x1bW5JbmRleCwgY29sdW1uQ291bnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb3BpZXMgdGhlIHZhbHVlcyBvZiBhIGdpdmVuIG1hdHJpeCBpbnRvIGEgcmVnaW9uIGluIHRoaXMgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm93SW5kZXhcIj5UaGUgcm93IHRvIHN0YXJ0IGNvcHlpbmcgdG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzb3JjZVJvd0luZGV4XCI+VGhlIHJvdyBvZiB0aGUgc3ViLW1hdHJpeCB0byBzdGFydCBjb3B5aW5nIGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dDb3VudFwiPlRoZSBudW1iZXIgb2Ygcm93cyB0byBjb3B5LiBNdXN0IGJlIHBvc2l0aXZlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uSW5kZXhcIj5UaGUgY29sdW1uIHRvIHN0YXJ0IGNvcHlpbmcgdG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzb3VyY2VDb2x1bW5JbmRleFwiPlRoZSBjb2x1bW4gb2YgdGhlIHN1Yi1tYXRyaXggdG8gc3RhcnQgY29weWluZyBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uQ291bnRcIj5UaGUgbnVtYmVyIG9mIGNvbHVtbnMgdG8gY29weS4gTXVzdCBiZSBwb3NpdGl2ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInN1Yk1hdHJpeFwiPlRoZSBzdWItbWF0cml4IHRvIGNvcHkgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZjogPGxpc3Q+PGl0ZW0+PHBhcmFtcmVmIG5hbWU9XCJyb3dJbmRleFwiLz4gaXNcclxuICAgICAgICAvLy8gbmVnYXRpdmUsIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJvd3MuPC9pdGVtPlxyXG4gICAgICAgIC8vLyA8aXRlbT48cGFyYW1yZWYgbmFtZT1cImNvbHVtbkluZGV4XCIvPiBpcyBuZWdhdGl2ZSwgb3IgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBudW1iZXJcclxuICAgICAgICAvLy8gb2YgY29sdW1ucy48L2l0ZW0+XHJcbiAgICAgICAgLy8vIDxpdGVtPjxjPihjb2x1bW5JbmRleCArIGNvbHVtbkxlbmd0aCkgJmd0Oz0gQ29sdW1uczwvYz48L2l0ZW0+XHJcbiAgICAgICAgLy8vIDxpdGVtPjxjPihyb3dJbmRleCArIHJvd0xlbmd0aCkgJmd0Oz0gUm93czwvYz48L2l0ZW0+PC9saXN0PjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8aXRlbT50aGUgc2l6ZSBvZiA8cGFyYW1yZWYgbmFtZT1cInN1Yk1hdHJpeFwiLz4gaXMgbm90IGF0IGxlYXN0IDxwYXJhbXJlZiBuYW1lPVwicm93Q291bnRcIi8+IHggPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5Db3VudFwiLz4uPC9pdGVtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cInJvd0NvdW50XCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cImNvbHVtbkNvdW50XCIvPlxyXG4gICAgICAgIC8vLyBpcyBub3QgcG9zaXRpdmUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0U3ViTWF0cml4KGludCByb3dJbmRleCwgaW50IHNvcmNlUm93SW5kZXgsIGludCByb3dDb3VudCwgaW50IGNvbHVtbkluZGV4LCBpbnQgc291cmNlQ29sdW1uSW5kZXgsIGludCBjb2x1bW5Db3VudCwgTWF0cml4PFQ+IHN1Yk1hdHJpeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN1Yk1hdHJpeC5TdG9yYWdlLkNvcHlTdWJNYXRyaXhUbyhTdG9yYWdlLCBzb3JjZVJvd0luZGV4LCByb3dJbmRleCwgcm93Q291bnQsIHNvdXJjZUNvbHVtbkluZGV4LCBjb2x1bW5JbmRleCwgY29sdW1uQ291bnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gVmVjdG9yIHRvIHRoZSBkaWFnb25hbC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNvdXJjZVwiPlRoZSB2ZWN0b3IgdG8gY29weSB0aGUgdmFsdWVzIGZyb20uIFRoZSBsZW5ndGggb2YgdGhlIHZlY3RvciBzaG91bGQgYmVcclxuICAgICAgICAvLy8gTWluKFJvd3MsIENvbHVtbnMpLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwic291cmNlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSBsZW5ndGggb2YgPHBhcmFtcmVmIG5hbWU9XCJzb3VyY2VcIi8+IGRvZXMgbm90XHJcbiAgICAgICAgLy8vIGVxdWFsIE1pbihSb3dzLCBDb2x1bW5zKS48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPHJlbWFya3M+Rm9yIG5vbi1zcXVhcmUgbWF0cmljZXMsIHRoZSBlbGVtZW50cyBvZiA8cGFyYW1yZWYgbmFtZT1cInNvdXJjZVwiLz4gYXJlIGNvcGllZCB0b1xyXG4gICAgICAgIC8vLyB0aGlzW2ksaV0uPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIHZvaWQgU2V0RGlhZ29uYWwoVmVjdG9yPFQ+IHNvdXJjZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInNvdXJjZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG1pbiA9IE1hdGguTWluKFJvd0NvdW50LCBDb2x1bW5Db3VudCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc291cmNlLkNvdW50ICE9IG1pbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGh7MH1cIiwgXCJzb3VyY2VcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF0KGksIGksIHNvdXJjZS5BdChpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29waWVzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIGFycmF5IHRvIHRoZSBkaWFnb25hbC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNvdXJjZVwiPlRoZSBhcnJheSB0byBjb3B5IHRoZSB2YWx1ZXMgZnJvbS4gVGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yIHNob3VsZCBiZVxyXG4gICAgICAgIC8vLyBNaW4oUm93cywgQ29sdW1ucykuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJzb3VyY2VcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIGxlbmd0aCBvZiA8cGFyYW1yZWYgbmFtZT1cInNvdXJjZVwiLz4gZG9lcyBub3RcclxuICAgICAgICAvLy8gZXF1YWwgTWluKFJvd3MsIENvbHVtbnMpLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5Gb3Igbm9uLXNxdWFyZSBtYXRyaWNlcywgdGhlIGVsZW1lbnRzIG9mIDxwYXJhbXJlZiBuYW1lPVwic291cmNlXCIvPiBhcmUgY29waWVkIHRvXHJcbiAgICAgICAgLy8vIHRoaXNbaSxpXS48L3JlbWFya3M+XHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgdm9pZCBTZXREaWFnb25hbChUW10gc291cmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwic291cmNlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbWluID0gTWF0aC5NaW4oUm93Q291bnQsIENvbHVtbkNvdW50KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UuTGVuZ3RoICE9IG1pbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50QXJyYXlzU2FtZUxlbmd0aHswfVwiLCBcInNvdXJjZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXQoaSwgaSwgc291cmNlW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSB0cmFuc3Bvc2Ugb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHRyYW5zcG9zZSBvZiB0aGlzIG1hdHJpeC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBUcmFuc3Bvc2UoKVxyXG4gICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMsIENvbHVtbkNvdW50LCBSb3dDb3VudCk7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuVHJhbnNwb3NlVG9VbmNoZWNrZWQocmVzdWx0LlN0b3JhZ2UsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFB1dHMgdGhlIHRyYW5zcG9zZSBvZiB0aGlzIG1hdHJpeCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgVHJhbnNwb3NlKE1hdHJpeDxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTdG9yYWdlLlRyYW5zcG9zZVRvKHJlc3VsdC5TdG9yYWdlLCBFeGlzdGluZ0RhdGEuQ2xlYXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBjb25qdWdhdGUgdHJhbnNwb3NlIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBjb25qdWdhdGUgdHJhbnNwb3NlIG9mIHRoaXMgbWF0cml4LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3QgTWF0cml4PFQ+IENvbmp1Z2F0ZVRyYW5zcG9zZSgpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFB1dHMgdGhlIGNvbmp1Z2F0ZSB0cmFuc3Bvc2Ugb2YgdGhpcyBtYXRyaXggaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCB2b2lkIENvbmp1Z2F0ZVRyYW5zcG9zZShNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQZXJtdXRlIHRoZSByb3dzIG9mIGEgbWF0cml4IGFjY29yZGluZyB0byBhIHBlcm11dGF0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicFwiPlRoZSByb3cgcGVybXV0YXRpb24gdG8gYXBwbHkgdG8gdGhpcyBtYXRyaXguPC9wYXJhbT5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQZXJtdXRlIHRoZSBjb2x1bW5zIG9mIGEgbWF0cml4IGFjY29yZGluZyB0byBhIHBlcm11dGF0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicFwiPlRoZSBjb2x1bW4gcGVybXV0YXRpb24gdG8gYXBwbHkgdG8gdGhpcyBtYXRyaXguPC9wYXJhbT5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyAgQ29uY2F0ZW5hdGVzIHRoaXMgbWF0cml4IHdpdGggdGhlIGdpdmVuIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0XCI+VGhlIG1hdHJpeCB0byBjb25jYXRlbmF0ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgY29tYmluZWQgbWF0cml4LjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPHNlZWFsc28gY3JlZj1cIlN0YWNrKE1hdHJpeHtUfSlcIi8+XHJcbiAgICAgICAgLy8vIDxzZWVhbHNvIGNyZWY9XCJEaWFnb25hbFN0YWNrKE1hdHJpeHtUfSlcIi8+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBBcHBlbmQoTWF0cml4PFQ+IHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJpZ2h0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJyaWdodFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJpZ2h0LlJvd0NvdW50ICE9IFJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRNYXRyaXhTYW1lUm93RGltZW5zaW9uXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBcyh0aGlzLCByaWdodCwgUm93Q291bnQsIENvbHVtbkNvdW50ICsgcmlnaHQuQ29sdW1uQ291bnQsIGZ1bGx5TXV0YWJsZTogdHJ1ZSk7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKHJlc3VsdC5TdG9yYWdlLCAwLCAwLCBSb3dDb3VudCwgMCwgMCwgQ29sdW1uQ291bnQsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJpZ2h0LlN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKHJlc3VsdC5TdG9yYWdlLCAwLCAwLCByaWdodC5Sb3dDb3VudCwgMCwgQ29sdW1uQ291bnQsIHJpZ2h0LkNvbHVtbkNvdW50LCBFeGlzdGluZ0RhdGEuQXNzdW1lWmVyb3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb25jYXRlbmF0ZXMgdGhpcyBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbWF0cml4IGFuZCBwbGFjZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRcIj5UaGUgbWF0cml4IHRvIGNvbmNhdGVuYXRlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIGNvbWJpbmVkIG1hdHJpeC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8c2VlYWxzbyBjcmVmPVwiU3RhY2soTWF0cml4e1R9LCBNYXRyaXh7VH0pXCIvPlxyXG4gICAgICAgIC8vLyA8c2VlYWxzbyBjcmVmPVwiRGlhZ29uYWxTdGFjayhNYXRyaXh7VH0sIE1hdHJpeHtUfSlcIi8+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQXBwZW5kKE1hdHJpeDxUPiByaWdodCwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicmlnaHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyaWdodC5Sb3dDb3VudCAhPSBSb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4U2FtZVJvd0RpbWVuc2lvblwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0LkNvbHVtbkNvdW50ICE9IChDb2x1bW5Db3VudCArIHJpZ2h0LkNvbHVtbkNvdW50KSB8fCByZXN1bHQuUm93Q291bnQgIT0gUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeFNhbWVDb2x1bW5EaW1lbnNpb25cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKHJlc3VsdC5TdG9yYWdlLCAwLCAwLCBSb3dDb3VudCwgMCwgMCwgQ29sdW1uQ291bnQsIEV4aXN0aW5nRGF0YS5DbGVhcik7XHJcbiAgICAgICAgICAgIHJpZ2h0LlN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKHJlc3VsdC5TdG9yYWdlLCAwLCAwLCByaWdodC5Sb3dDb3VudCwgMCwgQ29sdW1uQ291bnQsIHJpZ2h0LkNvbHVtbkNvdW50LCBFeGlzdGluZ0RhdGEuQ2xlYXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdGFja3MgdGhpcyBtYXRyaXggb24gdG9wIG9mIHRoZSBnaXZlbiBtYXRyaXggYW5kIHBsYWNlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb3dlclwiPlRoZSBtYXRyaXggdG8gc3RhY2sgdGhpcyBtYXRyaXggdXBvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgY29tYmluZWQgbWF0cml4LjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgbG93ZXIgaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8c3Ryb25nPnVwcGVyLkNvbHVtbnMgIT0gbG93ZXIuQ29sdW1uczwvc3Ryb25nPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPHNlZWFsc28gY3JlZj1cIkFwcGVuZChNYXRyaXh7VH0pXCIvPlxyXG4gICAgICAgIC8vLyA8c2VlYWxzbyBjcmVmPVwiRGlhZ29uYWxTdGFjayhNYXRyaXh7VH0pXCIvPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3RhY2soTWF0cml4PFQ+IGxvd2VyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGxvd2VyID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJsb3dlclwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxvd2VyLkNvbHVtbkNvdW50ICE9IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRNYXRyaXhTYW1lQ29sdW1uRGltZW5zaW9uezB9XCIsIFwibG93ZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzKHRoaXMsIGxvd2VyLCBSb3dDb3VudCArIGxvd2VyLlJvd0NvdW50LCBDb2x1bW5Db3VudCwgZnVsbHlNdXRhYmxlOiB0cnVlKTtcclxuICAgICAgICAgICAgU3RvcmFnZS5Db3B5U3ViTWF0cml4VG9VbmNoZWNrZWQocmVzdWx0LlN0b3JhZ2UsIDAsIDAsIFJvd0NvdW50LCAwLCAwLCBDb2x1bW5Db3VudCwgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgbG93ZXIuU3RvcmFnZS5Db3B5U3ViTWF0cml4VG9VbmNoZWNrZWQocmVzdWx0LlN0b3JhZ2UsIDAsIFJvd0NvdW50LCBsb3dlci5Sb3dDb3VudCwgMCwgMCwgbG93ZXIuQ29sdW1uQ291bnQsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN0YWNrcyB0aGlzIG1hdHJpeCBvbiB0b3Agb2YgdGhlIGdpdmVuIG1hdHJpeCBhbmQgcGxhY2VzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvd2VyXCI+VGhlIG1hdHJpeCB0byBzdGFjayB0aGlzIG1hdHJpeCB1cG9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIGNvbWJpbmVkIG1hdHJpeC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiBsb3dlciBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzdHJvbmc+dXBwZXIuQ29sdW1ucyAhPSBsb3dlci5Db2x1bW5zPC9zdHJvbmc+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8c2VlYWxzbyBjcmVmPVwiQXBwZW5kKE1hdHJpeHtUfSwgTWF0cml4e1R9KVwiLz5cclxuICAgICAgICAvLy8gPHNlZWFsc28gY3JlZj1cIkRpYWdvbmFsU3RhY2soTWF0cml4e1R9LCBNYXRyaXh7VH0pXCIvPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFN0YWNrKE1hdHJpeDxUPiBsb3dlciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsb3dlciA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwibG93ZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsb3dlci5Db2x1bW5Db3VudCAhPSBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4U2FtZUNvbHVtbkRpbWVuc2lvbnswfVwiLCBcImxvd2VyXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuUm93Q291bnQgIT0gKFJvd0NvdW50ICsgbG93ZXIuUm93Q291bnQpIHx8IHJlc3VsdC5Db2x1bW5Db3VudCAhPSBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4odGhpcywgcmVzdWx0LCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgU3RvcmFnZS5Db3B5U3ViTWF0cml4VG9VbmNoZWNrZWQocmVzdWx0LlN0b3JhZ2UsIDAsIDAsIFJvd0NvdW50LCAwLCAwLCBDb2x1bW5Db3VudCwgRXhpc3RpbmdEYXRhLkNsZWFyKTtcclxuICAgICAgICAgICAgbG93ZXIuU3RvcmFnZS5Db3B5U3ViTWF0cml4VG9VbmNoZWNrZWQocmVzdWx0LlN0b3JhZ2UsIDAsIFJvd0NvdW50LCBsb3dlci5Sb3dDb3VudCwgMCwgMCwgbG93ZXIuQ29sdW1uQ291bnQsIEV4aXN0aW5nRGF0YS5DbGVhcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERpYWdvbmFsbHkgc3RhY2tzIGhpcyBtYXRyaXggb24gdG9wIG9mIHRoZSBnaXZlbiBtYXRyaXguIFRoZSBuZXcgbWF0cml4IGlzIGEgTS1ieS1OIG1hdHJpeCxcclxuICAgICAgICAvLy8gd2hlcmUgTSA9IHRoaXMuUm93cyArIGxvd2VyLlJvd3MgYW5kIE4gPSB0aGlzLkNvbHVtbnMgKyBsb3dlci5Db2x1bW5zLlxyXG4gICAgICAgIC8vLyBUaGUgdmFsdWVzIG9mIG9mZiB0aGUgb2ZmIGRpYWdvbmFsIG1hdHJpY2VzL2Jsb2NrcyBhcmUgc2V0IHRvIHplcm8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb3dlclwiPlRoZSBsb3dlciwgcmlnaHQgbWF0cml4LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIGxvd2VyIGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPnRoZSBjb21iaW5lZCBtYXRyaXg8L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxzZWVhbHNvIGNyZWY9XCJTdGFjayhNYXRyaXh7VH0pXCIvPlxyXG4gICAgICAgIC8vLyA8c2VlYWxzbyBjcmVmPVwiQXBwZW5kKE1hdHJpeHtUfSlcIi8+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEaWFnb25hbFN0YWNrKE1hdHJpeDxUPiBsb3dlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsb3dlciA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwibG93ZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzKHRoaXMsIGxvd2VyLCBSb3dDb3VudCArIGxvd2VyLlJvd0NvdW50LCBDb2x1bW5Db3VudCArIGxvd2VyLkNvbHVtbkNvdW50LCBSb3dDb3VudCAhPSBDb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKHJlc3VsdC5TdG9yYWdlLCAwLCAwLCBSb3dDb3VudCwgMCwgMCwgQ29sdW1uQ291bnQsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIGxvd2VyLlN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKHJlc3VsdC5TdG9yYWdlLCAwLCBSb3dDb3VudCwgbG93ZXIuUm93Q291bnQsIDAsIENvbHVtbkNvdW50LCBsb3dlci5Db2x1bW5Db3VudCwgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGlhZ29uYWxseSBzdGFja3MgaGlzIG1hdHJpeCBvbiB0b3Agb2YgdGhlIGdpdmVuIG1hdHJpeCBhbmQgcGxhY2VzIHRoZSBjb21iaW5lZCBtYXRyaXggaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvd2VyXCI+VGhlIGxvd2VyLCByaWdodCBtYXRyaXguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgY29tYmluZWQgbWF0cml4PC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgbG93ZXIgaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgdGhlIHJlc3VsdCBtYXRyaXggaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgcmVzdWx0IG1hdHJpeCdzIGRpbWVuc2lvbnMgYXJlIG5vdCAodGhpcy5Sb3dzICsgbG93ZXIucm93cykgeCAodGhpcy5Db2x1bW5zICsgbG93ZXIuQ29sdW1ucykuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxzZWVhbHNvIGNyZWY9XCJTdGFjayhNYXRyaXh7VH0sIE1hdHJpeHtUfSlcIi8+XHJcbiAgICAgICAgLy8vIDxzZWVhbHNvIGNyZWY9XCJBcHBlbmQoTWF0cml4e1R9LCBNYXRyaXh7VH0pXCIvPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIERpYWdvbmFsU3RhY2soTWF0cml4PFQ+IGxvd2VyLCBNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGxvd2VyID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJsb3dlclwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0LlJvd0NvdW50ICE9IFJvd0NvdW50ICsgbG93ZXIuUm93Q291bnQgfHwgcmVzdWx0LkNvbHVtbkNvdW50ICE9IENvbHVtbkNvdW50ICsgbG93ZXIuQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKHJlc3VsdC5TdG9yYWdlLCAwLCAwLCBSb3dDb3VudCwgMCwgMCwgQ29sdW1uQ291bnQsIEV4aXN0aW5nRGF0YS5DbGVhcik7XHJcbiAgICAgICAgICAgIGxvd2VyLlN0b3JhZ2UuQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKHJlc3VsdC5TdG9yYWdlLCAwLCBSb3dDb3VudCwgbG93ZXIuUm93Q291bnQsIDAsIENvbHVtbkNvdW50LCBsb3dlci5Db2x1bW5Db3VudCwgRXhpc3RpbmdEYXRhLkNsZWFyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRXZhbHVhdGVzIHdoZXRoZXIgdGhpcyBtYXRyaXggaXMgc3ltbWV0cmljLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgYm9vbCBJc1N5bW1ldHJpYygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gPSByb3cgKyAxOyBjb2x1bW4gPCBDb2x1bW5Db3VudDsgY29sdW1uKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBdChyb3csIGNvbHVtbikuRXF1YWxzKEF0KGNvbHVtbiwgcm93KSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRXZhbHVhdGVzIHdoZXRoZXIgdGhpcyBtYXRyaXggaXMgSGVybWl0aWFuIChjb25qdWdhdGUgc3ltbWV0cmljKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBib29sIElzSGVybWl0aWFuKCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGlzIG1hdHJpeCBhcyBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkuXHJcbiAgICAgICAgLy8vIFRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3IgdGhlIGFycmF5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgbXVsdGlkaW1lbnNpb25hbCBjb250YWluaW5nIHRoZSB2YWx1ZXMgb2YgdGhpcyBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBUWyxdIFRvQXJyYXkoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuVG9BcnJheSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBtYXRyaXgncyBlbGVtZW50cyBhcyBhbiBhcnJheSB3aXRoIHRoZSBkYXRhIGxhaWQgb3V0IGNvbHVtbiBieSBjb2x1bW4gKGNvbHVtbiBtYWpvcikuXHJcbiAgICAgICAgLy8vIFRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3IgdGhlIGFycmF5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxleGFtcGxlPjxwcmU+XHJcbiAgICAgICAgLy8vIDEsIDIsIDNcclxuICAgICAgICAvLy8gNCwgNSwgNiAgd2lsbCBiZSByZXR1cm5lZCBhcyAgMSwgNCwgNywgMiwgNSwgOCwgMywgNiwgOVxyXG4gICAgICAgIC8vLyA3LCA4LCA5XHJcbiAgICAgICAgLy8vIDwvcHJlPjwvZXhhbXBsZT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QW4gYXJyYXkgY29udGFpbmluZyB0aGUgbWF0cml4J3MgZWxlbWVudHMuPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8c2VlYWxzbyBjcmVmPVwiVG9Sb3dNYWpvckFycmF5XCIvPlxyXG4gICAgICAgIC8vLyA8c2VlYWxzbyBjcmVmPVwiRW51bWVyYXRlKFplcm9zKVwiLz5cclxuICAgICAgICBwdWJsaWMgVFtdIFRvQ29sdW1uTWFqb3JBcnJheSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5Ub0NvbHVtbk1ham9yQXJyYXkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgbWF0cml4J3MgZWxlbWVudHMgYXMgYW4gYXJyYXkgd2l0aCB0aGUgZGF0YSBsYWlkIHJvdyBieSByb3cgKHJvdyBtYWpvcikuXHJcbiAgICAgICAgLy8vIFRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3IgdGhlIGFycmF5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxleGFtcGxlPjxwcmU+XHJcbiAgICAgICAgLy8vIDEsIDIsIDNcclxuICAgICAgICAvLy8gNCwgNSwgNiAgd2lsbCBiZSByZXR1cm5lZCBhcyAgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOVxyXG4gICAgICAgIC8vLyA3LCA4LCA5XHJcbiAgICAgICAgLy8vIDwvcHJlPjwvZXhhbXBsZT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QW4gYXJyYXkgY29udGFpbmluZyB0aGUgbWF0cml4J3MgZWxlbWVudHMuPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8c2VlYWxzbyBjcmVmPVwiVG9Db2x1bW5NYWpvckFycmF5XCIvPlxyXG4gICAgICAgIC8vLyA8c2VlYWxzbyBjcmVmPVwiRW51bWVyYXRlKFplcm9zKVwiLz5cclxuICAgICAgICBwdWJsaWMgVFtdIFRvUm93TWFqb3JBcnJheSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5Ub1Jvd01ham9yQXJyYXkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGlzIG1hdHJpeCBhcyBhcnJheSBvZiByb3cgYXJyYXlzLlxyXG4gICAgICAgIC8vLyBUaGUgcmV0dXJuZWQgYXJyYXlzIHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciB0aGUgYXJyYXlzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFRbXVtdIFRvUm93QXJyYXlzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdG9yYWdlLlRvUm93QXJyYXlzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhpcyBtYXRyaXggYXMgYXJyYXkgb2YgY29sdW1uIGFycmF5cy5cclxuICAgICAgICAvLy8gVGhlIHJldHVybmVkIGFycmF5cyB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3IgdGhlIGFycmF5cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBUW11bXSBUb0NvbHVtbkFycmF5cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5Ub0NvbHVtbkFycmF5cygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIHRoaXMgbWF0cml4IGlmLCBhbmQgb25seSBpZiwgdGhpcyBtYXRyaXggaXMgc3RvcmVkIGJ5IHN1Y2ggYW4gYXJyYXkgaW50ZXJuYWxseS5cclxuICAgICAgICAvLy8gT3RoZXJ3aXNlIHJldHVybnMgbnVsbC4gQ2hhbmdlcyB0byB0aGUgcmV0dXJuZWQgYXJyYXkgYW5kIHRoZSBtYXRyaXggd2lsbCBhZmZlY3QgZWFjaCBvdGhlci5cclxuICAgICAgICAvLy8gVXNlIFRvQXJyYXkgaW5zdGVhZCBpZiB5b3UgYWx3YXlzIG5lZWQgYW4gaW5kZXBlbmRlbnQgYXJyYXkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVFssXSBBc0FycmF5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdG9yYWdlLkFzQXJyYXkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgaW50ZXJuYWwgY29sdW1uIGJ5IGNvbHVtbiAoY29sdW1uIG1ham9yKSBhcnJheSBvZiB0aGlzIG1hdHJpeCBpZiwgYW5kIG9ubHkgaWYsIHRoaXMgbWF0cml4IGlzIHN0b3JlZCBieSBzdWNoIGFycmF5cyBpbnRlcm5hbGx5LlxyXG4gICAgICAgIC8vLyBPdGhlcndpc2UgcmV0dXJucyBudWxsLiBDaGFuZ2VzIHRvIHRoZSByZXR1cm5lZCBhcnJheXMgYW5kIHRoZSBtYXRyaXggd2lsbCBhZmZlY3QgZWFjaCBvdGhlci5cclxuICAgICAgICAvLy8gVXNlIFRvQ29sdW1uTWFqb3JBcnJheSBpbnN0ZWFkIGlmIHlvdSBhbHdheXMgbmVlZCBhbiBpbmRlcGVuZGVudCBhcnJheS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8ZXhhbXBsZT48cHJlPlxyXG4gICAgICAgIC8vLyAxLCAyLCAzXHJcbiAgICAgICAgLy8vIDQsIDUsIDYgIHdpbGwgYmUgcmV0dXJuZWQgYXMgIDEsIDQsIDcsIDIsIDUsIDgsIDMsIDYsIDlcclxuICAgICAgICAvLy8gNywgOCwgOVxyXG4gICAgICAgIC8vLyA8L3ByZT48L2V4YW1wbGU+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG1hdHJpeCdzIGVsZW1lbnRzLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPHNlZWFsc28gY3JlZj1cIlRvUm93TWFqb3JBcnJheVwiLz5cclxuICAgICAgICAvLy8gPHNlZWFsc28gY3JlZj1cIkVudW1lcmF0ZShaZXJvcylcIi8+XHJcbiAgICAgICAgcHVibGljIFRbXSBBc0NvbHVtbk1ham9yQXJyYXkoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuQXNDb2x1bW5NYWpvckFycmF5KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIGludGVybmFsIHJvdyBieSByb3cgKHJvdyBtYWpvcikgYXJyYXkgb2YgdGhpcyBtYXRyaXggaWYsIGFuZCBvbmx5IGlmLCB0aGlzIG1hdHJpeCBpcyBzdG9yZWQgYnkgc3VjaCBhcnJheXMgaW50ZXJuYWxseS5cclxuICAgICAgICAvLy8gT3RoZXJ3aXNlIHJldHVybnMgbnVsbC4gQ2hhbmdlcyB0byB0aGUgcmV0dXJuZWQgYXJyYXlzIGFuZCB0aGUgbWF0cml4IHdpbGwgYWZmZWN0IGVhY2ggb3RoZXIuXHJcbiAgICAgICAgLy8vIFVzZSBUb1Jvd01ham9yQXJyYXkgaW5zdGVhZCBpZiB5b3UgYWx3YXlzIG5lZWQgYW4gaW5kZXBlbmRlbnQgYXJyYXkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPGV4YW1wbGU+PHByZT5cclxuICAgICAgICAvLy8gMSwgMiwgM1xyXG4gICAgICAgIC8vLyA0LCA1LCA2ICB3aWxsIGJlIHJldHVybmVkIGFzICAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XHJcbiAgICAgICAgLy8vIDcsIDgsIDlcclxuICAgICAgICAvLy8gPC9wcmU+PC9leGFtcGxlPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BbiBhcnJheSBjb250YWluaW5nIHRoZSBtYXRyaXgncyBlbGVtZW50cy48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxzZWVhbHNvIGNyZWY9XCJUb0NvbHVtbk1ham9yQXJyYXlcIi8+XHJcbiAgICAgICAgLy8vIDxzZWVhbHNvIGNyZWY9XCJFbnVtZXJhdGUoWmVyb3MpXCIvPlxyXG4gICAgICAgIHB1YmxpYyBUW10gQXNSb3dNYWpvckFycmF5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdG9yYWdlLkFzUm93TWFqb3JBcnJheSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCByb3cgYXJyYXlzIG9mIHRoaXMgbWF0cml4IGlmLCBhbmQgb25seSBpZiwgdGhpcyBtYXRyaXggaXMgc3RvcmVkIGJ5IHN1Y2ggYXJyYXlzIGludGVybmFsbHkuXHJcbiAgICAgICAgLy8vIE90aGVyd2lzZSByZXR1cm5zIG51bGwuIENoYW5nZXMgdG8gdGhlIHJldHVybmVkIGFycmF5cyBhbmQgdGhlIG1hdHJpeCB3aWxsIGFmZmVjdCBlYWNoIG90aGVyLlxyXG4gICAgICAgIC8vLyBVc2UgVG9Sb3dBcnJheXMgaW5zdGVhZCBpZiB5b3UgYWx3YXlzIG5lZWQgYW4gaW5kZXBlbmRlbnQgYXJyYXkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVFtdW10gQXNSb3dBcnJheXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuQXNSb3dBcnJheXMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgaW50ZXJuYWwgY29sdW1uIGFycmF5cyBvZiB0aGlzIG1hdHJpeCBpZiwgYW5kIG9ubHkgaWYsIHRoaXMgbWF0cml4IGlzIHN0b3JlZCBieSBzdWNoIGFycmF5cyBpbnRlcm5hbGx5LlxyXG4gICAgICAgIC8vLyBPdGhlcndpc2UgcmV0dXJucyBudWxsLiBDaGFuZ2VzIHRvIHRoZSByZXR1cm5lZCBhcnJheXMgYW5kIHRoZSBtYXRyaXggd2lsbCBhZmZlY3QgZWFjaCBvdGhlci5cclxuICAgICAgICAvLy8gVXNlIFRvQ29sdW1uQXJyYXlzIGluc3RlYWQgaWYgeW91IGFsd2F5cyBuZWVkIGFuIGluZGVwZW5kZW50IGFycmF5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFRbXVtdIEFzQ29sdW1uQXJyYXlzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdG9yYWdlLkFzQ29sdW1uQXJyYXlzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYW4gSUVudW1lcmFibGUgdGhhdCBjYW4gYmUgdXNlZCB0byBpdGVyYXRlIHRocm91Z2ggYWxsIHZhbHVlcyBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlxyXG4gICAgICAgIC8vLyBUaGUgZW51bWVyYXRvciB3aWxsIGluY2x1ZGUgYWxsIHZhbHVlcywgZXZlbiBpZiB0aGV5IGFyZSB6ZXJvLlxyXG4gICAgICAgIC8vLyBUaGUgb3JkZXJpbmcgb2YgdGhlIHZhbHVlcyBpcyB1bnNwZWNpZmllZCAobm90IG5lY2Vzc2FyaWx5IGNvbHVtbi13aXNlIG9yIHJvdy13aXNlKS5cclxuICAgICAgICAvLy8gPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyBJRW51bWVyYWJsZTxUPiBFbnVtZXJhdGUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuRW51bWVyYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYW4gSUVudW1lcmFibGUgdGhhdCBjYW4gYmUgdXNlZCB0byBpdGVyYXRlIHRocm91Z2ggYWxsIHZhbHVlcyBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlxyXG4gICAgICAgIC8vLyBUaGUgZW51bWVyYXRvciB3aWxsIGluY2x1ZGUgYWxsIHZhbHVlcywgZXZlbiBpZiB0aGV5IGFyZSB6ZXJvLlxyXG4gICAgICAgIC8vLyBUaGUgb3JkZXJpbmcgb2YgdGhlIHZhbHVlcyBpcyB1bnNwZWNpZmllZCAobm90IG5lY2Vzc2FyaWx5IGNvbHVtbi13aXNlIG9yIHJvdy13aXNlKS5cclxuICAgICAgICAvLy8gPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyBJRW51bWVyYWJsZTxUPiBFbnVtZXJhdGUoWmVyb3MgemVyb3MgPSBaZXJvcy5JbmNsdWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3dpdGNoICh6ZXJvcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBaZXJvcy5BbGxvd1NraXA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuRW51bWVyYXRlTm9uWmVybygpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5FbnVtZXJhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGFuIElFbnVtZXJhYmxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbCB2YWx1ZXMgb2YgdGhlIG1hdHJpeCBhbmQgdGhlaXIgaW5kZXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+XHJcbiAgICAgICAgLy8vIFRoZSBlbnVtZXJhdG9yIHJldHVybnMgYSBUdXBsZSB3aXRoIHRoZSBmaXJzdCB0d28gdmFsdWVzIGJlaW5nIHRoZSByb3cgYW5kIGNvbHVtbiBpbmRleFxyXG4gICAgICAgIC8vLyBhbmQgdGhlIHRoaXJkIHZhbHVlIGJlaW5nIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBhdCB0aGF0IGluZGV4LlxyXG4gICAgICAgIC8vLyBUaGUgZW51bWVyYXRvciB3aWxsIGluY2x1ZGUgYWxsIHZhbHVlcywgZXZlbiBpZiB0aGV5IGFyZSB6ZXJvLlxyXG4gICAgICAgIC8vLyA8L3JlbWFya3M+XHJcbiAgICAgICAgcHVibGljIElFbnVtZXJhYmxlPFR1cGxlPGludCwgaW50LCBUPj4gRW51bWVyYXRlSW5kZXhlZCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5FbnVtZXJhdGVJbmRleGVkKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYW4gSUVudW1lcmFibGUgdGhhdCBjYW4gYmUgdXNlZCB0byBpdGVyYXRlIHRocm91Z2ggYWxsIHZhbHVlcyBvZiB0aGUgbWF0cml4IGFuZCB0aGVpciBpbmRleC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5cclxuICAgICAgICAvLy8gVGhlIGVudW1lcmF0b3IgcmV0dXJucyBhIFR1cGxlIHdpdGggdGhlIGZpcnN0IHR3byB2YWx1ZXMgYmVpbmcgdGhlIHJvdyBhbmQgY29sdW1uIGluZGV4XHJcbiAgICAgICAgLy8vIGFuZCB0aGUgdGhpcmQgdmFsdWUgYmVpbmcgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IGF0IHRoYXQgaW5kZXguXHJcbiAgICAgICAgLy8vIFRoZSBlbnVtZXJhdG9yIHdpbGwgaW5jbHVkZSBhbGwgdmFsdWVzLCBldmVuIGlmIHRoZXkgYXJlIHplcm8uXHJcbiAgICAgICAgLy8vIDwvcmVtYXJrcz5cclxuICAgICAgICBwdWJsaWMgSUVudW1lcmFibGU8VHVwbGU8aW50LCBpbnQsIFQ+PiBFbnVtZXJhdGVJbmRleGVkKFplcm9zIHplcm9zID0gWmVyb3MuSW5jbHVkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoemVyb3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgWmVyb3MuQWxsb3dTa2lwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yYWdlLkVudW1lcmF0ZU5vblplcm9JbmRleGVkKCk7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yYWdlLkVudW1lcmF0ZUluZGV4ZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGFuIElFbnVtZXJhYmxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbCBjb2x1bW5zIG9mIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgSUVudW1lcmFibGU8VmVjdG9yPFQ+PiBFbnVtZXJhdGVDb2x1bW5zKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ29sdW1uQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgcmV0dXJuIENvbHVtbihpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGFuIElFbnVtZXJhYmxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGEgc3Vic2V0IG9mIGFsbCBjb2x1bW5zIG9mIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmRleFwiPlRoZSBjb2x1bW4gdG8gc3RhcnQgZW51bWVyYXRpbmcgb3Zlci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlbmd0aFwiPlRoZSBudW1iZXIgb2YgY29sdW1ucyB0byBlbnVtZXJhdGluZyBvdmVyLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIElFbnVtZXJhYmxlPFZlY3RvcjxUPj4gRW51bWVyYXRlQ29sdW1ucyhpbnQgaW5kZXgsIGludCBsZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbWF4SW5kZXggPSBNYXRoLk1pbihpbmRleCArIGxlbmd0aCwgQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gTWF0aC5NYXgoaW5kZXgsIDApOyBpIDwgbWF4SW5kZXg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgcmV0dXJuIENvbHVtbihpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGFuIElFbnVtZXJhYmxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbCBjb2x1bW5zIG9mIHRoZSBtYXRyaXggYW5kIHRoZWlyIGluZGV4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlxyXG4gICAgICAgIC8vLyBUaGUgZW51bWVyYXRvciByZXR1cm5zIGEgVHVwbGUgd2l0aCB0aGUgZmlyc3QgdmFsdWUgYmVpbmcgdGhlIGNvbHVtbiBpbmRleFxyXG4gICAgICAgIC8vLyBhbmQgdGhlIHNlY29uZCB2YWx1ZSBiZWluZyB0aGUgdmFsdWUgb2YgdGhlIGNvbHVtbiBhdCB0aGF0IGluZGV4LlxyXG4gICAgICAgIC8vLyA8L3JlbWFya3M+XHJcbiAgICAgICAgcHVibGljIElFbnVtZXJhYmxlPFR1cGxlPGludCwgVmVjdG9yPFQ+Pj4gRW51bWVyYXRlQ29sdW1uc0luZGV4ZWQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDb2x1bW5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCByZXR1cm4gbmV3IFR1cGxlPGludCwgVmVjdG9yPFQ+PihpLCBDb2x1bW4oaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYW4gSUVudW1lcmFibGUgdGhhdCBjYW4gYmUgdXNlZCB0byBpdGVyYXRlIHRocm91Z2ggYSBzdWJzZXQgb2YgYWxsIGNvbHVtbnMgb2YgdGhlIG1hdHJpeCBhbmQgdGhlaXIgaW5kZXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmRleFwiPlRoZSBjb2x1bW4gdG8gc3RhcnQgZW51bWVyYXRpbmcgb3Zlci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlbmd0aFwiPlRoZSBudW1iZXIgb2YgY29sdW1ucyB0byBlbnVtZXJhdGluZyBvdmVyLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlxyXG4gICAgICAgIC8vLyBUaGUgZW51bWVyYXRvciByZXR1cm5zIGEgVHVwbGUgd2l0aCB0aGUgZmlyc3QgdmFsdWUgYmVpbmcgdGhlIGNvbHVtbiBpbmRleFxyXG4gICAgICAgIC8vLyBhbmQgdGhlIHNlY29uZCB2YWx1ZSBiZWluZyB0aGUgdmFsdWUgb2YgdGhlIGNvbHVtbiBhdCB0aGF0IGluZGV4LlxyXG4gICAgICAgIC8vLyA8L3JlbWFya3M+XHJcbiAgICAgICAgcHVibGljIElFbnVtZXJhYmxlPFR1cGxlPGludCwgVmVjdG9yPFQ+Pj4gRW51bWVyYXRlQ29sdW1uc0luZGV4ZWQoaW50IGluZGV4LCBpbnQgbGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG1heEluZGV4ID0gTWF0aC5NaW4oaW5kZXggKyBsZW5ndGgsIENvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IE1hdGguTWF4KGluZGV4LCAwKTsgaSA8IG1heEluZGV4OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHJldHVybiBuZXcgVHVwbGU8aW50LCBWZWN0b3I8VD4+KGksIENvbHVtbihpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhbiBJRW51bWVyYWJsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGl0ZXJhdGUgdGhyb3VnaCBhbGwgcm93cyBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIElFbnVtZXJhYmxlPFZlY3RvcjxUPj4gRW51bWVyYXRlUm93cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHJldHVybiBSb3coaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhbiBJRW51bWVyYWJsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGl0ZXJhdGUgdGhyb3VnaCBhIHN1YnNldCBvZiBhbGwgcm93cyBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5kZXhcIj5UaGUgcm93IHRvIHN0YXJ0IGVudW1lcmF0aW5nIG92ZXIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZW5ndGhcIj5UaGUgbnVtYmVyIG9mIHJvd3MgdG8gZW51bWVyYXRpbmcgb3Zlci48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBJRW51bWVyYWJsZTxWZWN0b3I8VD4+IEVudW1lcmF0ZVJvd3MoaW50IGluZGV4LCBpbnQgbGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG1heEluZGV4ID0gTWF0aC5NaW4oaW5kZXggKyBsZW5ndGgsIFJvd0NvdW50KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IE1hdGguTWF4KGluZGV4LCAwKTsgaSA8IG1heEluZGV4OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHJldHVybiBSb3coaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhbiBJRW51bWVyYWJsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGl0ZXJhdGUgdGhyb3VnaCBhbGwgcm93cyBvZiB0aGUgbWF0cml4IGFuZCB0aGVpciBpbmRleC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5cclxuICAgICAgICAvLy8gVGhlIGVudW1lcmF0b3IgcmV0dXJucyBhIFR1cGxlIHdpdGggdGhlIGZpcnN0IHZhbHVlIGJlaW5nIHRoZSByb3cgaW5kZXhcclxuICAgICAgICAvLy8gYW5kIHRoZSBzZWNvbmQgdmFsdWUgYmVpbmcgdGhlIHZhbHVlIG9mIHRoZSByb3cgYXQgdGhhdCBpbmRleC5cclxuICAgICAgICAvLy8gPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyBJRW51bWVyYWJsZTxUdXBsZTxpbnQsIFZlY3RvcjxUPj4+IEVudW1lcmF0ZVJvd3NJbmRleGVkKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIFZlY3RvcjxUPj4oaSwgUm93KGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGFuIElFbnVtZXJhYmxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGEgc3Vic2V0IG9mIGFsbCByb3dzIG9mIHRoZSBtYXRyaXggYW5kIHRoZWlyIGluZGV4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5kZXhcIj5UaGUgcm93IHRvIHN0YXJ0IGVudW1lcmF0aW5nIG92ZXIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZW5ndGhcIj5UaGUgbnVtYmVyIG9mIHJvd3MgdG8gZW51bWVyYXRpbmcgb3Zlci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5cclxuICAgICAgICAvLy8gVGhlIGVudW1lcmF0b3IgcmV0dXJucyBhIFR1cGxlIHdpdGggdGhlIGZpcnN0IHZhbHVlIGJlaW5nIHRoZSByb3cgaW5kZXhcclxuICAgICAgICAvLy8gYW5kIHRoZSBzZWNvbmQgdmFsdWUgYmVpbmcgdGhlIHZhbHVlIG9mIHRoZSByb3cgYXQgdGhhdCBpbmRleC5cclxuICAgICAgICAvLy8gPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyBJRW51bWVyYWJsZTxUdXBsZTxpbnQsIFZlY3RvcjxUPj4+IEVudW1lcmF0ZVJvd3NJbmRleGVkKGludCBpbmRleCwgaW50IGxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBtYXhJbmRleCA9IE1hdGguTWluKGluZGV4ICsgbGVuZ3RoLCBSb3dDb3VudCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBNYXRoLk1heChpbmRleCwgMCk7IGkgPCBtYXhJbmRleDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCByZXR1cm4gbmV3IFR1cGxlPGludCwgVmVjdG9yPFQ+PihpLCBSb3coaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIG9mIHRoaXMgbWF0cml4IGFuZCByZXBsYWNlcyB0aGUgdmFsdWUgd2l0aCBpdHMgcmVzdWx0LlxyXG4gICAgICAgIC8vLyBJZiBmb3JjZU1hcFplcm8gaXMgbm90IHNldCB0byB0cnVlLCB6ZXJvIHZhbHVlcyBtYXkgb3IgbWF5IG5vdCBiZSBza2lwcGVkIGRlcGVuZGluZ1xyXG4gICAgICAgIC8vLyBvbiB0aGUgYWN0dWFsIGRhdGEgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbiAocmVsZXZhbnQgbW9zdGx5IGZvciBzcGFyc2UgbWF0cmljZXMpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFwSW5wbGFjZShGdW5jPFQsIFQ+IGYsIFplcm9zIHplcm9zID0gWmVyb3MuQWxsb3dTa2lwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU3RvcmFnZS5NYXBJbnBsYWNlKChGdW5jPFQsVD4pZiwgemVyb3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBvZiB0aGlzIG1hdHJpeCBhbmQgcmVwbGFjZXMgdGhlIHZhbHVlIHdpdGggaXRzIHJlc3VsdC5cclxuICAgICAgICAvLy8gVGhlIHJvdyBhbmQgY29sdW1uIGluZGljZXMgb2YgZWFjaCB2YWx1ZSAoemVyby1iYXNlZCkgYXJlIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vLyBJZiBmb3JjZU1hcFplcm8gaXMgbm90IHNldCB0byB0cnVlLCB6ZXJvIHZhbHVlcyBtYXkgb3IgbWF5IG5vdCBiZSBza2lwcGVkIGRlcGVuZGluZ1xyXG4gICAgICAgIC8vLyBvbiB0aGUgYWN0dWFsIGRhdGEgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbiAocmVsZXZhbnQgbW9zdGx5IGZvciBzcGFyc2UgbWF0cmljZXMpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFwSW5kZXhlZElucGxhY2UoRnVuYzxpbnQsIGludCwgVCwgVD4gZiwgWmVyb3MgemVyb3MgPSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTdG9yYWdlLk1hcEluZGV4ZWRJbnBsYWNlKChGdW5jPGludCxpbnQsVCxUPilmLCB6ZXJvcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIG9mIHRoaXMgbWF0cml4IGFuZCByZXBsYWNlcyB0aGUgdmFsdWUgaW4gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIElmIGZvcmNlTWFwWmVybyBpcyBub3Qgc2V0IHRvIHRydWUsIHplcm8gdmFsdWVzIG1heSBvciBtYXkgbm90IGJlIHNraXBwZWQgZGVwZW5kaW5nXHJcbiAgICAgICAgLy8vIG9uIHRoZSBhY3R1YWwgZGF0YSBzdG9yYWdlIGltcGxlbWVudGF0aW9uIChyZWxldmFudCBtb3N0bHkgZm9yIHNwYXJzZSBtYXRyaWNlcykuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXAoRnVuYzxULCBUPiBmLCBNYXRyaXg8VD4gcmVzdWx0LCBaZXJvcyB6ZXJvcyA9IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHModGhpcywgcmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU3RvcmFnZS5NYXBJbnBsYWNlKChGdW5jPFQsVD4pZiwgemVyb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU3RvcmFnZS5NYXBUbzxUPihyZXN1bHQuU3RvcmFnZSwgKEZ1bmM8VCxUPilmLCB6ZXJvcywgemVyb3MgPT0gWmVyb3MuSW5jbHVkZSA/IEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyA6IEV4aXN0aW5nRGF0YS5DbGVhcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgb2YgdGhpcyBtYXRyaXggYW5kIHJlcGxhY2VzIHRoZSB2YWx1ZSBpbiB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gVGhlIGluZGV4IG9mIGVhY2ggdmFsdWUgKHplcm8tYmFzZWQpIGlzIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudCB0byB0aGUgZnVuY3Rpb24uXHJcbiAgICAgICAgLy8vIElmIGZvcmNlTWFwWmVybyBpcyBub3Qgc2V0IHRvIHRydWUsIHplcm8gdmFsdWVzIG1heSBvciBtYXkgbm90IGJlIHNraXBwZWQgZGVwZW5kaW5nXHJcbiAgICAgICAgLy8vIG9uIHRoZSBhY3R1YWwgZGF0YSBzdG9yYWdlIGltcGxlbWVudGF0aW9uIChyZWxldmFudCBtb3N0bHkgZm9yIHNwYXJzZSBtYXRyaWNlcykuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXBJbmRleGVkKEZ1bmM8aW50LCBpbnQsIFQsIFQ+IGYsIE1hdHJpeDxUPiByZXN1bHQsIFplcm9zIHplcm9zID0gWmVyb3MuQWxsb3dTa2lwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCByZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBTdG9yYWdlLk1hcEluZGV4ZWRJbnBsYWNlKChGdW5jPGludCxpbnQsVCxUPilmLCB6ZXJvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBTdG9yYWdlLk1hcEluZGV4ZWRUbzxUPihyZXN1bHQuU3RvcmFnZSwgKEZ1bmM8aW50LGludCxULFQ+KWYsIHplcm9zLCB6ZXJvcyA9PSBaZXJvcy5JbmNsdWRlID8gRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zIDogRXhpc3RpbmdEYXRhLkNsZWFyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBvZiB0aGlzIG1hdHJpeCBhbmQgcmVwbGFjZXMgdGhlIHZhbHVlIGluIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyBJZiBmb3JjZU1hcFplcm8gaXMgbm90IHNldCB0byB0cnVlLCB6ZXJvIHZhbHVlcyBtYXkgb3IgbWF5IG5vdCBiZSBza2lwcGVkIGRlcGVuZGluZ1xyXG4gICAgICAgIC8vLyBvbiB0aGUgYWN0dWFsIGRhdGEgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbiAocmVsZXZhbnQgbW9zdGx5IGZvciBzcGFyc2UgbWF0cmljZXMpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFwQ29udmVydDxUVT4oRnVuYzxULCBUVT4gZiwgTWF0cml4PFRVPiByZXN1bHQsIFplcm9zIHplcm9zID0gWmVyb3MuQWxsb3dTa2lwKVxyXG4gICAgICAgICAgICB3aGVyZSBUVSA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUVT4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU3RvcmFnZS5NYXBUbzxUVT4ocmVzdWx0LlN0b3JhZ2UsIChGdW5jPFQsVFU+KWYsIHplcm9zLCB6ZXJvcyA9PSBaZXJvcy5JbmNsdWRlID8gRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zIDogRXhpc3RpbmdEYXRhLkNsZWFyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgb2YgdGhpcyBtYXRyaXggYW5kIHJlcGxhY2VzIHRoZSB2YWx1ZSBpbiB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gVGhlIGluZGV4IG9mIGVhY2ggdmFsdWUgKHplcm8tYmFzZWQpIGlzIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudCB0byB0aGUgZnVuY3Rpb24uXHJcbiAgICAgICAgLy8vIElmIGZvcmNlTWFwWmVybyBpcyBub3Qgc2V0IHRvIHRydWUsIHplcm8gdmFsdWVzIG1heSBvciBtYXkgbm90IGJlIHNraXBwZWQgZGVwZW5kaW5nXHJcbiAgICAgICAgLy8vIG9uIHRoZSBhY3R1YWwgZGF0YSBzdG9yYWdlIGltcGxlbWVudGF0aW9uIChyZWxldmFudCBtb3N0bHkgZm9yIHNwYXJzZSBtYXRyaWNlcykuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXBJbmRleGVkQ29udmVydDxUVT4oRnVuYzxpbnQsIGludCwgVCwgVFU+IGYsIE1hdHJpeDxUVT4gcmVzdWx0LCBaZXJvcyB6ZXJvcyA9IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICAgICAgd2hlcmUgVFUgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VFU+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuTWFwSW5kZXhlZFRvPFRVPihyZXN1bHQuU3RvcmFnZSwgKEZ1bmM8aW50LGludCxULFRVPilmLCB6ZXJvcywgemVyb3MgPT0gWmVyb3MuSW5jbHVkZSA/IEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyA6IEV4aXN0aW5nRGF0YS5DbGVhcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIG9mIHRoaXMgbWF0cml4IGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIGFzIGEgbmV3IG1hdHJpeC5cclxuICAgICAgICAvLy8gSWYgZm9yY2VNYXBaZXJvIGlzIG5vdCBzZXQgdG8gdHJ1ZSwgemVybyB2YWx1ZXMgbWF5IG9yIG1heSBub3QgYmUgc2tpcHBlZCBkZXBlbmRpbmdcclxuICAgICAgICAvLy8gb24gdGhlIGFjdHVhbCBkYXRhIHN0b3JhZ2UgaW1wbGVtZW50YXRpb24gKHJlbGV2YW50IG1vc3RseSBmb3Igc3BhcnNlIG1hdHJpY2VzKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VFU+IE1hcDxUVT4oRnVuYzxULCBUVT4gZiwgWmVyb3MgemVyb3MgPSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFRVPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VFU+Lk1hdHJpeDtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcywgUm93Q291bnQsIENvbHVtbkNvdW50LCBmdWxseU11dGFibGU6IHplcm9zID09IFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgICAgICBTdG9yYWdlLk1hcFRvVW5jaGVja2VkPFRVPihyZXN1bHQuU3RvcmFnZSwgKEZ1bmM8VCxUVT4pZiwgemVyb3MsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIG9mIHRoaXMgbWF0cml4IGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIGFzIGEgbmV3IG1hdHJpeC5cclxuICAgICAgICAvLy8gVGhlIGluZGV4IG9mIGVhY2ggdmFsdWUgKHplcm8tYmFzZWQpIGlzIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudCB0byB0aGUgZnVuY3Rpb24uXHJcbiAgICAgICAgLy8vIElmIGZvcmNlTWFwWmVybyBpcyBub3Qgc2V0IHRvIHRydWUsIHplcm8gdmFsdWVzIG1heSBvciBtYXkgbm90IGJlIHNraXBwZWQgZGVwZW5kaW5nXHJcbiAgICAgICAgLy8vIG9uIHRoZSBhY3R1YWwgZGF0YSBzdG9yYWdlIGltcGxlbWVudGF0aW9uIChyZWxldmFudCBtb3N0bHkgZm9yIHNwYXJzZSBtYXRyaWNlcykuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFRVPiBNYXBJbmRleGVkPFRVPihGdW5jPGludCwgaW50LCBULCBUVT4gZiwgWmVyb3MgemVyb3MgPSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXhCdWlsZGVyPFRVPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VFU+Lk1hdHJpeDtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4odGhpcywgUm93Q291bnQsIENvbHVtbkNvdW50LCBmdWxseU11dGFibGU6IHplcm9zID09IFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgICAgICBTdG9yYWdlLk1hcEluZGV4ZWRUb1VuY2hlY2tlZDxUVT4ocmVzdWx0LlN0b3JhZ2UsIChGdW5jPGludCxpbnQsVCxUVT4pZiwgemVyb3MsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZvciBlYWNoIHJvdywgYXBwbGllcyBhIGZ1bmN0aW9uIGYgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSByb3csIHRocmVhZGluZyBhbiBhY2N1bXVsYXRvciBhcmd1bWVudCB0aHJvdWdoIHRoZSBjb21wdXRhdGlvbi5cclxuICAgICAgICAvLy8gUmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSByZXN1bHRpbmcgYWNjdW11bGF0b3Igc3RhdGVzIGZvciBlYWNoIHJvdy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBUVVtdIEZvbGRCeVJvdzxUVT4oRnVuYzxUVSwgVCwgVFU+IGYsIFRVIHN0YXRlLCBaZXJvcyB6ZXJvcyA9IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgVFVbUm93Q291bnRdO1xyXG4gICAgICAgICAgICBpZiAoIUVxdWFsaXR5Q29tcGFyZXI8VFU+LkRlZmF1bHQuRXF1YWxzKHN0YXRlLCBkZWZhdWx0KFRVKSkpXHJcbiAgICAgICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHJlc3VsdC5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBzdGF0ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgU3RvcmFnZS5Gb2xkQnlSb3dVbmNoZWNrZWQ8VFU+KHJlc3VsdCwgKEZ1bmM8VFUsVCxUVT4pZiwgKEZ1bmM8VFUsaW50LFRVPikoKHgsIGMpID0+IHgpLCByZXN1bHQsIHplcm9zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRm9yIGVhY2ggY29sdW1uLCBhcHBsaWVzIGEgZnVuY3Rpb24gZiB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIGNvbHVtbiwgdGhyZWFkaW5nIGFuIGFjY3VtdWxhdG9yIGFyZ3VtZW50IHRocm91Z2ggdGhlIGNvbXB1dGF0aW9uLlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIHJlc3VsdGluZyBhY2N1bXVsYXRvciBzdGF0ZXMgZm9yIGVhY2ggY29sdW1uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFRVW10gRm9sZEJ5Q29sdW1uPFRVPihGdW5jPFRVLCBULCBUVT4gZiwgVFUgc3RhdGUsIFplcm9zIHplcm9zID0gWmVyb3MuQWxsb3dTa2lwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBUVVtDb2x1bW5Db3VudF07XHJcbiAgICAgICAgICAgIGlmICghRXF1YWxpdHlDb21wYXJlcjxUVT4uRGVmYXVsdC5FcXVhbHMoc3RhdGUsIGRlZmF1bHQoVFUpKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCByZXN1bHQuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBzdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBTdG9yYWdlLkZvbGRCeUNvbHVtblVuY2hlY2tlZDxUVT4ocmVzdWx0LCAoRnVuYzxUVSxULFRVPilmLCAoRnVuYzxUVSxpbnQsVFU+KSgoeCwgYykgPT4geCksIHJlc3VsdCwgemVyb3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBsaWVzIGEgZnVuY3Rpb24gZiB0byBlYWNoIHJvdyB2ZWN0b3IsIHRocmVhZGluZyBhbiBhY2N1bXVsYXRvciB2ZWN0b3IgYXJndW1lbnQgdGhyb3VnaCB0aGUgY29tcHV0YXRpb24uXHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIHJlc3VsdGluZyBhY2N1bXVsYXRvciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFRVPiBGb2xkUm93czxUVT4oRnVuYzxWZWN0b3I8VFU+LCBWZWN0b3I8VD4sIFZlY3RvcjxUVT4+IGYsIFZlY3RvcjxUVT4gc3RhdGUpXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3JlYWNoICh2YXIgdmVjdG9yIGluIEVudW1lcmF0ZVJvd3MoKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBmKHN0YXRlLCB2ZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbGllcyBhIGZ1bmN0aW9uIGYgdG8gZWFjaCBjb2x1bW4gdmVjdG9yLCB0aHJlYWRpbmcgYW4gYWNjdW11bGF0b3IgdmVjdG9yIGFyZ3VtZW50IHRocm91Z2ggdGhlIGNvbXB1dGF0aW9uLlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSByZXN1bHRpbmcgYWNjdW11bGF0b3IgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUVT4gRm9sZENvbHVtbnM8VFU+KEZ1bmM8VmVjdG9yPFRVPiwgVmVjdG9yPFQ+LCBWZWN0b3I8VFU+PiBmLCBWZWN0b3I8VFU+IHN0YXRlKVxyXG4gICAgICAgICAgICB3aGVyZSBUVSA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUVT4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yZWFjaCAodmFyIHZlY3RvciBpbiBFbnVtZXJhdGVDb2x1bW5zKCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgdmVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlZHVjZXMgYWxsIHJvdyB2ZWN0b3JzIGJ5IGFwcGx5aW5nIGEgZnVuY3Rpb24gYmV0d2VlbiB0d28gb2YgdGhlbSwgdW50aWwgb25seSBhIHNpbmdsZSB2ZWN0b3IgaXMgbGVmdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gUmVkdWNlUm93cyhGdW5jPFZlY3RvcjxUPiwgVmVjdG9yPFQ+LCBWZWN0b3I8VD4+IGYpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5BZ2dyZWdhdGU8VmVjdG9yPFQ+PihFbnVtZXJhdGVSb3dzKCksKEZ1bmM8VmVjdG9yPFQ+LFZlY3RvcjxUPixWZWN0b3I8VD4+KWYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZWR1Y2VzIGFsbCBjb2x1bW4gdmVjdG9ycyBieSBhcHBseWluZyBhIGZ1bmN0aW9uIGJldHdlZW4gdHdvIG9mIHRoZW0sIHVudGlsIG9ubHkgYSBzaW5nbGUgdmVjdG9yIGlzIGxlZnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFJlZHVjZUNvbHVtbnMoRnVuYzxWZWN0b3I8VD4sIFZlY3RvcjxUPiwgVmVjdG9yPFQ+PiBmKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN5c3RlbS5MaW5xLkVudW1lcmFibGUuQWdncmVnYXRlPFZlY3RvcjxUPj4oRW51bWVyYXRlQ29sdW1ucygpLChGdW5jPFZlY3RvcjxUPixWZWN0b3I8VD4sVmVjdG9yPFQ+PilmKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgcGFpciBvZiB0d28gbWF0cmljZXMgYW5kIHJlcGxhY2VzIHRoZSB2YWx1ZSBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1hcDIoRnVuYzxULCBULCBUPiBmLCBNYXRyaXg8VD4gb3RoZXIsIE1hdHJpeDxUPiByZXN1bHQsIFplcm9zIHplcm9zID0gWmVyb3MuQWxsb3dTa2lwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU3RvcmFnZS5NYXAyVG8ocmVzdWx0LlN0b3JhZ2UsIG90aGVyLlN0b3JhZ2UsIChGdW5jPFQsVCxUPilmLCB6ZXJvcywgRXhpc3RpbmdEYXRhLkNsZWFyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgcGFpciBvZiB0d28gbWF0cmljZXMgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMgYXMgYSBuZXcgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBNYXAyKEZ1bmM8VCwgVCwgVD4gZiwgTWF0cml4PFQ+IG90aGVyLCBaZXJvcyB6ZXJvcyA9IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBTdG9yYWdlLk1hcDJUbyhyZXN1bHQuU3RvcmFnZSwgb3RoZXIuU3RvcmFnZSwgKEZ1bmM8VCxULFQ+KWYsIHplcm9zLCBFeGlzdGluZ0RhdGEuQXNzdW1lWmVyb3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gdXBkYXRlIHRoZSBzdGF0dXMgd2l0aCBlYWNoIHZhbHVlIHBhaXIgb2YgdHdvIG1hdHJpY2VzIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgc3RhdHVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFRTdGF0ZSBGb2xkMjxUT3RoZXIsIFRTdGF0ZT4oRnVuYzxUU3RhdGUsIFQsIFRPdGhlciwgVFN0YXRlPiBmLCBUU3RhdGUgc3RhdGUsIE1hdHJpeDxUT3RoZXI+IG90aGVyLCBaZXJvcyB6ZXJvcyA9IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICAgICAgd2hlcmUgVE90aGVyIDogc3RydWN0LCBJRXF1YXRhYmxlPFRPdGhlcj4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuRm9sZDI8VE90aGVyLFRTdGF0ZT4ob3RoZXIuU3RvcmFnZSwgKEZ1bmM8VFN0YXRlLFQsVE90aGVyLFRTdGF0ZT4pZiwgc3RhdGUsIHplcm9zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIHR1cGxlIHdpdGggdGhlIGluZGV4IGFuZCB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBzYXRpc2Z5aW5nIGEgcHJlZGljYXRlLCBvciBudWxsIGlmIG5vbmUgaXMgZm91bmQuXHJcbiAgICAgICAgLy8vIFplcm8gZWxlbWVudHMgbWF5IGJlIHNraXBwZWQgb24gc3BhcnNlIGRhdGEgc3RydWN0dXJlcyBpZiBhbGxvd2VkIChkZWZhdWx0KS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBUdXBsZTxpbnQsIGludCwgVD4gRmluZChGdW5jPFQsIGJvb2w+IHByZWRpY2F0ZSwgWmVyb3MgemVyb3MgPSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5GaW5kKChGdW5jPFQsYm9vbD4pcHJlZGljYXRlLCB6ZXJvcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYSB0dXBsZSB3aXRoIHRoZSBpbmRleCBhbmQgdmFsdWVzIG9mIHRoZSBmaXJzdCBlbGVtZW50IHBhaXIgb2YgdHdvIG1hdHJpY2VzIG9mIHRoZSBzYW1lIHNpemUgc2F0aXNmeWluZyBhIHByZWRpY2F0ZSwgb3IgbnVsbCBpZiBub25lIGlzIGZvdW5kLlxyXG4gICAgICAgIC8vLyBaZXJvIGVsZW1lbnRzIG1heSBiZSBza2lwcGVkIG9uIHNwYXJzZSBkYXRhIHN0cnVjdHVyZXMgaWYgYWxsb3dlZCAoZGVmYXVsdCkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVHVwbGU8aW50LCBpbnQsIFQsIFRPdGhlcj4gRmluZDI8VE90aGVyPihGdW5jPFQsIFRPdGhlciwgYm9vbD4gcHJlZGljYXRlLCBNYXRyaXg8VE90aGVyPiBvdGhlciwgWmVyb3MgemVyb3MgPSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAgICAgIHdoZXJlIFRPdGhlciA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUT3RoZXI+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdG9yYWdlLkZpbmQyPFRPdGhlcj4ob3RoZXIuU3RvcmFnZSwgKEZ1bmM8VCxUT3RoZXIsYm9vbD4pcHJlZGljYXRlLCB6ZXJvcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBzYXRpc2ZpZXMgYSBwcmVkaWNhdGUuXHJcbiAgICAgICAgLy8vIFplcm8gZWxlbWVudHMgbWF5IGJlIHNraXBwZWQgb24gc3BhcnNlIGRhdGEgc3RydWN0dXJlcyBpZiBhbGxvd2VkIChkZWZhdWx0KS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBib29sIEV4aXN0cyhGdW5jPFQsIGJvb2w+IHByZWRpY2F0ZSwgWmVyb3MgemVyb3MgPSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5GaW5kKChGdW5jPFQsYm9vbD4pcHJlZGljYXRlLCB6ZXJvcykgIT0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0cnVlIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IHBhaXJzIG9mIHR3byBtYXRyaWNlcyBvZiB0aGUgc2FtZSBzaXplIHNhdGlzZmllcyBhIHByZWRpY2F0ZS5cclxuICAgICAgICAvLy8gWmVybyBlbGVtZW50cyBtYXkgYmUgc2tpcHBlZCBvbiBzcGFyc2UgZGF0YSBzdHJ1Y3R1cmVzIGlmIGFsbG93ZWQgKGRlZmF1bHQpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgRXhpc3RzMjxUT3RoZXI+KEZ1bmM8VCwgVE90aGVyLCBib29sPiBwcmVkaWNhdGUsIE1hdHJpeDxUT3RoZXI+IG90aGVyLCBaZXJvcyB6ZXJvcyA9IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICAgICAgd2hlcmUgVE90aGVyIDogc3RydWN0LCBJRXF1YXRhYmxlPFRPdGhlcj4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuRmluZDI8VE90aGVyPihvdGhlci5TdG9yYWdlLCAoRnVuYzxULFRPdGhlcixib29sPilwcmVkaWNhdGUsIHplcm9zKSAhPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRydWUgaWYgYWxsIGVsZW1lbnRzIHNhdGlzZnkgYSBwcmVkaWNhdGUuXHJcbiAgICAgICAgLy8vIFplcm8gZWxlbWVudHMgbWF5IGJlIHNraXBwZWQgb24gc3BhcnNlIGRhdGEgc3RydWN0dXJlcyBpZiBhbGxvd2VkIChkZWZhdWx0KS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBib29sIEZvckFsbChGdW5jPFQsIGJvb2w+IHByZWRpY2F0ZSwgWmVyb3MgemVyb3MgPSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5GaW5kKChGdW5jPFQsYm9vbD4pKHggPT4gIXByZWRpY2F0ZSh4KSksIHplcm9zKSA9PSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRydWUgaWYgYWxsIGVsZW1lbnQgcGFpcnMgb2YgdHdvIG1hdHJpY2VzIG9mIHRoZSBzYW1lIHNpemUgc2F0aXNmeSBhIHByZWRpY2F0ZS5cclxuICAgICAgICAvLy8gWmVybyBlbGVtZW50cyBtYXkgYmUgc2tpcHBlZCBvbiBzcGFyc2UgZGF0YSBzdHJ1Y3R1cmVzIGlmIGFsbG93ZWQgKGRlZmF1bHQpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgRm9yQWxsMjxUT3RoZXI+KEZ1bmM8VCwgVE90aGVyLCBib29sPiBwcmVkaWNhdGUsIE1hdHJpeDxUT3RoZXI+IG90aGVyLCBaZXJvcyB6ZXJvcyA9IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICAgICAgd2hlcmUgVE90aGVyIDogc3RydWN0LCBJRXF1YXRhYmxlPFRPdGhlcj4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuRmluZDI8VE90aGVyPihvdGhlci5TdG9yYWdlLCAoRnVuYzxULFRPdGhlcixib29sPikoKHgsIHkpID0+ICFwcmVkaWNhdGUoeCwgeSkpLCB6ZXJvcykgPT0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcbiIsIi8vIDxjb3B5cmlnaHQgZmlsZT1cIlZlY3Rvci5Bcml0aG1ldGljLmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTYgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGUuTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhO1xyXG51c2luZyBTeXN0ZW07XHJcblxyXG5cclxubmFtZXNwYWNlIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYVxyXG57XHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgcGFydGlhbCBjbGFzcyBWZWN0b3I8VD5cclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSB6ZXJvIHZhbHVlIGZvciB0eXBlIFQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFQgWmVybyA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3IuWmVybztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgdmFsdWUgb2YgMS4wIGZvciB0eXBlIFQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFQgT25lID0gQnVpbGRlckluc3RhbmNlPFQ+LlZlY3Rvci5PbmU7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTmVnYXRlcyB2ZWN0b3IgYW5kIHNhdmUgcmVzdWx0IHRvIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGFyZ2V0IHZlY3RvcjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9OZWdhdGUoVmVjdG9yPFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcGxleCBjb25qdWdhdGVzIHZlY3RvciBhbmQgc2F2ZSByZXN1bHQgdG8gPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UYXJnZXQgdmVjdG9yPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb0Nvbmp1Z2F0ZShWZWN0b3I8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGRzIGEgc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdG8gYWRkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvQWRkKFQgc2NhbGFyLCBWZWN0b3I8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGRzIGFub3RoZXIgdmVjdG9yIHRvIHRoaXMgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgdmVjdG9yIHRvIGFkZCB0byB0aGlzIG9uZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb0FkZChWZWN0b3I8VD4gb3RoZXIsIFZlY3RvcjxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN1YnRyYWN0cyBhIHNjYWxhciBmcm9tIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdG8gc3VidHJhY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9TdWJ0cmFjdChUIHNjYWxhciwgVmVjdG9yPFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3VidHJhY3RzIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGZyb20gYSBzY2FsYXIgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBzdWJ0cmFjdCBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCB2b2lkIERvU3VidHJhY3RGcm9tKFQgc2NhbGFyLCBWZWN0b3I8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRG9OZWdhdGUocmVzdWx0KTtcclxuICAgICAgICAgICAgcmVzdWx0LkRvQWRkKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3VidHJhY3RzIGFub3RoZXIgdmVjdG9yIHRvIHRoaXMgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgdmVjdG9yIHRvIHN1YnRyYWN0IGZyb20gdGhpcyBvbmUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9TdWJ0cmFjdChWZWN0b3I8VD4gb3RoZXIsIFZlY3RvcjxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgYSBzY2FsYXIgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBtdWx0aXBseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb011bHRpcGx5KFQgc2NhbGFyLCBWZWN0b3I8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBvdGhlciB2ZWN0b3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHN1bSBvZiBhW2ldKmJbaV0gZm9yIGFsbCBpLjwvcmV0dXJucz5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgVCBEb0RvdFByb2R1Y3QoVmVjdG9yPFQ+IG90aGVyKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0aGUgY29uanVnYXRlIG9mIHRoaXMgdmVjdG9yIGFuZCBhbm90aGVyIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG90aGVyIHZlY3Rvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgc3VtIG9mIGNvbmooYVtpXSkqYltpXSBmb3IgYWxsIGkuPC9yZXR1cm5zPlxyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCBUIERvQ29uanVnYXRlRG90UHJvZHVjdChWZWN0b3I8VD4gb3RoZXIpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBvdXRlciBwcm9kdWN0IE1baSxqXSA9IHVbaV0qdltqXSBvZiB0aGlzIGFuZCBhbm90aGVyIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBvdGhlciB2ZWN0b3I8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgcHJvZHVjdC48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCB2b2lkIERvT3V0ZXJQcm9kdWN0KFZlY3RvcjxUPiBvdGhlciwgTWF0cml4PFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB3b3JrID0gdl9idWlsZGVyLkRlbnNlKENvdW50KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlci5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEb011bHRpcGx5KG90aGVyLkF0KGkpLCB3b3JrKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5TZXRDb2x1bW4oaSwgd29yayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGl2aWRlcyBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBieSBhIHNjYWxhciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHNjYWxhciBkZW5vbWluYXRvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGRpdmlzaW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9EaXZpZGUoVCBkaXZpc29yLCBWZWN0b3I8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEaXZpZGVzIGEgc2NhbGFyIGJ5IGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHNjYWxhciBudW1lcmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvRGl2aWRlQnlUaGlzKFQgZGl2aWRlbmQsIFZlY3RvcjxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBjYW5vbmljYWwgbW9kdWx1cywgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlzb3IsXHJcbiAgICAgICAgLy8vIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBmb3IgdGhlIGdpdmVuIGRpdmlzb3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHNjYWxhciBkZW5vbWluYXRvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5BIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvTW9kdWx1cyhUIGRpdmlzb3IsIFZlY3RvcjxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBjYW5vbmljYWwgbW9kdWx1cywgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlzb3IsXHJcbiAgICAgICAgLy8vIGZvciB0aGUgZ2l2ZW4gZGl2aWRlbmQgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aWRlbmRcIj5UaGUgc2NhbGFyIG51bWVyYXRvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5BIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvTW9kdWx1c0J5VGhpcyhUIGRpdmlkZW5kLCBWZWN0b3I8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgcmVtYWluZGVyICglIG9wZXJhdG9yKSwgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlkZW5kLFxyXG4gICAgICAgIC8vLyBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSB2ZWN0b3IgZm9yIHRoZSBnaXZlbiBkaXZpc29yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBzY2FsYXIgZGVub21pbmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+QSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1JlbWFpbmRlcihUIGRpdmlzb3IsIFZlY3RvcjxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSByZW1haW5kZXIgKCUgb3BlcmF0b3IpLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aWRlbmQsXHJcbiAgICAgICAgLy8vIGZvciB0aGUgZ2l2ZW4gZGl2aWRlbmQgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aWRlbmRcIj5UaGUgc2NhbGFyIG51bWVyYXRvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5BIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUmVtYWluZGVyQnlUaGlzKFQgZGl2aWRlbmQsIFZlY3RvcjxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBtdWx0aXBsaWVzIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSB2ZWN0b3IgdG8gcG9pbnR3aXNlIG11bHRpcGx5IHdpdGggdGhpcyBvbmUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50d2lzZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlTXVsdGlwbHkoVmVjdG9yPFQ+IG90aGVyLCBWZWN0b3I8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgZGl2aWRlIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHBvaW50d2lzZSBkZW5vbWluYXRvciB2ZWN0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgZGl2aXNpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZURpdmlkZShWZWN0b3I8VD4gZGl2aXNvciwgVmVjdG9yPFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIHJhaXNlIHRoaXMgdmVjdG9yIHRvIGFuIGV4cG9uZW50IGFuZCBzdG9yZSB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJleHBvbmVudFwiPlRoZSBleHBvbmVudCB0byByYWlzZSB0aGlzIHZlY3RvciB2YWx1ZXMgdG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50d2lzZSBwb3dlci48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlUG93ZXIoVCBleHBvbmVudCwgVmVjdG9yPFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIHJhaXNlIHRoaXMgdmVjdG9yIHRvIGFuIGV4cG9uZW50IHZlY3RvciBhbmQgc3RvcmUgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXhwb25lbnRcIj5UaGUgZXhwb25lbnQgdmVjdG9yIHRvIHJhaXNlIHRoaXMgdmVjdG9yIHZhbHVlcyB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgcG9pbnR3aXNlIHBvd2VyLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VQb3dlcihWZWN0b3I8VD4gZXhwb25lbnQsIFZlY3RvcjxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBjYW5vbmljYWwgbW9kdWx1cywgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlzb3IsXHJcbiAgICAgICAgLy8vIG9mIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHBvaW50d2lzZSBkZW5vbWluYXRvciB2ZWN0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbW9kdWx1cy48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlTW9kdWx1cyhWZWN0b3I8VD4gZGl2aXNvciwgVmVjdG9yPFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gb2YgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgcG9pbnR3aXNlIGRlbm9taW5hdG9yIHZlY3RvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtb2R1bHVzLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VSZW1haW5kZXIoVmVjdG9yPFQ+IGRpdmlzb3IsIFZlY3RvcjxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBleHBvbmVudGlhbCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0LjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VFeHAoVmVjdG9yPFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQuPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZUxvZyhWZWN0b3I8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VBYnMoVmVjdG9yPFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VBY29zKFZlY3RvcjxUPiByZXN1bHQpO1xyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlQXNpbihWZWN0b3I8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZUF0YW4oVmVjdG9yPFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VDZWlsaW5nKFZlY3RvcjxUPiByZXN1bHQpO1xyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlQ29zKFZlY3RvcjxUPiByZXN1bHQpO1xyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlQ29zaChWZWN0b3I8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZUZsb29yKFZlY3RvcjxUPiByZXN1bHQpO1xyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlTG9nMTAoVmVjdG9yPFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VSb3VuZChWZWN0b3I8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZVNpZ24oVmVjdG9yPFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VTaW4oVmVjdG9yPFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VTaW5oKFZlY3RvcjxUPiByZXN1bHQpO1xyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlU3FydChWZWN0b3I8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZVRhbihWZWN0b3I8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZVRhbmgoVmVjdG9yPFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VBdGFuMihWZWN0b3I8VD4gb3RoZXIsIFZlY3RvcjxUPiByZXN1bHQpO1xyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlQXRhbjIoVCBzY2FsYXIsIFZlY3RvcjxUPiByZXN1bHQpO1xyXG4gICAgICAgIHByb3RlY3RlZCBhYnN0cmFjdCB2b2lkIERvUG9pbnR3aXNlTWluaW11bShUIHNjYWxhciwgVmVjdG9yPFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VNaW5pbXVtKFZlY3RvcjxUPiBvdGhlciwgVmVjdG9yPFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VNYXhpbXVtKFQgc2NhbGFyLCBWZWN0b3I8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZU1heGltdW0oVmVjdG9yPFQ+IG90aGVyLCBWZWN0b3I8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZUFic29sdXRlTWluaW11bShUIHNjYWxhciwgVmVjdG9yPFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VBYnNvbHV0ZU1pbmltdW0oVmVjdG9yPFQ+IG90aGVyLCBWZWN0b3I8VD4gcmVzdWx0KTtcclxuICAgICAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgdm9pZCBEb1BvaW50d2lzZUFic29sdXRlTWF4aW11bShUIHNjYWxhciwgVmVjdG9yPFQ+IHJlc3VsdCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIGFic3RyYWN0IHZvaWQgRG9Qb2ludHdpc2VBYnNvbHV0ZU1heGltdW0oVmVjdG9yPFQ+IG90aGVyLCBWZWN0b3I8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGRzIGEgc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBhZGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBjb3B5IG9mIHRoZSB2ZWN0b3Igd2l0aCB0aGUgc2NhbGFyIGFkZGVkLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IEFkZChUIHNjYWxhcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzY2FsYXIuRXF1YWxzKFplcm8pKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZfYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvQWRkKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkcyBhIHNjYWxhciB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIGFkZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGQoVCBzY2FsYXIsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNjYWxhci5FcXVhbHMoWmVybykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvcHlUbyhyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb0FkZChzY2FsYXIsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgYW5vdGhlciB2ZWN0b3IgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSB2ZWN0b3IgdG8gYWRkIHRvIHRoaXMgb25lLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgbmV3IHZlY3RvciBjb250YWluaW5nIHRoZSBzdW0gb2YgYm90aCB2ZWN0b3JzLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJvdGhlclwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gQWRkKFZlY3RvcjxUPiBvdGhlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSBvdGhlci5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJvdGhlclwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZfYnVpbGRlci5TYW1lQXModGhpcywgb3RoZXIpO1xyXG4gICAgICAgICAgICBEb0FkZChvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkcyBhbm90aGVyIHZlY3RvciB0byB0aGlzIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIHZlY3RvciB0byBhZGQgdG8gdGhpcyBvbmUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwib3RoZXJcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGQoVmVjdG9yPFQ+IG90aGVyLCBWZWN0b3I8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvdW50ICE9IHJlc3VsdC5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvQWRkKG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgYSBzY2FsYXIgZnJvbSBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdG8gc3VidHJhY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBuZXcgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIHN1YnRyYWN0aW9uIG9mIHRoaXMgdmVjdG9yIGFuZCB0aGUgc2NhbGFyLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFN1YnRyYWN0KFQgc2NhbGFyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHNjYWxhci5FcXVhbHMoWmVybykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9TdWJ0cmFjdChzY2FsYXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN1YnRyYWN0cyBhIHNjYWxhciBmcm9tIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdG8gc3VidHJhY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU3VidHJhY3QoVCBzY2FsYXIsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNjYWxhci5FcXVhbHMoWmVybykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvcHlUbyhyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1N1YnRyYWN0KHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3VidHJhY3RzIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGZyb20gYSBzY2FsYXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIHN1YnRyYWN0IGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBuZXcgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIHN1YnRyYWN0aW9uIG9mIHRoZSBzY2FsYXIgYW5kIHRoaXMgdmVjdG9yLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFN1YnRyYWN0RnJvbShUIHNjYWxhcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBEb1N1YnRyYWN0RnJvbShzY2FsYXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN1YnRyYWN0cyBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBmcm9tIGEgc2NhbGFyIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdG8gc3VidHJhY3QgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTdWJ0cmFjdEZyb20oVCBzY2FsYXIsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9TdWJ0cmFjdEZyb20oc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIG5lZ2F0ZWQgdmVjdG9yLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPHJlbWFya3M+QWRkZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIHVuYXJ5IG5lZ2F0aW9uIG9wZXJhdG9yLjwvcmVtYXJrcz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IE5lZ2F0ZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0cnVuVmVjdG9yID0gdl9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9OZWdhdGUocmV0cnVuVmVjdG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldHJ1blZlY3RvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTmVnYXRlcyB2ZWN0b3IgYW5kIHNhdmUgcmVzdWx0IHRvIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGFyZ2V0IHZlY3RvcjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgTmVnYXRlKFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9OZWdhdGUocmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3VidHJhY3RzIGFub3RoZXIgdmVjdG9yIGZyb20gdGhpcyB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSB2ZWN0b3IgdG8gc3VidHJhY3QgZnJvbSB0aGlzIG9uZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIG5ldyB2ZWN0b3IgY29udGFpbmluZyB0aGUgc3VidHJhY3Rpb24gb2YgdGhlIHR3byB2ZWN0b3JzLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJvdGhlclwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gU3VidHJhY3QoVmVjdG9yPFQ+IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvdW50ICE9IG90aGVyLkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcIm90aGVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBcyh0aGlzLCBvdGhlcik7XHJcbiAgICAgICAgICAgIERvU3VidHJhY3Qob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN1YnRyYWN0cyBhbm90aGVyIHZlY3RvciB0byB0aGlzIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIHZlY3RvciB0byBzdWJ0cmFjdCBmcm9tIHRoaXMgb25lLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgdmVjdG9yIGFuZCA8cGFyYW1yZWYgbmFtZT1cIm90aGVyXCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU3VidHJhY3QoVmVjdG9yPFQ+IG90aGVyLCBWZWN0b3I8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvdW50ICE9IHJlc3VsdC5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvU3VidHJhY3Qob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybiB2ZWN0b3Igd2l0aCBjb21wbGV4IGNvbmp1Z2F0ZSB2YWx1ZXMgb2YgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5Db25qdWdhdGVkIHZlY3RvcjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IENvbmp1Z2F0ZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0cnVuVmVjdG9yID0gdl9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9Db25qdWdhdGUocmV0cnVuVmVjdG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldHJ1blZlY3RvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcGxleCBjb25qdWdhdGVzIHZlY3RvciBhbmQgc2F2ZSByZXN1bHQgdG8gPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UYXJnZXQgdmVjdG9yPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDb25qdWdhdGUoVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSByZXN1bHQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb0Nvbmp1Z2F0ZShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIGEgc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBtdWx0aXBseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIG5ldyB2ZWN0b3IgdGhhdCBpcyB0aGUgbXVsdGlwbGljYXRpb24gb2YgdGhlIHZlY3RvciBhbmQgdGhlIHNjYWxhci48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBNdWx0aXBseShUIHNjYWxhcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzY2FsYXIuRXF1YWxzKE9uZSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2NhbGFyLkVxdWFscyhaZXJvKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZfYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBEb011bHRpcGx5KHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyBhIHNjYWxhciB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIG11bHRpcGx5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgdmVjdG9yIGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE11bHRpcGx5KFQgc2NhbGFyLCBWZWN0b3I8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvdW50ICE9IHJlc3VsdC5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzY2FsYXIuRXF1YWxzKE9uZSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvcHlUbyhyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2NhbGFyLkVxdWFscyhaZXJvKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvTXVsdGlwbHkoc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBvdGhlciB2ZWN0b3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHN1bSBvZiBhW2ldKmJbaV0gZm9yIGFsbCBpLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cIm90aGVyXCIvPiBpcyBub3Qgb2YgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPHNlZWFsc28gY3JlZj1cIkNvbmp1Z2F0ZURvdFByb2R1Y3RcIi8+XHJcbiAgICAgICAgcHVibGljIFQgRG90UHJvZHVjdChWZWN0b3I8VD4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gb3RoZXIuQ291bnQpIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwib3RoZXJcIik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gRG9Eb3RQcm9kdWN0KG90aGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdGhlIGNvbmp1Z2F0ZSBvZiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBvdGhlciB2ZWN0b3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHN1bSBvZiBjb25qKGFbaV0pKmJbaV0gZm9yIGFsbCBpLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cIm90aGVyXCIvPiBpcyBub3Qgb2YgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJvdGhlclwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIi8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8c2VlYWxzbyBjcmVmPVwiRG90UHJvZHVjdFwiLz5cclxuICAgICAgICBwdWJsaWMgVCBDb25qdWdhdGVEb3RQcm9kdWN0KFZlY3RvcjxUPiBvdGhlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSBvdGhlci5Db3VudCkgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJvdGhlclwiKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBEb0Nvbmp1Z2F0ZURvdFByb2R1Y3Qob3RoZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEaXZpZGVzIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGJ5IGEgc2NhbGFyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBkaXZpZGUgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIG5ldyB2ZWN0b3IgdGhhdCBpcyB0aGUgZGl2aXNpb24gb2YgdGhlIHZlY3RvciBhbmQgdGhlIHNjYWxhci48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBEaXZpZGUoVCBzY2FsYXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoc2NhbGFyLkVxdWFscyhPbmUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZfYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvRGl2aWRlKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGl2aWRlcyBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBieSBhIHNjYWxhciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIGRpdmlkZSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgdmVjdG9yIGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIERpdmlkZShUIHNjYWxhciwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSByZXN1bHQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2NhbGFyLkVxdWFscyhPbmUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb3B5VG8ocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9EaXZpZGUoc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEaXZpZGVzIGEgc2NhbGFyIGJ5IGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBkaXZpZGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBuZXcgdmVjdG9yIHRoYXQgaXMgdGhlIGRpdmlzaW9uIG9mIHRoZSB2ZWN0b3IgYW5kIHRoZSBzY2FsYXIuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gRGl2aWRlQnlUaGlzKFQgc2NhbGFyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZfYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvRGl2aWRlQnlUaGlzKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGl2aWRlcyBhIHNjYWxhciBieSBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIGRpdmlkZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgZGl2aXNpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBEaXZpZGVCeVRoaXMoVCBzY2FsYXIsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9EaXZpZGVCeVRoaXMoc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgY2Fub25pY2FsIG1vZHVsdXMsIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpc29yLFxyXG4gICAgICAgIC8vLyBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSB2ZWN0b3IgZm9yIHRoZSBnaXZlbiBkaXZpc29yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBzY2FsYXIgZGVub21pbmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIHJlc3VsdC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBNb2R1bHVzKFQgZGl2aXNvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBEb01vZHVsdXMoZGl2aXNvciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGNhbm9uaWNhbCBtb2R1bHVzLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aXNvcixcclxuICAgICAgICAvLy8gZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGZvciB0aGUgZ2l2ZW4gZGl2aXNvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgc2NhbGFyIGRlbm9taW5hdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPkEgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgTW9kdWx1cyhUIGRpdmlzb3IsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9Nb2R1bHVzKGRpdmlzb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBjYW5vbmljYWwgbW9kdWx1cywgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlzb3IsXHJcbiAgICAgICAgLy8vIGZvciB0aGUgZ2l2ZW4gZGl2aWRlbmQgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aWRlbmRcIj5UaGUgc2NhbGFyIG51bWVyYXRvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSB2ZWN0b3IgY29udGFpbmluZyB0aGUgcmVzdWx0LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IE1vZHVsdXNCeVRoaXMoVCBkaXZpZGVuZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBEb01vZHVsdXNCeVRoaXMoZGl2aWRlbmQsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBjYW5vbmljYWwgbW9kdWx1cywgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlzb3IsXHJcbiAgICAgICAgLy8vIGZvciB0aGUgZ2l2ZW4gZGl2aWRlbmQgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aWRlbmRcIj5UaGUgc2NhbGFyIG51bWVyYXRvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5BIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1vZHVsdXNCeVRoaXMoVCBkaXZpZGVuZCwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSByZXN1bHQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb01vZHVsdXNCeVRoaXMoZGl2aWRlbmQsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSByZW1haW5kZXIgKHZlY3RvciAlIGRpdmlzb3IpLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aWRlbmQsXHJcbiAgICAgICAgLy8vIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBmb3IgdGhlIGdpdmVuIGRpdmlzb3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHNjYWxhciBkZW5vbWluYXRvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSB2ZWN0b3IgY29udGFpbmluZyB0aGUgcmVzdWx0LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFJlbWFpbmRlcihUIGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9SZW1haW5kZXIoZGl2aXNvciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciAodmVjdG9yICUgZGl2aXNvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGZvciB0aGUgZ2l2ZW4gZGl2aXNvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgc2NhbGFyIGRlbm9taW5hdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPkEgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtYWluZGVyKFQgZGl2aXNvciwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSByZXN1bHQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1JlbWFpbmRlcihkaXZpc29yLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgcmVtYWluZGVyIChkaXZpZGVuZCAlIHZlY3RvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gZm9yIHRoZSBnaXZlbiBkaXZpZGVuZCBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpZGVuZFwiPlRoZSBzY2FsYXIgbnVtZXJhdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIHZlY3RvciBjb250YWluaW5nIHRoZSByZXN1bHQuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gUmVtYWluZGVyQnlUaGlzKFQgZGl2aWRlbmQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9SZW1haW5kZXJCeVRoaXMoZGl2aWRlbmQsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSByZW1haW5kZXIgKGRpdmlkZW5kICUgdmVjdG9yKSwgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlkZW5kLFxyXG4gICAgICAgIC8vLyBmb3IgdGhlIGdpdmVuIGRpdmlkZW5kIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHNjYWxhciBudW1lcmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+QSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZW1haW5kZXJCeVRoaXMoVCBkaXZpZGVuZCwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSByZXN1bHQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1JlbWFpbmRlckJ5VGhpcyhkaXZpZGVuZCwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIG11bHRpcGxpZXMgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIHZlY3RvciB0byBwb2ludHdpc2UgbXVsdGlwbHkgd2l0aCB0aGlzIG9uZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIG5ldyB2ZWN0b3Igd2hpY2ggaXMgdGhlIHBvaW50d2lzZSBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgdHdvIHZlY3RvcnMuPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgdmVjdG9yIGFuZCA8cGFyYW1yZWYgbmFtZT1cIm90aGVyXCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VNdWx0aXBseShWZWN0b3I8VD4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gb3RoZXIuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwib3RoZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2X2J1aWxkZXIuU2FtZUFzKHRoaXMsIG90aGVyKTtcclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VNdWx0aXBseShvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIG11bHRpcGxpZXMgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIHZlY3RvciB0byBwb2ludHdpc2UgbXVsdGlwbHkgd2l0aCB0aGlzIG9uZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgcG9pbnR3aXNlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwib3RoZXJcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VNdWx0aXBseShWZWN0b3I8VD4gb3RoZXIsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gb3RoZXIuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwib3RoZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSByZXN1bHQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1BvaW50d2lzZU11bHRpcGx5KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgZGl2aWRlIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHBvaW50d2lzZSBkZW5vbWluYXRvciB2ZWN0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgbmV3IHZlY3RvciB3aGljaCBpcyB0aGUgcG9pbnR3aXNlIGRpdmlzaW9uIG9mIHRoZSB0d28gdmVjdG9ycy48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwiZGl2aXNvclwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gUG9pbnR3aXNlRGl2aWRlKFZlY3RvcjxUPiBkaXZpc29yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvdW50ICE9IGRpdmlzb3IuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwiZGl2aXNvclwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZfYnVpbGRlci5TYW1lQXModGhpcywgZGl2aXNvcik7XHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlRGl2aWRlKGRpdmlzb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBkaXZpZGUgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgcG9pbnR3aXNlIGRlbm9taW5hdG9yIHZlY3RvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50d2lzZSBkaXZpc2lvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgdmVjdG9yIGFuZCA8cGFyYW1yZWYgbmFtZT1cImRpdmlzb3JcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VEaXZpZGUoVmVjdG9yPFQ+IGRpdmlzb3IsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gZGl2aXNvci5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJkaXZpc29yXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VEaXZpZGUoZGl2aXNvciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIHJhaXNlIHRoaXMgdmVjdG9yIHRvIGFuIGV4cG9uZW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXhwb25lbnRcIj5UaGUgZXhwb25lbnQgdG8gcmFpc2UgdGhpcyB2ZWN0b3IgdmFsdWVzIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VQb3dlcihUIGV4cG9uZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZfYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlUG93ZXIoZXhwb25lbnQsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSByYWlzZSB0aGlzIHZlY3RvciB0byBhbiBleHBvbmVudCBhbmQgc3RvcmUgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXhwb25lbnRcIj5UaGUgZXhwb25lbnQgdG8gcmFpc2UgdGhpcyB2ZWN0b3IgdmFsdWVzIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IGludG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VQb3dlcihUIGV4cG9uZW50LCBWZWN0b3I8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvdW50ICE9IHJlc3VsdC5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlUG93ZXIoZXhwb25lbnQsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSByYWlzZSB0aGlzIHZlY3RvciB0byBhbiBleHBvbmVudCBhbmQgc3RvcmUgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXhwb25lbnRcIj5UaGUgZXhwb25lbnQgdG8gcmFpc2UgdGhpcyB2ZWN0b3IgdmFsdWVzIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VQb3dlcihWZWN0b3I8VD4gZXhwb25lbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gZXhwb25lbnQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwiZXhwb25lbnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBEb1BvaW50d2lzZVBvd2VyKGV4cG9uZW50LCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgcmFpc2UgdGhpcyB2ZWN0b3IgdG8gYW4gZXhwb25lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJleHBvbmVudFwiPlRoZSBleHBvbmVudCB0byByYWlzZSB0aGlzIHZlY3RvciB2YWx1ZXMgdG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW50by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgdmVjdG9yIGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZVBvd2VyKFZlY3RvcjxUPiBleHBvbmVudCwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSBleHBvbmVudC5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJleHBvbmVudFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKENvdW50ICE9IHJlc3VsdC5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlUG93ZXIoZXhwb25lbnQsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBjYW5vbmljYWwgbW9kdWx1cywgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlzb3IsXHJcbiAgICAgICAgLy8vIG9mIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHBvaW50d2lzZSBkZW5vbWluYXRvciB2ZWN0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwiZGl2aXNvclwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gUG9pbnR3aXNlTW9kdWx1cyhWZWN0b3I8VD4gZGl2aXNvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSBkaXZpc29yLkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcImRpdmlzb3JcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2X2J1aWxkZXIuU2FtZUFzKHRoaXMsIGRpdmlzb3IpO1xyXG4gICAgICAgICAgICBEb1BvaW50d2lzZU1vZHVsdXMoZGl2aXNvciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGNhbm9uaWNhbCBtb2R1bHVzLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aXNvcixcclxuICAgICAgICAvLy8gb2YgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgcG9pbnR3aXNlIGRlbm9taW5hdG9yIHZlY3RvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50d2lzZSBtb2R1bHVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwiZGl2aXNvclwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgdmVjdG9yIGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZU1vZHVsdXMoVmVjdG9yPFQ+IGRpdmlzb3IsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gZGl2aXNvci5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJkaXZpc29yXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VNb2R1bHVzKGRpdmlzb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gb2YgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgcG9pbnR3aXNlIGRlbm9taW5hdG9yIHZlY3RvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJkaXZpc29yXCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VSZW1haW5kZXIoVmVjdG9yPFQ+IGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gZGl2aXNvci5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJkaXZpc29yXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBcyh0aGlzLCBkaXZpc29yKTtcclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VSZW1haW5kZXIoZGl2aXNvciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgcG9pbnR3aXNlIGRlbm9taW5hdG9yIHZlY3RvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50d2lzZSByZW1haW5kZXIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJkaXZpc29yXCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlUmVtYWluZGVyKFZlY3RvcjxUPiBkaXZpc29yLCBWZWN0b3I8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvdW50ICE9IGRpdmlzb3IuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwiZGl2aXNvclwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKENvdW50ICE9IHJlc3VsdC5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlUmVtYWluZGVyKGRpdmlzb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEhlbHBlciBmdW5jdGlvbiB0byBhcHBseSBhIHVuYXJ5IGZ1bmN0aW9uIHRvIGEgdmVjdG9yLiBUaGUgZnVuY3Rpb25cclxuICAgICAgICAvLy8gZiBtb2RpZmllcyB0aGUgdmVjdG9yIGdpdmVuIHRvIGl0IGluIHBsYWNlLiAgQmVmb3JlIGl0c1xyXG4gICAgICAgIC8vLyBjYWxsZWQsIGEgY29weSBvZiB0aGUgJ3RoaXMnIHZlY3RvciB3aXRoIHRoZSBzYW1lIGRpbWVuc2lvbiBpc1xyXG4gICAgICAgIC8vLyBmaXJzdCBjcmVhdGVkLCB0aGVuIHBhc3NlZCB0byBmLiAgVGhlIGNvcHkgaXMgcmV0dXJuZWQgYXMgdGhlIHJlc3VsdFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZlwiPkZ1bmN0aW9uIHdoaWNoIHRha2VzIGEgdmVjdG9yLCBtb2RpZmllcyBpdCBpbiBwbGFjZSBhbmQgcmV0dXJucyB2b2lkPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+TmV3IGluc3RhbmNlIG9mIHZlY3RvciB3aGljaCBpcyB0aGUgcmVzdWx0PC9yZXR1cm5zPlxyXG4gICAgICAgIHByb3RlY3RlZCBWZWN0b3I8VD4gUG9pbnR3aXNlVW5hcnkoQWN0aW9uPFZlY3RvcjxUPj4gZilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBmKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEhlbHBlciBmdW5jdGlvbiB0byBhcHBseSBhIHVuYXJ5IGZ1bmN0aW9uIHdoaWNoIG1vZGlmaWVzIGEgdmVjdG9yXHJcbiAgICAgICAgLy8vIGluIHBsYWNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZlwiPkZ1bmN0aW9uIHdoaWNoIHRha2VzIGEgdmVjdG9yLCBtb2RpZmllcyBpdCBpbiBwbGFjZSBhbmQgcmV0dXJucyB2b2lkPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHdoZXJlIHRoZSByZXN1bHQgaXMgdG8gYmUgc3RvcmVkPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwcm90ZWN0ZWQgdm9pZCBQb2ludHdpc2VVbmFyeShBY3Rpb248VmVjdG9yPFQ+PiBmLCBWZWN0b3I8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvdW50ICE9IHJlc3VsdC5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGYocmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFwcGx5IGEgYmluYXJ5IGZ1bmN0aW9uIHdoaWNoIHRha2VzIGEgc2NhbGFyIGFuZFxyXG4gICAgICAgIC8vLyBhIHZlY3RvciBhbmQgbW9kaWZpZXMgdGhlIGxhdHRlciBpbiBwbGFjZS4gQSBjb3B5IG9mIHRoZSBcInRoaXNcIlxyXG4gICAgICAgIC8vLyB2ZWN0b3IgaXMgdGhlcmVmb3JlIGZpcnN0IG1hZGUgYW5kIHRoZW4gcGFzc2VkIHRvIGYgdG9nZXRoZXIgd2l0aFxyXG4gICAgICAgIC8vLyB0aGUgc2NhbGFyIGFyZ3VtZW50LiAgVGhlIGNvcHkgaXMgdGhlbiByZXR1cm5lZCBhcyB0aGUgcmVzdWx0XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmXCI+RnVuY3Rpb24gd2hpY2ggdGFrZXMgYSBzY2FsYXIgYW5kIGEgdmVjdG9yLCBtb2RpZmllcyB0aGUgdmVjdG9yIGluIHBsYWNlIGFuZCByZXR1cm5zIHZvaWQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIHNjYWxhciB0byBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdGluZyB2ZWN0b3I8L3JldHVybnM+XHJcbiAgICAgICAgcHJvdGVjdGVkIFZlY3RvcjxUPiBQb2ludHdpc2VCaW5hcnkoQWN0aW9uPFQsIFZlY3RvcjxUPj4gZiwgVCBvdGhlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBmKG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBIZWxwZXIgZnVuY3Rpb24gdG8gYXBwbHkgYSBiaW5hcnkgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYSBzY2FsYXIgYW5kXHJcbiAgICAgICAgLy8vIGEgdmVjdG9yLCBtb2RpZmllcyB0aGUgbGF0dGVyIGluIHBsYWNlIGFuZCByZXR1cm5zIHZvaWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmXCI+RnVuY3Rpb24gd2hpY2ggdGFrZXMgYSBzY2FsYXIgYW5kIGEgdmVjdG9yLCBtb2RpZmllcyB0aGUgdmVjdG9yIGluIHBsYWNlIGFuZCByZXR1cm5zIHZvaWQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgc2NhbGFyIHRvIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb248L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3Igd2hlcmUgdGhlIHJlc3VsdCB3aWxsIGJlIHBsYWNlZDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHJvdGVjdGVkIHZvaWQgUG9pbnR3aXNlQmluYXJ5KEFjdGlvbjxULCBWZWN0b3I8VD4+IGYsIFQgeCwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSByZXN1bHQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGYoeCwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFwcGx5IGEgYmluYXJ5IGZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byB2ZWN0b3JzXHJcbiAgICAgICAgLy8vIGFuZCBtb2RpZmllcyB0aGUgbGF0dGVyIGluIHBsYWNlLiAgQSBjb3B5IG9mIHRoZSBcInRoaXNcIiB2ZWN0b3IgaXNcclxuICAgICAgICAvLy8gZmlyc3QgbWFkZSBhbmQgdGhlbiBwYXNzZWQgdG8gZiB0b2dldGhlciB3aXRoIHRoZSBvdGhlciB2ZWN0b3IuIFRoZVxyXG4gICAgICAgIC8vLyBjb3B5IGlzIHRoZW4gcmV0dXJuZWQgYXMgdGhlIHJlc3VsdFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZlwiPkZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byB2ZWN0b3JzLCBtb2RpZmllcyB0aGUgc2Vjb25kIGluIHBsYWNlIGFuZCByZXR1cm5zIHZvaWQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG90aGVyIHZlY3RvciB0byBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGFzIGFyZ3VtZW50LiBJdCBpcyBub3QgbW9kaWZpZWQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0aW5nIHZlY3RvcjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJvdGhlclwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHByb3RlY3RlZCBWZWN0b3I8VD4gUG9pbnR3aXNlQmluYXJ5KEFjdGlvbjxWZWN0b3I8VD4sIFZlY3RvcjxUPj4gZiwgVmVjdG9yPFQ+IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvdW50ICE9IG90aGVyLkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcIm90aGVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBcyh0aGlzLCBvdGhlcik7XHJcbiAgICAgICAgICAgIGYob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEhlbHBlciBmdW5jdGlvbiB0byBhcHBseSBhIGJpbmFyeSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gdmVjdG9yc1xyXG4gICAgICAgIC8vLyBhbmQgbW9kaWZpZXMgdGhlIHNlY29uZCBvbmUgaW4gcGxhY2VcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZcIj5GdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gdmVjdG9ycywgbW9kaWZpZXMgdGhlIHNlY29uZCBpbiBwbGFjZSBhbmQgcmV0dXJucyB2b2lkPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBvdGhlciB2ZWN0b3IgdG8gYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiBhcyBhcmd1bWVudC4gSXQgaXMgbm90IG1vZGlmaWVkPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0aW5nIHZlY3RvcjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwib3RoZXJcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwcm90ZWN0ZWQgdm9pZCBQb2ludHdpc2VCaW5hcnkoQWN0aW9uPFZlY3RvcjxUPiwgVmVjdG9yPFQ+PiBmLCBWZWN0b3I8VD4gb3RoZXIsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gb3RoZXIuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwib3RoZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSByZXN1bHQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGYob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBleHBvbmVudCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VFeHAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZUV4cCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBleHBvbmVudCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlRXhwKFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4pRG9Qb2ludHdpc2VFeHAsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBmdW5jdGlvbiB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VMb2coKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZUxvZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBmdW5jdGlvbiB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlTG9nKFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4pRG9Qb2ludHdpc2VMb2csIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBhYnMgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VBYnMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZUFicyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBhYnMgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VBYnMoVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZUFicywgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGFjb3MgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VBY29zKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4pRG9Qb2ludHdpc2VBY29zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGFjb3MgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VBY29zKFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4pRG9Qb2ludHdpc2VBY29zLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgYXNpbiBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFBvaW50d2lzZUFzaW4oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZUFzaW4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgYXNpbiBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZUFzaW4oVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZUFzaW4sIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBhdGFuIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gUG9pbnR3aXNlQXRhbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnR3aXNlVW5hcnkoKEFjdGlvbjxWZWN0b3I8VD4+KURvUG9pbnR3aXNlQXRhbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBhdGFuIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdDwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlQXRhbihWZWN0b3I8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnR3aXNlVW5hcnkoKEFjdGlvbjxWZWN0b3I8VD4+KURvUG9pbnR3aXNlQXRhbiwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGF0YW4yIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgb2YgdGhlIGN1cnJlbnRcclxuICAgICAgICAvLy8gdmVjdG9yIGFuZCBhIGdpdmVuIG90aGVyIHZlY3RvciBiZWluZyB0aGUgJ3gnIG9mIGF0YW4yIGFuZCB0aGVcclxuICAgICAgICAvLy8gJ3RoaXMnIHZlY3RvciBiZWluZyB0aGUgJ3knXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VBdGFuMihWZWN0b3I8VD4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnR3aXNlQmluYXJ5KChBY3Rpb248VmVjdG9yPFQ+LFZlY3RvcjxUPj4pRG9Qb2ludHdpc2VBdGFuMiwgb3RoZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgYXRhbjIgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBvZiB0aGUgY3VycmVudFxyXG4gICAgICAgIC8vLyB2ZWN0b3IgYW5kIGEgZ2l2ZW4gb3RoZXIgdmVjdG9yIGJlaW5nIHRoZSAneCcgb2YgYXRhbjIgYW5kIHRoZVxyXG4gICAgICAgIC8vLyAndGhpcycgdmVjdG9yIGJlaW5nIHRoZSAneSdcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZUF0YW4yKFZlY3RvcjxUPiBvdGhlciwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZUJpbmFyeSgoQWN0aW9uPFZlY3RvcjxUPixWZWN0b3I8VD4+KURvUG9pbnR3aXNlQXRhbjIsIG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgY2VpbGluZyBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFBvaW50d2lzZUNlaWxpbmcoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZUNlaWxpbmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgY2VpbGluZyBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZUNlaWxpbmcoVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZUNlaWxpbmcsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBjb3MgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VDb3MoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZUNvcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBjb3MgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VDb3MoVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZUNvcywgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGNvc2ggZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VDb3NoKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4pRG9Qb2ludHdpc2VDb3NoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGNvc2ggZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VDb3NoKFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4pRG9Qb2ludHdpc2VDb3NoLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgZmxvb3IgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VGbG9vcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnR3aXNlVW5hcnkoKEFjdGlvbjxWZWN0b3I8VD4+KURvUG9pbnR3aXNlRmxvb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgZmxvb3IgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VGbG9vcihWZWN0b3I8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnR3aXNlVW5hcnkoKEFjdGlvbjxWZWN0b3I8VD4+KURvUG9pbnR3aXNlRmxvb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBsb2cxMCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFBvaW50d2lzZUxvZzEwKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4pRG9Qb2ludHdpc2VMb2cxMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBsb2cxMCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZUxvZzEwKFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4pRG9Qb2ludHdpc2VMb2cxMCwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIHJvdW5kIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gUG9pbnR3aXNlUm91bmQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZVJvdW5kKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIHJvdW5kIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdDwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlUm91bmQoVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZVJvdW5kLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgc2lnbiBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFBvaW50d2lzZVNpZ24oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZVNpZ24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgc2lnbiBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZVNpZ24oVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZVNpZ24sIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBzaW4gZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VTaW4oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZVNpbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBzaW4gZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VTaW4oVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZVNpbiwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIHNpbmggZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VTaW5oKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4pRG9Qb2ludHdpc2VTaW5oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIHNpbmggZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VTaW5oKFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4pRG9Qb2ludHdpc2VTaW5oLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgc3FydCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFBvaW50d2lzZVNxcnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZVNxcnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgc3FydCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZVNxcnQoVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZVNxcnQsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSB0YW4gZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VUYW4oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZVRhbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSB0YW4gZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VUYW4oVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50d2lzZVVuYXJ5KChBY3Rpb248VmVjdG9yPFQ+PilEb1BvaW50d2lzZVRhbiwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIHRhbmggZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VUYW5oKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4pRG9Qb2ludHdpc2VUYW5oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIHRhbmggZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VUYW5oKFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4pRG9Qb2ludHdpc2VUYW5oLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgb3V0ZXIgcHJvZHVjdCBNW2ksal0gPSB1W2ldKnZbal0gb2YgdGhpcyBhbmQgYW5vdGhlciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBvdGhlciB2ZWN0b3I8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gT3V0ZXJQcm9kdWN0KFZlY3RvcjxUPiBvdGhlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBtYXRyaXggPSBtX2J1aWxkZXIuU2FtZUFzKHRoaXMsIENvdW50LCBvdGhlci5Db3VudCk7XHJcbiAgICAgICAgICAgIERvT3V0ZXJQcm9kdWN0KG90aGVyLCBtYXRyaXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgb3V0ZXIgcHJvZHVjdCBNW2ksal0gPSB1W2ldKnZbal0gb2YgdGhpcyBhbmQgYW5vdGhlciB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgb3RoZXIgdmVjdG9yPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHByb2R1Y3QuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBPdXRlclByb2R1Y3QoVmVjdG9yPFQ+IG90aGVyLCBNYXRyaXg8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvdW50ICE9IHJlc3VsdC5Sb3dDb3VudCB8fCBvdGhlci5Db3VudCAhPSByZXN1bHQuQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeERpbWVuc2lvbnNcIiwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvT3V0ZXJQcm9kdWN0KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8VD4gT3V0ZXJQcm9kdWN0KFZlY3RvcjxUPiB1LCBWZWN0b3I8VD4gdilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB1Lk91dGVyUHJvZHVjdCh2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIG1pbmltdW0gd2l0aCBhIHNjYWxhciB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB2YWx1ZSB0byBjb21wYXJlIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VNaW5pbXVtKFQgc2NhbGFyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZfYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlTWluaW11bShzY2FsYXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBtaW5pbXVtIHdpdGggYSBzY2FsYXIgdG8gZWFjaCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdmFsdWUgdG8gY29tcGFyZSB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgdmVjdG9yIGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZU1pbmltdW0oVCBzY2FsYXIsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VNaW5pbXVtKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIG1heGltdW0gd2l0aCBhIHNjYWxhciB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB2YWx1ZSB0byBjb21wYXJlIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VNYXhpbXVtKFQgc2NhbGFyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZfYnVpbGRlci5TYW1lQXM8VD4odGhpcyk7XHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlTWF4aW11bShzY2FsYXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBtYXhpbXVtIHdpdGggYSBzY2FsYXIgdG8gZWFjaCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdmFsdWUgdG8gY29tcGFyZSB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgdmVjdG9yIGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZU1heGltdW0oVCBzY2FsYXIsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VNYXhpbXVtKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGFic29sdXRlIG1pbmltdW0gd2l0aCBhIHNjYWxhciB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB2YWx1ZSB0byBjb21wYXJlIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VBYnNvbHV0ZU1pbmltdW0oVCBzY2FsYXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VBYnNvbHV0ZU1pbmltdW0oc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgYWJzb2x1dGUgbWluaW11bSB3aXRoIGEgc2NhbGFyIHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHZhbHVlIHRvIGNvbXBhcmUgdG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGlzIHZlY3RvciBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQb2ludHdpc2VBYnNvbHV0ZU1pbmltdW0oVCBzY2FsYXIsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VBYnNvbHV0ZU1pbmltdW0oc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgYWJzb2x1dGUgbWF4aW11bSB3aXRoIGEgc2NhbGFyIHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHZhbHVlIHRvIGNvbXBhcmUgdG8uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFBvaW50d2lzZUFic29sdXRlTWF4aW11bShUIHNjYWxhcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBEb1BvaW50d2lzZUFic29sdXRlTWF4aW11bShzY2FsYXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBhYnNvbHV0ZSBtYXhpbXVtIHdpdGggYSBzY2FsYXIgdG8gZWFjaCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdmFsdWUgdG8gY29tcGFyZSB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgdmVjdG9yIGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZUFic29sdXRlTWF4aW11bShUIHNjYWxhciwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSByZXN1bHQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1BvaW50d2lzZUFic29sdXRlTWF4aW11bShzY2FsYXIsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBtaW5pbXVtIHdpdGggdGhlIHZhbHVlcyBvZiBhbm90aGVyIHZlY3RvciB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgdmVjdG9yIHdpdGggdGhlIHZhbHVlcyB0byBjb21wYXJlIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBQb2ludHdpc2VNaW5pbXVtKFZlY3RvcjxUPiBvdGhlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBEb1BvaW50d2lzZU1pbmltdW0ob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBtaW5pbXVtIHdpdGggdGhlIHZhbHVlcyBvZiBhbm90aGVyIHZlY3RvciB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgdmVjdG9yIHdpdGggdGhlIHZhbHVlcyB0byBjb21wYXJlIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlTWluaW11bShWZWN0b3I8VD4gb3RoZXIsIFZlY3RvcjxUPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VNaW5pbXVtKG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgbWF4aW11bSB3aXRoIHRoZSB2YWx1ZXMgb2YgYW5vdGhlciB2ZWN0b3IgdG8gZWFjaCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIHZlY3RvciB3aXRoIHRoZSB2YWx1ZXMgdG8gY29tcGFyZSB0by48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gUG9pbnR3aXNlTWF4aW11bShWZWN0b3I8VD4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VNYXhpbXVtKG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgbWF4aW11bSB3aXRoIHRoZSB2YWx1ZXMgb2YgYW5vdGhlciB2ZWN0b3IgdG8gZWFjaCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIHZlY3RvciB3aXRoIHRoZSB2YWx1ZXMgdG8gY29tcGFyZSB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoaXMgdmVjdG9yIGFuZCA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFBvaW50d2lzZU1heGltdW0oVmVjdG9yPFQ+IG90aGVyLCBWZWN0b3I8VD4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKENvdW50ICE9IHJlc3VsdC5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERvUG9pbnR3aXNlTWF4aW11bShvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGFic29sdXRlIG1pbmltdW0gd2l0aCB0aGUgdmFsdWVzIG9mIGFub3RoZXIgdmVjdG9yIHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSB2ZWN0b3Igd2l0aCB0aGUgdmFsdWVzIHRvIGNvbXBhcmUgdG8uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFBvaW50d2lzZUFic29sdXRlTWluaW11bShWZWN0b3I8VD4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VBYnNvbHV0ZU1pbmltdW0ob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBhYnNvbHV0ZSBtaW5pbXVtIHdpdGggdGhlIHZhbHVlcyBvZiBhbm90aGVyIHZlY3RvciB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgdmVjdG9yIHdpdGggdGhlIHZhbHVlcyB0byBjb21wYXJlIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlQWJzb2x1dGVNaW5pbXVtKFZlY3RvcjxUPiBvdGhlciwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSByZXN1bHQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1BvaW50d2lzZUFic29sdXRlTWluaW11bShvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIGFic29sdXRlIG1heGltdW0gd2l0aCB0aGUgdmFsdWVzIG9mIGFub3RoZXIgdmVjdG9yIHRvIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSB2ZWN0b3Igd2l0aCB0aGUgdmFsdWVzIHRvIGNvbXBhcmUgdG8uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFBvaW50d2lzZUFic29sdXRlTWF4aW11bShWZWN0b3I8VD4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgRG9Qb2ludHdpc2VBYnNvbHV0ZU1heGltdW0ob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBhcHBsaWVzIHRoZSBhYnNvbHV0ZSBtYXhpbXVtIHdpdGggdGhlIHZhbHVlcyBvZiBhbm90aGVyIHZlY3RvciB0byBlYWNoIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgdmVjdG9yIHdpdGggdGhlIHZhbHVlcyB0byBjb21wYXJlIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhpcyB2ZWN0b3IgYW5kIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUG9pbnR3aXNlQWJzb2x1dGVNYXhpbXVtKFZlY3RvcjxUPiBvdGhlciwgVmVjdG9yPFQ+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCAhPSByZXN1bHQuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEb1BvaW50d2lzZUFic29sdXRlTWF4aW11bShvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsY3VsYXRlcyB0aGUgTDEgbm9ybSBvZiB0aGUgdmVjdG9yLCBhbHNvIGtub3duIGFzIE1hbmhhdHRhbiBub3JtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBzdW0gb2YgdGhlIGFic29sdXRlIHZhbHVlcy48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGRvdWJsZSBMMU5vcm0oKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYWxjdWxhdGVzIHRoZSBMMiBub3JtIG9mIHRoZSB2ZWN0b3IsIGFsc28ga25vd24gYXMgRXVjbGlkZWFuIG5vcm0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHNxdWFyZSByb290IG9mIHRoZSBzdW0gb2YgdGhlIHNxdWFyZWQgdmFsdWVzLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3QgZG91YmxlIEwyTm9ybSgpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIGluZmluaXR5IG5vcm0gb2YgdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbWF4aW11bSBhYnNvbHV0ZSB2YWx1ZS48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGRvdWJsZSBJbmZpbml0eU5vcm0oKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgcC1Ob3JtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicFwiPlRoZSBwIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjxjPlNjYWxhciByZXQgPSAoc3VtKGFicyh0aGlzW2ldKV5wKSleKDEvcCk8L2M+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBkb3VibGUgTm9ybShkb3VibGUgcCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTm9ybWFsaXplcyB0aGlzIHZlY3RvciB0byBhIHVuaXQgdmVjdG9yIHdpdGggcmVzcGVjdCB0byB0aGUgcC1ub3JtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicFwiPlRoZSBwIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoaXMgdmVjdG9yIG5vcm1hbGl6ZWQgdG8gYSB1bml0IHZlY3RvciB3aXRoIHJlc3BlY3QgdG8gdGhlIHAtbm9ybS48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IFZlY3RvcjxUPiBOb3JtYWxpemUoZG91YmxlIHApO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBhYnNvbHV0ZSBtaW5pbXVtIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHZhbHVlIG9mIHRoZSBhYnNvbHV0ZSBtaW5pbXVtIGVsZW1lbnQuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBUIEFic29sdXRlTWluaW11bSgpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBhYnNvbHV0ZSBtaW5pbXVtIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGluZGV4IG9mIGFic29sdXRlIG1pbmltdW0gZWxlbWVudC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGludCBBYnNvbHV0ZU1pbmltdW1JbmRleCgpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBhYnNvbHV0ZSBtYXhpbXVtIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHZhbHVlIG9mIHRoZSBhYnNvbHV0ZSBtYXhpbXVtIGVsZW1lbnQuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBUIEFic29sdXRlTWF4aW11bSgpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBhYnNvbHV0ZSBtYXhpbXVtIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGluZGV4IG9mIGFic29sdXRlIG1heGltdW0gZWxlbWVudC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGludCBBYnNvbHV0ZU1heGltdW1JbmRleCgpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIHZhbHVlIG9mIG1heGltdW0gZWxlbWVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgdmFsdWUgb2YgbWF4aW11bSBlbGVtZW50LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVCBNYXhpbXVtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBBdChNYXhpbXVtSW5kZXgoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXhpbXVtIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGluZGV4IG9mIG1heGltdW0gZWxlbWVudC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGludCBNYXhpbXVtSW5kZXgoKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbWluaW11bSBlbGVtZW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSB2YWx1ZSBvZiB0aGUgbWluaW11bSBlbGVtZW50LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVCBNaW5pbXVtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBBdChNaW5pbXVtSW5kZXgoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtaW5pbXVtIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGluZGV4IG9mIG1pbmltdW0gZWxlbWVudC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGludCBNaW5pbXVtSW5kZXgoKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgc3VtIG9mIHRoZSB2ZWN0b3IncyBlbGVtZW50cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgc3VtIG9mIHRoZSB2ZWN0b3IncyBlbGVtZW50cy48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IFQgU3VtKCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIHZlY3RvcidzIGVsZW1lbnRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBzdW0gb2YgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSB2ZWN0b3IncyBlbGVtZW50cy48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGRvdWJsZSBTdW1NYWduaXR1ZGVzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBMMU5vcm0oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiVmVjdG9yLkJDTC5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDEzIE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucztcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgU3lzdGVtLkxpbnE7XHJcbnVzaW5nIFN5c3RlbS5UZXh0O1xyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuU3RvcmFnZTtcclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmFcclxue1xyXG4gICAgW0RlYnVnZ2VyRGlzcGxheShcIlZlY3RvciB7XCIgKyBcIkNvdW50XCIrIFwifVwiKV1cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBwYXJ0aWFsIGNsYXNzIFZlY3RvcjxUPlxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgb2JqZWN0IGlzIGVxdWFsIHRvIGFub3RoZXIgb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPkFuIG9iamVjdCB0byBjb21wYXJlIHdpdGggdGhpcyBvYmplY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vICAgIDxjPnRydWU8L2M+IGlmIHRoZSBjdXJyZW50IG9iamVjdCBpcyBlcXVhbCB0byB0aGUgPHBhcmFtcmVmIG5hbWU9XCJvdGhlclwiLz4gcGFyYW1ldGVyOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBib29sIEVxdWFscyhWZWN0b3I8VD4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgIT0gbnVsbCAmJiBTdG9yYWdlLkVxdWFscyhvdGhlci5TdG9yYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgPHNlZSBjcmVmPVwiU3lzdGVtLk9iamVjdFwiLz4gaXMgZXF1YWwgdG8gdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm9ialwiPlRoZSA8c2VlIGNyZWY9XCJTeXN0ZW0uT2JqZWN0XCIvPiB0byBjb21wYXJlIHdpdGggdGhpcyBpbnN0YW5jZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gICAgIDxjPnRydWU8L2M+IGlmIHRoZSBzcGVjaWZpZWQgPHNlZSBjcmVmPVwiU3lzdGVtLk9iamVjdFwiLz4gaXMgZXF1YWwgdG8gdGhpcyBpbnN0YW5jZTsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc2VhbGVkIG92ZXJyaWRlIGJvb2wgRXF1YWxzKG9iamVjdCBvYmopXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBvYmogYXMgVmVjdG9yPFQ+O1xyXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgIT0gbnVsbCAmJiBTdG9yYWdlLkVxdWFscyhvdGhlci5TdG9yYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIGhhc2ggY29kZSBmb3IgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gQSBoYXNoIGNvZGUgZm9yIHRoaXMgaW5zdGFuY2UsIHN1aXRhYmxlIGZvciB1c2UgaW4gaGFzaGluZyBhbGdvcml0aG1zIGFuZCBkYXRhIHN0cnVjdHVyZXMgbGlrZSBhIGhhc2ggdGFibGUuXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc2VhbGVkIG92ZXJyaWRlIGludCBHZXRIYXNoQ29kZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5HZXRIYXNoQ29kZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiNpZiAhTkVUU1RBTkRBUkQxXzNcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgbmV3IG9iamVjdCB0aGF0IGlzIGEgY29weSBvZiB0aGUgY3VycmVudCBpbnN0YW5jZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gQSBuZXcgb2JqZWN0IHRoYXQgaXMgYSBjb3B5IG9mIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBvYmplY3QgSUNsb25lYWJsZS5DbG9uZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2xvbmUoKTtcclxuICAgICAgICB9XHJcblxyXG4jZW5kaWZcclxuXHJcbiAgICAgICAgaW50IElMaXN0PFQ+LkluZGV4T2YoVCBpdGVtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQXQoaSkuRXF1YWxzKGl0ZW0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgSUxpc3Q8VD4uSW5zZXJ0KGludCBpbmRleCwgVCBpdGVtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEV4Y2VwdGlvbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBJTGlzdDxUPi5SZW1vdmVBdChpbnQgaW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBib29sIElDb2xsZWN0aW9uPFQ+LklzUmVhZE9ubHlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBJQ29sbGVjdGlvbjxUPi5BZGQoVCBpdGVtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEV4Y2VwdGlvbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYm9vbCBJQ29sbGVjdGlvbjxUPi5SZW1vdmUoVCBpdGVtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEV4Y2VwdGlvbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYm9vbCBJQ29sbGVjdGlvbjxUPi5Db250YWlucyhUIGl0ZW0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBSZVNoYXJwZXIgZGlzYWJsZSBvbmNlIExvb3BDYW5CZUNvbnZlcnRlZFRvUXVlcnlcclxuICAgICAgICAgICAgZm9yZWFjaCAodmFyIHggaW4gdGhpcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHguRXF1YWxzKGl0ZW0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgSUNvbGxlY3Rpb248VD4uQ29weVRvKFRbXSBhcnJheSwgaW50IGFycmF5SW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXkgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImFycmF5XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBTdG9yYWdlLkNvcHlTdWJWZWN0b3JUbyhuZXcgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+KGFycmF5Lkxlbmd0aCwgYXJyYXkpLCAwLCBhcnJheUluZGV4LCBDb3VudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBib29sIElMaXN0LklzUmVhZE9ubHlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYm9vbCBJTGlzdC5Jc0ZpeGVkU2l6ZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIHRydWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9iamVjdCBJTGlzdC50aGlzW2ludCBpbmRleF1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBTdG9yYWdlW2luZGV4XTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBTdG9yYWdlW2luZGV4XSA9IChUKSB2YWx1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50IElMaXN0LkluZGV4T2Yob2JqZWN0IHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCEodmFsdWUgaXMgVCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgoSUxpc3Q8VD4pIHRoaXMpLkluZGV4T2YoKFQpIHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJvb2wgSUxpc3QuQ29udGFpbnMob2JqZWN0IHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCEodmFsdWUgaXMgVCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgoSUNvbGxlY3Rpb248VD4pIHRoaXMpLkNvbnRhaW5zKChUKSB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2b2lkIElMaXN0Lkluc2VydChpbnQgaW5kZXgsIG9iamVjdCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFeGNlcHRpb24oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludCBJTGlzdC5BZGQob2JqZWN0IHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEV4Y2VwdGlvbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBJTGlzdC5SZW1vdmUob2JqZWN0IHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEV4Y2VwdGlvbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBJTGlzdC5SZW1vdmVBdChpbnQgaW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBib29sIElDb2xsZWN0aW9uLklzU3luY2hyb25pemVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gZmFsc2U7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9iamVjdCBJQ29sbGVjdGlvbi5TeW5jUm9vdFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIFN0b3JhZ2U7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgSUNvbGxlY3Rpb24uQ29weVRvKEFycmF5IGFycmF5LCBpbnQgaW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXkgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImFycmF5XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhcnJheS5SYW5rICE9IDEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFNpbmdsZURpbWVuc2lvbkFycmF5XCIsIFwiYXJyYXlcIik7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBTdG9yYWdlLkNvcHlTdWJWZWN0b3JUbyhuZXcgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+KGFycmF5Lkxlbmd0aCwgKFRbXSkgYXJyYXkpLCAwLCBpbmRleCwgQ291bnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGFuIGVudW1lcmF0b3IgdGhhdCBpdGVyYXRlcyB0aHJvdWdoIHRoZSBjb2xsZWN0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBBIDxzZWUgY3JlZj1cIlQ6U3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWMuSUVudW1lcmF0b3JgMVwiLz4gdGhhdCBjYW4gYmUgdXNlZCB0byBpdGVyYXRlIHRocm91Z2ggdGhlIGNvbGxlY3Rpb24uXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBJRW51bWVyYXRvcjxUPiBJRW51bWVyYWJsZTxUPi5HZXRFbnVtZXJhdG9yKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBFbnVtZXJhdGUoKS5HZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYW4gZW51bWVyYXRvciB0aGF0IGl0ZXJhdGVzIHRocm91Z2ggYSBjb2xsZWN0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBBbiA8c2VlIGNyZWY9XCJUOlN5c3RlbS5Db2xsZWN0aW9ucy5JRW51bWVyYXRvclwiLz4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIHRoZSBjb2xsZWN0aW9uLlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgSUVudW1lcmF0b3IgSUVudW1lcmFibGUuR2V0RW51bWVyYXRvcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRW51bWVyYXRlKCkuR2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgZGVzY3JpYmVzIHRoZSB0eXBlLCBkaW1lbnNpb25zIGFuZCBzaGFwZSBvZiB0aGlzIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIHN0cmluZyBUb1R5cGVTdHJpbmcoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5Gb3JtYXQoXCJ7MH0gezF9LXsyfVwiLCBHZXRUeXBlKCkuTmFtZSwgQ291bnQsIHR5cGVvZiAoVCkuTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RyaW5nWyxdIFRvVmVjdG9yU3RyaW5nQXJyYXkoaW50IG1heFBlckNvbHVtbiwgaW50IG1heENoYXJhY3RlcnNXaWR0aCwgaW50IHBhZGRpbmcsIHN0cmluZyBlbGxpcHNpcywgRnVuYzxULCBzdHJpbmc+IGZvcm1hdFZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gZW5mb3JjZSBtaW5pbWEgdG8gYXZvaWQgcGF0aGV0aWMgY2FzZXNcclxuICAgICAgICAgICAgbWF4UGVyQ29sdW1uID0gTWF0aC5NYXgobWF4UGVyQ29sdW1uLCAzKTtcclxuICAgICAgICAgICAgbWF4Q2hhcmFjdGVyc1dpZHRoID0gTWF0aC5NYXgobWF4Q2hhcmFjdGVyc1dpZHRoLCAxNik7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IG5ldyBMaXN0PFR1cGxlPGludCwgc3RyaW5nW10+PigpO1xyXG4gICAgICAgICAgICBpbnQgY2hhcnMgPSAwO1xyXG4gICAgICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IENvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBmdWxsIGNvbHVtblxyXG4gICAgICAgICAgICAgICAgaW50IGhlaWdodCA9IE1hdGguTWluKG1heFBlckNvbHVtbiwgQ291bnQgLSBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IEZvcm1hdENvbXBsZXRlQ29sdW1uKG9mZnNldCwgaGVpZ2h0LCAoRnVuYzxULHN0cmluZz4pZm9ybWF0VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnMgKz0gY2FuZGlkYXRlLkl0ZW0xICsgcGFkZGluZztcclxuICAgICAgICAgICAgICAgIGlmIChjaGFycyA+IG1heENoYXJhY3RlcnNXaWR0aCAmJiBvZmZzZXQgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29sdW1ucy5BZGQoY2FuZGlkYXRlKTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IENvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSBub3QgZG9uZSB5ZXQsIGJ1dCBhZGRpbmcgdGhlIGxhc3QgY29sdW1uIGhhcyBmYWlsZWRcclxuICAgICAgICAgICAgICAgIC8vIC0tPiBtYWtlIHRoZSBsYXN0IGNvbHVtbiBwYXJ0aWFsXHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IGNvbHVtbnNbY29sdW1ucy5Db3VudCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBsYXN0Lkl0ZW0yO1xyXG4gICAgICAgICAgICAgICAgY1tjLkxlbmd0aCAtIDJdID0gZWxsaXBzaXM7XHJcbiAgICAgICAgICAgICAgICBjW2MuTGVuZ3RoIC0gMV0gPSBmb3JtYXRWYWx1ZShBdChDb3VudCAtIDEpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW50IHJvd3MgPSBjb2x1bW5zWzBdLkl0ZW0yLkxlbmd0aDtcclxuICAgICAgICAgICAgaW50IGNvbHMgPSBjb2x1bW5zLkNvdW50O1xyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgc3RyaW5nW3Jvd3MsIGNvbHNdO1xyXG4gICAgICAgICAgICBpbnQgY29sSW5kZXggPSAwO1xyXG4gICAgICAgICAgICBmb3JlYWNoICh2YXIgY29sdW1uIGluIGNvbHVtbnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGsgPSAwOyBrIDwgY29sdW1uLkl0ZW0yLkxlbmd0aDsgaysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2ssIGNvbEluZGV4XSA9IGNvbHVtbi5JdGVtMltrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGsgPSBjb2x1bW4uSXRlbTIuTGVuZ3RoOyBrIDwgcm93czsgaysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2ssIGNvbEluZGV4XSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2xJbmRleCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBzdHJpbmcgRm9ybWF0U3RyaW5nQXJyYXlUb1N0cmluZyhzdHJpbmdbLF0gYXJyYXksIHN0cmluZyBjb2x1bW5TZXBhcmF0b3IsIHN0cmluZyByb3dTZXBhcmF0b3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcm93cyA9IGFycmF5LkdldExlbmd0aCgwKTtcclxuICAgICAgICAgICAgdmFyIGNvbHMgPSBhcnJheS5HZXRMZW5ndGgoMSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgd2lkdGhzID0gbmV3IGludFtjb2xzXTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCByb3dzOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgY29sczsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoc1tqXSA9IE1hdGguTWF4KHdpZHRoc1tqXSwgYXJyYXlbaSwgal0uTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNiID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCByb3dzOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNiLkFwcGVuZChhcnJheVtpLCAwXS5QYWRMZWZ0KHdpZHRoc1swXSkpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDE7IGogPCBjb2xzOyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKGNvbHVtblNlcGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKGFycmF5W2ksIGpdLlBhZExlZnQod2lkdGhzW2pdKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmQocm93U2VwYXJhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2IuVG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFR1cGxlPGludCwgc3RyaW5nW10+IEZvcm1hdENvbXBsZXRlQ29sdW1uKGludCBvZmZzZXQsIGludCBoZWlnaHQsIEZ1bmM8VCwgc3RyaW5nPiBmb3JtYXRWYWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjID0gbmV3IHN0cmluZ1toZWlnaHRdO1xyXG4gICAgICAgICAgICBpbnQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGhlaWdodDsgaysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjW2luZGV4KytdID0gZm9ybWF0VmFsdWUoQXQob2Zmc2V0ICsgaykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGludCB3ID0gU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5NYXg8c3RyaW5nPihjLChGdW5jPHN0cmluZyxpbnQ+KSh4ID0+IHguTGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGU8aW50LCBzdHJpbmdbXT4odywgYyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50IG9mIHRoaXMgdmVjdG9yLCBjb2x1bW4gYnkgY29sdW1uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWF4UGVyQ29sdW1uXCI+TWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBhbmQgdGh1cyBsaW5lcyBwZXIgY29sdW1uLiBUeXBpY2FsIHZhbHVlOiAxMjsgTWluaW11bTogMy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1heENoYXJhY3RlcnNXaWR0aFwiPk1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgcGVyIGxpbmUgb3ZlciBhbGwgY29sdW1ucy4gVHlwaWNhbCB2YWx1ZTogODA7IE1pbmltdW06IDE2LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZWxsaXBzaXNcIj5DaGFyYWN0ZXIgdG8gdXNlIHRvIHByaW50IGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgdG8gcHJpbnQgYWxsIGVudHJpZXMuIFR5cGljYWwgdmFsdWU6IFwiLi5cIi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtblNlcGFyYXRvclwiPkNoYXJhY3RlciB0byB1c2UgdG8gc2VwYXJhdGUgdHdvIGNvbHVtbnMgb24gYSBsaW5lLiBUeXBpY2FsIHZhbHVlOiBcIiAgXCIgKDIgc3BhY2VzKS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd1NlcGFyYXRvclwiPkNoYXJhY3RlciB0byB1c2UgdG8gc2VwYXJhdGUgdHdvIHJvd3MvbGluZXMuIFR5cGljYWwgdmFsdWU6IEVudmlyb25tZW50Lk5ld0xpbmUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmb3JtYXRWYWx1ZVwiPkZ1bmN0aW9uIHRvIHByb3ZpZGUgYSBzdHJpbmcgZm9yIGFueSBnaXZlbiBlbnRyeSB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdHJpbmcgVG9WZWN0b3JTdHJpbmcoaW50IG1heFBlckNvbHVtbiwgaW50IG1heENoYXJhY3RlcnNXaWR0aCwgc3RyaW5nIGVsbGlwc2lzLCBzdHJpbmcgY29sdW1uU2VwYXJhdG9yLCBzdHJpbmcgcm93U2VwYXJhdG9yLCBGdW5jPFQsIHN0cmluZz4gZm9ybWF0VmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRm9ybWF0U3RyaW5nQXJyYXlUb1N0cmluZyhcclxuICAgICAgICAgICAgICAgIFRvVmVjdG9yU3RyaW5nQXJyYXkobWF4UGVyQ29sdW1uLCBtYXhDaGFyYWN0ZXJzV2lkdGgsIGNvbHVtblNlcGFyYXRvci5MZW5ndGgsIGVsbGlwc2lzLCAoRnVuYzxULHN0cmluZz4pZm9ybWF0VmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uU2VwYXJhdG9yLCByb3dTZXBhcmF0b3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgY29udGVudCBvZiB0aGlzIHZlY3RvciwgY29sdW1uIGJ5IGNvbHVtbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1heFBlckNvbHVtblwiPk1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgYW5kIHRodXMgbGluZXMgcGVyIGNvbHVtbi4gVHlwaWNhbCB2YWx1ZTogMTI7IE1pbmltdW06IDMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtYXhDaGFyYWN0ZXJzV2lkdGhcIj5NYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHBlciBsaW5lIG92ZXIgYWxsIGNvbHVtbnMuIFR5cGljYWwgdmFsdWU6IDgwOyBNaW5pbXVtOiAxNi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZvcm1hdFwiPkZsb2F0aW5nIHBvaW50IGZvcm1hdCBzdHJpbmcuIENhbiBiZSBudWxsLiBEZWZhdWx0IHZhbHVlOiBHNi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInByb3ZpZGVyXCI+Rm9ybWF0IHByb3ZpZGVyIG9yIGN1bHR1cmUuIENhbiBiZSBudWxsLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0cmluZyBUb1ZlY3RvclN0cmluZyhpbnQgbWF4UGVyQ29sdW1uLCBpbnQgbWF4Q2hhcmFjdGVyc1dpZHRoLCBzdHJpbmcgZm9ybWF0ID0gbnVsbCwgSUZvcm1hdFByb3ZpZGVyIHByb3ZpZGVyID0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gXCJHNlwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gVG9WZWN0b3JTdHJpbmcobWF4UGVyQ29sdW1uLCBtYXhDaGFyYWN0ZXJzV2lkdGgsIFwiLi5cIiwgXCIgIFwiLCBFbnZpcm9ubWVudC5OZXdMaW5lLCAoRnVuYzxULHN0cmluZz4pKHggPT4geC5Ub1N0cmluZyhmb3JtYXQsIHByb3ZpZGVyKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgY29udGVudCBvZiB0aGlzIHZlY3RvciwgY29sdW1uIGJ5IGNvbHVtbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZvcm1hdFwiPkZsb2F0aW5nIHBvaW50IGZvcm1hdCBzdHJpbmcuIENhbiBiZSBudWxsLiBEZWZhdWx0IHZhbHVlOiBHNi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInByb3ZpZGVyXCI+Rm9ybWF0IHByb3ZpZGVyIG9yIGN1bHR1cmUuIENhbiBiZSBudWxsLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0cmluZyBUb1ZlY3RvclN0cmluZyhzdHJpbmcgZm9ybWF0ID0gbnVsbCwgSUZvcm1hdFByb3ZpZGVyIHByb3ZpZGVyID0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gXCJHNlwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gVG9WZWN0b3JTdHJpbmcoMTIsIDgwLCBcIi4uXCIsIFwiICBcIiwgRW52aXJvbm1lbnQuTmV3TGluZSwgKEZ1bmM8VCxzdHJpbmc+KSh4ID0+IHguVG9TdHJpbmcoZm9ybWF0LCBwcm92aWRlcikpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IHN1bW1hcml6ZXMgdGhpcyB2ZWN0b3IsIGNvbHVtbiBieSBjb2x1bW4gYW5kIHdpdGggYSB0eXBlIGhlYWRlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1heFBlckNvbHVtblwiPk1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgYW5kIHRodXMgbGluZXMgcGVyIGNvbHVtbi4gVHlwaWNhbCB2YWx1ZTogMTI7IE1pbmltdW06IDMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtYXhDaGFyYWN0ZXJzV2lkdGhcIj5NYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHBlciBsaW5lIG92ZXIgYWxsIGNvbHVtbnMuIFR5cGljYWwgdmFsdWU6IDgwOyBNaW5pbXVtOiAxNi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZvcm1hdFwiPkZsb2F0aW5nIHBvaW50IGZvcm1hdCBzdHJpbmcuIENhbiBiZSBudWxsLiBEZWZhdWx0IHZhbHVlOiBHNi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInByb3ZpZGVyXCI+Rm9ybWF0IHByb3ZpZGVyIG9yIGN1bHR1cmUuIENhbiBiZSBudWxsLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0cmluZyBUb1N0cmluZyhpbnQgbWF4UGVyQ29sdW1uLCBpbnQgbWF4Q2hhcmFjdGVyc1dpZHRoLCBzdHJpbmcgZm9ybWF0ID0gbnVsbCwgSUZvcm1hdFByb3ZpZGVyIHByb3ZpZGVyID0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcuQ29uY2F0KFRvVHlwZVN0cmluZygpLCBFbnZpcm9ubWVudC5OZXdMaW5lLCBUb1ZlY3RvclN0cmluZyhtYXhQZXJDb2x1bW4sIG1heENoYXJhY3RlcnNXaWR0aCwgZm9ybWF0LCBwcm92aWRlcikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgc3VtbWFyaXplcyB0aGlzIHZlY3Rvci5cclxuICAgICAgICAvLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGNlbGxzIGNhbiBiZSBjb25maWd1cmVkIGluIHRoZSA8c2VlIGNyZWY9XCJDb250cm9sXCIvPiBjbGFzcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzZWFsZWQgb3ZlcnJpZGUgc3RyaW5nIFRvU3RyaW5nKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcuQ29uY2F0KFRvVHlwZVN0cmluZygpLCBFbnZpcm9ubWVudC5OZXdMaW5lLCBUb1ZlY3RvclN0cmluZygpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IHN1bW1hcml6ZXMgdGhpcyB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjZWxscyBjYW4gYmUgY29uZmlndXJlZCBpbiB0aGUgPHNlZSBjcmVmPVwiQ29udHJvbFwiLz4gY2xhc3MuXHJcbiAgICAgICAgLy8vIFRoZSBmb3JtYXQgc3RyaW5nIGlzIGlnbm9yZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RyaW5nIFRvU3RyaW5nKHN0cmluZyBmb3JtYXQgPSBudWxsLCBJRm9ybWF0UHJvdmlkZXIgZm9ybWF0UHJvdmlkZXIgPSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5Db25jYXQoVG9UeXBlU3RyaW5nKCksIEVudmlyb25tZW50Lk5ld0xpbmUsIFRvVmVjdG9yU3RyaW5nKGZvcm1hdCwgZm9ybWF0UHJvdmlkZXIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiVmVjdG9yLk9wZXJhdG9ycy5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDEzIE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5SdW50aW1lLkNvbXBpbGVyU2VydmljZXM7XHJcblxyXG5uYW1lc3BhY2UgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhXHJcbntcclxuICAgIHB1YmxpYyBhYnN0cmFjdCBwYXJ0aWFsIGNsYXNzIFZlY3RvcjxUPlxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIDxzdHJvbmc+VmVjdG9yPC9zdHJvbmc+IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIG9mIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5UaGlzIG1ldGhvZCBpcyBpbmNsdWRlZCBmb3IgY29tcGxldGVuZXNzLjwvcmVtYXJrcz5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgdmVjdG9yIHRvIGdldCB0aGUgdmFsdWVzIGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSB2ZWN0b3IgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+LjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gb3BlcmF0b3IgKyhWZWN0b3I8VD4gcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0U2lkZS5DbG9uZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgPHN0cm9uZz5WZWN0b3I8L3N0cm9uZz4gY29udGFpbmluZyB0aGUgbmVnYXRlZCB2YWx1ZXMgb2YgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBnZXQgdGhlIHZhbHVlcyBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIG5lZ2F0ZWQgdmFsdWVzIGFzIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IG9wZXJhdG9yIC0oVmVjdG9yPFQ+IHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiByaWdodFNpZGUuTmVnYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgdHdvIDxzdHJvbmc+VmVjdG9yczwvc3Ryb25nPiB0b2dldGhlciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+T25lIG9mIHRoZSB2ZWN0b3JzIHRvIGFkZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSBvdGhlciB2ZWN0b3IgdG8gYWRkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gb3IgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gb3BlcmF0b3IgKyhWZWN0b3I8VD4gbGVmdFNpZGUsIFZlY3RvcjxUPiByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdFNpZGUuQWRkKHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgYSBzY2FsYXIgdG8gZWFjaCBlbGVtZW50IG9mIGEgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgdmVjdG9yIHRvIGFkZCB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSBzY2FsYXIgdmFsdWUgdG8gYWRkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBvcGVyYXRvciArKFZlY3RvcjxUPiBsZWZ0U2lkZSwgVCByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdFNpZGUuQWRkKHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgYSBzY2FsYXIgdG8gZWFjaCBlbGVtZW50IG9mIGEgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgc2NhbGFyIHZhbHVlIHRvIGFkZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSB2ZWN0b3IgdG8gYWRkIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gb3BlcmF0b3IgKyhUIGxlZnRTaWRlLCBWZWN0b3I8VD4gcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0U2lkZS5BZGQobGVmdFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgdHdvIDxzdHJvbmc+VmVjdG9yczwvc3Ryb25nPiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIHZlY3RvciB0byBzdWJ0cmFjdCBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBzdWJ0cmFjdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gYW5kIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IG9wZXJhdG9yIC0oVmVjdG9yPFQ+IGxlZnRTaWRlLCBWZWN0b3I8VD4gcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnRTaWRlLlN1YnRyYWN0KHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN1YnRyYWN0cyBhIHNjYWxhciBmcm9tIGVhY2ggZWxlbWVudCBvZiBhIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIHZlY3RvciB0byBzdWJ0cmFjdCBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHNjYWxhciB2YWx1ZSB0byBzdWJ0cmFjdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gb3BlcmF0b3IgLShWZWN0b3I8VD4gbGVmdFNpZGUsIFQgcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnRTaWRlLlN1YnRyYWN0KHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN1YnRyYWN0cyBlYWNoIGVsZW1lbnQgb2YgYSB2ZWN0b3IgZnJvbSBhIHNjYWxhci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIHNjYWxhciB2YWx1ZSB0byBzdWJ0cmFjdCBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBzdWJ0cmFjdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IG9wZXJhdG9yIC0oVCBsZWZ0U2lkZSwgVmVjdG9yPFQ+IHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiByaWdodFNpZGUuU3VidHJhY3RGcm9tKGxlZnRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyBhIHZlY3RvciB3aXRoIGEgc2NhbGFyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgdmVjdG9yIHRvIHNjYWxlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHNjYWxhciB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gb3BlcmF0b3IgKihWZWN0b3I8VD4gbGVmdFNpZGUsIFQgcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnRTaWRlLk11bHRpcGx5KHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgYSB2ZWN0b3Igd2l0aCBhIHNjYWxhci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIHNjYWxhciB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSB2ZWN0b3IgdG8gc2NhbGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBvcGVyYXRvciAqKFQgbGVmdFNpZGUsIFZlY3RvcjxUPiByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gcmlnaHRTaWRlLk11bHRpcGx5KGxlZnRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdHdvIDxzdHJvbmc+VmVjdG9yczwvc3Ryb25nPi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIGxlZnQgcm93IHZlY3Rvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSByaWdodCBjb2x1bW4gdmVjdG9yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBkb3QgcHJvZHVjdCBiZXR3ZWVuIHRoZSB0d28gdmVjdG9ycy48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gYW5kIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVCBvcGVyYXRvciAqKFZlY3RvcjxUPiBsZWZ0U2lkZSwgVmVjdG9yPFQ+IHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0U2lkZS5Eb3RQcm9kdWN0KHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERpdmlkZXMgYSBzY2FsYXIgd2l0aCBhIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHNjYWxhciB0byBkaXZpZGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHZlY3Rvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwiZGl2aXNvclwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBvcGVyYXRvciAvKFQgZGl2aWRlbmQsIFZlY3RvcjxUPiBkaXZpc29yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuRGl2aWRlQnlUaGlzKGRpdmlkZW5kKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGl2aWRlcyBhIHZlY3RvciB3aXRoIGEgc2NhbGFyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aWRlbmRcIj5UaGUgdmVjdG9yIHRvIGRpdmlkZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgc2NhbGFyIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIGRpdmlzaW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJkaXZpZGVuZFwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBvcGVyYXRvciAvKFZlY3RvcjxUPiBkaXZpZGVuZCwgVCBkaXZpc29yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdmlkZW5kLkRpdmlkZShkaXZpc29yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGRpdmlkZXMgdHdvIDxzdHJvbmc+VmVjdG9yczwvc3Ryb25nPi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHZlY3RvciB0byBkaXZpZGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIG90aGVyIHZlY3Rvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJkaXZpZGVuZFwiLz4gYW5kIDxwYXJhbXJlZiBuYW1lPVwiZGl2aXNvclwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImRpdmlkZW5kXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IG9wZXJhdG9yIC8oVmVjdG9yPFQ+IGRpdmlkZW5kLCBWZWN0b3I8VD4gZGl2aXNvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXZpZGVuZC5Qb2ludHdpc2VEaXZpZGUoZGl2aXNvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSByZW1haW5kZXIgKCUgb3BlcmF0b3IpLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aWRlbmQsXHJcbiAgICAgICAgLy8vIG9mIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIG9mIHRoZSBnaXZlbiBkaXZpc29yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aWRlbmRcIj5UaGUgdmVjdG9yIHdob3NlIGVsZW1lbnRzIHdlIHdhbnQgdG8gY29tcHV0ZSB0aGUgcmVtYWluZGVyIG9mLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBkaXZpc29yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImRpdmlkZW5kXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IG9wZXJhdG9yICUoVmVjdG9yPFQ+IGRpdmlkZW5kLCBUIGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2aWRlbmQuUmVtYWluZGVyKGRpdmlzb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgcmVtYWluZGVyICglIG9wZXJhdG9yKSwgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlkZW5kLFxyXG4gICAgICAgIC8vLyBvZiB0aGUgZ2l2ZW4gZGl2aWRlbmQgb2YgZWFjaCBlbGVtZW50IG9mIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpZGVuZFwiPlRoZSBkaXZpZGVuZCB3ZSB3YW50IHRvIGNvbXB1dGUgdGhlIHJlbWFpbmRlciBvZi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgdmVjdG9yIHdob3NlIGVsZW1lbnRzIHdlIHdhbnQgdG8gdXNlIGFzIGRpdmlzb3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJkaXZpZGVuZFwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBvcGVyYXRvciAlKFQgZGl2aWRlbmQsIFZlY3RvcjxUPiBkaXZpc29yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuUmVtYWluZGVyQnlUaGlzKGRpdmlkZW5kKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHBvaW50d2lzZSByZW1haW5kZXIgKCUgb3BlcmF0b3IpLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aWRlbmQsXHJcbiAgICAgICAgLy8vIG9mIGVhY2ggZWxlbWVudCBvZiB0d28gdmVjdG9ycy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHZlY3RvciB3aG9zZSBlbGVtZW50cyB3ZSB3YW50IHRvIGNvbXB1dGUgdGhlIHJlbWFpbmRlciBvZi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgZGl2aXNvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImRpdmlkZW5kXCIvPiBhbmQgPHBhcmFtcmVmIG5hbWU9XCJkaXZpc29yXCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwiZGl2aWRlbmRcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gb3BlcmF0b3IgJShWZWN0b3I8VD4gZGl2aWRlbmQsIFZlY3RvcjxUPiBkaXZpc29yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdmlkZW5kLlBvaW50d2lzZVJlbWFpbmRlcihkaXZpc29yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IG9wX0RvdE11bHRpcGx5KFZlY3RvcjxUPiB4LCBWZWN0b3I8VD4geSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4LlBvaW50d2lzZU11bHRpcGx5KHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICBcclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBvcF9Eb3REaXZpZGUoVmVjdG9yPFQ+IGRpdmlkZW5kLCBWZWN0b3I8VD4gZGl2aXNvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXZpZGVuZC5Qb2ludHdpc2VEaXZpZGUoZGl2aXNvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBcclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBvcF9Eb3RQZXJjZW50KFZlY3RvcjxUPiBkaXZpZGVuZCwgVmVjdG9yPFQ+IGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2aWRlbmQuUG9pbnR3aXNlUmVtYWluZGVyKGRpdmlzb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gb3BfRG90SGF0KFZlY3RvcjxUPiB2ZWN0b3IsIFZlY3RvcjxUPiBleHBvbmVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWN0b3IuUG9pbnR3aXNlUG93ZXIoZXhwb25lbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gb3BfRG90SGF0KFZlY3RvcjxUPiB2ZWN0b3IsIFQgZXhwb25lbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdmVjdG9yLlBvaW50d2lzZVBvd2VyKGV4cG9uZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHNxcnQgb2YgYSB2ZWN0b3IgcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IHZlY3RvcjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBTcXJ0KFZlY3RvcjxUPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlU3FydCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgZXhwb25lbnRpYWwgb2YgYSB2ZWN0b3IgcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IHZlY3RvcjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBFeHAoVmVjdG9yPFQ+IHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4geC5Qb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4peC5Eb1BvaW50d2lzZUV4cCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBsb2cgb2YgYSB2ZWN0b3IgcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IHZlY3RvcjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBMb2coVmVjdG9yPFQ+IHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4geC5Qb2ludHdpc2VVbmFyeSgoQWN0aW9uPFZlY3RvcjxUPj4peC5Qb2ludHdpc2VMb2cpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBsb2cxMCBvZiBhIHZlY3RvciBwb2ludHdpc2VcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgaW5wdXQgdmVjdG9yPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IExvZzEwKFZlY3RvcjxUPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlTG9nMTAoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHNpbiBvZiBhIHZlY3RvciBwb2ludHdpc2VcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgaW5wdXQgdmVjdG9yPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IFNpbihWZWN0b3I8VD4geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4LlBvaW50d2lzZVNpbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgY29zIG9mIGEgdmVjdG9yIHBvaW50d2lzZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieFwiPlRoZSBpbnB1dCB2ZWN0b3I8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gQ29zKFZlY3RvcjxUPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlQ29zKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSB0YW4gb2YgYSB2ZWN0b3IgcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IHZlY3RvcjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBUYW4oVmVjdG9yPFQ+IHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4geC5Qb2ludHdpc2VUYW4oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGFzaW4gb2YgYSB2ZWN0b3IgcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IHZlY3RvcjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBBc2luKFZlY3RvcjxUPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlQXNpbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgYWNvcyBvZiBhIHZlY3RvciBwb2ludHdpc2VcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgaW5wdXQgdmVjdG9yPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IEFjb3MoVmVjdG9yPFQ+IHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4geC5Qb2ludHdpc2VBY29zKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBhdGFuIG9mIGEgdmVjdG9yIHBvaW50d2lzZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieFwiPlRoZSBpbnB1dCB2ZWN0b3I8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gQXRhbihWZWN0b3I8VD4geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4LlBvaW50d2lzZUF0YW4oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHNpbmggb2YgYSB2ZWN0b3IgcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IHZlY3RvcjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBTaW5oKFZlY3RvcjxUPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlU2luaCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgY29zaCBvZiBhIHZlY3RvciBwb2ludHdpc2VcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgaW5wdXQgdmVjdG9yPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IENvc2goVmVjdG9yPFQ+IHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4geC5Qb2ludHdpc2VDb3NoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSB0YW5oIG9mIGEgdmVjdG9yIHBvaW50d2lzZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieFwiPlRoZSBpbnB1dCB2ZWN0b3I8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gVGFuaChWZWN0b3I8VD4geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4LlBvaW50d2lzZVRhbmgoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIGEgdmVjdG9yIHBvaW50d2lzZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieFwiPlRoZSBpbnB1dCB2ZWN0b3I8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8VD4gQWJzKFZlY3RvcjxUPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlQWJzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBmbG9vciBvZiBhIHZlY3RvciBwb2ludHdpc2VcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgaW5wdXQgdmVjdG9yPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IEZsb29yKFZlY3RvcjxUPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlRmxvb3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGNlaWxpbmcgb2YgYSB2ZWN0b3IgcG9pbnR3aXNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIGlucHV0IHZlY3RvcjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxUPiBDZWlsaW5nKFZlY3RvcjxUPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlQ2VpbGluZygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgcm91bmRlZCB2YWx1ZSBvZiBhIHZlY3RvciBwb2ludHdpc2VcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgaW5wdXQgdmVjdG9yPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPFQ+IFJvdW5kKFZlY3RvcjxUPiB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHguUG9pbnR3aXNlUm91bmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiVmVjdG9yLmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTMgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLlJ1bnRpbWU7XHJcbnVzaW5nIFN5c3RlbS5SdW50aW1lLkNvbXBpbGVyU2VydmljZXM7XHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGUuTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhO1xyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuU3RvcmFnZTtcclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmFcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIERlZmluZXMgdGhlIGdlbmVyaWMgY2xhc3MgZm9yIDxjPlZlY3RvcjwvYz4gY2xhc3Nlcy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAvLy8gPHR5cGVwYXJhbSBuYW1lPVwiVFwiPlN1cHBvcnRlZCBkYXRhIHR5cGVzIGFyZSBkb3VibGUsIHNpbmdsZSwgPHNlZSBjcmVmPVwiQ29tcGxleFwiLz4sIGFuZCA8c2VlIGNyZWY9XCJDb21wbGV4MzJcIi8+LjwvdHlwZXBhcmFtPlxyXG4gICAgW1NlcmlhbGl6YWJsZV1cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBwYXJ0aWFsIGNsYXNzIFZlY3RvcjxUPiA6XHJcbiAgICAgICAgSUZvcm1hdHRhYmxlLCBJRXF1YXRhYmxlPFZlY3RvcjxUPj4sIElMaXN0LCBJTGlzdDxUPlxyXG4jaWYgIU5FVFNUQU5EQVJEMV8zXHJcbiAgICAgICAgLCBJQ2xvbmVhYmxlXHJcbiNlbmRpZlxyXG4gICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3JCdWlsZGVyPFQ+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3I7XHJcbiAgICAgICAgcHVibGljIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBWZWN0b3IgY2xhc3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcm90ZWN0ZWQgVmVjdG9yKFZlY3RvclN0b3JhZ2U8VD4gc3RvcmFnZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UgPSBzdG9yYWdlO1xyXG4gICAgICAgICAgICBDb3VudCA9IHN0b3JhZ2UuTGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSByYXcgdmVjdG9yIGRhdGEgc3RvcmFnZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3JTdG9yYWdlPFQ+IFN0b3JhZ2UgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgbGVuZ3RoIG9yIG51bWJlciBvZiBkaW1lbnNpb25zIG9mIHRoaXMgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGludCBDb3VudCB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PkdldHMgb3Igc2V0cyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIDxwYXJhbXJlZiBuYW1lPVwiaW5kZXhcIi8+Ljwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmRleFwiPlRoZSBpbmRleCBvZiB0aGUgdmFsdWUgdG8gZ2V0IG9yIHNldC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgdmFsdWUgb2YgdGhlIHZlY3RvciBhdCB0aGUgZ2l2ZW4gPHBhcmFtcmVmIG5hbWU9XCJpbmRleFwiLz4uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImluZGV4XCIvPiBpcyBuZWdhdGl2ZSBvclxyXG4gICAgICAgIC8vLyBncmVhdGVyIHRoYW4gdGhlIHNpemUgb2YgdGhlIHZlY3Rvci48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgVCB0aGlzW2ludCBpbmRleF1cclxuICAgICAgICB7XHJcbiNpZiAhTkVUNDBcclxuICAgICAgICAgICAgW01ldGhvZEltcGwoTWV0aG9kSW1wbE9wdGlvbnMuQWdncmVzc2l2ZUlubGluaW5nKV1cclxuI2VuZGlmXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gU3RvcmFnZVtpbmRleF07IH1cclxuXHJcbiNpZiAhTkVUNDBcclxuICAgICAgICAgICAgW01ldGhvZEltcGwoTWV0aG9kSW1wbE9wdGlvbnMuQWdncmVzc2l2ZUlubGluaW5nKV1cclxuI2VuZGlmXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzZXQgeyBTdG9yYWdlW2luZGV4XSA9IHZhbHVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+R2V0cyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIDxwYXJhbXJlZiBuYW1lPVwiaW5kZXhcIi8+IHdpdGhvdXQgcmFuZ2UgY2hlY2tpbmcuLjwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmRleFwiPlRoZSBpbmRleCBvZiB0aGUgdmFsdWUgdG8gZ2V0IG9yIHNldC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgdmFsdWUgb2YgdGhlIHZlY3RvciBhdCB0aGUgZ2l2ZW4gPHBhcmFtcmVmIG5hbWU9XCJpbmRleFwiLz4uPC9yZXR1cm5zPlxyXG4jaWYgIU5FVDQwXHJcbiAgICAgICAgW01ldGhvZEltcGwoTWV0aG9kSW1wbE9wdGlvbnMuQWdncmVzc2l2ZUlubGluaW5nKV1cclxuI2VuZGlmXHJcbiAgICAgICAgXHJcbiAgICAgICAgcHVibGljIFQgQXQoaW50IGluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuQXQoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlNldHMgdGhlIDxwYXJhbXJlZiBuYW1lPVwidmFsdWVcIi8+IGF0IHRoZSBnaXZlbiA8cGFyYW1yZWYgbmFtZT1cImluZGV4XCIvPiB3aXRob3V0IHJhbmdlIGNoZWNraW5nLi48L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5kZXhcIj5UaGUgaW5kZXggb2YgdGhlIHZhbHVlIHRvIGdldCBvciBzZXQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2YWx1ZVwiPlRoZSB2YWx1ZSB0byBzZXQuPC9wYXJhbT5cclxuI2lmICFORVQ0MFxyXG4gICAgICAgIFtNZXRob2RJbXBsKE1ldGhvZEltcGxPcHRpb25zLkFnZ3Jlc3NpdmVJbmxpbmluZyldXHJcbiNlbmRpZlxyXG4gICAgICAgIFxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEF0KGludCBpbmRleCwgVCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQXQoaW5kZXgsIHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVzZXRzIGFsbCB2YWx1ZXMgdG8gemVyby5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENsZWFyKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ2xlYXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0cyBhbGwgdmFsdWVzIG9mIGEgc3VidmVjdG9yIHRvIHplcm8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhclN1YlZlY3RvcihpbnQgaW5kZXgsIGludCBjb3VudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChjb3VudCA8IDEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJjb3VudFwiLCBcIlJlc291cmNlcy5Bcmd1bWVudE11c3RCZVBvc2l0aXZlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5kZXggKyBjb3VudCA+IENvdW50IHx8IGluZGV4IDwgMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImluZGV4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBTdG9yYWdlLkNsZWFyKGluZGV4LCBjb3VudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCBhbGwgdmFsdWVzIHdob3NlIGFic29sdXRlIHZhbHVlIGlzIHNtYWxsZXIgdGhhbiB0aGUgdGhyZXNob2xkIHRvIHplcm8sIGluLXBsYWNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IHZvaWQgQ29lcmNlWmVybyhkb3VibGUgdGhyZXNob2xkKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgYWxsIHZhbHVlcyB0aGF0IG1lZXQgdGhlIHByZWRpY2F0ZSB0byB6ZXJvLCBpbi1wbGFjZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENvZXJjZVplcm8oRnVuYzxULCBib29sPiB6ZXJvUHJlZGljYXRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwSW5wbGFjZSgoRnVuYzxULFQ+KSh4ID0+IHplcm9QcmVkaWNhdGUoeCkgPyBaZXJvIDogeCksIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYSBkZWVwLWNvcHkgY2xvbmUgb2YgdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIGRlZXAtY29weSBjbG9uZSBvZiB0aGUgdmVjdG9yLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IENsb25lKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBTdG9yYWdlLkNvcHlUb1VuY2hlY2tlZChyZXN1bHQuU3RvcmFnZSwgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoZSB2YWx1ZXMgb2YgdGhpcyB2ZWN0b3IgdG8gdGhlIGdpdmVuIHZhbHVlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlc1wiPlRoZSBhcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZXMgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwidmFsdWVzXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwidmFsdWVzXCIvPiBpcyBub3QgdGhlIHNhbWUgc2l6ZSBhcyB0aGlzIHZlY3Rvci48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXRWYWx1ZXMoVFtdIHZhbHVlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBuZXcgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+KENvdW50LCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICBzb3VyY2UuQ29weVRvKFN0b3JhZ2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGlzIHZlY3RvciBpbnRvIHRoZSB0YXJnZXQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidGFyZ2V0XCI+VGhlIHZlY3RvciB0byBjb3B5IGVsZW1lbnRzIGludG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJ0YXJnZXRcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cInRhcmdldFwiLz4gaXMgbm90IHRoZSBzYW1lIHNpemUgYXMgdGhpcyB2ZWN0b3IuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQ29weVRvKFZlY3RvcjxUPiB0YXJnZXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJ0YXJnZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFN0b3JhZ2UuQ29weVRvKHRhcmdldC5TdG9yYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIHZlY3RvciBjb250YWluaW5nIHNwZWNpZmllZCBlbGVtZW50cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluZGV4XCI+VGhlIGZpcnN0IGVsZW1lbnQgdG8gYmVnaW4gY29weWluZyBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY291bnRcIj5UaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGNvcHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSB2ZWN0b3IgY29udGFpbmluZyBhIGNvcHkgb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50cy48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPjxsaXN0PjxpdGVtPklmIDxwYXJhbXJlZiBuYW1lPVwiaW5kZXhcIi8+IGlzIG5vdCBwb3NpdGl2ZSBvclxyXG4gICAgICAgIC8vLyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNpemUgb2YgdGhlIHZlY3Rvci48L2l0ZW0+XHJcbiAgICAgICAgLy8vIDxpdGVtPklmIDxwYXJhbXJlZiBuYW1lPVwiaW5kZXhcIi8+ICsgPHBhcmFtcmVmIG5hbWU9XCJjb3VudFwiLz4gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzaXplIG9mIHRoZSB2ZWN0b3IuPC9pdGVtPlxyXG4gICAgICAgIC8vLyA8L2xpc3Q+PC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJjb3VudFwiLz4gaXMgbm90IHBvc2l0aXZlLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gU3ViVmVjdG9yKGludCBpbmRleCwgaW50IGNvdW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHZfYnVpbGRlci5TYW1lQXM8VD4odGhpcywgY291bnQpO1xyXG4gICAgICAgICAgICBTdG9yYWdlLkNvcHlTdWJWZWN0b3JUbyh0YXJnZXQuU3RvcmFnZSwgaW5kZXgsIDAsIGNvdW50LCBFeGlzdGluZ0RhdGEuQXNzdW1lWmVyb3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb3BpZXMgdGhlIHZhbHVlcyBvZiBhIGdpdmVuIHZlY3RvciBpbnRvIGEgcmVnaW9uIGluIHRoaXMgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5kZXhcIj5UaGUgZmllbGQgdG8gc3RhcnQgY29weWluZyB0bzwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY291bnRcIj5UaGUgbnVtYmVyIG9mIGZpZWxkcyB0byBjb3B5LiBNdXN0IGJlIHBvc2l0aXZlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic3ViVmVjdG9yXCI+VGhlIHN1Yi12ZWN0b3IgdG8gY29weSBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwic3ViVmVjdG9yXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+PC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0U3ViVmVjdG9yKGludCBpbmRleCwgaW50IGNvdW50LCBWZWN0b3I8VD4gc3ViVmVjdG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHN1YlZlY3RvciA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwic3ViVmVjdG9yXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzdWJWZWN0b3IuU3RvcmFnZS5Db3B5U3ViVmVjdG9yVG8oU3RvcmFnZSwgMCwgaW5kZXgsIGNvdW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29waWVzIHRoZSByZXF1ZXN0ZWQgZWxlbWVudHMgZnJvbSB0aGlzIHZlY3RvciB0byBhbm90aGVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGVzdGluYXRpb25cIj5UaGUgdmVjdG9yIHRvIGNvcHkgdGhlIGVsZW1lbnRzIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic291cmNlSW5kZXhcIj5UaGUgZWxlbWVudCB0byBzdGFydCBjb3B5aW5nIGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0YXJnZXRJbmRleFwiPlRoZSBlbGVtZW50IHRvIHN0YXJ0IGNvcHlpbmcgdG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb3VudFwiPlRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gY29weS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENvcHlTdWJWZWN0b3JUbyhWZWN0b3I8VD4gZGVzdGluYXRpb24sIGludCBzb3VyY2VJbmRleCwgaW50IHRhcmdldEluZGV4LCBpbnQgY291bnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZGVzdGluYXRpb24gPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImRlc3RpbmF0aW9uXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciByYW5nZSBjaGVja3NcclxuICAgICAgICAgICAgU3RvcmFnZS5Db3B5U3ViVmVjdG9yVG8oZGVzdGluYXRpb24uU3RvcmFnZSwgc291cmNlSW5kZXgsIHRhcmdldEluZGV4LCBjb3VudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIGRhdGEgY29udGFpbmVkIGluIHRoZSB2ZWN0b3IgYXMgYW4gYXJyYXkuXHJcbiAgICAgICAgLy8vIFRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhpcyB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3IgdGhlIGFycmF5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSB2ZWN0b3IncyBkYXRhIGFzIGFuIGFycmF5LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVFtdIFRvQXJyYXkoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuVG9BcnJheSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBhcnJheSBvZiB0aGlzIHZlY3RvciBpZiwgYW5kIG9ubHkgaWYsIHRoaXMgdmVjdG9yIGlzIHN0b3JlZCBieSBzdWNoIGFuIGFycmF5IGludGVybmFsbHkuXHJcbiAgICAgICAgLy8vIE90aGVyd2lzZSByZXR1cm5zIG51bGwuIENoYW5nZXMgdG8gdGhlIHJldHVybmVkIGFycmF5IGFuZCB0aGUgdmVjdG9yIHdpbGwgYWZmZWN0IGVhY2ggb3RoZXIuXHJcbiAgICAgICAgLy8vIFVzZSBUb0FycmF5IGluc3RlYWQgaWYgeW91IGFsd2F5cyBuZWVkIGFuIGluZGVwZW5kZW50IGFycmF5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFRbXSBBc0FycmF5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdG9yYWdlLkFzQXJyYXkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbWF0cml4IGJhc2VkIG9uIHRoaXMgdmVjdG9yIGluIGNvbHVtbiBmb3JtIChvbmUgc2luZ2xlIGNvbHVtbikuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIFRoaXMgdmVjdG9yIGFzIGEgY29sdW1uIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gVG9Db2x1bW5NYXRyaXgoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXModGhpcywgQ291bnQsIDEpO1xyXG4gICAgICAgICAgICBTdG9yYWdlLkNvcHlUb0NvbHVtblVuY2hlY2tlZChyZXN1bHQuU3RvcmFnZSwgMCwgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbWF0cml4IGJhc2VkIG9uIHRoaXMgdmVjdG9yIGluIHJvdyBmb3JtIChvbmUgc2luZ2xlIHJvdykuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIFRoaXMgdmVjdG9yIGFzIGEgcm93IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gVG9Sb3dNYXRyaXgoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXModGhpcywgMSwgQ291bnQpO1xyXG4gICAgICAgICAgICBTdG9yYWdlLkNvcHlUb1Jvd1VuY2hlY2tlZChyZXN1bHQuU3RvcmFnZSwgMCwgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhbiBJRW51bWVyYWJsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGl0ZXJhdGUgdGhyb3VnaCBhbGwgdmFsdWVzIG9mIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+XHJcbiAgICAgICAgLy8vIFRoZSBlbnVtZXJhdG9yIHdpbGwgaW5jbHVkZSBhbGwgdmFsdWVzLCBldmVuIGlmIHRoZXkgYXJlIHplcm8uXHJcbiAgICAgICAgLy8vIDwvcmVtYXJrcz5cclxuICAgICAgICBwdWJsaWMgSUVudW1lcmFibGU8VD4gRW51bWVyYXRlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdG9yYWdlLkVudW1lcmF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGFuIElFbnVtZXJhYmxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbCB2YWx1ZXMgb2YgdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5cclxuICAgICAgICAvLy8gVGhlIGVudW1lcmF0b3Igd2lsbCBpbmNsdWRlIGFsbCB2YWx1ZXMsIGV2ZW4gaWYgdGhleSBhcmUgemVyby5cclxuICAgICAgICAvLy8gPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyBJRW51bWVyYWJsZTxUPiBFbnVtZXJhdGUoWmVyb3MgemVyb3MgPSBaZXJvcy5JbmNsdWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3dpdGNoICh6ZXJvcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBaZXJvcy5BbGxvd1NraXA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuRW51bWVyYXRlTm9uWmVybygpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5FbnVtZXJhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGFuIElFbnVtZXJhYmxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbCB2YWx1ZXMgb2YgdGhlIHZlY3RvciBhbmQgdGhlaXIgaW5kZXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+XHJcbiAgICAgICAgLy8vIFRoZSBlbnVtZXJhdG9yIHJldHVybnMgYSBUdXBsZSB3aXRoIHRoZSBmaXJzdCB2YWx1ZSBiZWluZyB0aGUgZWxlbWVudCBpbmRleFxyXG4gICAgICAgIC8vLyBhbmQgdGhlIHNlY29uZCB2YWx1ZSBiZWluZyB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgYXQgdGhhdCBpbmRleC5cclxuICAgICAgICAvLy8gVGhlIGVudW1lcmF0b3Igd2lsbCBpbmNsdWRlIGFsbCB2YWx1ZXMsIGV2ZW4gaWYgdGhleSBhcmUgemVyby5cclxuICAgICAgICAvLy8gPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyBJRW51bWVyYWJsZTxUdXBsZTxpbnQsIFQ+PiBFbnVtZXJhdGVJbmRleGVkKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdG9yYWdlLkVudW1lcmF0ZUluZGV4ZWQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhbiBJRW51bWVyYWJsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGl0ZXJhdGUgdGhyb3VnaCBhbGwgdmFsdWVzIG9mIHRoZSB2ZWN0b3IgYW5kIHRoZWlyIGluZGV4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlxyXG4gICAgICAgIC8vLyBUaGUgZW51bWVyYXRvciByZXR1cm5zIGEgVHVwbGUgd2l0aCB0aGUgZmlyc3QgdmFsdWUgYmVpbmcgdGhlIGVsZW1lbnQgaW5kZXhcclxuICAgICAgICAvLy8gYW5kIHRoZSBzZWNvbmQgdmFsdWUgYmVpbmcgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IGF0IHRoYXQgaW5kZXguXHJcbiAgICAgICAgLy8vIFRoZSBlbnVtZXJhdG9yIHdpbGwgaW5jbHVkZSBhbGwgdmFsdWVzLCBldmVuIGlmIHRoZXkgYXJlIHplcm8uXHJcbiAgICAgICAgLy8vIDwvcmVtYXJrcz5cclxuICAgICAgICBwdWJsaWMgSUVudW1lcmFibGU8VHVwbGU8aW50LCBUPj4gRW51bWVyYXRlSW5kZXhlZChaZXJvcyB6ZXJvcyA9IFplcm9zLkluY2x1ZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHplcm9zKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFplcm9zLkFsbG93U2tpcDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5FbnVtZXJhdGVOb25aZXJvSW5kZXhlZCgpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5FbnVtZXJhdGVJbmRleGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgb2YgdGhpcyB2ZWN0b3IgYW5kIHJlcGxhY2VzIHRoZSB2YWx1ZSB3aXRoIGl0cyByZXN1bHQuXHJcbiAgICAgICAgLy8vIElmIGZvcmNlTWFwWmVybyBpcyBub3Qgc2V0IHRvIHRydWUsIHplcm8gdmFsdWVzIG1heSBvciBtYXkgbm90IGJlIHNraXBwZWQgZGVwZW5kaW5nXHJcbiAgICAgICAgLy8vIG9uIHRoZSBhY3R1YWwgZGF0YSBzdG9yYWdlIGltcGxlbWVudGF0aW9uIChyZWxldmFudCBtb3N0bHkgZm9yIHNwYXJzZSB2ZWN0b3JzKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1hcElucGxhY2UoRnVuYzxULCBUPiBmLCBaZXJvcyB6ZXJvcyA9IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuTWFwSW5wbGFjZSgoRnVuYzxULFQ+KWYsIHplcm9zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgb2YgdGhpcyB2ZWN0b3IgYW5kIHJlcGxhY2VzIHRoZSB2YWx1ZSB3aXRoIGl0cyByZXN1bHQuXHJcbiAgICAgICAgLy8vIFRoZSBpbmRleCBvZiBlYWNoIHZhbHVlICh6ZXJvLWJhc2VkKSBpcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vLyBJZiBmb3JjZU1hcFplcm8gaXMgbm90IHNldCB0byB0cnVlLCB6ZXJvIHZhbHVlcyBtYXkgb3IgbWF5IG5vdCBiZSBza2lwcGVkIGRlcGVuZGluZ1xyXG4gICAgICAgIC8vLyBvbiB0aGUgYWN0dWFsIGRhdGEgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbiAocmVsZXZhbnQgbW9zdGx5IGZvciBzcGFyc2UgdmVjdG9ycykuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXBJbmRleGVkSW5wbGFjZShGdW5jPGludCwgVCwgVD4gZiwgWmVyb3MgemVyb3MgPSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTdG9yYWdlLk1hcEluZGV4ZWRJbnBsYWNlKChGdW5jPGludCxULFQ+KWYsIHplcm9zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgb2YgdGhpcyB2ZWN0b3IgYW5kIHJlcGxhY2VzIHRoZSB2YWx1ZSBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gSWYgZm9yY2VNYXBaZXJvIGlzIG5vdCBzZXQgdG8gdHJ1ZSwgemVybyB2YWx1ZXMgbWF5IG9yIG1heSBub3QgYmUgc2tpcHBlZCBkZXBlbmRpbmdcclxuICAgICAgICAvLy8gb24gdGhlIGFjdHVhbCBkYXRhIHN0b3JhZ2UgaW1wbGVtZW50YXRpb24gKHJlbGV2YW50IG1vc3RseSBmb3Igc3BhcnNlIHZlY3RvcnMpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFwKEZ1bmM8VCwgVD4gZiwgVmVjdG9yPFQ+IHJlc3VsdCwgWmVyb3MgemVyb3MgPSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoUmVmZXJlbmNlRXF1YWxzKHRoaXMsIHJlc3VsdCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFN0b3JhZ2UuTWFwSW5wbGFjZSgoRnVuYzxULFQ+KWYsIHplcm9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFN0b3JhZ2UuTWFwVG88VD4ocmVzdWx0LlN0b3JhZ2UsIChGdW5jPFQsVD4pZiwgemVyb3MsIHplcm9zID09IFplcm9zLkluY2x1ZGUgPyBFeGlzdGluZ0RhdGEuQXNzdW1lWmVyb3MgOiBFeGlzdGluZ0RhdGEuQ2xlYXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIG9mIHRoaXMgdmVjdG9yIGFuZCByZXBsYWNlcyB0aGUgdmFsdWUgaW4gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIFRoZSBpbmRleCBvZiBlYWNoIHZhbHVlICh6ZXJvLWJhc2VkKSBpcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vLyBJZiBmb3JjZU1hcFplcm8gaXMgbm90IHNldCB0byB0cnVlLCB6ZXJvIHZhbHVlcyBtYXkgb3IgbWF5IG5vdCBiZSBza2lwcGVkIGRlcGVuZGluZ1xyXG4gICAgICAgIC8vLyBvbiB0aGUgYWN0dWFsIGRhdGEgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbiAocmVsZXZhbnQgbW9zdGx5IGZvciBzcGFyc2UgdmVjdG9ycykuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXBJbmRleGVkKEZ1bmM8aW50LCBULCBUPiBmLCBWZWN0b3I8VD4gcmVzdWx0LCBaZXJvcyB6ZXJvcyA9IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHModGhpcywgcmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU3RvcmFnZS5NYXBJbmRleGVkSW5wbGFjZSgoRnVuYzxpbnQsVCxUPilmLCB6ZXJvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBTdG9yYWdlLk1hcEluZGV4ZWRUbzxUPihyZXN1bHQuU3RvcmFnZSwgKEZ1bmM8aW50LFQsVD4pZiwgemVyb3MsIHplcm9zID09IFplcm9zLkluY2x1ZGUgPyBFeGlzdGluZ0RhdGEuQXNzdW1lWmVyb3MgOiBFeGlzdGluZ0RhdGEuQ2xlYXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIG9mIHRoaXMgdmVjdG9yIGFuZCByZXBsYWNlcyB0aGUgdmFsdWUgaW4gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIElmIGZvcmNlTWFwWmVybyBpcyBub3Qgc2V0IHRvIHRydWUsIHplcm8gdmFsdWVzIG1heSBvciBtYXkgbm90IGJlIHNraXBwZWQgZGVwZW5kaW5nXHJcbiAgICAgICAgLy8vIG9uIHRoZSBhY3R1YWwgZGF0YSBzdG9yYWdlIGltcGxlbWVudGF0aW9uIChyZWxldmFudCBtb3N0bHkgZm9yIHNwYXJzZSB2ZWN0b3JzKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1hcENvbnZlcnQ8VFU+KEZ1bmM8VCwgVFU+IGYsIFZlY3RvcjxUVT4gcmVzdWx0LCBaZXJvcyB6ZXJvcyA9IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICAgICAgd2hlcmUgVFUgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VFU+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuTWFwVG88VFU+KHJlc3VsdC5TdG9yYWdlLCAoRnVuYzxULFRVPilmLCB6ZXJvcywgemVyb3MgPT0gWmVyb3MuSW5jbHVkZSA/IEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyA6IEV4aXN0aW5nRGF0YS5DbGVhcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIG9mIHRoaXMgdmVjdG9yIGFuZCByZXBsYWNlcyB0aGUgdmFsdWUgaW4gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIFRoZSBpbmRleCBvZiBlYWNoIHZhbHVlICh6ZXJvLWJhc2VkKSBpcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vLyBJZiBmb3JjZU1hcFplcm8gaXMgbm90IHNldCB0byB0cnVlLCB6ZXJvIHZhbHVlcyBtYXkgb3IgbWF5IG5vdCBiZSBza2lwcGVkIGRlcGVuZGluZ1xyXG4gICAgICAgIC8vLyBvbiB0aGUgYWN0dWFsIGRhdGEgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbiAocmVsZXZhbnQgbW9zdGx5IGZvciBzcGFyc2UgdmVjdG9ycykuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXBJbmRleGVkQ29udmVydDxUVT4oRnVuYzxpbnQsIFQsIFRVPiBmLCBWZWN0b3I8VFU+IHJlc3VsdCwgWmVyb3MgemVyb3MgPSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTdG9yYWdlLk1hcEluZGV4ZWRUbzxUVT4ocmVzdWx0LlN0b3JhZ2UsIChGdW5jPGludCxULFRVPilmLCB6ZXJvcywgemVyb3MgPT0gWmVyb3MuSW5jbHVkZSA/IEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyA6IEV4aXN0aW5nRGF0YS5DbGVhcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIG9mIHRoaXMgdmVjdG9yIGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIGFzIGEgbmV3IHZlY3Rvci5cclxuICAgICAgICAvLy8gSWYgZm9yY2VNYXBaZXJvIGlzIG5vdCBzZXQgdG8gdHJ1ZSwgemVybyB2YWx1ZXMgbWF5IG9yIG1heSBub3QgYmUgc2tpcHBlZCBkZXBlbmRpbmdcclxuICAgICAgICAvLy8gb24gdGhlIGFjdHVhbCBkYXRhIHN0b3JhZ2UgaW1wbGVtZW50YXRpb24gKHJlbGV2YW50IG1vc3RseSBmb3Igc3BhcnNlIHZlY3RvcnMpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUVT4gTWFwPFRVPihGdW5jPFQsIFRVPiBmLCBaZXJvcyB6ZXJvcyA9IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICAgICAgd2hlcmUgVFUgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VFU+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvckJ1aWxkZXI8VFU+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUVT4uVmVjdG9yO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgU3RvcmFnZS5NYXBUb1VuY2hlY2tlZDxUVT4ocmVzdWx0LlN0b3JhZ2UsIChGdW5jPFQsVFU+KWYsIHplcm9zLCBFeGlzdGluZ0RhdGEuQXNzdW1lWmVyb3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBvZiB0aGlzIHZlY3RvciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBhcyBhIG5ldyB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIFRoZSBpbmRleCBvZiBlYWNoIHZhbHVlICh6ZXJvLWJhc2VkKSBpcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vLyBJZiBmb3JjZU1hcFplcm8gaXMgbm90IHNldCB0byB0cnVlLCB6ZXJvIHZhbHVlcyBtYXkgb3IgbWF5IG5vdCBiZSBza2lwcGVkIGRlcGVuZGluZ1xyXG4gICAgICAgIC8vLyBvbiB0aGUgYWN0dWFsIGRhdGEgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbiAocmVsZXZhbnQgbW9zdGx5IGZvciBzcGFyc2UgdmVjdG9ycykuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yPFRVPiBNYXBJbmRleGVkPFRVPihGdW5jPGludCwgVCwgVFU+IGYsIFplcm9zIHplcm9zID0gWmVyb3MuQWxsb3dTa2lwKVxyXG4gICAgICAgICAgICB3aGVyZSBUVSA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUVT4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yQnVpbGRlcjxUVT4gdl9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFRVPi5WZWN0b3I7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KHRoaXMpO1xyXG4gICAgICAgICAgICBTdG9yYWdlLk1hcEluZGV4ZWRUb1VuY2hlY2tlZDxUVT4ocmVzdWx0LlN0b3JhZ2UsIChGdW5jPGludCxULFRVPilmLCB6ZXJvcywgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgcGFpciBvZiB0d28gdmVjdG9ycyBhbmQgcmVwbGFjZXMgdGhlIHZhbHVlIGluIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFwMihGdW5jPFQsIFQsIFQ+IGYsIFZlY3RvcjxUPiBvdGhlciwgVmVjdG9yPFQ+IHJlc3VsdCwgWmVyb3MgemVyb3MgPSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTdG9yYWdlLk1hcDJUbyhyZXN1bHQuU3RvcmFnZSwgb3RoZXIuU3RvcmFnZSwgKEZ1bmM8VCxULFQ+KWYsIHplcm9zLCBFeGlzdGluZ0RhdGEuQ2xlYXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBwYWlyIG9mIHR3byB2ZWN0b3JzIGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIGFzIGEgbmV3IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gTWFwMihGdW5jPFQsIFQsIFQ+IGYsIFZlY3RvcjxUPiBvdGhlciwgWmVyb3MgemVyb3MgPSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdl9idWlsZGVyLlNhbWVBczxUPih0aGlzKTtcclxuICAgICAgICAgICAgU3RvcmFnZS5NYXAyVG8ocmVzdWx0LlN0b3JhZ2UsIG90aGVyLlN0b3JhZ2UsIChGdW5jPFQsVCxUPilmLCB6ZXJvcywgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbGllcyBhIGZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgc3RhdHVzIHdpdGggZWFjaCB2YWx1ZSBwYWlyIG9mIHR3byB2ZWN0b3JzIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgc3RhdHVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFRTdGF0ZSBGb2xkMjxUT3RoZXIsIFRTdGF0ZT4oRnVuYzxUU3RhdGUsIFQsIFRPdGhlciwgVFN0YXRlPiBmLCBUU3RhdGUgc3RhdGUsIFZlY3RvcjxUT3RoZXI+IG90aGVyLCBaZXJvcyB6ZXJvcyA9IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICAgICAgd2hlcmUgVE90aGVyIDogc3RydWN0LCBJRXF1YXRhYmxlPFRPdGhlcj4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuRm9sZDI8VE90aGVyLFRTdGF0ZT4ob3RoZXIuU3RvcmFnZSwgKEZ1bmM8VFN0YXRlLFQsVE90aGVyLFRTdGF0ZT4pZiwgc3RhdGUsIHplcm9zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIHR1cGxlIHdpdGggdGhlIGluZGV4IGFuZCB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBzYXRpc2Z5aW5nIGEgcHJlZGljYXRlLCBvciBudWxsIGlmIG5vbmUgaXMgZm91bmQuXHJcbiAgICAgICAgLy8vIFplcm8gZWxlbWVudHMgbWF5IGJlIHNraXBwZWQgb24gc3BhcnNlIGRhdGEgc3RydWN0dXJlcyBpZiBhbGxvd2VkIChkZWZhdWx0KS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBUdXBsZTxpbnQsIFQ+IEZpbmQoRnVuYzxULCBib29sPiBwcmVkaWNhdGUsIFplcm9zIHplcm9zID0gWmVyb3MuQWxsb3dTa2lwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuRmluZCgoRnVuYzxULGJvb2w+KXByZWRpY2F0ZSwgemVyb3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgdHVwbGUgd2l0aCB0aGUgaW5kZXggYW5kIHZhbHVlcyBvZiB0aGUgZmlyc3QgZWxlbWVudCBwYWlyIG9mIHR3byB2ZWN0b3JzIG9mIHRoZSBzYW1lIHNpemUgc2F0aXNmeWluZyBhIHByZWRpY2F0ZSwgb3IgbnVsbCBpZiBub25lIGlzIGZvdW5kLlxyXG4gICAgICAgIC8vLyBaZXJvIGVsZW1lbnRzIG1heSBiZSBza2lwcGVkIG9uIHNwYXJzZSBkYXRhIHN0cnVjdHVyZXMgaWYgYWxsb3dlZCAoZGVmYXVsdCkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVHVwbGU8aW50LCBULCBUT3RoZXI+IEZpbmQyPFRPdGhlcj4oRnVuYzxULCBUT3RoZXIsIGJvb2w+IHByZWRpY2F0ZSwgVmVjdG9yPFRPdGhlcj4gb3RoZXIsIFplcm9zIHplcm9zID0gWmVyb3MuQWxsb3dTa2lwKVxyXG4gICAgICAgICAgICB3aGVyZSBUT3RoZXIgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VE90aGVyPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5GaW5kMjxUT3RoZXI+KG90aGVyLlN0b3JhZ2UsIChGdW5jPFQsVE90aGVyLGJvb2w+KXByZWRpY2F0ZSwgemVyb3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRydWUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgc2F0aXNmaWVzIGEgcHJlZGljYXRlLlxyXG4gICAgICAgIC8vLyBaZXJvIGVsZW1lbnRzIG1heSBiZSBza2lwcGVkIG9uIHNwYXJzZSBkYXRhIHN0cnVjdHVyZXMgaWYgYWxsb3dlZCAoZGVmYXVsdCkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBFeGlzdHMoRnVuYzxULCBib29sPiBwcmVkaWNhdGUsIFplcm9zIHplcm9zID0gWmVyb3MuQWxsb3dTa2lwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuRmluZCgoRnVuYzxULGJvb2w+KXByZWRpY2F0ZSwgemVyb3MpICE9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBwYWlycyBvZiB0d28gdmVjdG9ycyBvZiB0aGUgc2FtZSBzaXplIHNhdGlzZmllcyBhIHByZWRpY2F0ZS5cclxuICAgICAgICAvLy8gWmVybyBlbGVtZW50cyBtYXkgYmUgc2tpcHBlZCBvbiBzcGFyc2UgZGF0YSBzdHJ1Y3R1cmVzIGlmIGFsbG93ZWQgKGRlZmF1bHQpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgRXhpc3RzMjxUT3RoZXI+KEZ1bmM8VCwgVE90aGVyLCBib29sPiBwcmVkaWNhdGUsIFZlY3RvcjxUT3RoZXI+IG90aGVyLCBaZXJvcyB6ZXJvcyA9IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICAgICAgd2hlcmUgVE90aGVyIDogc3RydWN0LCBJRXF1YXRhYmxlPFRPdGhlcj4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0b3JhZ2UuRmluZDI8VE90aGVyPihvdGhlci5TdG9yYWdlLCAoRnVuYzxULFRPdGhlcixib29sPilwcmVkaWNhdGUsIHplcm9zKSAhPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRydWUgaWYgYWxsIGVsZW1lbnRzIHNhdGlzZnkgYSBwcmVkaWNhdGUuXHJcbiAgICAgICAgLy8vIFplcm8gZWxlbWVudHMgbWF5IGJlIHNraXBwZWQgb24gc3BhcnNlIGRhdGEgc3RydWN0dXJlcyBpZiBhbGxvd2VkIChkZWZhdWx0KS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBib29sIEZvckFsbChGdW5jPFQsIGJvb2w+IHByZWRpY2F0ZSwgWmVyb3MgemVyb3MgPSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5GaW5kKChGdW5jPFQsYm9vbD4pKHggPT4gIXByZWRpY2F0ZSh4KSksIHplcm9zKSA9PSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRydWUgaWYgYWxsIGVsZW1lbnQgcGFpcnMgb2YgdHdvIHZlY3RvcnMgb2YgdGhlIHNhbWUgc2l6ZSBzYXRpc2Z5IGEgcHJlZGljYXRlLlxyXG4gICAgICAgIC8vLyBaZXJvIGVsZW1lbnRzIG1heSBiZSBza2lwcGVkIG9uIHNwYXJzZSBkYXRhIHN0cnVjdHVyZXMgaWYgYWxsb3dlZCAoZGVmYXVsdCkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBGb3JBbGwyPFRPdGhlcj4oRnVuYzxULCBUT3RoZXIsIGJvb2w+IHByZWRpY2F0ZSwgVmVjdG9yPFRPdGhlcj4gb3RoZXIsIFplcm9zIHplcm9zID0gWmVyb3MuQWxsb3dTa2lwKVxyXG4gICAgICAgICAgICB3aGVyZSBUT3RoZXIgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VE90aGVyPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RvcmFnZS5GaW5kMjxUT3RoZXI+KG90aGVyLlN0b3JhZ2UsIChGdW5jPFQsVE90aGVyLGJvb2w+KSgoeCwgeSkgPT4gIXByZWRpY2F0ZSh4LCB5KSksIHplcm9zKSA9PSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvLyA8Y29weXJpZ2h0IGZpbGU9XCJCdWlsZGVyLmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5MaW5xO1xyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlO1xyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlLk1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYTtcclxuXHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5TdG9yYWdlO1xyXG5cclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlXHJcbntcclxuICAgIFxyXG4gICAgaW50ZXJuYWwgY2xhc3MgTWF0cml4QnVpbGRlciA6IE1hdHJpeEJ1aWxkZXI8ZG91YmxlPlxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgWmVyb1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIDBkOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZG91YmxlIE9uZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIDFkOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgTWF0cml4PGRvdWJsZT4gRGVuc2UoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8ZG91YmxlPiBzdG9yYWdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeChzdG9yYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIE1hdHJpeDxkb3VibGU+IFNwYXJzZShTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxkb3VibGU+IHN0b3JhZ2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeChzdG9yYWdlKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgTWF0cml4PGRvdWJsZT4gRGlhZ29uYWwoRGlhZ29uYWxNYXRyaXhTdG9yYWdlPGRvdWJsZT4gc3RvcmFnZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGlhZ29uYWxNYXRyaXgoc3RvcmFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICBcclxuXHJcbiAgICBpbnRlcm5hbCBjbGFzcyBWZWN0b3JCdWlsZGVyIDogVmVjdG9yQnVpbGRlcjxkb3VibGU+XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGRvdWJsZSBaZXJvXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gMGQ7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgT25lXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gMWQ7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3I8ZG91YmxlPiBEZW5zZShEZW5zZVZlY3RvclN0b3JhZ2U8ZG91YmxlPiBzdG9yYWdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZVZlY3RvcihzdG9yYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3I8ZG91YmxlPiBTcGFyc2UoU3BhcnNlVmVjdG9yU3RvcmFnZTxkb3VibGU+IHN0b3JhZ2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZVZlY3RvcihzdG9yYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFxyXG4gICAgXHJcblxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICBuYW1lc3BhY2UgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZW5lcmljIGxpbmVhciBhbGdlYnJhIHR5cGUgYnVpbGRlciwgZm9yIHNpdHVhdGlvbnMgd2hlcmUgYSBtYXRyaXggb3IgdmVjdG9yXHJcbiAgICAgICAgLy8vIG11c3QgYmUgY3JlYXRlZCBpbiBhIGdlbmVyaWMgd2F5LiBVc2FnZSBvZiBnZW5lcmljIGJ1aWxkZXJzIHNob3VsZCBub3QgYmVcclxuICAgICAgICAvLy8gcmVxdWlyZWQgaW4gbm9ybWFsIHVzZXIgY29kZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBjbGFzcyBNYXRyaXhCdWlsZGVyPFQ+IHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gR2V0cyB0aGUgdmFsdWUgb2YgPGM+MC4wPC9jPiBmb3IgdHlwZSBULlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgYWJzdHJhY3QgVCBaZXJvIHsgZ2V0OyB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBHZXRzIHRoZSB2YWx1ZSBvZiA8Yz4xLjA8L2M+IGZvciB0eXBlIFQuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBhYnN0cmFjdCBUIE9uZSB7IGdldDsgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IG1hdHJpeCBzdHJhaWdodCBmcm9tIGFuIGluaXRpYWxpemVkIG1hdHJpeCBzdG9yYWdlIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAvLy8gSWYgeW91IGhhdmUgYW4gaW5zdGFuY2Ugb2YgYSBkaXNjcmV0ZSBzdG9yYWdlIHR5cGUgaW5zdGVhZCwgdXNlIHRoZWlyIGRpcmVjdCBtZXRob2RzIGluc3RlYWQuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gT2ZTdG9yYWdlKE1hdHJpeFN0b3JhZ2U8VD4gc3RvcmFnZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UgPT0gbnVsbCkgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInN0b3JhZ2VcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRlbnNlID0gc3RvcmFnZSBhcyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPjtcclxuICAgICAgICAgICAgICAgIGlmIChkZW5zZSAhPSBudWxsKSByZXR1cm4gRGVuc2UoZGVuc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzcGFyc2UgPSBzdG9yYWdlIGFzIFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwYXJzZSAhPSBudWxsKSByZXR1cm4gU3BhcnNlKHNwYXJzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRpYWdvbmFsID0gc3RvcmFnZSBhcyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VD47XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlhZ29uYWwgIT0gbnVsbCkgcmV0dXJuIERpYWdvbmFsKGRpYWdvbmFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXhjZXB0aW9uKHN0cmluZy5Gb3JtYXQoXCJNYXRyaXggc3RvcmFnZSB0eXBlICd7MH0nIGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHkgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2UsIFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlIGFuZCBEaWFnb25hbE1hdHJpeFN0b3JhZ2UgYXJlIHN1cHBvcnRlZCBhcyB0aGlzIHBvaW50LlwiLCBzdG9yYWdlLkdldFR5cGUoKS5OYW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBtYXRyaXggd2l0aCB0aGUgc2FtZSBraW5kIG9mIHRoZSBwcm92aWRlZCBleGFtcGxlLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFNhbWVBczxUVT4oTWF0cml4PFRVPiBleGFtcGxlLCBpbnQgcm93cywgaW50IGNvbHVtbnMsIGJvb2wgZnVsbHlNdXRhYmxlID0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB3aGVyZSBUVSA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUVT4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGV4YW1wbGUuU3RvcmFnZTtcclxuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlIGlzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+KSByZXR1cm4gRGVuc2Uocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZSBpcyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VD4pIHJldHVybiBmdWxseU11dGFibGUgPyBTcGFyc2Uocm93cywgY29sdW1ucykgOiBEaWFnb25hbChyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlIGlzIFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+KSByZXR1cm4gU3BhcnNlKHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlbnNlKHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgbWF0cml4IHdpdGggdGhlIHNhbWUga2luZCBhbmQgZGltZW5zaW9ucyBvZiB0aGUgcHJvdmlkZWQgZXhhbXBsZS5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTYW1lQXM8VFU+KE1hdHJpeDxUVT4gZXhhbXBsZSlcclxuICAgICAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTYW1lQXM8VFU+KGV4YW1wbGUsIGV4YW1wbGUuUm93Q291bnQsIGV4YW1wbGUuQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgbWF0cml4IHdpdGggdGhlIHNhbWUga2luZCBvZiB0aGUgcHJvdmlkZWQgZXhhbXBsZS5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTYW1lQXMoVmVjdG9yPFQ+IGV4YW1wbGUsIGludCByb3dzLCBpbnQgY29sdW1ucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4YW1wbGUuU3RvcmFnZS5Jc0RlbnNlID8gRGVuc2Uocm93cywgY29sdW1ucykgOiBTcGFyc2Uocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBtYXRyaXggd2l0aCBhIHR5cGUgdGhhdCBjYW4gcmVwcmVzZW50IGFuZCBpcyBjbG9zZXN0IHRvIGJvdGggcHJvdmlkZWQgc2FtcGxlcy5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTYW1lQXMoTWF0cml4PFQ+IGV4YW1wbGUsIE1hdHJpeDxUPiBvdGhlckV4YW1wbGUsIGludCByb3dzLCBpbnQgY29sdW1ucywgYm9vbCBmdWxseU11dGFibGUgPSBmYWxzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0b3JhZ2UxID0gZXhhbXBsZS5TdG9yYWdlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0b3JhZ2UyID0gb3RoZXJFeGFtcGxlLlN0b3JhZ2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZTEgaXMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4gfHwgc3RvcmFnZTIgaXMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4pIHJldHVybiBEZW5zZShyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlMSBpcyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VD4gJiYgc3RvcmFnZTIgaXMgRGlhZ29uYWxNYXRyaXhTdG9yYWdlPFQ+KSByZXR1cm4gZnVsbHlNdXRhYmxlID8gU3BhcnNlKHJvd3MsIGNvbHVtbnMpIDogRGlhZ29uYWwocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZTEgaXMgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4gfHwgc3RvcmFnZTIgaXMgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4pIHJldHVybiBTcGFyc2Uocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVuc2Uocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBtYXRyaXggd2l0aCBhIHR5cGUgdGhhdCBjYW4gcmVwcmVzZW50IGFuZCBpcyBjbG9zZXN0IHRvIGJvdGggcHJvdmlkZWQgc2FtcGxlcyBhbmQgdGhlIGRpbWVuc2lvbnMgb2YgZXhhbXBsZS5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTYW1lQXMoTWF0cml4PFQ+IGV4YW1wbGUsIE1hdHJpeDxUPiBvdGhlckV4YW1wbGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTYW1lQXMoZXhhbXBsZSwgb3RoZXJFeGFtcGxlLCBleGFtcGxlLlJvd0NvdW50LCBleGFtcGxlLkNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCB3aXRoIHZhbHVlcyBzYW1wbGVkIGZyb20gdGhlIHByb3ZpZGVkIHJhbmRvbSBkaXN0cmlidXRpb24uXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcblxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCB3aXRoIHZhbHVlcyBzYW1wbGVkIGZyb20gdGhlIHN0YW5kYXJkIGRpc3RyaWJ1dGlvbiB3aXRoIGEgc3lzdGVtIHJhbmRvbSBzb3VyY2UuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcblxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCB3aXRoIHZhbHVlcyBzYW1wbGVkIGZyb20gdGhlIHN0YW5kYXJkIGRpc3RyaWJ1dGlvbiB3aXRoIGEgc3lzdGVtIHJhbmRvbSBzb3VyY2UuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcblxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHBvc2l0aXZlIGRlZmluaXRlIGRlbnNlIG1hdHJpeCB3aGVyZSBlYWNoIHZhbHVlIGlzIHRoZSBwcm9kdWN0XHJcbiAgICAgICAgICAgIC8vLyBvZiB0d28gc2FtcGxlcyBmcm9tIHRoZSBwcm92aWRlZCByYW5kb20gZGlzdHJpYnV0aW9uLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBwb3NpdGl2ZSBkZWZpbml0ZSBkZW5zZSBtYXRyaXggd2hlcmUgZWFjaCB2YWx1ZSBpcyB0aGUgcHJvZHVjdFxyXG4gICAgICAgICAgICAvLy8gb2YgdHdvIHNhbXBsZXMgZnJvbSB0aGUgc3RhbmRhcmQgZGlzdHJpYnV0aW9uLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBwb3NpdGl2ZSBkZWZpbml0ZSBkZW5zZSBtYXRyaXggd2hlcmUgZWFjaCB2YWx1ZSBpcyB0aGUgcHJvZHVjdFxyXG4gICAgICAgICAgICAvLy8gb2YgdHdvIHNhbXBsZXMgZnJvbSB0aGUgcHJvdmlkZWQgcmFuZG9tIGRpc3RyaWJ1dGlvbi5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuXHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IHN0cmFpZ2h0IGZyb20gYW4gaW5pdGlhbGl6ZWQgbWF0cml4IHN0b3JhZ2UgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgIC8vLyBUaGUgc3RvcmFnZSBpcyB1c2VkIGRpcmVjdGx5IHdpdGhvdXQgY29weWluZy5cclxuICAgICAgICAgICAgLy8vIEludGVuZGVkIGZvciBhZHZhbmNlZCBzY2VuYXJpb3Mgd2hlcmUgeW91J3JlIHdvcmtpbmcgZGlyZWN0bHkgd2l0aFxyXG4gICAgICAgICAgICAvLy8gc3RvcmFnZSBmb3IgcGVyZm9ybWFuY2Ugb3IgaW50ZXJvcCByZWFzb25zLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgYWJzdHJhY3QgTWF0cml4PFQ+IERlbnNlKERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+IHN0b3JhZ2UpO1xyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucy5cclxuICAgICAgICAgICAgLy8vIEFsbCBjZWxscyBvZiB0aGUgbWF0cml4IHdpbGwgYmUgaW5pdGlhbGl6ZWQgdG8gemVyby5cclxuICAgICAgICAgICAgLy8vIFplcm8tbGVuZ3RoIG1hdHJpY2VzIGFyZSBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERlbnNlKGludCByb3dzLCBpbnQgY29sdW1ucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlbnNlKG5ldyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPihyb3dzLCBjb2x1bW5zKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgZGlyZWN0bHkgYmluZGluZyB0byBhIHJhdyBhcnJheS5cclxuICAgICAgICAgICAgLy8vIFRoZSBhcnJheSBpcyBhc3N1bWVkIHRvIGJlIGluIGNvbHVtbi1tYWpvciBvcmRlciAoY29sdW1uIGJ5IGNvbHVtbikgYW5kIGlzIHVzZWQgZGlyZWN0bHkgd2l0aG91dCBjb3B5aW5nLlxyXG4gICAgICAgICAgICAvLy8gVmVyeSBlZmZpY2llbnQsIGJ1dCBjaGFuZ2VzIHRvIHRoZSBhcnJheSBhbmQgdGhlIG1hdHJpeCB3aWxsIGFmZmVjdCBlYWNoIG90aGVyLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gPHNlZWFsc28gaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm93LW1ham9yX29yZGVyXCIvPlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERlbnNlKGludCByb3dzLCBpbnQgY29sdW1ucywgVFtdIHN0b3JhZ2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShuZXcgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4ocm93cywgY29sdW1ucywgc3RvcmFnZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFuZCBpbml0aWFsaXplIGVhY2ggdmFsdWUgdG8gdGhlIHNhbWUgcHJvdmlkZWQgdmFsdWUuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gRGVuc2UoaW50IHJvd3MsIGludCBjb2x1bW5zLCBUIHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoWmVyby5FcXVhbHModmFsdWUpKSByZXR1cm4gRGVuc2Uocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVuc2UoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4uT2ZWYWx1ZShyb3dzLCBjb2x1bW5zLCB2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFuZCBpbml0aWFsaXplIGVhY2ggdmFsdWUgdXNpbmcgdGhlIHByb3ZpZGVkIGluaXQgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gRGVuc2UoaW50IHJvd3MsIGludCBjb2x1bW5zLCBGdW5jPGludCwgaW50LCBUPiBpbml0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVuc2UoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4uT2ZJbml0KHJvd3MsIGNvbHVtbnMsIChGdW5jPGludCxpbnQsVD4paW5pdCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgZGVuc2UgbWF0cml4IGFuZCBpbml0aWFsaXplIGVhY2ggZGlhZ29uYWwgdmFsdWUgdG8gdGhlIHNhbWUgcHJvdmlkZWQgdmFsdWUuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gRGVuc2VEaWFnb25hbChpbnQgcm93cywgaW50IGNvbHVtbnMsIFQgdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChaZXJvLkVxdWFscyh2YWx1ZSkpIHJldHVybiBEZW5zZShyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPi5PZkRpYWdvbmFsSW5pdChyb3dzLCBjb2x1bW5zLCAoRnVuYzxpbnQsVD4pKGkgPT4gdmFsdWUpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBkZW5zZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCBkaWFnb25hbCB2YWx1ZSB0byB0aGUgc2FtZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEZW5zZURpYWdvbmFsKGludCBvcmRlciwgVCB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKFplcm8uRXF1YWxzKHZhbHVlKSkgcmV0dXJuIERlbnNlKG9yZGVyLCBvcmRlcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVuc2UoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4uT2ZEaWFnb25hbEluaXQob3JkZXIsIG9yZGVyLCAoRnVuYzxpbnQsVD4pKGkgPT4gdmFsdWUpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBkZW5zZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCBkaWFnb25hbCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgaW5pdCBmdW5jdGlvbi5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEZW5zZURpYWdvbmFsKGludCByb3dzLCBpbnQgY29sdW1ucywgRnVuYzxpbnQsIFQ+IGluaXQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPi5PZkRpYWdvbmFsSW5pdChyb3dzLCBjb2x1bW5zLCAoRnVuYzxpbnQsVD4paW5pdCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgZGVuc2UgaWRlbnRpdHkgbWF0cml4IHdpdGggYSBvbmUtZGlhZ29uYWwuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gRGVuc2VJZGVudGl0eShpbnQgcm93cywgaW50IGNvbHVtbnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPi5PZkRpYWdvbmFsSW5pdChyb3dzLCBjb2x1bW5zLCAoRnVuYzxpbnQsVD4pKGkgPT4gT25lKSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgZGVuc2UgaWRlbnRpdHkgbWF0cml4IHdpdGggYSBvbmUtZGlhZ29uYWwuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gRGVuc2VJZGVudGl0eShpbnQgb3JkZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPi5PZkRpYWdvbmFsSW5pdChvcmRlciwgb3JkZXIsIChGdW5jPGludCxUPikoaSA9PiBPbmUpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBvdGhlciBtYXRyaXguXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBvdGhlciBtYXRyaXguXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEZW5zZU9mTWF0cml4KE1hdHJpeDxUPiBtYXRyaXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPi5PZk1hdHJpeChtYXRyaXguU3RvcmFnZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdHdvLWRpbWVuc2lvbmFsIGFycmF5LlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgcHJvdmlkZWQgYXJyYXkuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEZW5zZU9mQXJyYXkoVFssXSBhcnJheSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlbnNlKERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+Lk9mQXJyYXkoYXJyYXkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGluZGV4ZWQgZW51bWVyYWJsZS5cclxuICAgICAgICAgICAgLy8vIEtleXMgbXVzdCBiZSBwcm92aWRlZCBhdCBtb3N0IG9uY2UsIHplcm8gaXMgYXNzdW1lZCBpZiBhIGtleSBpcyBvbWl0dGVkLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZS5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERlbnNlT2ZJbmRleGVkKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8VHVwbGU8aW50LCBpbnQsIFQ+PiBlbnVtZXJhYmxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVuc2UoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4uT2ZJbmRleGVkRW51bWVyYWJsZShyb3dzLCBjb2x1bW5zLCBlbnVtZXJhYmxlKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlLlxyXG4gICAgICAgICAgICAvLy8gVGhlIGVudW1lcmFibGUgaXMgYXNzdW1lZCB0byBiZSBpbiBjb2x1bW4tbWFqb3Igb3JkZXIgKGNvbHVtbiBieSBjb2x1bW4pLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZS5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERlbnNlT2ZDb2x1bW5NYWpvcihpbnQgcm93cywgaW50IGNvbHVtbnMsIElFbnVtZXJhYmxlPFQ+IGNvbHVtbk1ham9yKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVuc2UoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4uT2ZDb2x1bW5NYWpvckVudW1lcmFibGUocm93cywgY29sdW1ucywgY29sdW1uTWFqb3IpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGVudW1lcmFibGUgb2YgZW51bWVyYWJsZSBjb2x1bW5zLlxyXG4gICAgICAgICAgICAvLy8gRWFjaCBlbnVtZXJhYmxlIGluIHRoZSBtYXN0ZXIgZW51bWVyYWJsZSBzcGVjaWZpZXMgYSBjb2x1bW4uXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlcy5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERlbnNlT2ZDb2x1bW5zKElFbnVtZXJhYmxlPElFbnVtZXJhYmxlPFQ+PiBkYXRhKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVuc2UoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4uT2ZDb2x1bW5BcnJheXMoU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5TZWxlY3Q8SUVudW1lcmFibGU8VD4sVFtdPihkYXRhLChGdW5jPElFbnVtZXJhYmxlPFQ+LFRbXT4pKHYgPT4gKHYgYXMgVFtdKSA/PyBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlRvQXJyYXk8VD4odikpKS5Ub0FycmF5KCkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGVudW1lcmFibGUgb2YgZW51bWVyYWJsZSBjb2x1bW5zLlxyXG4gICAgICAgICAgICAvLy8gRWFjaCBlbnVtZXJhYmxlIGluIHRoZSBtYXN0ZXIgZW51bWVyYWJsZSBzcGVjaWZpZXMgYSBjb2x1bW4uXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlcy5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERlbnNlT2ZDb2x1bW5zKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8SUVudW1lcmFibGU8VD4+IGRhdGEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPi5PZkNvbHVtbkVudW1lcmFibGVzKHJvd3MsIGNvbHVtbnMsIGRhdGEpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBvZiBUIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gY29sdW1uIGFycmF5cy5cclxuICAgICAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGFycmF5cy5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERlbnNlT2ZDb2x1bW5BcnJheXMocGFyYW1zIFRbXVtdIGNvbHVtbnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPi5PZkNvbHVtbkFycmF5cyhjb2x1bW5zKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggb2YgVCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGNvbHVtbiBhcnJheXMuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheXMuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEZW5zZU9mQ29sdW1uQXJyYXlzKElFbnVtZXJhYmxlPFRbXT4gY29sdW1ucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlbnNlKERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+Lk9mQ29sdW1uQXJyYXlzKChjb2x1bW5zIGFzIFRbXVtdKSA/PyBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlRvQXJyYXk8VFtdPihjb2x1bW5zKSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gY29sdW1uIHZlY3RvcnMuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3JzLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gRGVuc2VPZkNvbHVtblZlY3RvcnMocGFyYW1zIFZlY3RvcjxUPltdIGNvbHVtbnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IFZlY3RvclN0b3JhZ2U8VD5bY29sdW1ucy5MZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBjb2x1bW5zLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VbaV0gPSBjb2x1bW5zW2ldLlN0b3JhZ2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVuc2UoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4uT2ZDb2x1bW5WZWN0b3JzKHN0b3JhZ2UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGNvbHVtbiB2ZWN0b3JzLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9ycy5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERlbnNlT2ZDb2x1bW5WZWN0b3JzKElFbnVtZXJhYmxlPFZlY3RvcjxUPj4gY29sdW1ucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlbnNlKERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+Lk9mQ29sdW1uVmVjdG9ycyhTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlNlbGVjdDxWZWN0b3I8VD4sVmVjdG9yU3RvcmFnZTxUPj4oY29sdW1ucywoRnVuYzxWZWN0b3I8VD4sVmVjdG9yU3RvcmFnZTxUPj4pKGMgPT4gYy5TdG9yYWdlKSkuVG9BcnJheSgpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlLlxyXG4gICAgICAgICAgICAvLy8gVGhlIGVudW1lcmFibGUgaXMgYXNzdW1lZCB0byBiZSBpbiByb3ctbWFqb3Igb3JkZXIgKHJvdyBieSByb3cpLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZS5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERlbnNlT2ZSb3dNYWpvcihpbnQgcm93cywgaW50IGNvbHVtbnMsIElFbnVtZXJhYmxlPFQ+IGNvbHVtbk1ham9yKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVuc2UoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4uT2ZSb3dNYWpvckVudW1lcmFibGUocm93cywgY29sdW1ucywgY29sdW1uTWFqb3IpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGVudW1lcmFibGUgb2YgZW51bWVyYWJsZSByb3dzLlxyXG4gICAgICAgICAgICAvLy8gRWFjaCBlbnVtZXJhYmxlIGluIHRoZSBtYXN0ZXIgZW51bWVyYWJsZSBzcGVjaWZpZXMgYSByb3cuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlcy5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERlbnNlT2ZSb3dzKElFbnVtZXJhYmxlPElFbnVtZXJhYmxlPFQ+PiBkYXRhKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVuc2UoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4uT2ZSb3dBcnJheXMoU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5TZWxlY3Q8SUVudW1lcmFibGU8VD4sVFtdPihkYXRhLChGdW5jPElFbnVtZXJhYmxlPFQ+LFRbXT4pKHYgPT4gKHYgYXMgVFtdKSA/PyBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlRvQXJyYXk8VD4odikpKS5Ub0FycmF5KCkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGVudW1lcmFibGUgb2YgZW51bWVyYWJsZSByb3dzLlxyXG4gICAgICAgICAgICAvLy8gRWFjaCBlbnVtZXJhYmxlIGluIHRoZSBtYXN0ZXIgZW51bWVyYWJsZSBzcGVjaWZpZXMgYSByb3cuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlcy5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERlbnNlT2ZSb3dzKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8SUVudW1lcmFibGU8VD4+IGRhdGEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPi5PZlJvd0VudW1lcmFibGVzKHJvd3MsIGNvbHVtbnMsIGRhdGEpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBvZiBUIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gcm93IGFycmF5cy5cclxuICAgICAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGFycmF5cy5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERlbnNlT2ZSb3dBcnJheXMocGFyYW1zIFRbXVtdIHJvd3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPi5PZlJvd0FycmF5cyhyb3dzKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggb2YgVCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHJvdyBhcnJheXMuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheXMuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEZW5zZU9mUm93QXJyYXlzKElFbnVtZXJhYmxlPFRbXT4gcm93cylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlbnNlKERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+Lk9mUm93QXJyYXlzKChyb3dzIGFzIFRbXVtdKSA/PyBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlRvQXJyYXk8VFtdPihyb3dzKSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gcm93IHZlY3RvcnMuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3JzLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gRGVuc2VPZlJvd1ZlY3RvcnMocGFyYW1zIFZlY3RvcjxUPltdIHJvd3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IFZlY3RvclN0b3JhZ2U8VD5bcm93cy5MZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCByb3dzLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VbaV0gPSByb3dzW2ldLlN0b3JhZ2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVuc2UoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4uT2ZSb3dWZWN0b3JzKHN0b3JhZ2UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHJvdyB2ZWN0b3JzLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9ycy5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERlbnNlT2ZSb3dWZWN0b3JzKElFbnVtZXJhYmxlPFZlY3RvcjxUPj4gcm93cylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlbnNlKERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+Lk9mUm93VmVjdG9ycyhTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlNlbGVjdDxWZWN0b3I8VD4sVmVjdG9yU3RvcmFnZTxUPj4ocm93cywoRnVuYzxWZWN0b3I8VD4sVmVjdG9yU3RvcmFnZTxUPj4pKHIgPT4gci5TdG9yYWdlKSkuVG9BcnJheSgpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggd2l0aCB0aGUgZGlhZ29uYWwgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEZW5zZU9mRGlhZ29uYWxWZWN0b3IoVmVjdG9yPFQ+IGRpYWdvbmFsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IERlbnNlKGRpYWdvbmFsLkNvdW50LCBkaWFnb25hbC5Db3VudCk7XHJcbiAgICAgICAgICAgICAgICBtLlNldERpYWdvbmFsKGRpYWdvbmFsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IHdpdGggdGhlIGRpYWdvbmFsIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9yLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gRGVuc2VPZkRpYWdvbmFsVmVjdG9yKGludCByb3dzLCBpbnQgY29sdW1ucywgVmVjdG9yPFQ+IGRpYWdvbmFsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IERlbnNlKHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgICAgICAgICAgbS5TZXREaWFnb25hbChkaWFnb25hbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCB3aXRoIHRoZSBkaWFnb25hbCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEZW5zZU9mRGlhZ29uYWxBcnJheShUW10gZGlhZ29uYWwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gRGVuc2UoZGlhZ29uYWwuTGVuZ3RoLCBkaWFnb25hbC5MZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgbS5TZXREaWFnb25hbChkaWFnb25hbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCB3aXRoIHRoZSBkaWFnb25hbCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEZW5zZU9mRGlhZ29uYWxBcnJheShpbnQgcm93cywgaW50IGNvbHVtbnMsIFRbXSBkaWFnb25hbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBEZW5zZShyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICAgICAgICAgIG0uU2V0RGlhZ29uYWwoZGlhZ29uYWwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggZnJvbSBhIDJEIGFycmF5IG9mIGV4aXN0aW5nIG1hdHJpY2VzLlxyXG4gICAgICAgICAgICAvLy8gVGhlIG1hdHJpY2VzIGluIHRoZSBhcnJheSBhcmUgbm90IHJlcXVpcmVkIHRvIGJlIGRlbnNlIGFscmVhZHkuXHJcbiAgICAgICAgICAgIC8vLyBJZiB0aGUgbWF0cmljZXMgZG8gbm90IGFsaWduIHByb3Blcmx5LCB0aGV5IGFyZSBwbGFjZWQgb24gdGhlIHRvcCBsZWZ0XHJcbiAgICAgICAgICAgIC8vLyBjb3JuZXIgb2YgdGhlaXIgY2VsbCB3aXRoIHRoZSByZW1haW5pbmcgZmllbGRzIGxlZnQgemVyby5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEZW5zZU9mTWF0cml4QXJyYXkoTWF0cml4PFQ+WyxdIG1hdHJpY2VzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm93c3BhbnMgPSBuZXcgaW50W21hdHJpY2VzLkdldExlbmd0aCgwKV07XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sc3BhbnMgPSBuZXcgaW50W21hdHJpY2VzLkdldExlbmd0aCgxKV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHJvd3NwYW5zLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgY29sc3BhbnMuTGVuZ3RoOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzcGFuc1tpXSA9IE1hdGguTWF4KHJvd3NwYW5zW2ldLCBtYXRyaWNlc1tpLCBqXS5Sb3dDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHNwYW5zW2pdID0gTWF0aC5NYXgoY29sc3BhbnNbal0sIG1hdHJpY2VzW2ksIGpdLkNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IERlbnNlKHJvd3NwYW5zLlN1bSgpLCBjb2xzcGFucy5TdW0oKSk7XHJcbiAgICAgICAgICAgICAgICBpbnQgcm93b2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcm93c3BhbnMuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGNvbG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBjb2xzcGFucy5MZW5ndGg7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uU2V0U3ViTWF0cml4KHJvd29mZnNldCwgY29sb2Zmc2V0LCBtYXRyaWNlc1tpLCBqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9mZnNldCArPSBjb2xzcGFuc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcm93b2Zmc2V0ICs9IHJvd3NwYW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IHN0cmFpZ2h0IGZyb20gYW4gaW5pdGlhbGl6ZWQgbWF0cml4IHN0b3JhZ2UgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgIC8vLyBUaGUgc3RvcmFnZSBpcyB1c2VkIGRpcmVjdGx5IHdpdGhvdXQgY29weWluZy5cclxuICAgICAgICAgICAgLy8vIEludGVuZGVkIGZvciBhZHZhbmNlZCBzY2VuYXJpb3Mgd2hlcmUgeW91J3JlIHdvcmtpbmcgZGlyZWN0bHkgd2l0aFxyXG4gICAgICAgICAgICAvLy8gc3RvcmFnZSBmb3IgcGVyZm9ybWFuY2Ugb3IgaW50ZXJvcCByZWFzb25zLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgYWJzdHJhY3QgTWF0cml4PFQ+IFNwYXJzZShTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPiBzdG9yYWdlKTtcclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIHNwYXJzZSBtYXRyaXggb2YgVCB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucy5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm93c1wiPlRoZSBudW1iZXIgb2Ygcm93cy48L3BhcmFtPlxyXG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb2x1bW5zXCI+VGhlIG51bWJlciBvZiBjb2x1bW5zLjwvcGFyYW0+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3BhcnNlKGludCByb3dzLCBpbnQgY29sdW1ucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNwYXJzZShuZXcgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4ocm93cywgY29sdW1ucykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhbmQgaW5pdGlhbGl6ZSBlYWNoIHZhbHVlIHRvIHRoZSBzYW1lIHByb3ZpZGVkIHZhbHVlLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFNwYXJzZShpbnQgcm93cywgaW50IGNvbHVtbnMsIFQgdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChaZXJvLkVxdWFscyh2YWx1ZSkpIHJldHVybiBTcGFyc2Uocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3BhcnNlKFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+Lk9mVmFsdWUocm93cywgY29sdW1ucywgdmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgaW5pdCBmdW5jdGlvbi5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2UoaW50IHJvd3MsIGludCBjb2x1bW5zLCBGdW5jPGludCwgaW50LCBUPiBpbml0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3BhcnNlKFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+Lk9mSW5pdChyb3dzLCBjb2x1bW5zLCAoRnVuYzxpbnQsaW50LFQ+KWluaXQpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIHNwYXJzZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCBkaWFnb25hbCB2YWx1ZSB0byB0aGUgc2FtZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2VEaWFnb25hbChpbnQgcm93cywgaW50IGNvbHVtbnMsIFQgdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChaZXJvLkVxdWFscyh2YWx1ZSkpIHJldHVybiBTcGFyc2Uocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3BhcnNlKFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+Lk9mRGlhZ29uYWxJbml0KHJvd3MsIGNvbHVtbnMsIChGdW5jPGludCxUPikoaSA9PiB2YWx1ZSkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIHNwYXJzZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCBkaWFnb25hbCB2YWx1ZSB0byB0aGUgc2FtZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2VEaWFnb25hbChpbnQgb3JkZXIsIFQgdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChaZXJvLkVxdWFscyh2YWx1ZSkpIHJldHVybiBTcGFyc2Uob3JkZXIsIG9yZGVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4uT2ZEaWFnb25hbEluaXQob3JkZXIsIG9yZGVyLCAoRnVuYzxpbnQsVD4pKGkgPT4gdmFsdWUpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBzcGFyc2UgbWF0cml4IGFuZCBpbml0aWFsaXplIGVhY2ggZGlhZ29uYWwgdmFsdWUgdXNpbmcgdGhlIHByb3ZpZGVkIGluaXQgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3BhcnNlRGlhZ29uYWwoaW50IHJvd3MsIGludCBjb2x1bW5zLCBGdW5jPGludCwgVD4gaW5pdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNwYXJzZShTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPi5PZkRpYWdvbmFsSW5pdChyb3dzLCBjb2x1bW5zLCAoRnVuYzxpbnQsVD4paW5pdCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgZGVuc2UgaWRlbnRpdHkgbWF0cml4IHdpdGggYSBvbmUtZGlhZ29uYWwuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3BhcnNlSWRlbnRpdHkoaW50IHJvd3MsIGludCBjb2x1bW5zKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3BhcnNlKFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+Lk9mRGlhZ29uYWxJbml0KHJvd3MsIGNvbHVtbnMsIChGdW5jPGludCxUPikoaSA9PiBPbmUpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBkZW5zZSBpZGVudGl0eSBtYXRyaXggd2l0aCBhIG9uZS1kaWFnb25hbC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2VJZGVudGl0eShpbnQgb3JkZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4uT2ZEaWFnb25hbEluaXQob3JkZXIsIG9yZGVyLCAoRnVuYzxpbnQsVD4pKGkgPT4gT25lKSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIG90aGVyIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIG90aGVyIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFNwYXJzZU9mTWF0cml4KE1hdHJpeDxUPiBtYXRyaXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4uT2ZNYXRyaXgobWF0cml4LlN0b3JhZ2UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiB0d28tZGltZW5zaW9uYWwgYXJyYXkuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBwcm92aWRlZCBhcnJheS5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFNwYXJzZU9mQXJyYXkoVFssXSBhcnJheSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNwYXJzZShTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPi5PZkFycmF5KGFycmF5KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gaW5kZXhlZCBlbnVtZXJhYmxlLlxyXG4gICAgICAgICAgICAvLy8gS2V5cyBtdXN0IGJlIHByb3ZpZGVkIGF0IG1vc3Qgb25jZSwgemVybyBpcyBhc3N1bWVkIGlmIGEga2V5IGlzIG9taXR0ZWQuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3BhcnNlT2ZJbmRleGVkKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8VHVwbGU8aW50LCBpbnQsIFQ+PiBlbnVtZXJhYmxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3BhcnNlKFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+Lk9mSW5kZXhlZEVudW1lcmFibGUocm93cywgY29sdW1ucywgZW51bWVyYWJsZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGVudW1lcmFibGUuXHJcbiAgICAgICAgICAgIC8vLyBUaGUgZW51bWVyYWJsZSBpcyBhc3N1bWVkIHRvIGJlIGluIHJvdy1tYWpvciBvcmRlciAocm93IGJ5IHJvdykuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyA8c2VlYWxzbyBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb3ctbWFqb3Jfb3JkZXJcIi8+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3BhcnNlT2ZSb3dNYWpvcihpbnQgcm93cywgaW50IGNvbHVtbnMsIElFbnVtZXJhYmxlPFQ+IHJvd01ham9yKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3BhcnNlKFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+Lk9mUm93TWFqb3JFbnVtZXJhYmxlKHJvd3MsIGNvbHVtbnMsIHJvd01ham9yKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IHdpdGggdGhlIGdpdmVuIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gYXJyYXkuXHJcbiAgICAgICAgICAgIC8vLyBUaGUgYXJyYXkgaXMgYXNzdW1lZCB0byBiZSBpbiBjb2x1bW4tbWFqb3Igb3JkZXIgKGNvbHVtbiBieSBjb2x1bW4pLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgcHJvdmlkZWQgYXJyYXkuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIDxzZWVhbHNvIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jvdy1tYWpvcl9vcmRlclwiLz5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2VPZkNvbHVtbk1ham9yKGludCByb3dzLCBpbnQgY29sdW1ucywgSUxpc3Q8VD4gY29sdW1uTWFqb3IpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4uT2ZDb2x1bW5NYWpvckxpc3Qocm93cywgY29sdW1ucywgY29sdW1uTWFqb3IpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlIG9mIGVudW1lcmFibGUgY29sdW1ucy5cclxuICAgICAgICAgICAgLy8vIEVhY2ggZW51bWVyYWJsZSBpbiB0aGUgbWFzdGVyIGVudW1lcmFibGUgc3BlY2lmaWVzIGEgY29sdW1uLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZXMuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2VPZkNvbHVtbnMoSUVudW1lcmFibGU8SUVudW1lcmFibGU8VD4+IGRhdGEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4uT2ZDb2x1bW5BcnJheXMoU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5TZWxlY3Q8SUVudW1lcmFibGU8VD4sVFtdPihkYXRhLChGdW5jPElFbnVtZXJhYmxlPFQ+LFRbXT4pKHYgPT4gKHYgYXMgVFtdKSA/PyBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlRvQXJyYXk8VD4odikpKS5Ub0FycmF5KCkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlIG9mIGVudW1lcmFibGUgY29sdW1ucy5cclxuICAgICAgICAgICAgLy8vIEVhY2ggZW51bWVyYWJsZSBpbiB0aGUgbWFzdGVyIGVudW1lcmFibGUgc3BlY2lmaWVzIGEgY29sdW1uLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZXMuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2VPZkNvbHVtbnMoaW50IHJvd3MsIGludCBjb2x1bW5zLCBJRW51bWVyYWJsZTxJRW51bWVyYWJsZTxUPj4gZGF0YSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNwYXJzZShTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPi5PZkNvbHVtbkVudW1lcmFibGVzKHJvd3MsIGNvbHVtbnMsIGRhdGEpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBjb2x1bW4gYXJyYXlzLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXlzLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3BhcnNlT2ZDb2x1bW5BcnJheXMocGFyYW1zIFRbXVtdIGNvbHVtbnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4uT2ZDb2x1bW5BcnJheXMoY29sdW1ucykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGNvbHVtbiBhcnJheXMuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheXMuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2VPZkNvbHVtbkFycmF5cyhJRW51bWVyYWJsZTxUW10+IGNvbHVtbnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4uT2ZDb2x1bW5BcnJheXMoKGNvbHVtbnMgYXMgVFtdW10pID8/IFN5c3RlbS5MaW5xLkVudW1lcmFibGUuVG9BcnJheTxUW10+KGNvbHVtbnMpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gY29sdW1uIHZlY3RvcnMuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3JzLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3BhcnNlT2ZDb2x1bW5WZWN0b3JzKHBhcmFtcyBWZWN0b3I8VD5bXSBjb2x1bW5zKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBWZWN0b3JTdG9yYWdlPFQ+W2NvbHVtbnMuTGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgY29sdW1ucy5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlW2ldID0gY29sdW1uc1tpXS5TdG9yYWdlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNwYXJzZShTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPi5PZkNvbHVtblZlY3RvcnMoc3RvcmFnZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGNvbHVtbiB2ZWN0b3JzLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9ycy5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFNwYXJzZU9mQ29sdW1uVmVjdG9ycyhJRW51bWVyYWJsZTxWZWN0b3I8VD4+IGNvbHVtbnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4uT2ZDb2x1bW5WZWN0b3JzKFN5c3RlbS5MaW5xLkVudW1lcmFibGUuU2VsZWN0PFZlY3RvcjxUPixWZWN0b3JTdG9yYWdlPFQ+Pihjb2x1bW5zLChGdW5jPFZlY3RvcjxUPixWZWN0b3JTdG9yYWdlPFQ+PikoYyA9PiBjLlN0b3JhZ2UpKS5Ub0FycmF5KCkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlIG9mIGVudW1lcmFibGUgcm93cy5cclxuICAgICAgICAgICAgLy8vIEVhY2ggZW51bWVyYWJsZSBpbiB0aGUgbWFzdGVyIGVudW1lcmFibGUgc3BlY2lmaWVzIGEgcm93LlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZXMuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2VPZlJvd3MoSUVudW1lcmFibGU8SUVudW1lcmFibGU8VD4+IGRhdGEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4uT2ZSb3dBcnJheXMoU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5TZWxlY3Q8SUVudW1lcmFibGU8VD4sVFtdPihkYXRhLChGdW5jPElFbnVtZXJhYmxlPFQ+LFRbXT4pKHYgPT4gKHYgYXMgVFtdKSA/PyBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlRvQXJyYXk8VD4odikpKS5Ub0FycmF5KCkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlIG9mIGVudW1lcmFibGUgcm93cy5cclxuICAgICAgICAgICAgLy8vIEVhY2ggZW51bWVyYWJsZSBpbiB0aGUgbWFzdGVyIGVudW1lcmFibGUgc3BlY2lmaWVzIGEgcm93LlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZXMuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2VPZlJvd3MoaW50IHJvd3MsIGludCBjb2x1bW5zLCBJRW51bWVyYWJsZTxJRW51bWVyYWJsZTxUPj4gZGF0YSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNwYXJzZShTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPi5PZlJvd0VudW1lcmFibGVzKHJvd3MsIGNvbHVtbnMsIGRhdGEpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiByb3cgYXJyYXlzLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXlzLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3BhcnNlT2ZSb3dBcnJheXMocGFyYW1zIFRbXVtdIHJvd3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4uT2ZSb3dBcnJheXMocm93cykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHJvdyBhcnJheXMuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheXMuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2VPZlJvd0FycmF5cyhJRW51bWVyYWJsZTxUW10+IHJvd3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4uT2ZSb3dBcnJheXMoKHJvd3MgYXMgVFtdW10pID8/IFN5c3RlbS5MaW5xLkVudW1lcmFibGUuVG9BcnJheTxUW10+KHJvd3MpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gcm93IHZlY3RvcnMuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3JzLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3BhcnNlT2ZSb3dWZWN0b3JzKHBhcmFtcyBWZWN0b3I8VD5bXSByb3dzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBWZWN0b3JTdG9yYWdlPFQ+W3Jvd3MuTGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcm93cy5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlW2ldID0gcm93c1tpXS5TdG9yYWdlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNwYXJzZShTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPi5PZlJvd1ZlY3RvcnMoc3RvcmFnZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHJvdyB2ZWN0b3JzLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9ycy5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFNwYXJzZU9mUm93VmVjdG9ycyhJRW51bWVyYWJsZTxWZWN0b3I8VD4+IHJvd3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4uT2ZSb3dWZWN0b3JzKFN5c3RlbS5MaW5xLkVudW1lcmFibGUuU2VsZWN0PFZlY3RvcjxUPixWZWN0b3JTdG9yYWdlPFQ+Pihyb3dzLChGdW5jPFZlY3RvcjxUPixWZWN0b3JTdG9yYWdlPFQ+PikociA9PiByLlN0b3JhZ2UpKS5Ub0FycmF5KCkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggd2l0aCB0aGUgZGlhZ29uYWwgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2VPZkRpYWdvbmFsVmVjdG9yKFZlY3RvcjxUPiBkaWFnb25hbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBTcGFyc2UoZGlhZ29uYWwuQ291bnQsIGRpYWdvbmFsLkNvdW50KTtcclxuICAgICAgICAgICAgICAgIG0uU2V0RGlhZ29uYWwoZGlhZ29uYWwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IHdpdGggdGhlIGRpYWdvbmFsIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9yLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3BhcnNlT2ZEaWFnb25hbFZlY3RvcihpbnQgcm93cywgaW50IGNvbHVtbnMsIFZlY3RvcjxUPiBkaWFnb25hbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBTcGFyc2Uocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgICAgICBtLlNldERpYWdvbmFsKGRpYWdvbmFsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCB3aXRoIHRoZSBkaWFnb25hbCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2VPZkRpYWdvbmFsQXJyYXkoVFtdIGRpYWdvbmFsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IFNwYXJzZShkaWFnb25hbC5MZW5ndGgsIGRpYWdvbmFsLkxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBtLlNldERpYWdvbmFsKGRpYWdvbmFsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCB3aXRoIHRoZSBkaWFnb25hbCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBTcGFyc2VPZkRpYWdvbmFsQXJyYXkoaW50IHJvd3MsIGludCBjb2x1bW5zLCBUW10gZGlhZ29uYWwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gU3BhcnNlKHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgICAgICAgICAgbS5TZXREaWFnb25hbChkaWFnb25hbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggZnJvbSBhIDJEIGFycmF5IG9mIGV4aXN0aW5nIG1hdHJpY2VzLlxyXG4gICAgICAgICAgICAvLy8gVGhlIG1hdHJpY2VzIGluIHRoZSBhcnJheSBhcmUgbm90IHJlcXVpcmVkIHRvIGJlIHNwYXJzZSBhbHJlYWR5LlxyXG4gICAgICAgICAgICAvLy8gSWYgdGhlIG1hdHJpY2VzIGRvIG5vdCBhbGlnbiBwcm9wZXJseSwgdGhleSBhcmUgcGxhY2VkIG9uIHRoZSB0b3AgbGVmdFxyXG4gICAgICAgICAgICAvLy8gY29ybmVyIG9mIHRoZWlyIGNlbGwgd2l0aCB0aGUgcmVtYWluaW5nIGZpZWxkcyBsZWZ0IHplcm8uXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gU3BhcnNlT2ZNYXRyaXhBcnJheShNYXRyaXg8VD5bLF0gbWF0cmljZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3dzcGFucyA9IG5ldyBpbnRbbWF0cmljZXMuR2V0TGVuZ3RoKDApXTtcclxuICAgICAgICAgICAgICAgIHZhciBjb2xzcGFucyA9IG5ldyBpbnRbbWF0cmljZXMuR2V0TGVuZ3RoKDEpXTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcm93c3BhbnMuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBjb2xzcGFucy5MZW5ndGg7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3NwYW5zW2ldID0gTWF0aC5NYXgocm93c3BhbnNbaV0sIG1hdHJpY2VzW2ksIGpdLlJvd0NvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sc3BhbnNbal0gPSBNYXRoLk1heChjb2xzcGFuc1tqXSwgbWF0cmljZXNbaSwgal0uQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBtID0gU3BhcnNlKHJvd3NwYW5zLlN1bSgpLCBjb2xzcGFucy5TdW0oKSk7XHJcbiAgICAgICAgICAgICAgICBpbnQgcm93b2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcm93c3BhbnMuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGNvbG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBjb2xzcGFucy5MZW5ndGg7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uU2V0U3ViTWF0cml4KHJvd29mZnNldCwgY29sb2Zmc2V0LCBtYXRyaWNlc1tpLCBqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9mZnNldCArPSBjb2xzcGFuc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcm93b2Zmc2V0ICs9IHJvd3NwYW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBtYXRyaXggc3RyYWlnaHQgZnJvbSBhbiBpbml0aWFsaXplZCBtYXRyaXggc3RvcmFnZSBpbnN0YW5jZS5cclxuICAgICAgICAgICAgLy8vIFRoZSBzdG9yYWdlIGlzIHVzZWQgZGlyZWN0bHkgd2l0aG91dCBjb3B5aW5nLlxyXG4gICAgICAgICAgICAvLy8gSW50ZW5kZWQgZm9yIGFkdmFuY2VkIHNjZW5hcmlvcyB3aGVyZSB5b3UncmUgd29ya2luZyBkaXJlY3RseSB3aXRoXHJcbiAgICAgICAgICAgIC8vLyBzdG9yYWdlIGZvciBwZXJmb3JtYW5jZSBvciBpbnRlcm9wIHJlYXNvbnMuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBhYnN0cmFjdCBNYXRyaXg8VD4gRGlhZ29uYWwoRGlhZ29uYWxNYXRyaXhTdG9yYWdlPFQ+IHN0b3JhZ2UpO1xyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucy5cclxuICAgICAgICAgICAgLy8vIEFsbCBjZWxscyBvZiB0aGUgbWF0cml4IHdpbGwgYmUgaW5pdGlhbGl6ZWQgdG8gemVyby5cclxuICAgICAgICAgICAgLy8vIFplcm8tbGVuZ3RoIG1hdHJpY2VzIGFyZSBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERpYWdvbmFsKGludCByb3dzLCBpbnQgY29sdW1ucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERpYWdvbmFsKG5ldyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VD4ocm93cywgY29sdW1ucykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgbWF0cml4IHdpdGggdGhlIGdpdmVuIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIGRpcmVjdGx5IGJpbmRpbmcgdG8gYSByYXcgYXJyYXkuXHJcbiAgICAgICAgICAgIC8vLyBUaGUgYXJyYXkgaXMgYXNzdW1lZCB0byByZXByZXNlbnQgdGhlIGRpYWdvbmFsIHZhbHVlcyBhbmQgaXMgdXNlZCBkaXJlY3RseSB3aXRob3V0IGNvcHlpbmcuXHJcbiAgICAgICAgICAgIC8vLyBWZXJ5IGVmZmljaWVudCwgYnV0IGNoYW5nZXMgdG8gdGhlIGFycmF5IGFuZCB0aGUgbWF0cml4IHdpbGwgYWZmZWN0IGVhY2ggb3RoZXIuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gRGlhZ29uYWwoaW50IHJvd3MsIGludCBjb2x1bW5zLCBUW10gc3RvcmFnZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERpYWdvbmFsKG5ldyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VD4ocm93cywgY29sdW1ucywgc3RvcmFnZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3F1YXJlIGRpYWdvbmFsIG1hdHJpeCBkaXJlY3RseSBiaW5kaW5nIHRvIGEgcmF3IGFycmF5LlxyXG4gICAgICAgICAgICAvLy8gVGhlIGFycmF5IGlzIGFzc3VtZWQgdG8gcmVwcmVzZW50IHRoZSBkaWFnb25hbCB2YWx1ZXMgYW5kIGlzIHVzZWQgZGlyZWN0bHkgd2l0aG91dCBjb3B5aW5nLlxyXG4gICAgICAgICAgICAvLy8gVmVyeSBlZmZpY2llbnQsIGJ1dCBjaGFuZ2VzIHRvIHRoZSBhcnJheSBhbmQgdGhlIG1hdHJpeCB3aWxsIGFmZmVjdCBlYWNoIG90aGVyLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERpYWdvbmFsKFRbXSBzdG9yYWdlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGlhZ29uYWwobmV3IERpYWdvbmFsTWF0cml4U3RvcmFnZTxUPihzdG9yYWdlLkxlbmd0aCwgc3RvcmFnZS5MZW5ndGgsIHN0b3JhZ2UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIG1hdHJpeCBhbmQgaW5pdGlhbGl6ZSBlYWNoIGRpYWdvbmFsIHZhbHVlIHRvIHRoZSBzYW1lIHByb3ZpZGVkIHZhbHVlLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERpYWdvbmFsKGludCByb3dzLCBpbnQgY29sdW1ucywgVCB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKFplcm8uRXF1YWxzKHZhbHVlKSkgcmV0dXJuIERpYWdvbmFsKHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERpYWdvbmFsKERpYWdvbmFsTWF0cml4U3RvcmFnZTxUPi5PZlZhbHVlKHJvd3MsIGNvbHVtbnMsIHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCBkaWFnb25hbCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgaW5pdCBmdW5jdGlvbi5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEaWFnb25hbChpbnQgcm93cywgaW50IGNvbHVtbnMsIEZ1bmM8aW50LCBUPiBpbml0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGlhZ29uYWwoRGlhZ29uYWxNYXRyaXhTdG9yYWdlPFQ+Lk9mSW5pdChyb3dzLCBjb2x1bW5zLCAoRnVuYzxpbnQsVD4paW5pdCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgaWRlbnRpdHkgbWF0cml4IHdpdGggYSBvbmUtZGlhZ29uYWwuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gRGlhZ29uYWxJZGVudGl0eShpbnQgcm93cywgaW50IGNvbHVtbnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEaWFnb25hbChEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VD4uT2ZWYWx1ZShyb3dzLCBjb2x1bW5zLCBPbmUpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIGlkZW50aXR5IG1hdHJpeCB3aXRoIGEgb25lLWRpYWdvbmFsLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IERpYWdvbmFsSWRlbnRpdHkoaW50IG9yZGVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGlhZ29uYWwoRGlhZ29uYWxNYXRyaXhTdG9yYWdlPFQ+Lk9mVmFsdWUob3JkZXIsIG9yZGVyLCBPbmUpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBtYXRyaXggd2l0aCB0aGUgZGlhZ29uYWwgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEaWFnb25hbE9mRGlhZ29uYWxWZWN0b3IoVmVjdG9yPFQ+IGRpYWdvbmFsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IERpYWdvbmFsKGRpYWdvbmFsLkNvdW50LCBkaWFnb25hbC5Db3VudCk7XHJcbiAgICAgICAgICAgICAgICBtLlNldERpYWdvbmFsKGRpYWdvbmFsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgbWF0cml4IHdpdGggdGhlIGRpYWdvbmFsIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9yLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gRGlhZ29uYWxPZkRpYWdvbmFsVmVjdG9yKGludCByb3dzLCBpbnQgY29sdW1ucywgVmVjdG9yPFQ+IGRpYWdvbmFsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IERpYWdvbmFsKHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgICAgICAgICAgbS5TZXREaWFnb25hbChkaWFnb25hbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIG1hdHJpeCB3aXRoIHRoZSBkaWFnb25hbCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEaWFnb25hbE9mRGlhZ29uYWxBcnJheShUW10gZGlhZ29uYWwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gRGlhZ29uYWwoZGlhZ29uYWwuTGVuZ3RoLCBkaWFnb25hbC5MZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgbS5TZXREaWFnb25hbChkaWFnb25hbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIG1hdHJpeCB3aXRoIHRoZSBkaWFnb25hbCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIE1hdHJpeDxUPiBEaWFnb25hbE9mRGlhZ29uYWxBcnJheShpbnQgcm93cywgaW50IGNvbHVtbnMsIFRbXSBkaWFnb25hbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBEaWFnb25hbChyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICAgICAgICAgIG0uU2V0RGlhZ29uYWwoZGlhZ29uYWwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZW5lcmljIGxpbmVhciBhbGdlYnJhIHR5cGUgYnVpbGRlciwgZm9yIHNpdHVhdGlvbnMgd2hlcmUgYSBtYXRyaXggb3IgdmVjdG9yXHJcbiAgICAgICAgLy8vIG11c3QgYmUgY3JlYXRlZCBpbiBhIGdlbmVyaWMgd2F5LiBVc2FnZSBvZiBnZW5lcmljIGJ1aWxkZXJzIHNob3VsZCBub3QgYmVcclxuICAgICAgICAvLy8gcmVxdWlyZWQgaW4gbm9ybWFsIHVzZXIgY29kZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBjbGFzcyBWZWN0b3JCdWlsZGVyPFQ+IHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gR2V0cyB0aGUgdmFsdWUgb2YgPGM+MC4wPC9jPiBmb3IgdHlwZSBULlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgYWJzdHJhY3QgVCBaZXJvIHsgZ2V0OyB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBHZXRzIHRoZSB2YWx1ZSBvZiA8Yz4xLjA8L2M+IGZvciB0eXBlIFQuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBhYnN0cmFjdCBUIE9uZSB7IGdldDsgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHZlY3RvciBzdHJhaWdodCBmcm9tIGFuIGluaXRpYWxpemVkIG1hdHJpeCBzdG9yYWdlIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAvLy8gSWYgeW91IGhhdmUgYW4gaW5zdGFuY2Ugb2YgYSBkaXNjcmV0ZSBzdG9yYWdlIHR5cGUgaW5zdGVhZCwgdXNlIHRoZWlyIGRpcmVjdCBtZXRob2RzIGluc3RlYWQuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gT2ZTdG9yYWdlKFZlY3RvclN0b3JhZ2U8VD4gc3RvcmFnZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UgPT0gbnVsbCkgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInN0b3JhZ2VcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRlbnNlID0gc3RvcmFnZSBhcyBEZW5zZVZlY3RvclN0b3JhZ2U8VD47XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVuc2UgIT0gbnVsbCkgcmV0dXJuIERlbnNlKGRlbnNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc3BhcnNlID0gc3RvcmFnZSBhcyBTcGFyc2VWZWN0b3JTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwYXJzZSAhPSBudWxsKSByZXR1cm4gU3BhcnNlKHNwYXJzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEV4Y2VwdGlvbihzdHJpbmcuRm9ybWF0KFwiVmVjdG9yIHN0b3JhZ2UgdHlwZSAnezB9JyBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5IERlbnNlVmVjdG9yU3RvcmFnZSBhbmQgU3BhcnNlVmVjdG9yU3RvcmFnZSBhcmUgc3VwcG9ydGVkIGFzIHRoaXMgcG9pbnQuXCIsIHN0b3JhZ2UuR2V0VHlwZSgpLk5hbWUpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHZlY3RvciB3aXRoIHRoZSBzYW1lIGtpbmQgb2YgdGhlIHByb3ZpZGVkIGV4YW1wbGUuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gU2FtZUFzPFRVPihWZWN0b3I8VFU+IGV4YW1wbGUsIGludCBsZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB3aGVyZSBUVSA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUVT4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhhbXBsZS5TdG9yYWdlLklzRGVuc2UgPyBEZW5zZShsZW5ndGgpIDogU3BhcnNlKGxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyB2ZWN0b3Igd2l0aCB0aGUgc2FtZSBraW5kIGFuZCBkaW1lbnNpb24gb2YgdGhlIHByb3ZpZGVkIGV4YW1wbGUuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gU2FtZUFzPFRVPihWZWN0b3I8VFU+IGV4YW1wbGUpXHJcbiAgICAgICAgICAgICAgICB3aGVyZSBUVSA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUVT4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhhbXBsZS5TdG9yYWdlLklzRGVuc2UgPyBEZW5zZShleGFtcGxlLkNvdW50KSA6IFNwYXJzZShleGFtcGxlLkNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHZlY3RvciB3aXRoIHRoZSBzYW1lIGtpbmQgb2YgdGhlIHByb3ZpZGVkIGV4YW1wbGUuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gU2FtZUFzPFRVPihNYXRyaXg8VFU+IGV4YW1wbGUsIGludCBsZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB3aGVyZSBUVSA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUVT4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhhbXBsZS5TdG9yYWdlLklzRGVuc2UgPyBEZW5zZShsZW5ndGgpIDogU3BhcnNlKGxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyB2ZWN0b3Igd2l0aCBhIHR5cGUgdGhhdCBjYW4gcmVwcmVzZW50IGFuZCBpcyBjbG9zZXN0IHRvIGJvdGggcHJvdmlkZWQgc2FtcGxlcy5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIFZlY3RvcjxUPiBTYW1lQXMoVmVjdG9yPFQ+IGV4YW1wbGUsIFZlY3RvcjxUPiBvdGhlckV4YW1wbGUsIGludCBsZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBleGFtcGxlLlN0b3JhZ2UuSXNEZW5zZSB8fCBvdGhlckV4YW1wbGUuU3RvcmFnZS5Jc0RlbnNlID8gRGVuc2UobGVuZ3RoKSA6IFNwYXJzZShsZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgdmVjdG9yIHdpdGggYSB0eXBlIHRoYXQgY2FuIHJlcHJlc2VudCBhbmQgaXMgY2xvc2VzdCB0byBib3RoIHByb3ZpZGVkIHNhbXBsZXMgYW5kIHRoZSBkaW1lbnNpb25zIG9mIGV4YW1wbGUuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gU2FtZUFzKFZlY3RvcjxUPiBleGFtcGxlLCBWZWN0b3I8VD4gb3RoZXJFeGFtcGxlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhhbXBsZS5TdG9yYWdlLklzRGVuc2UgfHwgb3RoZXJFeGFtcGxlLlN0b3JhZ2UuSXNEZW5zZSA/IERlbnNlKGV4YW1wbGUuQ291bnQpIDogU3BhcnNlKGV4YW1wbGUuQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgdmVjdG9yIHdpdGggYSB0eXBlIHRoYXQgY2FuIHJlcHJlc2VudCBhbmQgaXMgY2xvc2VzdCB0byBib3RoIHByb3ZpZGVkIHNhbXBsZXMuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gU2FtZUFzKE1hdHJpeDxUPiBtYXRyaXgsIFZlY3RvcjxUPiB2ZWN0b3IsIGludCBsZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRyaXguU3RvcmFnZS5Jc0RlbnNlIHx8IHZlY3Rvci5TdG9yYWdlLklzRGVuc2UgPyBEZW5zZShsZW5ndGgpIDogU3BhcnNlKGxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3Igd2l0aCB2YWx1ZXMgc2FtcGxlZCBmcm9tIHRoZSBwcm92aWRlZCByYW5kb20gZGlzdHJpYnV0aW9uLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICAvL3B1YmxpYyBhYnN0cmFjdCBWZWN0b3I8VD4gUmFuZG9tKGludCBsZW5ndGgsIElDb250aW51b3VzRGlzdHJpYnV0aW9uIGRpc3RyaWJ1dGlvbik7XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgdmVjdG9yIHdpdGggdmFsdWVzIHNhbXBsZWQgZnJvbSB0aGUgc3RhbmRhcmQgZGlzdHJpYnV0aW9uIHdpdGggYSBzeXN0ZW0gcmFuZG9tIHNvdXJjZS5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgLyogcHVibGljIFZlY3RvcjxUPiBSYW5kb20oaW50IGxlbmd0aClcclxuICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICByZXR1cm4gUmFuZG9tKGxlbmd0aCwgbmV3IE5vcm1hbChTeXN0ZW1SYW5kb21Tb3VyY2UuRGVmYXVsdCkpO1xyXG4gICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIHZlY3RvciB3aXRoIHZhbHVlcyBzYW1wbGVkIGZyb20gdGhlIHN0YW5kYXJkIGRpc3RyaWJ1dGlvbiB3aXRoIGEgc3lzdGVtIHJhbmRvbSBzb3VyY2UuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gUmFuZG9tKGludCBsZW5ndGgsIGludCBzZWVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUmFuZG9tKGxlbmd0aCwgbmV3IE5vcm1hbChuZXcgU3lzdGVtUmFuZG9tU291cmNlKHNlZWQsIHRydWUpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIHZlY3RvciBzdHJhaWdodCBmcm9tIGFuIGluaXRpYWxpemVkIHZlY3RvciBzdG9yYWdlIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAvLy8gVGhlIHN0b3JhZ2UgaXMgdXNlZCBkaXJlY3RseSB3aXRob3V0IGNvcHlpbmcuXHJcbiAgICAgICAgICAgIC8vLyBJbnRlbmRlZCBmb3IgYWR2YW5jZWQgc2NlbmFyaW9zIHdoZXJlIHlvdSdyZSB3b3JraW5nIGRpcmVjdGx5IHdpdGhcclxuICAgICAgICAgICAgLy8vIHN0b3JhZ2UgZm9yIHBlcmZvcm1hbmNlIG9yIGludGVyb3AgcmVhc29ucy5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIGFic3RyYWN0IFZlY3RvcjxUPiBEZW5zZShEZW5zZVZlY3RvclN0b3JhZ2U8VD4gc3RvcmFnZSk7XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBkZW5zZSB2ZWN0b3Igb2YgVCB3aXRoIHRoZSBnaXZlbiBzaXplLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzaXplXCI+VGhlIHNpemUgb2YgdGhlIHZlY3Rvci48L3BhcmFtPlxyXG4gICAgICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IERlbnNlKGludCBzaXplKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVuc2UobmV3IERlbnNlVmVjdG9yU3RvcmFnZTxUPihzaXplKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIGRlbnNlIHZlY3RvciBvZiBUIHRoYXQgaXMgZGlyZWN0bHkgYm91bmQgdG8gdGhlIHNwZWNpZmllZCBhcnJheS5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIFZlY3RvcjxUPiBEZW5zZShUW10gYXJyYXkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShuZXcgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+KGFycmF5Lkxlbmd0aCwgYXJyYXkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIHZlY3RvciBhbmQgaW5pdGlhbGl6ZSBlYWNoIHZhbHVlIHVzaW5nIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIFZlY3RvcjxUPiBEZW5zZShpbnQgbGVuZ3RoLCBUIHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoWmVyby5FcXVhbHModmFsdWUpKSByZXR1cm4gRGVuc2UobGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShEZW5zZVZlY3RvclN0b3JhZ2U8VD4uT2ZWYWx1ZShsZW5ndGgsIHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3IgYW5kIGluaXRpYWxpemUgZWFjaCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgaW5pdCBmdW5jdGlvbi5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIFZlY3RvcjxUPiBEZW5zZShpbnQgbGVuZ3RoLCBGdW5jPGludCwgVD4gaW5pdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlbnNlKERlbnNlVmVjdG9yU3RvcmFnZTxUPi5PZkluaXQobGVuZ3RoLCAoRnVuYzxpbnQsVD4paW5pdCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgdmVjdG9yIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gb3RoZXIgdmVjdG9yLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgdmVjdG9yIHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgb3RoZXIgdmVjdG9yLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gRGVuc2VPZlZlY3RvcihWZWN0b3I8VD4gdmVjdG9yKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVuc2UoRGVuc2VWZWN0b3JTdG9yYWdlPFQ+Lk9mVmVjdG9yKHZlY3Rvci5TdG9yYWdlKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3IgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBhcnJheS5cclxuICAgICAgICAgICAgLy8vIFRoaXMgbmV3IHZlY3RvciB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gRGVuc2VPZkFycmF5KFRbXSBhcnJheSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlbnNlKERlbnNlVmVjdG9yU3RvcmFnZTxUPi5PZlZlY3RvcihuZXcgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+KGFycmF5Lkxlbmd0aCwgYXJyYXkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3IgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgdmVjdG9yIHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZS5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgdmVjdG9yLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IERlbnNlT2ZFbnVtZXJhYmxlKElFbnVtZXJhYmxlPFQ+IGVudW1lcmFibGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShEZW5zZVZlY3RvclN0b3JhZ2U8VD4uT2ZFbnVtZXJhYmxlKGVudW1lcmFibGUpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIHZlY3RvciBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGluZGV4ZWQgZW51bWVyYWJsZS5cclxuICAgICAgICAgICAgLy8vIEtleXMgbXVzdCBiZSBwcm92aWRlZCBhdCBtb3N0IG9uY2UsIHplcm8gaXMgYXNzdW1lZCBpZiBhIGtleSBpcyBvbWl0dGVkLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgdmVjdG9yIHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZS5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgdmVjdG9yLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IERlbnNlT2ZJbmRleGVkKGludCBsZW5ndGgsIElFbnVtZXJhYmxlPFR1cGxlPGludCwgVD4+IGVudW1lcmFibGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZW5zZShEZW5zZVZlY3RvclN0b3JhZ2U8VD4uT2ZJbmRleGVkRW51bWVyYWJsZShsZW5ndGgsIGVudW1lcmFibGUpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSB2ZWN0b3Igc3RyYWlnaHQgZnJvbSBhbiBpbml0aWFsaXplZCB2ZWN0b3Igc3RvcmFnZSBpbnN0YW5jZS5cclxuICAgICAgICAgICAgLy8vIFRoZSBzdG9yYWdlIGlzIHVzZWQgZGlyZWN0bHkgd2l0aG91dCBjb3B5aW5nLlxyXG4gICAgICAgICAgICAvLy8gSW50ZW5kZWQgZm9yIGFkdmFuY2VkIHNjZW5hcmlvcyB3aGVyZSB5b3UncmUgd29ya2luZyBkaXJlY3RseSB3aXRoXHJcbiAgICAgICAgICAgIC8vLyBzdG9yYWdlIGZvciBwZXJmb3JtYW5jZSBvciBpbnRlcm9wIHJlYXNvbnMuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBhYnN0cmFjdCBWZWN0b3I8VD4gU3BhcnNlKFNwYXJzZVZlY3RvclN0b3JhZ2U8VD4gc3RvcmFnZSk7XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBzcGFyc2UgdmVjdG9yIG9mIFQgd2l0aCB0aGUgZ2l2ZW4gc2l6ZS5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2l6ZVwiPlRoZSBzaXplIG9mIHRoZSB2ZWN0b3IuPC9wYXJhbT5cclxuICAgICAgICAgICAgcHVibGljIFZlY3RvcjxUPiBTcGFyc2UoaW50IHNpemUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UobmV3IFNwYXJzZVZlY3RvclN0b3JhZ2U8VD4oc2l6ZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIHZlY3RvciBhbmQgaW5pdGlhbGl6ZSBlYWNoIHZhbHVlIHVzaW5nIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIFZlY3RvcjxUPiBTcGFyc2UoaW50IGxlbmd0aCwgVCB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKFplcm8uRXF1YWxzKHZhbHVlKSkgcmV0dXJuIFNwYXJzZShsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNwYXJzZShTcGFyc2VWZWN0b3JTdG9yYWdlPFQ+Lk9mVmFsdWUobGVuZ3RoLCB2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIHZlY3RvciBhbmQgaW5pdGlhbGl6ZSBlYWNoIHZhbHVlIHVzaW5nIHRoZSBwcm92aWRlZCBpbml0IGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFNwYXJzZShpbnQgbGVuZ3RoLCBGdW5jPGludCwgVD4gaW5pdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNwYXJzZShTcGFyc2VWZWN0b3JTdG9yYWdlPFQ+Lk9mSW5pdChsZW5ndGgsIChGdW5jPGludCxUPilpbml0KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgdmVjdG9yIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gb3RoZXIgdmVjdG9yLlxyXG4gICAgICAgICAgICAvLy8gVGhpcyBuZXcgdmVjdG9yIHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgb3RoZXIgdmVjdG9yLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gU3BhcnNlT2ZWZWN0b3IoVmVjdG9yPFQ+IHZlY3RvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNwYXJzZShTcGFyc2VWZWN0b3JTdG9yYWdlPFQ+Lk9mVmVjdG9yKHZlY3Rvci5TdG9yYWdlKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgdmVjdG9yIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gYXJyYXkuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyB2ZWN0b3Igd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheS5cclxuICAgICAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgdmVjdG9yLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgVmVjdG9yPFQ+IFNwYXJzZU9mQXJyYXkoVFtdIGFycmF5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3BhcnNlKFNwYXJzZVZlY3RvclN0b3JhZ2U8VD4uT2ZFbnVtZXJhYmxlKGFycmF5KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgdmVjdG9yIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gZW51bWVyYWJsZS5cclxuICAgICAgICAgICAgLy8vIFRoaXMgbmV3IHZlY3RvciB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGVudW1lcmFibGUuXHJcbiAgICAgICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIHZlY3Rvci5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIFZlY3RvcjxUPiBTcGFyc2VPZkVudW1lcmFibGUoSUVudW1lcmFibGU8VD4gZW51bWVyYWJsZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNwYXJzZShTcGFyc2VWZWN0b3JTdG9yYWdlPFQ+Lk9mRW51bWVyYWJsZShlbnVtZXJhYmxlKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgdmVjdG9yIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gaW5kZXhlZCBlbnVtZXJhYmxlLlxyXG4gICAgICAgICAgICAvLy8gS2V5cyBtdXN0IGJlIHByb3ZpZGVkIGF0IG1vc3Qgb25jZSwgemVybyBpcyBhc3N1bWVkIGlmIGEga2V5IGlzIG9taXR0ZWQuXHJcbiAgICAgICAgICAgIC8vLyBUaGlzIG5ldyB2ZWN0b3Igd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlLlxyXG4gICAgICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBWZWN0b3I8VD4gU3BhcnNlT2ZJbmRleGVkKGludCBsZW5ndGgsIElFbnVtZXJhYmxlPFR1cGxlPGludCwgVD4+IGVudW1lcmFibGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTcGFyc2UoU3BhcnNlVmVjdG9yU3RvcmFnZTxUPi5PZkluZGV4ZWRFbnVtZXJhYmxlKGxlbmd0aCwgZW51bWVyYWJsZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGNsYXNzIEJ1aWxkZXJJbnN0YW5jZTxUPiB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN0YXRpYyBUdXBsZTxNYXRyaXhCdWlsZGVyPFQ+LCBWZWN0b3JCdWlsZGVyPFQ+PiBfc2luZ2xldG9uID0gQ3JlYXRlKCk7XHJcblxyXG4gICAgICAgICAgICBzdGF0aWMgVHVwbGU8TWF0cml4QnVpbGRlcjxUPiwgVmVjdG9yQnVpbGRlcjxUPj4gQ3JlYXRlKClcclxuICAgICAgICAgICAge1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKFQpID09IHR5cGVvZihkb3VibGUpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGU8TWF0cml4QnVpbGRlcjxUPiwgVmVjdG9yQnVpbGRlcjxUPj4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChNYXRyaXhCdWlsZGVyPFQ+KShvYmplY3QpbmV3IERvdWJsZS5NYXRyaXhCdWlsZGVyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChWZWN0b3JCdWlsZGVyPFQ+KShvYmplY3QpbmV3IERvdWJsZS5WZWN0b3JCdWlsZGVyKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEV4Y2VwdGlvbihzdHJpbmcuRm9ybWF0KFwiTWF0cmljZXMgYW5kIHZlY3RvcnMgb2YgdHlwZSAnezB9JyBhcmUgbm90IHN1cHBvcnRlZC4gT25seSBEb3VibGUsIFNpbmdsZSwgQ29tcGxleCBvciBDb21wbGV4MzIgYXJlIHN1cHBvcnRlZCBhdCB0aGlzIHBvaW50LlwiLCB0eXBlb2YoVCkuTmFtZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgUmVnaXN0ZXIoTWF0cml4QnVpbGRlcjxUPiBtYXRyaXhCdWlsZGVyLCBWZWN0b3JCdWlsZGVyPFQ+IHZlY3RvckJ1aWxkZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9zaW5nbGV0b24gPSBuZXcgVHVwbGU8TWF0cml4QnVpbGRlcjxUPiwgVmVjdG9yQnVpbGRlcjxUPj4obWF0cml4QnVpbGRlciwgdmVjdG9yQnVpbGRlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4QnVpbGRlcjxUPiBNYXRyaXhcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9zaW5nbGV0b24uSXRlbTE7IH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3JCdWlsZGVyPFQ+IFZlY3RvclxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBnZXQgeyByZXR1cm4gX3NpbmdsZXRvbi5JdGVtMjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8vIDxjb3B5cmlnaHQgZmlsZT1cIk1hdHJpeEV4dGVuc2lvbnMuY3NcIiBjb21wYW55PVwiTWF0aC5ORVRcIj5cclxuLy8gTWF0aC5ORVQgTnVtZXJpY3MsIHBhcnQgb2YgdGhlIE1hdGguTkVUIFByb2plY3RcclxuLy8gaHR0cDovL251bWVyaWNzLm1hdGhkb3RuZXQuY29tXHJcbi8vIGh0dHA6Ly9naXRodWIuY29tL21hdGhuZXQvbWF0aG5ldC1udW1lcmljc1xyXG4vL1xyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNSBNYXRoLk5FVFxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxyXG4vLyBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4vLyBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuLy8gcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXHJcbi8vIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4vLyBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xyXG4vLyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4vLyBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXHJcbi8vIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbi8vIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXHJcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxyXG4vLyBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4vLyBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbi8vIDwvY29weXJpZ2h0PlxyXG5cclxubmFtZXNwYWNlIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYVxyXG57XHJcbiAgICB1c2luZyBDb21wbGV4NjQgPSBtYXRobmV0bnVtZXJpY3NicmlkZ2UuQ29tcGxleDtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIE1hdHJpeEV4dGVuc2lvbnNcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnZlcnRzIGEgbWF0cml4IHRvIHNpbmdsZSBwcmVjaXNpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxmbG9hdD4gVG9TaW5nbGUodGhpcyBNYXRyaXg8ZG91YmxlPiBtYXRyaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0cml4Lk1hcDxmbG9hdD4oKFN5c3RlbS5GdW5jPGRvdWJsZSxmbG9hdD4pKHggPT4gKGZsb2F0KXgpLCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb252ZXJ0cyBhIG1hdHJpeCB0byBkb3VibGUgcHJlY2lzaW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8ZG91YmxlPiBUb0RvdWJsZSh0aGlzIE1hdHJpeDxmbG9hdD4gbWF0cml4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeC5NYXA8ZG91YmxlPigoU3lzdGVtLkZ1bmM8ZmxvYXQsZG91YmxlPikoeCA9PiAoZG91YmxlKXgpLCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb252ZXJ0cyBhIG1hdHJpeCB0byBzaW5nbGUgcHJlY2lzaW9uIGNvbXBsZXggbnVtYmVycy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PG1hdGhuZXRudW1lcmljc2JyaWRnZS5Db21wbGV4MzI+IFRvQ29tcGxleDMyKHRoaXMgTWF0cml4PENvbXBsZXg2ND4gbWF0cml4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeC5NYXA8bWF0aG5ldG51bWVyaWNzYnJpZGdlLkNvbXBsZXgzMj4oKFN5c3RlbS5GdW5jPENvbXBsZXg2NCxtYXRobmV0bnVtZXJpY3NicmlkZ2UuQ29tcGxleDMyPikoeCA9PiBuZXcgbWF0aG5ldG51bWVyaWNzYnJpZGdlLkNvbXBsZXgzMigoZmxvYXQpeC5SZWFsLCAoZmxvYXQpeC5JbWFnaW5hcnkpKSwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29udmVydHMgYSBtYXRyaXggdG8gZG91YmxlIHByZWNpc2lvbiBjb21wbGV4IG51bWJlcnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxDb21wbGV4NjQ+IFRvQ29tcGxleCh0aGlzIE1hdHJpeDxtYXRobmV0bnVtZXJpY3NicmlkZ2UuQ29tcGxleDMyPiBtYXRyaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0cml4Lk1hcDxDb21wbGV4NjQ+KChTeXN0ZW0uRnVuYzxtYXRobmV0bnVtZXJpY3NicmlkZ2UuQ29tcGxleDMyLENvbXBsZXg2ND4pKHggPT4gbmV3IENvbXBsZXg2NCh4LlJlYWwsIHguSW1hZ2luYXJ5KSksIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgYSBzaW5nbGUgcHJlY2lzaW9uIGNvbXBsZXggbWF0cml4IHdpdGggdGhlIHJlYWwgcGFydHMgZnJvbSB0aGUgZ2l2ZW4gbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8bWF0aG5ldG51bWVyaWNzYnJpZGdlLkNvbXBsZXgzMj4gVG9Db21wbGV4MzIodGhpcyBNYXRyaXg8ZmxvYXQ+IG1hdHJpeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRyaXguTWFwPG1hdGhuZXRudW1lcmljc2JyaWRnZS5Db21wbGV4MzI+KChTeXN0ZW0uRnVuYzxmbG9hdCxtYXRobmV0bnVtZXJpY3NicmlkZ2UuQ29tcGxleDMyPikoeCA9PiBuZXcgbWF0aG5ldG51bWVyaWNzYnJpZGdlLkNvbXBsZXgzMih4LCAwZikpLCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIGEgZG91YmxlIHByZWNpc2lvbiBjb21wbGV4IG1hdHJpeCB3aXRoIHRoZSByZWFsIHBhcnRzIGZyb20gdGhlIGdpdmVuIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PENvbXBsZXg2ND4gVG9Db21wbGV4KHRoaXMgTWF0cml4PGRvdWJsZT4gbWF0cml4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeC5NYXA8Q29tcGxleDY0PigoU3lzdGVtLkZ1bmM8ZG91YmxlLENvbXBsZXg2ND4pKHggPT4gbmV3IENvbXBsZXg2NCh4LCAwZCkpLCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIGEgcmVhbCBtYXRyaXggcmVwcmVzZW50aW5nIHRoZSByZWFsIHBhcnRzIG9mIGEgY29tcGxleCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxkb3VibGU+IFJlYWwodGhpcyBNYXRyaXg8Q29tcGxleDY0PiBtYXRyaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0cml4Lk1hcDxkb3VibGU+KChTeXN0ZW0uRnVuYzxDb21wbGV4NjQsZG91YmxlPikoeCA9PiB4LlJlYWwpLCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIGEgcmVhbCBtYXRyaXggcmVwcmVzZW50aW5nIHRoZSByZWFsIHBhcnRzIG9mIGEgY29tcGxleCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIE1hdHJpeDxmbG9hdD4gUmVhbCh0aGlzIE1hdHJpeDxtYXRobmV0bnVtZXJpY3NicmlkZ2UuQ29tcGxleDMyPiBtYXRyaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0cml4Lk1hcDxmbG9hdD4oKFN5c3RlbS5GdW5jPG1hdGhuZXRudW1lcmljc2JyaWRnZS5Db21wbGV4MzIsZmxvYXQ+KSh4ID0+IHguUmVhbCksIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgYSByZWFsIG1hdHJpeCByZXByZXNlbnRpbmcgdGhlIGltYWdpbmFyeSBwYXJ0cyBvZiBhIGNvbXBsZXggbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8ZG91YmxlPiBJbWFnaW5hcnkodGhpcyBNYXRyaXg8Q29tcGxleDY0PiBtYXRyaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0cml4Lk1hcDxkb3VibGU+KChTeXN0ZW0uRnVuYzxDb21wbGV4NjQsZG91YmxlPikoeCA9PiB4LkltYWdpbmFyeSksIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgYSByZWFsIG1hdHJpeCByZXByZXNlbnRpbmcgdGhlIGltYWdpbmFyeSBwYXJ0cyBvZiBhIGNvbXBsZXggbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBNYXRyaXg8ZmxvYXQ+IEltYWdpbmFyeSh0aGlzIE1hdHJpeDxtYXRobmV0bnVtZXJpY3NicmlkZ2UuQ29tcGxleDMyPiBtYXRyaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0cml4Lk1hcDxmbG9hdD4oKFN5c3RlbS5GdW5jPG1hdGhuZXRudW1lcmljc2JyaWRnZS5Db21wbGV4MzIsZmxvYXQ+KSh4ID0+IHguSW1hZ2luYXJ5KSwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiTWF0cml4U3RvcmFnZS5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDE1IE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlLk1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYTtcclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLlJ1bnRpbWUuU2VyaWFsaXphdGlvbjtcclxuXHJcblxyXG5uYW1lc3BhY2UgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLlN0b3JhZ2Vcclxue1xyXG4gICAgW1NlcmlhbGl6YWJsZV1cclxuICAgIFtEYXRhQ29udHJhY3QoTmFtZXNwYWNlID0gXCJ1cm46TWF0aE5ldC9OdW1lcmljcy9MaW5lYXJBbGdlYnJhXCIpXVxyXG4gICAgcHVibGljIGFic3RyYWN0IHBhcnRpYWwgY2xhc3MgTWF0cml4U3RvcmFnZTxUPiA6IElFcXVhdGFibGU8TWF0cml4U3RvcmFnZTxUPj5cclxuICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgIHtcclxuICAgICAgICAvLyBbcnVlZ2ddIHB1YmxpYyBmaWVsZHMgYXJlIE9LIGhlcmVcclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBUIFplcm8gPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4Llplcm87XHJcblxyXG4gICAgICAgIFtEYXRhTWVtYmVyKE9yZGVyID0gMSldXHJcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGludCBSb3dDb3VudDtcclxuXHJcbiAgICAgICAgW0RhdGFNZW1iZXIoT3JkZXIgPSAyKV1cclxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgaW50IENvbHVtbkNvdW50O1xyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgTWF0cml4U3RvcmFnZShpbnQgcm93Q291bnQsIGludCBjb2x1bW5Db3VudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyb3dDb3VudCA8PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwicm93Q291bnRcIiwgXCJSZXNvdXJjZXMuTWF0cml4Um93c011c3RCZVBvc2l0aXZlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY29sdW1uQ291bnQgPD0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImNvbHVtbkNvdW50XCIsIFwiUmVzb3VyY2VzLk1hdHJpeENvbHVtbnNNdXN0QmVQb3NpdGl2ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgUm93Q291bnQgPSByb3dDb3VudDtcclxuICAgICAgICAgICAgQ29sdW1uQ291bnQgPSBjb2x1bW5Db3VudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVHJ1ZSBpZiB0aGUgbWF0cml4IHN0b3JhZ2UgZm9ybWF0IGlzIGRlbnNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGJvb2wgSXNEZW5zZSB7IGdldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRydWUgaWYgYWxsIGZpZWxkcyBvZiB0aGlzIG1hdHJpeCBjYW4gYmUgc2V0IHRvIGFueSB2YWx1ZS5cclxuICAgICAgICAvLy8gRmFsc2UgaWYgc29tZSBmaWVsZHMgYXJlIGZpeGVkLCBsaWtlIG9uIGEgZGlhZ29uYWwgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGJvb2wgSXNGdWxseU11dGFibGUgeyBnZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgZmllbGQgY2FuIGJlIHNldCB0byBhbnkgdmFsdWUuXHJcbiAgICAgICAgLy8vIEZhbHNlIGlmIHRoZSBmaWVsZCBpcyBmaXhlZCwgbGlrZSBhbiBvZmYtZGlhZ29uYWwgZmllbGQgb24gYSBkaWFnb25hbCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3QgYm9vbCBJc011dGFibGVBdChpbnQgcm93LCBpbnQgY29sdW1uKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIG9yIHNldHMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiByb3cgYW5kIGNvbHVtbiwgd2l0aCByYW5nZSBjaGVja2luZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd1wiPlxyXG4gICAgICAgIC8vLyBUaGUgcm93IG9mIHRoZSBlbGVtZW50LlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtblwiPlxyXG4gICAgICAgIC8vLyBUaGUgY29sdW1uIG9mIHRoZSBlbGVtZW50LlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIHZhbHVlIHRvIGdldCBvciBzZXQuPC92YWx1ZT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+VGhpcyBtZXRob2QgaXMgcmFuZ2VkIGNoZWNrZWQuIDxzZWUgY3JlZj1cIkF0KGludCxpbnQpXCIvPiBhbmQgPHNlZSBjcmVmPVwiQXQoaW50LGludCxUKVwiLz5cclxuICAgICAgICAvLy8gdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIHdpdGhvdXQgcmFuZ2UgY2hlY2tpbmcuPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyBUIHRoaXNbaW50IHJvdywgaW50IGNvbHVtbl1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWYWxpZGF0ZVJhbmdlKHJvdywgY29sdW1uKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBBdChyb3csIGNvbHVtbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWYWxpZGF0ZVJhbmdlKHJvdywgY29sdW1uKTtcclxuICAgICAgICAgICAgICAgIEF0KHJvdywgY29sdW1uLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0cmlldmVzIHRoZSByZXF1ZXN0ZWQgZWxlbWVudCB3aXRob3V0IHJhbmdlIGNoZWNraW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm93XCI+XHJcbiAgICAgICAgLy8vIFRoZSByb3cgb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uXCI+XHJcbiAgICAgICAgLy8vIFRoZSBjb2x1bW4gb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBUaGUgcmVxdWVzdGVkIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPHJlbWFya3M+Tm90IHJhbmdlLWNoZWNrZWQuPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBUIEF0KGludCByb3csIGludCBjb2x1bW4pO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldHMgdGhlIGVsZW1lbnQgd2l0aG91dCByYW5nZSBjaGVja2luZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd1wiPiBUaGUgcm93IG9mIHRoZSBlbGVtZW50LiA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtblwiPiBUaGUgY29sdW1uIG9mIHRoZSBlbGVtZW50LiA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlXCI+IFRoZSB2YWx1ZSB0byBzZXQgdGhlIGVsZW1lbnQgdG8uIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPldBUk5JTkc6IFRoaXMgbWV0aG9kIGlzIG5vdCB0aHJlYWQgc2FmZS4gVXNlIFwibG9ja1wiIHdpdGggaXQgYW5kIGJlIHN1cmUgdG8gYXZvaWQgZGVhZGxvY2tzLjwvcmVtYXJrcz5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3Qgdm9pZCBBdChpbnQgcm93LCBpbnQgY29sdW1uLCBUIHZhbHVlKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY3VycmVudCBvYmplY3QgaXMgZXF1YWwgdG8gYW5vdGhlciBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+XHJcbiAgICAgICAgLy8vIEFuIG9iamVjdCB0byBjb21wYXJlIHdpdGggdGhpcyBvYmplY3QuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8Yz50cnVlPC9jPiBpZiB0aGUgY3VycmVudCBvYmplY3QgaXMgZXF1YWwgdG8gdGhlIDxwYXJhbXJlZiBuYW1lPVwib3RoZXJcIi8+IHBhcmFtZXRlcjsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYm9vbCBFcXVhbHMoTWF0cml4U3RvcmFnZTxUPiBvdGhlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFJlamVjdCBlcXVhbGl0eSB3aGVuIHRoZSBhcmd1bWVudCBpcyBudWxsIG9yIGhhcyBhIGRpZmZlcmVudCBzaGFwZS5cclxuICAgICAgICAgICAgaWYgKG90aGVyID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoQ29sdW1uQ291bnQgIT0gb3RoZXIuQ29sdW1uQ291bnQgfHwgUm93Q291bnQgIT0gb3RoZXIuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWNjZXB0IGlmIHRoZSBhcmd1bWVudCBpcyB0aGUgc2FtZSBvYmplY3QgYXMgdGhpcy5cclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCBvdGhlcikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGVsZW1lbnQgd2lzZSBjb21wYXJpc29uLlxyXG4gICAgICAgICAgICByZXR1cm4gRmluZDJVbmNoZWNrZWQ8VD4ob3RoZXIsIChGdW5jPFQsVCxib29sPikoKGEsIGIpID0+ICFhLkVxdWFscyhiKSksIFplcm9zLkFsbG93U2tpcCkgPT0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgPHNlZSBjcmVmPVwiVDpTeXN0ZW0uT2JqZWN0XCIvPiBpcyBlcXVhbCB0byB0aGUgY3VycmVudCA8c2VlIGNyZWY9XCJUOlN5c3RlbS5PYmplY3RcIi8+LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgPHNlZSBjcmVmPVwiVDpTeXN0ZW0uT2JqZWN0XCIvPiBpcyBlcXVhbCB0byB0aGUgY3VycmVudCA8c2VlIGNyZWY9XCJUOlN5c3RlbS5PYmplY3RcIi8+OyBvdGhlcndpc2UsIGZhbHNlLlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib2JqXCI+VGhlIDxzZWUgY3JlZj1cIlQ6U3lzdGVtLk9iamVjdFwiLz4gdG8gY29tcGFyZSB3aXRoIHRoZSBjdXJyZW50IDxzZWUgY3JlZj1cIlQ6U3lzdGVtLk9iamVjdFwiLz4uIDwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHNlYWxlZCBvdmVycmlkZSBib29sIEVxdWFscyhvYmplY3Qgb2JqKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVxdWFscyhvYmogYXMgTWF0cml4U3RvcmFnZTxUPik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNlcnZlcyBhcyBhIGhhc2ggZnVuY3Rpb24gZm9yIGEgcGFydGljdWxhciB0eXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBBIGhhc2ggY29kZSBmb3IgdGhlIGN1cnJlbnQgPHNlZSBjcmVmPVwiVDpTeXN0ZW0uT2JqZWN0XCIvPi5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBpbnQgR2V0SGFzaENvZGUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGhhc2hOdW0gPSBNYXRoLk1pbihSb3dDb3VudCpDb2x1bW5Db3VudCwgMjUpO1xyXG4gICAgICAgICAgICBpbnQgaGFzaCA9IDE3O1xyXG4gICAgICAgICAgICB1bmNoZWNrZWRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXNoTnVtOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiNpZiBORVRTVEFOREFSRDFfM1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBjb2wgPSBpJUNvbHVtbkNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGludCByb3cgPSBpL0NvbHVtbkNvdW50O1xyXG4jZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGludCBjb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IHJvdyA9IE1hdGguRGl2UmVtKGksIENvbHVtbkNvdW50LCBvdXQgY29sKTtcclxuI2VuZGlmXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzaCA9IGhhc2gqMzEgKyBBdChyb3csIGNvbCkuR2V0SGFzaENvZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaGFzaDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENMRUFSSU5HXHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIHZvaWQgQ2xlYXIoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQXQoaSwgaiwgWmVybyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENsZWFyKGludCByb3dJbmRleCwgaW50IHJvd0NvdW50LCBpbnQgY29sdW1uSW5kZXgsIGludCBjb2x1bW5Db3VudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyb3dDb3VudCA8IDEgfHwgY29sdW1uQ291bnQgPCAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyb3dJbmRleCArIHJvd0NvdW50ID4gUm93Q291bnQgfHwgcm93SW5kZXggPCAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwicm93SW5kZXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb2x1bW5JbmRleCArIGNvbHVtbkNvdW50ID4gQ29sdW1uQ291bnQgfHwgY29sdW1uSW5kZXggPCAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiY29sdW1uSW5kZXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIENsZWFyVW5jaGVja2VkKHJvd0luZGV4LCByb3dDb3VudCwgY29sdW1uSW5kZXgsIGNvbHVtbkNvdW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZpcnR1YWwgdm9pZCBDbGVhclVuY2hlY2tlZChpbnQgcm93SW5kZXgsIGludCByb3dDb3VudCwgaW50IGNvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcm93SW5kZXg7IGkgPCByb3dJbmRleCArIHJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBjb2x1bW5JbmRleDsgaiA8IGNvbHVtbkluZGV4ICsgY29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBBdChpLCBqLCBaZXJvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXJSb3dzKGludFtdIHJvd0luZGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocm93SW5kaWNlcy5MZW5ndGggPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBrID0gMDsgayA8IHJvd0luZGljZXMuTGVuZ3RoOyBrKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChyb3dJbmRpY2VzW2tdIDwgMCB8fCByb3dJbmRpY2VzW2tdID49IFJvd0NvdW50KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJyb3dJbmRpY2VzXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBDbGVhclJvd3NVbmNoZWNrZWQocm93SW5kaWNlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhckNvbHVtbnMoaW50W10gY29sdW1uSW5kaWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChjb2x1bW5JbmRpY2VzLkxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGsgPSAwOyBrIDwgY29sdW1uSW5kaWNlcy5MZW5ndGg7IGsrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCh1aW50KWNvbHVtbkluZGljZXNba10gPj0gKHVpbnQpQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImNvbHVtbkluZGljZXNcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIENsZWFyQ29sdW1uc1VuY2hlY2tlZChjb2x1bW5JbmRpY2VzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZpcnR1YWwgdm9pZCBDbGVhclJvd3NVbmNoZWNrZWQoaW50W10gcm93SW5kaWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcm93SW5kaWNlcy5MZW5ndGg7IGsrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IHJvdyA9IHJvd0luZGljZXNba107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQXQocm93LCBqLCBaZXJvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdmlydHVhbCB2b2lkIENsZWFyQ29sdW1uc1VuY2hlY2tlZChpbnRbXSBjb2x1bW5JbmRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjb2x1bW5JbmRpY2VzLkxlbmd0aDsgaysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgY29sdW1uID0gY29sdW1uSW5kaWNlc1trXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBBdChpLCBjb2x1bW4sIFplcm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNQVRSSVggQ09QWVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDb3B5VG8oTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEgPSBFeGlzdGluZ0RhdGEuQ2xlYXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJ0YXJnZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHModGhpcywgdGFyZ2V0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gdGFyZ2V0LlJvd0NvdW50IHx8IENvbHVtbkNvdW50ICE9IHRhcmdldC5Db2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBzdHJpbmcuRm9ybWF0KFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4RGltZW5zaW9uczIsIFJvd0NvdW50ICsgeCArIENvbHVtbkNvdW50LCB0YXJnZXQuUm93Q291bnQgKyB4ICsgdGFyZ2V0LkNvbHVtbkNvdW50XCIgKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihtZXNzYWdlLCBcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgQ29weVRvVW5jaGVja2VkKHRhcmdldCwgZXhpc3RpbmdEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZpcnR1YWwgdm9pZCBDb3B5VG9VbmNoZWNrZWQoTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQoaSwgaiwgQXQoaSwgaikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDb3B5U3ViTWF0cml4VG8oTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VSb3dJbmRleCwgaW50IHRhcmdldFJvd0luZGV4LCBpbnQgcm93Q291bnQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VDb2x1bW5JbmRleCwgaW50IHRhcmdldENvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQsXHJcbiAgICAgICAgICAgIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEgPSBFeGlzdGluZ0RhdGEuQ2xlYXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJ0YXJnZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyb3dDb3VudCA9PSAwIHx8IGNvbHVtbkNvdW50ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCB0YXJnZXQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFZhbGlkYXRlU3ViTWF0cml4UmFuZ2U8VD4odGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgc291cmNlUm93SW5kZXgsIHRhcmdldFJvd0luZGV4LCByb3dDb3VudCxcclxuICAgICAgICAgICAgICAgIHNvdXJjZUNvbHVtbkluZGV4LCB0YXJnZXRDb2x1bW5JbmRleCwgY29sdW1uQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKHRhcmdldCwgc291cmNlUm93SW5kZXgsIHRhcmdldFJvd0luZGV4LCByb3dDb3VudCxcclxuICAgICAgICAgICAgICAgIHNvdXJjZUNvbHVtbkluZGV4LCB0YXJnZXRDb2x1bW5JbmRleCwgY29sdW1uQ291bnQsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2aXJ0dWFsIHZvaWQgQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlUm93SW5kZXgsIGludCB0YXJnZXRSb3dJbmRleCwgaW50IHJvd0NvdW50LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlQ29sdW1uSW5kZXgsIGludCB0YXJnZXRDb2x1bW5JbmRleCwgaW50IGNvbHVtbkNvdW50LFxyXG4gICAgICAgICAgICBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IHNvdXJjZUNvbHVtbkluZGV4LCBqaiA9IHRhcmdldENvbHVtbkluZGV4OyBqIDwgc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudDsgaisrLCBqaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gc291cmNlUm93SW5kZXgsIGlpID0gdGFyZ2V0Um93SW5kZXg7IGkgPCBzb3VyY2VSb3dJbmRleCArIHJvd0NvdW50OyBpKyssIGlpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkF0KGlpLCBqaiwgQXQoaSwgaikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBST1cgQ09QWVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDb3B5Um93VG8oVmVjdG9yU3RvcmFnZTxUPiB0YXJnZXQsIGludCByb3dJbmRleCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSA9IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmFsaWRhdGVSb3dSYW5nZTxUPih0YXJnZXQsIHJvd0luZGV4KTtcclxuICAgICAgICAgICAgQ29weVN1YlJvd1RvVW5jaGVja2VkKHRhcmdldCwgcm93SW5kZXgsIDAsIDAsIENvbHVtbkNvdW50LCBleGlzdGluZ0RhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ29weVN1YlJvd1RvKFZlY3RvclN0b3JhZ2U8VD4gdGFyZ2V0LCBpbnQgcm93SW5kZXgsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VDb2x1bW5JbmRleCwgaW50IHRhcmdldENvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQsXHJcbiAgICAgICAgICAgIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEgPSBFeGlzdGluZ0RhdGEuQ2xlYXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJ0YXJnZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb2x1bW5Db3VudCA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFZhbGlkYXRlU3ViUm93UmFuZ2U8VD4odGFyZ2V0LCByb3dJbmRleCwgc291cmNlQ29sdW1uSW5kZXgsIHRhcmdldENvbHVtbkluZGV4LCBjb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIENvcHlTdWJSb3dUb1VuY2hlY2tlZCh0YXJnZXQsIHJvd0luZGV4LCBzb3VyY2VDb2x1bW5JbmRleCwgdGFyZ2V0Q29sdW1uSW5kZXgsIGNvbHVtbkNvdW50LCBleGlzdGluZ0RhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdmlydHVhbCB2b2lkIENvcHlTdWJSb3dUb1VuY2hlY2tlZChWZWN0b3JTdG9yYWdlPFQ+IHRhcmdldCwgaW50IHJvd0luZGV4LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlQ29sdW1uSW5kZXgsIGludCB0YXJnZXRDb2x1bW5JbmRleCwgaW50IGNvbHVtbkNvdW50LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IHNvdXJjZUNvbHVtbkluZGV4LCBqaiA9IHRhcmdldENvbHVtbkluZGV4OyBqIDwgc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudDsgaisrLCBqaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQXQoamosIEF0KHJvd0luZGV4LCBqKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENPTFVNTiBDT1BZXHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENvcHlDb2x1bW5UbyhWZWN0b3JTdG9yYWdlPFQ+IHRhcmdldCwgaW50IGNvbHVtbkluZGV4LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhID0gRXhpc3RpbmdEYXRhLkNsZWFyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWYWxpZGF0ZUNvbHVtblJhbmdlPFQ+KHRhcmdldCwgY29sdW1uSW5kZXgpO1xyXG4gICAgICAgICAgICBDb3B5U3ViQ29sdW1uVG9VbmNoZWNrZWQodGFyZ2V0LCBjb2x1bW5JbmRleCwgMCwgMCwgUm93Q291bnQsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDb3B5U3ViQ29sdW1uVG8oVmVjdG9yU3RvcmFnZTxUPiB0YXJnZXQsIGludCBjb2x1bW5JbmRleCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZVJvd0luZGV4LCBpbnQgdGFyZ2V0Um93SW5kZXgsIGludCByb3dDb3VudCxcclxuICAgICAgICAgICAgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSA9IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJvd0NvdW50ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmFsaWRhdGVTdWJDb2x1bW5SYW5nZTxUPih0YXJnZXQsIGNvbHVtbkluZGV4LCBzb3VyY2VSb3dJbmRleCwgdGFyZ2V0Um93SW5kZXgsIHJvd0NvdW50KTtcclxuICAgICAgICAgICAgQ29weVN1YkNvbHVtblRvVW5jaGVja2VkKHRhcmdldCwgY29sdW1uSW5kZXgsIHNvdXJjZVJvd0luZGV4LCB0YXJnZXRSb3dJbmRleCwgcm93Q291bnQsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2aXJ0dWFsIHZvaWQgQ29weVN1YkNvbHVtblRvVW5jaGVja2VkKFZlY3RvclN0b3JhZ2U8VD4gdGFyZ2V0LCBpbnQgY29sdW1uSW5kZXgsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VSb3dJbmRleCwgaW50IHRhcmdldFJvd0luZGV4LCBpbnQgcm93Q291bnQsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gc291cmNlUm93SW5kZXgsIGlpID0gdGFyZ2V0Um93SW5kZXg7IGkgPCBzb3VyY2VSb3dJbmRleCArIHJvd0NvdW50OyBpKyssIGlpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5BdChpaSwgQXQoaSwgY29sdW1uSW5kZXgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVFJBTlNQT1NFXHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFRyYW5zcG9zZVRvKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhID0gRXhpc3RpbmdEYXRhLkNsZWFyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gdGFyZ2V0LkNvbHVtbkNvdW50IHx8IENvbHVtbkNvdW50ICE9IHRhcmdldC5Sb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBzdHJpbmcuRm9ybWF0KFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4RGltZW5zaW9uczIsIFJvd0NvdW50ICsgeCArIENvbHVtbkNvdW50LCB0YXJnZXQuUm93Q291bnQgKyB4ICsgdGFyZ2V0LkNvbHVtbkNvdW50XCIpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKG1lc3NhZ2UsIFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoUmVmZXJlbmNlRXF1YWxzKHRoaXMsIHRhcmdldCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRyYW5zcG9zZVNxdWFyZUlucGxhY2VVbmNoZWNrZWQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVHJhbnNwb3NlVG9VbmNoZWNrZWQodGFyZ2V0LCBleGlzdGluZ0RhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdmlydHVhbCB2b2lkIFRyYW5zcG9zZVRvVW5jaGVja2VkKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkF0KGosIGksIEF0KGksIGopKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdmlydHVhbCB2b2lkIFRyYW5zcG9zZVNxdWFyZUlucGxhY2VVbmNoZWNrZWQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGo7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBUIHN3YXAgPSBBdChpLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICBBdChpLCBqLCBBdChqLCBpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgQXQoaiwgaSwgc3dhcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVYVFJBQ1RcclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgVFtdIFRvUm93TWFqb3JBcnJheSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFRbUm93Q291bnQqQ29sdW1uQ291bnRdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpKkNvbHVtbkNvdW50O1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldFtvZmZzZXQgKyBqXSA9IEF0KGksIGopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBUW10gVG9Db2x1bW5NYWpvckFycmF5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSBuZXcgVFtSb3dDb3VudCpDb2x1bW5Db3VudF07XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGoqUm93Q291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W29mZnNldCArIGldID0gQXQoaSwgaik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIFRbXVtdIFRvUm93QXJyYXlzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSBuZXcgVFtSb3dDb3VudF1bXTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gbmV3IFRbQ29sdW1uQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd1tqXSA9IEF0KGksIGopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0W2ldID0gcm93O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBUW11bXSBUb0NvbHVtbkFycmF5cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFRbQ29sdW1uQ291bnRdW107XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IG5ldyBUW1Jvd0NvdW50XTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5baV0gPSBBdChpLCBqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldFtqXSA9IGNvbHVtbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgVFssXSBUb0FycmF5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSBuZXcgVFtSb3dDb3VudCwgQ29sdW1uQ291bnRdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRbaSwgal0gPSBBdChpLCBqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgVFtdIEFzUm93TWFqb3JBcnJheSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIFRbXSBBc0NvbHVtbk1ham9yQXJyYXkoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBUW11bXSBBc1Jvd0FycmF5cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIFRbXVtdIEFzQ29sdW1uQXJyYXlzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgVFssXSBBc0FycmF5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRU5VTUVSQVRJT05cclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgSUVudW1lcmFibGU8VD4gRW51bWVyYXRlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHJldHVybiBBdChpLCBqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgSUVudW1lcmFibGU8VHVwbGU8aW50LCBpbnQsIFQ+PiBFbnVtZXJhdGVJbmRleGVkKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHJldHVybiBuZXcgVHVwbGU8aW50LCBpbnQsIFQ+KGksIGosIEF0KGksIGopKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgSUVudW1lcmFibGU8VD4gRW51bWVyYXRlTm9uWmVybygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IEF0KGksIGopO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoeCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCByZXR1cm4geDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIElFbnVtZXJhYmxlPFR1cGxlPGludCwgaW50LCBUPj4gRW51bWVyYXRlTm9uWmVyb0luZGV4ZWQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBBdChpLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVplcm8uRXF1YWxzKHgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVD4oaSwgaiwgeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGSU5EXHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIFR1cGxlPGludCwgaW50LCBUPiBGaW5kKEZ1bmM8VCwgYm9vbD4gcHJlZGljYXRlLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gQXQoaSwgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGU8aW50LCBpbnQsIFQ+KGksIGosIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBUdXBsZTxpbnQsIGludCwgVCwgVE90aGVyPiBGaW5kMjxUT3RoZXI+KE1hdHJpeFN0b3JhZ2U8VE90aGVyPiBvdGhlciwgRnVuYzxULCBUT3RoZXIsIGJvb2w+IHByZWRpY2F0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAgICAgIHdoZXJlIFRPdGhlciA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUT3RoZXI+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlciA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwib3RoZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChSb3dDb3VudCAhPSBvdGhlci5Sb3dDb3VudCB8fCBDb2x1bW5Db3VudCAhPSBvdGhlci5Db2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBzdHJpbmcuRm9ybWF0KFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4RGltZW5zaW9uczIsIFJvd0NvdW50ICsgeCArIENvbHVtbkNvdW50LCBvdGhlci5Sb3dDb3VudCArIHggKyBvdGhlci5Db2x1bW5Db3VudFwiKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihtZXNzYWdlLCBcIm90aGVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gRmluZDJVbmNoZWNrZWQ8VE90aGVyPihvdGhlciwgKEZ1bmM8VCxUT3RoZXIsYm9vbD4pcHJlZGljYXRlLCB6ZXJvcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2aXJ0dWFsIFR1cGxlPGludCwgaW50LCBULCBUT3RoZXI+IEZpbmQyVW5jaGVja2VkPFRPdGhlcj4oTWF0cml4U3RvcmFnZTxUT3RoZXI+IG90aGVyLCBGdW5jPFQsIFRPdGhlciwgYm9vbD4gcHJlZGljYXRlLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICAgICAgd2hlcmUgVE90aGVyIDogc3RydWN0LCBJRXF1YXRhYmxlPFRPdGhlcj4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBBdChpLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJJdGVtID0gb3RoZXIuQXQoaSwgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtLCBvdGhlckl0ZW0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVCwgVE90aGVyPihpLCBqLCBpdGVtLCBvdGhlckl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZVTkNUSU9OQUwgQ09NQklOQVRPUlM6IE1BUFxyXG5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCB2b2lkIE1hcElucGxhY2UoRnVuYzxULCBUPiBmLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEF0KGksIGosIGYoQXQoaSwgaikpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgdm9pZCBNYXBJbmRleGVkSW5wbGFjZShGdW5jPGludCwgaW50LCBULCBUPiBmLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEF0KGksIGosIGYoaSwgaiwgQXQoaSwgaikpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFwVG88VFU+KE1hdHJpeFN0b3JhZ2U8VFU+IHRhcmdldCwgRnVuYzxULCBUVT4gZiwgWmVyb3MgemVyb3MsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJ0YXJnZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChSb3dDb3VudCAhPSB0YXJnZXQuUm93Q291bnQgfHwgQ29sdW1uQ291bnQgIT0gdGFyZ2V0LkNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHN0cmluZy5Gb3JtYXQoXCJSZXNvdXJjZXMuQXJndW1lbnRNYXRyaXhEaW1lbnNpb25zMiwgUm93Q291bnQgKyB4ICsgQ29sdW1uQ291bnQsIHRhcmdldC5Sb3dDb3VudCArIHggKyB0YXJnZXQuQ29sdW1uQ291bnRcIik7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24obWVzc2FnZSwgXCJ0YXJnZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIE1hcFRvVW5jaGVja2VkPFRVPih0YXJnZXQsIChGdW5jPFQsVFU+KWYsIHplcm9zLCBleGlzdGluZ0RhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdmlydHVhbCB2b2lkIE1hcFRvVW5jaGVja2VkPFRVPihNYXRyaXhTdG9yYWdlPFRVPiB0YXJnZXQsIEZ1bmM8VCwgVFU+IGYsIFplcm9zIHplcm9zLCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgICAgICB3aGVyZSBUVSA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUVT4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkF0KGksIGosIGYoQXQoaSwgaikpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFwSW5kZXhlZFRvPFRVPihNYXRyaXhTdG9yYWdlPFRVPiB0YXJnZXQsIEZ1bmM8aW50LCBpbnQsIFQsIFRVPiBmLCBaZXJvcyB6ZXJvcywgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICAgICAgd2hlcmUgVFUgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VFU+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFJvd0NvdW50ICE9IHRhcmdldC5Sb3dDb3VudCB8fCBDb2x1bW5Db3VudCAhPSB0YXJnZXQuQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gc3RyaW5nLkZvcm1hdChcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeERpbWVuc2lvbnMyLCBSb3dDb3VudCArIHggKyBDb2x1bW5Db3VudCwgdGFyZ2V0LlJvd0NvdW50ICsgeCArIHRhcmdldC5Db2x1bW5Db3VudFwiKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihtZXNzYWdlLCBcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgTWFwSW5kZXhlZFRvVW5jaGVja2VkPFRVPih0YXJnZXQsIChGdW5jPGludCxpbnQsVCxUVT4pZiwgemVyb3MsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2aXJ0dWFsIHZvaWQgTWFwSW5kZXhlZFRvVW5jaGVja2VkPFRVPihNYXRyaXhTdG9yYWdlPFRVPiB0YXJnZXQsIEZ1bmM8aW50LCBpbnQsIFQsIFRVPiBmLCBaZXJvcyB6ZXJvcywgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICAgICAgd2hlcmUgVFUgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VFU+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5BdChpLCBqLCBmKGksIGosIEF0KGksIGopKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1hcFN1Yk1hdHJpeEluZGV4ZWRUbzxUVT4oTWF0cml4U3RvcmFnZTxUVT4gdGFyZ2V0LCBGdW5jPGludCwgaW50LCBULCBUVT4gZixcclxuICAgICAgICAgICAgaW50IHNvdXJjZVJvd0luZGV4LCBpbnQgdGFyZ2V0Um93SW5kZXgsIGludCByb3dDb3VudCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZUNvbHVtbkluZGV4LCBpbnQgdGFyZ2V0Q29sdW1uSW5kZXgsIGludCBjb2x1bW5Db3VudCxcclxuICAgICAgICAgICAgWmVyb3MgemVyb3MsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJ0YXJnZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyb3dDb3VudCA9PSAwIHx8IGNvbHVtbkNvdW50ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCB0YXJnZXQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFZhbGlkYXRlU3ViTWF0cml4UmFuZ2U8VFU+KHRhcmdldCxcclxuICAgICAgICAgICAgICAgIHNvdXJjZVJvd0luZGV4LCB0YXJnZXRSb3dJbmRleCwgcm93Q291bnQsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VDb2x1bW5JbmRleCwgdGFyZ2V0Q29sdW1uSW5kZXgsIGNvbHVtbkNvdW50KTtcclxuXHJcbiAgICAgICAgICAgIE1hcFN1Yk1hdHJpeEluZGV4ZWRUb1VuY2hlY2tlZDxUVT4odGFyZ2V0LCAoRnVuYzxpbnQsaW50LFQsVFU+KWYsIHNvdXJjZVJvd0luZGV4LCB0YXJnZXRSb3dJbmRleCwgcm93Q291bnQsIHNvdXJjZUNvbHVtbkluZGV4LCB0YXJnZXRDb2x1bW5JbmRleCwgY29sdW1uQ291bnQsIHplcm9zLCBleGlzdGluZ0RhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdmlydHVhbCB2b2lkIE1hcFN1Yk1hdHJpeEluZGV4ZWRUb1VuY2hlY2tlZDxUVT4oTWF0cml4U3RvcmFnZTxUVT4gdGFyZ2V0LCBGdW5jPGludCwgaW50LCBULCBUVT4gZixcclxuICAgICAgICAgICAgaW50IHNvdXJjZVJvd0luZGV4LCBpbnQgdGFyZ2V0Um93SW5kZXgsIGludCByb3dDb3VudCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZUNvbHVtbkluZGV4LCBpbnQgdGFyZ2V0Q29sdW1uSW5kZXgsIGludCBjb2x1bW5Db3VudCxcclxuICAgICAgICAgICAgWmVyb3MgemVyb3MsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gc291cmNlQ29sdW1uSW5kZXgsIGpqID0gdGFyZ2V0Q29sdW1uSW5kZXg7IGogPCBzb3VyY2VDb2x1bW5JbmRleCArIGNvbHVtbkNvdW50OyBqKyssIGpqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSBzb3VyY2VSb3dJbmRleCwgaWkgPSB0YXJnZXRSb3dJbmRleDsgaSA8IHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQ7IGkrKywgaWkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQoaWksIGpqLCBmKGlpLCBqaiwgQXQoaSwgaikpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFwMlRvKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBNYXRyaXhTdG9yYWdlPFQ+IG90aGVyLCBGdW5jPFQsIFQsIFQ+IGYsIFplcm9zIHplcm9zLCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3RoZXIgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcIm90aGVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gdGFyZ2V0LlJvd0NvdW50IHx8IENvbHVtbkNvdW50ICE9IHRhcmdldC5Db2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBzdHJpbmcuRm9ybWF0KFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4RGltZW5zaW9uczIsIFJvd0NvdW50ICsgeCArIENvbHVtbkNvdW50LCB0YXJnZXQuUm93Q291bnQgKyB4ICsgdGFyZ2V0LkNvbHVtbkNvdW50XCIpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKG1lc3NhZ2UsIFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gb3RoZXIuUm93Q291bnQgfHwgQ29sdW1uQ291bnQgIT0gb3RoZXIuQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gc3RyaW5nLkZvcm1hdChcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeERpbWVuc2lvbnMyLCBSb3dDb3VudCArIHggKyBDb2x1bW5Db3VudCwgb3RoZXIuUm93Q291bnQgKyB4ICsgb3RoZXIuQ29sdW1uQ291bnRcIik7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24obWVzc2FnZSwgXCJvdGhlclwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgTWFwMlRvVW5jaGVja2VkKHRhcmdldCwgb3RoZXIsIChGdW5jPFQsVCxUPilmLCB6ZXJvcywgZXhpc3RpbmdEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZpcnR1YWwgdm9pZCBNYXAyVG9VbmNoZWNrZWQoTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsIE1hdHJpeFN0b3JhZ2U8VD4gb3RoZXIsIEZ1bmM8VCwgVCwgVD4gZiwgWmVyb3MgemVyb3MsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQoaSwgaiwgZihBdChpLCBqKSwgb3RoZXIuQXQoaSwgaikpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRlVOQ1RJT05BTCBDT01CSU5BVE9SUzogRk9MRFxyXG5cclxuICAgICAgICAvLy8gPHJlbWFya3M+VGhlIHN0YXRlIGFycmF5IHdpbGwgbm90IGJlIG1vZGlmaWVkLCB1bmxlc3MgaXQgaXMgdGhlIHNhbWUgaW5zdGFuY2UgYXMgdGhlIHRhcmdldCBhcnJheSAod2hpY2ggaXMgYWxsb3dlZCkuPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEZvbGRCeVJvdzxUVT4oVFVbXSB0YXJnZXQsIEZ1bmM8VFUsIFQsIFRVPiBmLCBGdW5jPFRVLCBpbnQsIFRVPiBmaW5hbGl6ZSwgVFVbXSBzdGF0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJ0YXJnZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRhcmdldC5MZW5ndGggIT0gUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RhdGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInN0YXRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5MZW5ndGggIT0gUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwic3RhdGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEZvbGRCeVJvd1VuY2hlY2tlZDxUVT4odGFyZ2V0LCAoRnVuYzxUVSxULFRVPilmLCAoRnVuYzxUVSxpbnQsVFU+KWZpbmFsaXplLCBzdGF0ZSwgemVyb3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlRoZSBzdGF0ZSBhcnJheSB3aWxsIG5vdCBiZSBtb2RpZmllZCwgdW5sZXNzIGl0IGlzIHRoZSBzYW1lIGluc3RhbmNlIGFzIHRoZSB0YXJnZXQgYXJyYXkgKHdoaWNoIGlzIGFsbG93ZWQpLjwvcmVtYXJrcz5cclxuICAgICAgICBpbnRlcm5hbCB2aXJ0dWFsIHZvaWQgRm9sZEJ5Um93VW5jaGVja2VkPFRVPihUVVtdIHRhcmdldCwgRnVuYzxUVSwgVCwgVFU+IGYsIEZ1bmM8VFUsIGludCwgVFU+IGZpbmFsaXplLCBUVVtdIHN0YXRlLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVFUgcyA9IHN0YXRlW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBmKHMsIEF0KGksIGopKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IGZpbmFsaXplKHMsIENvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlRoZSBzdGF0ZSBhcnJheSB3aWxsIG5vdCBiZSBtb2RpZmllZCwgdW5sZXNzIGl0IGlzIHRoZSBzYW1lIGluc3RhbmNlIGFzIHRoZSB0YXJnZXQgYXJyYXkgKHdoaWNoIGlzIGFsbG93ZWQpLjwvcmVtYXJrcz5cclxuICAgICAgICBwdWJsaWMgdm9pZCBGb2xkQnlDb2x1bW48VFU+KFRVW10gdGFyZ2V0LCBGdW5jPFRVLCBULCBUVT4gZiwgRnVuYzxUVSwgaW50LCBUVT4gZmluYWxpemUsIFRVW10gc3RhdGUsIFplcm9zIHplcm9zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQuTGVuZ3RoICE9IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHN0YXRlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJzdGF0ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhdGUuTGVuZ3RoICE9IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInN0YXRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBGb2xkQnlDb2x1bW5VbmNoZWNrZWQ8VFU+KHRhcmdldCwgKEZ1bmM8VFUsVCxUVT4pZiwgKEZ1bmM8VFUsaW50LFRVPilmaW5hbGl6ZSwgc3RhdGUsIHplcm9zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5UaGUgc3RhdGUgYXJyYXkgd2lsbCBub3QgYmUgbW9kaWZpZWQsIHVubGVzcyBpdCBpcyB0aGUgc2FtZSBpbnN0YW5jZSBhcyB0aGUgdGFyZ2V0IGFycmF5ICh3aGljaCBpcyBhbGxvd2VkKS48L3JlbWFya3M+XHJcbiAgICAgICAgaW50ZXJuYWwgdmlydHVhbCB2b2lkIEZvbGRCeUNvbHVtblVuY2hlY2tlZDxUVT4oVFVbXSB0YXJnZXQsIEZ1bmM8VFUsIFQsIFRVPiBmLCBGdW5jPFRVLCBpbnQsIFRVPiBmaW5hbGl6ZSwgVFVbXSBzdGF0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRVIHMgPSBzdGF0ZVtqXTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gZihzLCBBdChpLCBqKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRbal0gPSBmaW5hbGl6ZShzLCBSb3dDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBUU3RhdGUgRm9sZDI8VE90aGVyLCBUU3RhdGU+KE1hdHJpeFN0b3JhZ2U8VE90aGVyPiBvdGhlciwgRnVuYzxUU3RhdGUsIFQsIFRPdGhlciwgVFN0YXRlPiBmLCBUU3RhdGUgc3RhdGUsIFplcm9zIHplcm9zKVxyXG4gICAgICAgICAgICB3aGVyZSBUT3RoZXIgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VE90aGVyPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAob3RoZXIgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcIm90aGVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gb3RoZXIuUm93Q291bnQgfHwgQ29sdW1uQ291bnQgIT0gb3RoZXIuQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gc3RyaW5nLkZvcm1hdChcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeERpbWVuc2lvbnMyLCBSb3dDb3VudCArIHggKyBDb2x1bW5Db3VudCwgb3RoZXIuUm93Q291bnQgKyB4ICsgb3RoZXIuQ29sdW1uQ291bnRcIik7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24obWVzc2FnZSwgXCJvdGhlclwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIEZvbGQyVW5jaGVja2VkPFRPdGhlcixUU3RhdGU+KG90aGVyLCAoRnVuYzxUU3RhdGUsVCxUT3RoZXIsVFN0YXRlPilmLCBzdGF0ZSwgemVyb3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdmlydHVhbCBUU3RhdGUgRm9sZDJVbmNoZWNrZWQ8VE90aGVyLCBUU3RhdGU+KE1hdHJpeFN0b3JhZ2U8VE90aGVyPiBvdGhlciwgRnVuYzxUU3RhdGUsIFQsIFRPdGhlciwgVFN0YXRlPiBmLCBUU3RhdGUgc3RhdGUsIFplcm9zIHplcm9zKVxyXG4gICAgICAgICAgICB3aGVyZSBUT3RoZXIgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VE90aGVyPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGYoc3RhdGUsIEF0KGksIGopLCBvdGhlci5BdChpLCBqKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiTWF0cml4U3RvcmFnZS5WYWxpZGF0aW9uLmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTQgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxuXHJcblxyXG5uYW1lc3BhY2UgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLlN0b3JhZ2Vcclxue1xyXG4gICAgLy8gUmVTaGFycGVyIGRpc2FibGUgVW51c2VkUGFyYW1ldGVyLkxvY2FsXHJcblxyXG4gICAgcHVibGljIHBhcnRpYWwgY2xhc3MgTWF0cml4U3RvcmFnZTxUPlxyXG4gICAge1xyXG4gICAgICAgIHZvaWQgVmFsaWRhdGVSYW5nZShpbnQgcm93LCBpbnQgY29sdW1uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCh1aW50KXJvdyA+PSAodWludClSb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInJvd1wiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCh1aW50KWNvbHVtbiA+PSAodWludClDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImNvbHVtblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBWYWxpZGF0ZVN1Yk1hdHJpeFJhbmdlPFRVPihNYXRyaXhTdG9yYWdlPFRVPiB0YXJnZXQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VSb3dJbmRleCwgaW50IHRhcmdldFJvd0luZGV4LCBpbnQgcm93Q291bnQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VDb2x1bW5JbmRleCwgaW50IHRhcmdldENvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocm93Q291bnQgPCAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwicm93Q291bnRcIiwgXCJSZXNvdXJjZXMuQXJndW1lbnRNdXN0QmVQb3NpdGl2ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvbHVtbkNvdW50IDwgMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImNvbHVtbkNvdW50XCIsIFwiUmVzb3VyY2VzLkFyZ3VtZW50TXVzdEJlUG9zaXRpdmVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFZlcmlmeSBTb3VyY2VcclxuXHJcbiAgICAgICAgICAgIGlmICgodWludClzb3VyY2VSb3dJbmRleCA+PSAodWludClSb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInNvdXJjZVJvd0luZGV4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoKHVpbnQpc291cmNlQ29sdW1uSW5kZXggPj0gKHVpbnQpQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJzb3VyY2VDb2x1bW5JbmRleFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNvdXJjZVJvd01heCA9IHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQ7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VDb2x1bW5NYXggPSBzb3VyY2VDb2x1bW5JbmRleCArIGNvbHVtbkNvdW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKHNvdXJjZVJvd01heCA+IFJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwicm93Q291bnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VDb2x1bW5NYXggPiBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImNvbHVtbkNvdW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBWZXJpZnkgVGFyZ2V0XHJcblxyXG4gICAgICAgICAgICBpZiAoKHVpbnQpdGFyZ2V0Um93SW5kZXggPj0gKHVpbnQpdGFyZ2V0LlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwidGFyZ2V0Um93SW5kZXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICgodWludCl0YXJnZXRDb2x1bW5JbmRleCA+PSAodWludCl0YXJnZXQuQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJ0YXJnZXRDb2x1bW5JbmRleFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHRhcmdldFJvd01heCA9IHRhcmdldFJvd0luZGV4ICsgcm93Q291bnQ7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRDb2x1bW5NYXggPSB0YXJnZXRDb2x1bW5JbmRleCArIGNvbHVtbkNvdW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKHRhcmdldFJvd01heCA+IHRhcmdldC5Sb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInJvd0NvdW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0Q29sdW1uTWF4ID4gdGFyZ2V0LkNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiY29sdW1uQ291bnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgVmFsaWRhdGVSb3dSYW5nZTxUVT4oVmVjdG9yU3RvcmFnZTxUVT4gdGFyZ2V0LCBpbnQgcm93SW5kZXgpXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoKHVpbnQpcm93SW5kZXggPj0gKHVpbnQpUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJyb3dJbmRleFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ICE9IHRhcmdldC5MZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeFNhbWVSb3dEaW1lbnNpb25cIiwgXCJ0YXJnZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgVmFsaWRhdGVDb2x1bW5SYW5nZTxUVT4oVmVjdG9yU3RvcmFnZTxUVT4gdGFyZ2V0LCBpbnQgY29sdW1uSW5kZXgpXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoKHVpbnQpY29sdW1uSW5kZXggPj0gKHVpbnQpQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJjb2x1bW5JbmRleFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFJvd0NvdW50ICE9IHRhcmdldC5MZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeFNhbWVDb2x1bW5EaW1lbnNpb25cIiwgXCJ0YXJnZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgVmFsaWRhdGVTdWJSb3dSYW5nZTxUVT4oVmVjdG9yU3RvcmFnZTxUVT4gdGFyZ2V0LCBpbnQgcm93SW5kZXgsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VDb2x1bW5JbmRleCwgaW50IHRhcmdldENvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoY29sdW1uQ291bnQgPCAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiY29sdW1uQ291bnRcIiwgXCJSZXNvdXJjZXMuQXJndW1lbnRNdXN0QmVQb3NpdGl2ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVmVyaWZ5IFNvdXJjZVxyXG5cclxuICAgICAgICAgICAgaWYgKCh1aW50KXJvd0luZGV4ID49ICh1aW50KVJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwicm93SW5kZXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICgodWludClzb3VyY2VDb2x1bW5JbmRleCA+PSAodWludClDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInNvdXJjZUNvbHVtbkluZGV4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudCA+IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiY29sdW1uQ291bnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFZlcmlmeSBUYXJnZXRcclxuXHJcbiAgICAgICAgICAgIGlmICgodWludCl0YXJnZXRDb2x1bW5JbmRleCA+PSAodWludCl0YXJnZXQuTGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwidGFyZ2V0Q29sdW1uSW5kZXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRDb2x1bW5JbmRleCArIGNvbHVtbkNvdW50ID4gdGFyZ2V0Lkxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImNvbHVtbkNvdW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2b2lkIFZhbGlkYXRlU3ViQ29sdW1uUmFuZ2U8VFU+KFZlY3RvclN0b3JhZ2U8VFU+IHRhcmdldCwgaW50IGNvbHVtbkluZGV4LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlUm93SW5kZXgsIGludCB0YXJnZXRSb3dJbmRleCwgaW50IHJvd0NvdW50KVxyXG4gICAgICAgICAgICB3aGVyZSBUVSA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUVT4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJvd0NvdW50IDwgMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInJvd0NvdW50XCIsIFwiUmVzb3VyY2VzLkFyZ3VtZW50TXVzdEJlUG9zaXRpdmVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFZlcmlmeSBTb3VyY2VcclxuXHJcbiAgICAgICAgICAgIGlmICgodWludCljb2x1bW5JbmRleCA+PSAodWludClDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImNvbHVtbkluZGV4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoKHVpbnQpc291cmNlUm93SW5kZXggPj0gKHVpbnQpUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJzb3VyY2VSb3dJbmRleFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQgPiBSb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInJvd0NvdW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBWZXJpZnkgVGFyZ2V0XHJcblxyXG4gICAgICAgICAgICBpZiAoKHVpbnQpdGFyZ2V0Um93SW5kZXggPj0gKHVpbnQpdGFyZ2V0Lkxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInRhcmdldFJvd0luZGV4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0Um93SW5kZXggKyByb3dDb3VudCA+IHRhcmdldC5MZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJyb3dDb3VudFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZVNoYXJwZXIgcmVzdG9yZSBVbnVzZWRQYXJhbWV0ZXIuTG9jYWxcclxufVxyXG4iLCIvLyA8Y29weXJpZ2h0IGZpbGU9XCJWZWN0b3JTdG9yYWdlLmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTUgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGUuTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhO1xyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uUnVudGltZS5TZXJpYWxpemF0aW9uO1xyXG4vL3VzaW5nIE1hdGhOZXQuTnVtZXJpY3MuUHJvcGVydGllcztcclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuU3RvcmFnZVxyXG57XHJcbiAgICBbU2VyaWFsaXphYmxlXVxyXG4gICAgW0RhdGFDb250cmFjdChOYW1lc3BhY2UgPSBcInVybjpNYXRoTmV0L051bWVyaWNzL0xpbmVhckFsZ2VicmFcIildXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgcGFydGlhbCBjbGFzcyBWZWN0b3JTdG9yYWdlPFQ+IDogSUVxdWF0YWJsZTxWZWN0b3JTdG9yYWdlPFQ+PlxyXG4gICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAge1xyXG4gICAgICAgIC8vIFtydWVnZ10gcHVibGljIGZpZWxkcyBhcmUgT0sgaGVyZVxyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IFQgWmVybyA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3IuWmVybztcclxuXHJcbiAgICAgICAgW0RhdGFNZW1iZXIoT3JkZXIgPSAxKV1cclxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgaW50IExlbmd0aDtcclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIFZlY3RvclN0b3JhZ2UoaW50IGxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPD0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImxlbmd0aFwiLCBcIlJlc291cmNlcy5Bcmd1bWVudE11c3RCZVBvc2l0aXZlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBMZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRydWUgaWYgdGhlIHZlY3RvciBzdG9yYWdlIGZvcm1hdCBpcyBkZW5zZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBib29sIElzRGVuc2UgeyBnZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIG9yIHNldHMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleCwgd2l0aCByYW5nZSBjaGVja2luZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluZGV4XCI+XHJcbiAgICAgICAgLy8vIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudC5cclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSB2YWx1ZSB0byBnZXQgb3Igc2V0LjwvdmFsdWU+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlRoaXMgbWV0aG9kIGlzIHJhbmdlZCBjaGVja2VkLiA8c2VlIGNyZWY9XCJBdChpbnQpXCIvPiBhbmQgPHNlZSBjcmVmPVwiQXQoaW50LFQpXCIvPlxyXG4gICAgICAgIC8vLyB0byBnZXQgYW5kIHNldCB2YWx1ZXMgd2l0aG91dCByYW5nZSBjaGVja2luZy48L3JlbWFya3M+XHJcbiAgICAgICAgcHVibGljIFQgdGhpc1tpbnQgaW5kZXhdXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmFsaWRhdGVSYW5nZShpbmRleCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmFsaWRhdGVSYW5nZShpbmRleCk7XHJcbiAgICAgICAgICAgICAgICBBdChpbmRleCwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHJpZXZlcyB0aGUgcmVxdWVzdGVkIGVsZW1lbnQgd2l0aG91dCByYW5nZSBjaGVja2luZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluZGV4XCI+VGhlIGluZGV4IG9mIHRoZSBlbGVtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXF1ZXN0ZWQgZWxlbWVudC48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPk5vdCByYW5nZS1jaGVja2VkLjwvcmVtYXJrcz5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3QgVCBBdChpbnQgaW5kZXgpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldHMgdGhlIGVsZW1lbnQgd2l0aG91dCByYW5nZSBjaGVja2luZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluZGV4XCI+VGhlIGluZGV4IG9mIHRoZSBlbGVtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmFsdWVcIj5UaGUgdmFsdWUgdG8gc2V0IHRoZSBlbGVtZW50IHRvLiA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5XQVJOSU5HOiBUaGlzIG1ldGhvZCBpcyBub3QgdGhyZWFkIHNhZmUuIFVzZSBcImxvY2tcIiB3aXRoIGl0IGFuZCBiZSBzdXJlIHRvIGF2b2lkIGRlYWRsb2Nrcy48L3JlbWFya3M+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IHZvaWQgQXQoaW50IGluZGV4LCBUIHZhbHVlKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY3VycmVudCBvYmplY3QgaXMgZXF1YWwgdG8gYW5vdGhlciBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+XHJcbiAgICAgICAgLy8vIEFuIG9iamVjdCB0byBjb21wYXJlIHdpdGggdGhpcyBvYmplY3QuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8Yz50cnVlPC9jPiBpZiB0aGUgY3VycmVudCBvYmplY3QgaXMgZXF1YWwgdG8gdGhlIDxwYXJhbXJlZiBuYW1lPVwib3RoZXJcIi8+IHBhcmFtZXRlcjsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBib29sIEVxdWFscyhWZWN0b3JTdG9yYWdlPFQ+IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gUmVqZWN0IGVxdWFsaXR5IHdoZW4gdGhlIGFyZ3VtZW50IGlzIG51bGwgb3IgaGFzIGEgZGlmZmVyZW50IHNoYXBlLlxyXG4gICAgICAgICAgICBpZiAob3RoZXIgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChMZW5ndGggIT0gb3RoZXIuTGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFjY2VwdCBpZiB0aGUgYXJndW1lbnQgaXMgdGhlIHNhbWUgb2JqZWN0IGFzIHRoaXMuXHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHModGhpcywgb3RoZXIpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHBlcmZvcm0gZWxlbWVudCB3aXNlIGNvbXBhcmlzb24uXHJcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBMZW5ndGg7IGluZGV4KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghQXQoaW5kZXgpLkVxdWFscyhvdGhlci5BdChpbmRleCkpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIDxzZWUgY3JlZj1cIlQ6U3lzdGVtLk9iamVjdFwiLz4gaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgPHNlZSBjcmVmPVwiVDpTeXN0ZW0uT2JqZWN0XCIvPi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIDxzZWUgY3JlZj1cIlQ6U3lzdGVtLk9iamVjdFwiLz4gaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgPHNlZSBjcmVmPVwiVDpTeXN0ZW0uT2JqZWN0XCIvPjsgb3RoZXJ3aXNlLCBmYWxzZS5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm9ialwiPlRoZSA8c2VlIGNyZWY9XCJUOlN5c3RlbS5PYmplY3RcIi8+IHRvIGNvbXBhcmUgd2l0aCB0aGUgY3VycmVudCA8c2VlIGNyZWY9XCJUOlN5c3RlbS5PYmplY3RcIi8+LiA8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzZWFsZWQgb3ZlcnJpZGUgYm9vbCBFcXVhbHMob2JqZWN0IG9iailcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBFcXVhbHMob2JqIGFzIFZlY3RvclN0b3JhZ2U8VD4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXJ2ZXMgYXMgYSBoYXNoIGZ1bmN0aW9uIGZvciBhIHBhcnRpY3VsYXIgdHlwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gQSBoYXNoIGNvZGUgZm9yIHRoZSBjdXJyZW50IDxzZWUgY3JlZj1cIlQ6U3lzdGVtLk9iamVjdFwiLz4uXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IEdldEhhc2hDb2RlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBoYXNoTnVtID0gTWF0aC5NaW4oTGVuZ3RoLCAyNSk7XHJcbiAgICAgICAgICAgIGludCBoYXNoID0gMTc7XHJcbiAgICAgICAgICAgIHVuY2hlY2tlZFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhc2hOdW07IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoID0gaGFzaCozMSArIEF0KGkpLkdldEhhc2hDb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDTEVBUklOR1xyXG5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCB2b2lkIENsZWFyKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF0KGksIFplcm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCB2b2lkIENsZWFyKGludCBpbmRleCwgaW50IGNvdW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgaW5kZXggKyBjb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBdChpLCBaZXJvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVkVDVE9SIENPUFlcclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ29weVRvKFZlY3RvclN0b3JhZ2U8VD4gdGFyZ2V0LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhID0gRXhpc3RpbmdEYXRhLkNsZWFyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoUmVmZXJlbmNlRXF1YWxzKHRoaXMsIHRhcmdldCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKExlbmd0aCAhPSB0YXJnZXQuTGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgQ29weVRvVW5jaGVja2VkKHRhcmdldCwgZXhpc3RpbmdEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZpcnR1YWwgdm9pZCBDb3B5VG9VbmNoZWNrZWQoVmVjdG9yU3RvcmFnZTxUPiB0YXJnZXQsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IExlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQXQoaSwgQXQoaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBST1cgQ09QWVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDb3B5VG9Sb3coTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsIGludCByb3dJbmRleCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSA9IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKExlbmd0aCAhPSB0YXJnZXQuQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWYWxpZGF0ZVJvd1JhbmdlKHRhcmdldCwgcm93SW5kZXgpO1xyXG4gICAgICAgICAgICBDb3B5VG9Sb3dVbmNoZWNrZWQodGFyZ2V0LCByb3dJbmRleCwgZXhpc3RpbmdEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZpcnR1YWwgdm9pZCBDb3B5VG9Sb3dVbmNoZWNrZWQoTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsIGludCByb3dJbmRleCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgTGVuZ3RoOyBqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5BdChyb3dJbmRleCwgaiwgQXQoaikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDT0xVTU4gQ09QWVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDb3B5VG9Db2x1bW4oTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsIGludCBjb2x1bW5JbmRleCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSA9IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKExlbmd0aCAhPSB0YXJnZXQuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWYWxpZGF0ZUNvbHVtblJhbmdlKHRhcmdldCwgY29sdW1uSW5kZXgpO1xyXG4gICAgICAgICAgICBDb3B5VG9Db2x1bW5VbmNoZWNrZWQodGFyZ2V0LCBjb2x1bW5JbmRleCwgZXhpc3RpbmdEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZpcnR1YWwgdm9pZCBDb3B5VG9Db2x1bW5VbmNoZWNrZWQoTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsIGludCBjb2x1bW5JbmRleCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5BdChpLCBjb2x1bW5JbmRleCwgQXQoaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTVUItVkVDVE9SIENPUFlcclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ29weVN1YlZlY3RvclRvKFZlY3RvclN0b3JhZ2U8VD4gdGFyZ2V0LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlSW5kZXgsIGludCB0YXJnZXRJbmRleCwgaW50IGNvdW50LFxyXG4gICAgICAgICAgICBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhID0gRXhpc3RpbmdEYXRhLkNsZWFyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY291bnQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWYWxpZGF0ZVN1YlZlY3RvclJhbmdlKHRhcmdldCwgc291cmNlSW5kZXgsIHRhcmdldEluZGV4LCBjb3VudCk7XHJcbiAgICAgICAgICAgIENvcHlTdWJWZWN0b3JUb1VuY2hlY2tlZCh0YXJnZXQsIHNvdXJjZUluZGV4LCB0YXJnZXRJbmRleCwgY291bnQsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2aXJ0dWFsIHZvaWQgQ29weVN1YlZlY3RvclRvVW5jaGVja2VkKFZlY3RvclN0b3JhZ2U8VD4gdGFyZ2V0LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlSW5kZXgsIGludCB0YXJnZXRJbmRleCwgaW50IGNvdW50LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCB0YXJnZXQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gbmV3IFRbY291bnRdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB0bXAuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wW2ldID0gQXQoaSArIHNvdXJjZUluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdG1wLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEF0KGkgKyB0YXJnZXRJbmRleCwgdG1wW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBzb3VyY2VJbmRleCwgaWkgPSB0YXJnZXRJbmRleDsgaSA8IHNvdXJjZUluZGV4ICsgY291bnQ7IGkrKywgaWkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkF0KGlpLCBBdChpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNVQi1ST1cgQ09QWVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDb3B5VG9TdWJSb3coTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsIGludCByb3dJbmRleCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZUNvbHVtbkluZGV4LCBpbnQgdGFyZ2V0Q29sdW1uSW5kZXgsIGludCBjb2x1bW5Db3VudCxcclxuICAgICAgICAgICAgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSA9IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvbHVtbkNvdW50ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmFsaWRhdGVTdWJSb3dSYW5nZSh0YXJnZXQsIHJvd0luZGV4LCBzb3VyY2VDb2x1bW5JbmRleCwgdGFyZ2V0Q29sdW1uSW5kZXgsIGNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgQ29weVRvU3ViUm93VW5jaGVja2VkKHRhcmdldCwgcm93SW5kZXgsIHNvdXJjZUNvbHVtbkluZGV4LCB0YXJnZXRDb2x1bW5JbmRleCwgY29sdW1uQ291bnQsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2aXJ0dWFsIHZvaWQgQ29weVRvU3ViUm93VW5jaGVja2VkKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBpbnQgcm93SW5kZXgsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VDb2x1bW5JbmRleCwgaW50IHRhcmdldENvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gc291cmNlQ29sdW1uSW5kZXgsIGpqID0gdGFyZ2V0Q29sdW1uSW5kZXg7IGogPCBzb3VyY2VDb2x1bW5JbmRleCArIGNvbHVtbkNvdW50OyBqKyssIGpqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5BdChyb3dJbmRleCwgamosIEF0KGopKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU1VCLUNPTFVNTiBDT1BZXHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENvcHlUb1N1YkNvbHVtbihNYXRyaXhTdG9yYWdlPFQ+IHRhcmdldCwgaW50IGNvbHVtbkluZGV4LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlUm93SW5kZXgsIGludCB0YXJnZXRSb3dJbmRleCwgaW50IHJvd0NvdW50LFxyXG4gICAgICAgICAgICBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhID0gRXhpc3RpbmdEYXRhLkNsZWFyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocm93Q291bnQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWYWxpZGF0ZVN1YkNvbHVtblJhbmdlKHRhcmdldCwgY29sdW1uSW5kZXgsIHNvdXJjZVJvd0luZGV4LCB0YXJnZXRSb3dJbmRleCwgcm93Q291bnQpO1xyXG4gICAgICAgICAgICBDb3B5VG9TdWJDb2x1bW5VbmNoZWNrZWQodGFyZ2V0LCBjb2x1bW5JbmRleCwgc291cmNlUm93SW5kZXgsIHRhcmdldFJvd0luZGV4LCByb3dDb3VudCwgZXhpc3RpbmdEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZpcnR1YWwgdm9pZCBDb3B5VG9TdWJDb2x1bW5VbmNoZWNrZWQoTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsIGludCBjb2x1bW5JbmRleCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZVJvd0luZGV4LCBpbnQgdGFyZ2V0Um93SW5kZXgsIGludCByb3dDb3VudCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBzb3VyY2VSb3dJbmRleCwgaWkgPSB0YXJnZXRSb3dJbmRleDsgaSA8IHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQ7IGkrKywgaWkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkF0KGlpLCBjb2x1bW5JbmRleCwgQXQoaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFWFRSQUNUXHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIFRbXSBUb0FycmF5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSBuZXcgVFtMZW5ndGhdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHJldC5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0W2ldID0gQXQoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIFRbXSBBc0FycmF5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRU5VTUVSQVRJT05cclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgSUVudW1lcmFibGU8VD4gRW51bWVyYXRlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHJldHVybiBBdChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgSUVudW1lcmFibGU8VHVwbGU8aW50LCBUPj4gRW51bWVyYXRlSW5kZXhlZCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IExlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCByZXR1cm4gbmV3IFR1cGxlPGludCwgVD4oaSwgQXQoaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBJRW51bWVyYWJsZTxUPiBFbnVtZXJhdGVOb25aZXJvKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gQXQoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIVplcm8uRXF1YWxzKHgpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHJldHVybiB4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBJRW51bWVyYWJsZTxUdXBsZTxpbnQsIFQ+PiBFbnVtZXJhdGVOb25aZXJvSW5kZXhlZCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IExlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IEF0KGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyh4KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCByZXR1cm4gbmV3IFR1cGxlPGludCwgVD4oaSwgeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZJTkRcclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgVHVwbGU8aW50LCBUPiBGaW5kKEZ1bmM8VCwgYm9vbD4gcHJlZGljYXRlLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gQXQoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKGl0ZW0pKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGU8aW50LCBUPihpLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBUdXBsZTxpbnQsIFQsIFRPdGhlcj4gRmluZDI8VE90aGVyPihWZWN0b3JTdG9yYWdlPFRPdGhlcj4gb3RoZXIsIEZ1bmM8VCwgVE90aGVyLCBib29sPiBwcmVkaWNhdGUsIFplcm9zIHplcm9zKVxyXG4gICAgICAgICAgICB3aGVyZSBUT3RoZXIgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VE90aGVyPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAob3RoZXIgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcIm90aGVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoTGVuZ3RoICE9IG90aGVyLkxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJvdGhlclwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIEZpbmQyVW5jaGVja2VkPFRPdGhlcj4ob3RoZXIsIChGdW5jPFQsVE90aGVyLGJvb2w+KXByZWRpY2F0ZSwgemVyb3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdmlydHVhbCBUdXBsZTxpbnQsIFQsIFRPdGhlcj4gRmluZDJVbmNoZWNrZWQ8VE90aGVyPihWZWN0b3JTdG9yYWdlPFRPdGhlcj4gb3RoZXIsIEZ1bmM8VCwgVE90aGVyLCBib29sPiBwcmVkaWNhdGUsIFplcm9zIHplcm9zKVxyXG4gICAgICAgICAgICB3aGVyZSBUT3RoZXIgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VE90aGVyPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IExlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IEF0KGkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG90aGVySXRlbSA9IG90aGVyLkF0KGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtLCBvdGhlckl0ZW0pKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGU8aW50LCBULCBUT3RoZXI+KGksIGl0ZW0sIG90aGVySXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGVU5DVElPTkFMIENPTUJJTkFUT1JTOiBNQVBcclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgdm9pZCBNYXBJbnBsYWNlKEZ1bmM8VCwgVD4gZiwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IExlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBdChpLCBmKEF0KGkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIHZvaWQgTWFwSW5kZXhlZElucGxhY2UoRnVuYzxpbnQsIFQsIFQ+IGYsIFplcm9zIHplcm9zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXQoaSwgZihpLCBBdChpKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXBUbzxUVT4oVmVjdG9yU3RvcmFnZTxUVT4gdGFyZ2V0LCBGdW5jPFQsIFRVPiBmLCBaZXJvcyB6ZXJvcywgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICAgICAgd2hlcmUgVFUgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VFU+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKExlbmd0aCAhPSB0YXJnZXQuTGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgTWFwVG9VbmNoZWNrZWQ8VFU+KHRhcmdldCwgKEZ1bmM8VCxUVT4pZiwgemVyb3MsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2aXJ0dWFsIHZvaWQgTWFwVG9VbmNoZWNrZWQ8VFU+KFZlY3RvclN0b3JhZ2U8VFU+IHRhcmdldCwgRnVuYzxULCBUVT4gZiwgWmVyb3MgemVyb3MsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IExlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQXQoaSwgZihBdChpKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXBJbmRleGVkVG88VFU+KFZlY3RvclN0b3JhZ2U8VFU+IHRhcmdldCwgRnVuYzxpbnQsIFQsIFRVPiBmLCBaZXJvcyB6ZXJvcywgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICAgICAgd2hlcmUgVFUgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VFU+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKExlbmd0aCAhPSB0YXJnZXQuTGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgTWFwSW5kZXhlZFRvVW5jaGVja2VkPFRVPih0YXJnZXQsIChGdW5jPGludCxULFRVPilmLCB6ZXJvcywgZXhpc3RpbmdEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZpcnR1YWwgdm9pZCBNYXBJbmRleGVkVG9VbmNoZWNrZWQ8VFU+KFZlY3RvclN0b3JhZ2U8VFU+IHRhcmdldCwgRnVuYzxpbnQsIFQsIFRVPiBmLCBaZXJvcyB6ZXJvcywgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICAgICAgd2hlcmUgVFUgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VFU+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5BdChpLCBmKGksIEF0KGkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1hcDJUbyhWZWN0b3JTdG9yYWdlPFQ+IHRhcmdldCwgVmVjdG9yU3RvcmFnZTxUPiBvdGhlciwgRnVuYzxULCBULCBUPiBmLCBaZXJvcyB6ZXJvcywgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG90aGVyID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJvdGhlclwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKExlbmd0aCAhPSB0YXJnZXQuTGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKExlbmd0aCAhPSBvdGhlci5MZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudFZlY3RvcnNTYW1lTGVuZ3RoXCIsIFwib3RoZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIE1hcDJUb1VuY2hlY2tlZCh0YXJnZXQsIG90aGVyLCAoRnVuYzxULFQsVD4pZiwgemVyb3MsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2aXJ0dWFsIHZvaWQgTWFwMlRvVW5jaGVja2VkKFZlY3RvclN0b3JhZ2U8VD4gdGFyZ2V0LCBWZWN0b3JTdG9yYWdlPFQ+IG90aGVyLCBGdW5jPFQsIFQsIFQ+IGYsIFplcm9zIHplcm9zLCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkF0KGksIGYoQXQoaSksIG90aGVyLkF0KGkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZVTkNUSU9OQUwgQ09NQklOQVRPUlM6IEZPTERcclxuXHJcbiAgICAgICAgcHVibGljIFRTdGF0ZSBGb2xkMjxUT3RoZXIsIFRTdGF0ZT4oVmVjdG9yU3RvcmFnZTxUT3RoZXI+IG90aGVyLCBGdW5jPFRTdGF0ZSwgVCwgVE90aGVyLCBUU3RhdGU+IGYsIFRTdGF0ZSBzdGF0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAgICAgIHdoZXJlIFRPdGhlciA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUT3RoZXI+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlciA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwib3RoZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChMZW5ndGggIT0gb3RoZXIuTGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcIm90aGVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gRm9sZDJVbmNoZWNrZWQ8VE90aGVyLFRTdGF0ZT4ob3RoZXIsIChGdW5jPFRTdGF0ZSxULFRPdGhlcixUU3RhdGU+KWYsIHN0YXRlLCB6ZXJvcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2aXJ0dWFsIFRTdGF0ZSBGb2xkMlVuY2hlY2tlZDxUT3RoZXIsIFRTdGF0ZT4oVmVjdG9yU3RvcmFnZTxUT3RoZXI+IG90aGVyLCBGdW5jPFRTdGF0ZSwgVCwgVE90aGVyLCBUU3RhdGU+IGYsIFRTdGF0ZSBzdGF0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAgICAgIHdoZXJlIFRPdGhlciA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUT3RoZXI+LCBJRm9ybWF0dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgQXQoaSksIG90aGVyLkF0KGkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvLyA8Y29weXJpZ2h0IGZpbGU9XCJWZWN0b3JTdG9yYWdlLlZhbGlkYXRpb24uY3NcIiBjb21wYW55PVwiTWF0aC5ORVRcIj5cclxuLy8gTWF0aC5ORVQgTnVtZXJpY3MsIHBhcnQgb2YgdGhlIE1hdGguTkVUIFByb2plY3RcclxuLy8gaHR0cDovL251bWVyaWNzLm1hdGhkb3RuZXQuY29tXHJcbi8vIGh0dHA6Ly9naXRodWIuY29tL21hdGhuZXQvbWF0aG5ldC1udW1lcmljc1xyXG4vL1xyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMyBNYXRoLk5FVFxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxyXG4vLyBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4vLyBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuLy8gcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXHJcbi8vIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4vLyBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xyXG4vLyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4vLyBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXHJcbi8vIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbi8vIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXHJcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxyXG4vLyBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4vLyBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbi8vIDwvY29weXJpZ2h0PlxyXG5cclxudXNpbmcgU3lzdGVtO1xyXG5cclxubmFtZXNwYWNlIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5TdG9yYWdlXHJcbntcclxuICAgIC8vIFJlU2hhcnBlciBkaXNhYmxlIFVudXNlZFBhcmFtZXRlci5HbG9iYWxcclxuICAgIHB1YmxpYyBwYXJ0aWFsIGNsYXNzIFZlY3RvclN0b3JhZ2U8VD5cclxuICAgIHtcclxuICAgICAgICB2b2lkIFZhbGlkYXRlUmFuZ2UoaW50IGluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCh1aW50KWluZGV4ID49ICh1aW50KUxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImluZGV4XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2b2lkIFZhbGlkYXRlU3ViVmVjdG9yUmFuZ2UoVmVjdG9yU3RvcmFnZTxUPiB0YXJnZXQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VJbmRleCwgaW50IHRhcmdldEluZGV4LCBpbnQgY291bnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoY291bnQgPCAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiY291bnRcIiwgXCJSZXNvdXJjZXMuQXJndW1lbnRNdXN0QmVQb3NpdGl2ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVmVyaWZ5IFNvdXJjZVxyXG5cclxuICAgICAgICAgICAgaWYgKCh1aW50KXNvdXJjZUluZGV4ID49ICh1aW50KUxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInNvdXJjZUluZGV4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc291cmNlTWF4ID0gc291cmNlSW5kZXggKyBjb3VudDtcclxuXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VNYXggPiBMZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJjb3VudFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVmVyaWZ5IFRhcmdldFxyXG5cclxuICAgICAgICAgICAgaWYgKCh1aW50KXRhcmdldEluZGV4ID49ICh1aW50KXRhcmdldC5MZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJ0YXJnZXRJbmRleFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHRhcmdldE1heCA9IHRhcmdldEluZGV4ICsgY291bnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0TWF4ID4gdGFyZ2V0Lkxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImNvdW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2b2lkIFZhbGlkYXRlUm93UmFuZ2UoTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsIGludCByb3dJbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICgodWludClyb3dJbmRleCA+PSAodWludCl0YXJnZXQuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJyb3dJbmRleFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRhcmdldC5Db2x1bW5Db3VudCAhPSBMZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeFNhbWVSb3dEaW1lbnNpb25cIiwgXCJ0YXJnZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgVmFsaWRhdGVDb2x1bW5SYW5nZShNYXRyaXhTdG9yYWdlPFQ+IHRhcmdldCwgaW50IGNvbHVtbkluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCh1aW50KWNvbHVtbkluZGV4ID49ICh1aW50KXRhcmdldC5Db2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImNvbHVtbkluZGV4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0LlJvd0NvdW50ICE9IExlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4U2FtZUNvbHVtbkRpbWVuc2lvblwiLCBcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBWYWxpZGF0ZVN1YlJvd1JhbmdlKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBpbnQgcm93SW5kZXgsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VDb2x1bW5JbmRleCwgaW50IHRhcmdldENvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoY29sdW1uQ291bnQgPCAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiY29sdW1uQ291bnRcIiwgXCJSZXNvdXJjZXMuQXJndW1lbnRNdXN0QmVQb3NpdGl2ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVmVyaWZ5IFNvdXJjZVxyXG5cclxuICAgICAgICAgICAgaWYgKCh1aW50KXNvdXJjZUNvbHVtbkluZGV4ID49ICh1aW50KUxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInNvdXJjZUNvbHVtbkluZGV4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudCA+IExlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImNvbHVtbkNvdW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBWZXJpZnkgVGFyZ2V0XHJcblxyXG4gICAgICAgICAgICBpZiAoKHVpbnQpcm93SW5kZXggPj0gKHVpbnQpdGFyZ2V0LlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwicm93SW5kZXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICgodWludCl0YXJnZXRDb2x1bW5JbmRleCA+PSAodWludCl0YXJnZXQuQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJ0YXJnZXRDb2x1bW5JbmRleFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRhcmdldENvbHVtbkluZGV4ICsgY29sdW1uQ291bnQgPiB0YXJnZXQuQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJjb2x1bW5Db3VudFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBWYWxpZGF0ZVN1YkNvbHVtblJhbmdlKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBpbnQgY29sdW1uSW5kZXgsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VSb3dJbmRleCwgaW50IHRhcmdldFJvd0luZGV4LCBpbnQgcm93Q291bnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocm93Q291bnQgPCAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwicm93Q291bnRcIiwgXCJSZXNvdXJjZXMuQXJndW1lbnRNdXN0QmVQb3NpdGl2ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVmVyaWZ5IFNvdXJjZVxyXG5cclxuICAgICAgICAgICAgaWYgKCh1aW50KXNvdXJjZVJvd0luZGV4ID49ICh1aW50KUxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInNvdXJjZVJvd0luZGV4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc291cmNlUm93SW5kZXggKyByb3dDb3VudCA+IExlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInJvd0NvdW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBWZXJpZnkgVGFyZ2V0XHJcblxyXG4gICAgICAgICAgICBpZiAoKHVpbnQpY29sdW1uSW5kZXggPj0gKHVpbnQpdGFyZ2V0LkNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiY29sdW1uSW5kZXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICgodWludCl0YXJnZXRSb3dJbmRleCA+PSAodWludCl0YXJnZXQuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJ0YXJnZXRSb3dJbmRleFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRhcmdldFJvd0luZGV4ICsgcm93Q291bnQgPiB0YXJnZXQuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJyb3dDb3VudFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFJlU2hhcnBlciByZXN0b3JlIFVudXNlZFBhcmFtZXRlci5HbG9iYWxcclxufVxyXG4iLCIvLyA8Y29weXJpZ2h0IGZpbGU9XCJWZWN0b3JFeHRlbnNpb25zLmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTUgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmFcclxue1xyXG4gICAgdXNpbmcgQ29tcGxleDY0ID0gbWF0aG5ldG51bWVyaWNzYnJpZGdlLkNvbXBsZXg7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBWZWN0b3JFeHRlbnNpb25zXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb252ZXJ0cyBhIHZlY3RvciB0byBzaW5nbGUgcHJlY2lzaW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8ZmxvYXQ+IFRvU2luZ2xlKHRoaXMgVmVjdG9yPGRvdWJsZT4gdmVjdG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZlY3Rvci5NYXA8ZmxvYXQ+KChTeXN0ZW0uRnVuYzxkb3VibGUsZmxvYXQ+KSh4ID0+IChmbG9hdCl4KSwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29udmVydHMgYSB2ZWN0b3IgdG8gZG91YmxlIHByZWNpc2lvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPGRvdWJsZT4gVG9Eb3VibGUodGhpcyBWZWN0b3I8ZmxvYXQ+IHZlY3RvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWN0b3IuTWFwPGRvdWJsZT4oKFN5c3RlbS5GdW5jPGZsb2F0LGRvdWJsZT4pKHggPT4gKGRvdWJsZSl4KSwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29udmVydHMgYSB2ZWN0b3IgdG8gc2luZ2xlIHByZWNpc2lvbiBjb21wbGV4IG51bWJlcnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxtYXRobmV0bnVtZXJpY3NicmlkZ2UuQ29tcGxleDMyPiBUb0NvbXBsZXgzMih0aGlzIFZlY3RvcjxDb21wbGV4NjQ+IHZlY3RvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWN0b3IuTWFwPG1hdGhuZXRudW1lcmljc2JyaWRnZS5Db21wbGV4MzI+KChTeXN0ZW0uRnVuYzxDb21wbGV4NjQsbWF0aG5ldG51bWVyaWNzYnJpZGdlLkNvbXBsZXgzMj4pKHggPT4gbmV3IG1hdGhuZXRudW1lcmljc2JyaWRnZS5Db21wbGV4MzIoKGZsb2F0KXguUmVhbCwgKGZsb2F0KXguSW1hZ2luYXJ5KSksIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnZlcnRzIGEgdmVjdG9yIHRvIGRvdWJsZSBwcmVjaXNpb24gY29tcGxleCBudW1iZXJzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8Q29tcGxleDY0PiBUb0NvbXBsZXgodGhpcyBWZWN0b3I8bWF0aG5ldG51bWVyaWNzYnJpZGdlLkNvbXBsZXgzMj4gdmVjdG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZlY3Rvci5NYXA8Q29tcGxleDY0PigoU3lzdGVtLkZ1bmM8bWF0aG5ldG51bWVyaWNzYnJpZGdlLkNvbXBsZXgzMixDb21wbGV4NjQ+KSh4ID0+IG5ldyBDb21wbGV4NjQoeC5SZWFsLCB4LkltYWdpbmFyeSkpLCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIGEgc2luZ2xlIHByZWNpc2lvbiBjb21wbGV4IHZlY3RvciB3aXRoIHRoZSByZWFsIHBhcnRzIGZyb20gdGhlIGdpdmVuIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPG1hdGhuZXRudW1lcmljc2JyaWRnZS5Db21wbGV4MzI+IFRvQ29tcGxleDMyKHRoaXMgVmVjdG9yPGZsb2F0PiB2ZWN0b3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdmVjdG9yLk1hcDxtYXRobmV0bnVtZXJpY3NicmlkZ2UuQ29tcGxleDMyPigoU3lzdGVtLkZ1bmM8ZmxvYXQsbWF0aG5ldG51bWVyaWNzYnJpZGdlLkNvbXBsZXgzMj4pKHggPT4gbmV3IG1hdGhuZXRudW1lcmljc2JyaWRnZS5Db21wbGV4MzIoeCwgMGYpKSwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBhIGRvdWJsZSBwcmVjaXNpb24gY29tcGxleCB2ZWN0b3Igd2l0aCB0aGUgcmVhbCBwYXJ0cyBmcm9tIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjxDb21wbGV4NjQ+IFRvQ29tcGxleCh0aGlzIFZlY3Rvcjxkb3VibGU+IHZlY3RvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWN0b3IuTWFwPENvbXBsZXg2ND4oKFN5c3RlbS5GdW5jPGRvdWJsZSxDb21wbGV4NjQ+KSh4ID0+IG5ldyBDb21wbGV4NjQoeCwgMGQpKSwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBhIHJlYWwgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgcmVhbCBwYXJ0cyBvZiBhIGNvbXBsZXggdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8ZG91YmxlPiBSZWFsKHRoaXMgVmVjdG9yPENvbXBsZXg2ND4gdmVjdG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZlY3Rvci5NYXA8ZG91YmxlPigoU3lzdGVtLkZ1bmM8Q29tcGxleDY0LGRvdWJsZT4pKHggPT4geC5SZWFsKSwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBhIHJlYWwgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgcmVhbCBwYXJ0cyBvZiBhIGNvbXBsZXggdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3I8ZmxvYXQ+IFJlYWwodGhpcyBWZWN0b3I8bWF0aG5ldG51bWVyaWNzYnJpZGdlLkNvbXBsZXgzMj4gdmVjdG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZlY3Rvci5NYXA8ZmxvYXQ+KChTeXN0ZW0uRnVuYzxtYXRobmV0bnVtZXJpY3NicmlkZ2UuQ29tcGxleDMyLGZsb2F0PikoeCA9PiB4LlJlYWwpLCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIGEgcmVhbCB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBpbWFnaW5hcnkgcGFydHMgb2YgYSBjb21wbGV4IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPGRvdWJsZT4gSW1hZ2luYXJ5KHRoaXMgVmVjdG9yPENvbXBsZXg2ND4gdmVjdG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZlY3Rvci5NYXA8ZG91YmxlPigoU3lzdGVtLkZ1bmM8Q29tcGxleDY0LGRvdWJsZT4pKHggPT4geC5JbWFnaW5hcnkpLCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIGEgcmVhbCB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBpbWFnaW5hcnkgcGFydHMgb2YgYSBjb21wbGV4IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yPGZsb2F0PiBJbWFnaW5hcnkodGhpcyBWZWN0b3I8bWF0aG5ldG51bWVyaWNzYnJpZGdlLkNvbXBsZXgzMj4gdmVjdG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZlY3Rvci5NYXA8ZmxvYXQ+KChTeXN0ZW0uRnVuYzxtYXRobmV0bnVtZXJpY3NicmlkZ2UuQ29tcGxleDMyLGZsb2F0PikoeCA9PiB4LkltYWdpbmFyeSksIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8vIDxjb3B5cmlnaHQgZmlsZT1cIlBlcm11dGF0aW9uLmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzXHJcbntcclxuICAgIHVzaW5nIFN5c3RlbTtcclxuICAgIFxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBDbGFzcyB0byByZXByZXNlbnQgYSBwZXJtdXRhdGlvbiBmb3IgYSBzdWJzZXQgb2YgdGhlIG5hdHVyYWwgbnVtYmVycy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBbU2VyaWFsaXphYmxlXVxyXG4gICAgcHVibGljIGNsYXNzIFBlcm11dGF0aW9uXHJcbiAgICB7XHJcbiAgICAgICAgI3JlZ2lvbiBmaWVsZHNcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBFbnRyeSBfaW5kaWNlc1tpXSByZXByZXNlbnRzIHRoZSBsb2NhdGlvbiB0byB3aGljaCBpIGlzIHBlcm11dGVkIHRvLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBpbnRbXSBfaW5kaWNlcztcclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvbiBmaWVsZHNcclxuXHJcbiAgICAgICAgI3JlZ2lvbiBDb25zdHJ1Y3RvclxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBQZXJtdXRhdGlvbiBjbGFzcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluZGljZXNcIj5BbiBhcnJheSB3aGljaCByZXByZXNlbnRzIHdoZXJlIGVhY2ggaW50ZWdlciBpcyBwZXJtdXRlZCB0b286IGluZGljZXNbaV0gcmVwcmVzZW50cyB0aGF0IGludGVnZXIgaVxyXG4gICAgICAgIC8vLyBpcyBwZXJtdXRlZCB0byBsb2NhdGlvbiBpbmRpY2VzW2ldLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFBlcm11dGF0aW9uKGludFtdIGluZGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIUNoZWNrRm9yUHJvcGVyUGVybXV0YXRpb24oaW5kaWNlcykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5QZXJtdXRhdGlvbkFzSW50QXJyYXlJbnZhbGlkXCIsIFwiaW5kaWNlc1wiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX2luZGljZXMgPSAoaW50W10paW5kaWNlcy5DbG9uZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0aGlzIHBlcm11dGF0aW9uIGlzIG92ZXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgaW50IERpbWVuc2lvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9pbmRpY2VzLkxlbmd0aDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB3aGVyZSA8cGFyYW1yZWYgbmFtZT1cImlkeFwiLz4gcGVybXV0ZXMgdG9vLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaWR4XCI+VGhlIGluZGV4IHRvIHBlcm11dGUgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgaW5kZXggd2hpY2ggaXMgcGVybXV0ZWQgdG8uPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBpbnQgdGhpc1tpbnQgaWR4XVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfaW5kaWNlc1tpZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBpbnZlcnNlIG9mIHRoZSBwZXJtdXRhdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgaW52ZXJzZSBvZiB0aGUgcGVybXV0YXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBQZXJtdXRhdGlvbiBJbnZlcnNlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBpbnZJZHggPSBuZXcgaW50W0RpbWVuc2lvbl07XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgaW52SWR4Lkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnZJZHhbX2luZGljZXNbaV1dID0gaTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJtdXRhdGlvbihpbnZJZHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb25zdHJ1Y3QgYW4gYXJyYXkgZnJvbSBhIHNlcXVlbmNlIG9mIGludmVyc2lvbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPGV4YW1wbGU+XHJcbiAgICAgICAgLy8vIEZyb20gd2lraXBlZGlhOiB0aGUgcGVybXV0YXRpb24gMTIwNDMgaGFzIHRoZSBpbnZlcnNpb25zICgwLDIpLCAoMSwyKSBhbmQgKDMsNCkuIFRoaXMgd291bGQgYmVcclxuICAgICAgICAvLy8gZW5jb2RlZCB1c2luZyB0aGUgYXJyYXkgWzIyMjQ0XS5cclxuICAgICAgICAvLy8gPC9leGFtcGxlPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImludlwiPlRoZSBzZXQgb2YgaW52ZXJzaW9ucyB0byBjb25zdHJ1Y3QgdGhlIHBlcm11dGF0aW9uIGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBwZXJtdXRhdGlvbiBnZW5lcmF0ZWQgZnJvbSBhIHNlcXVlbmNlIG9mIGludmVyc2lvbnMuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgUGVybXV0YXRpb24gRnJvbUludmVyc2lvbnMoaW50W10gaW52KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGlkeCA9IG5ldyBpbnRbaW52Lkxlbmd0aF07XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgaW52Lkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZHhbaV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gaW52Lkxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWR4W2ldICE9IGludltpXSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgdCA9IGlkeFtpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZHhbaV0gPSBpZHhbaW52W2ldXTtcclxuICAgICAgICAgICAgICAgICAgICBpZHhbaW52W2ldXSA9IHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVybXV0YXRpb24oaWR4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29uc3RydWN0IGEgc2VxdWVuY2Ugb2YgaW52ZXJzaW9ucyBmcm9tIHRoZSBwZXJtdXRhdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8ZXhhbXBsZT5cclxuICAgICAgICAvLy8gRnJvbSB3aWtpcGVkaWE6IHRoZSBwZXJtdXRhdGlvbiAxMjA0MyBoYXMgdGhlIGludmVyc2lvbnMgKDAsMiksICgxLDIpIGFuZCAoMyw0KS4gVGhpcyB3b3VsZCBiZVxyXG4gICAgICAgIC8vLyBlbmNvZGVkIHVzaW5nIHRoZSBhcnJheSBbMjIyNDRdLlxyXG4gICAgICAgIC8vLyA8L2V4YW1wbGU+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgc2VxdWVuY2Ugb2YgaW52ZXJzaW9ucy48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGludFtdIFRvSW52ZXJzaW9ucygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gKGludFtdKV9pbmRpY2VzLkNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGlkeC5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlkeFtpXSAhPSBpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBxID0gQXJyYXkuRmluZEluZGV4PGludD4oaWR4LCBpICsgMSwgKFByZWRpY2F0ZTxpbnQ+KSh4ID0+IHggPT0gaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gaWR4W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlkeFtpXSA9IHE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWR4W3FdID0gdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGlkeDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIDxwYXJhbXJlZiBuYW1lPVwiaW5kaWNlc1wiLz4gYXJyYXkgcmVwcmVzZW50cyBhIHByb3BlciBwZXJtdXRhdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluZGljZXNcIj5BbiBhcnJheSB3aGljaCByZXByZXNlbnRzIHdoZXJlIGVhY2ggaW50ZWdlciBpcyBwZXJtdXRlZCB0b286IGluZGljZXNbaV0gcmVwcmVzZW50cyB0aGF0IGludGVnZXIgaVxyXG4gICAgICAgIC8vLyBpcyBwZXJtdXRlZCB0byBsb2NhdGlvbiBpbmRpY2VzW2ldLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgPHBhcmFtcmVmIG5hbWU9XCJpbmRpY2VzXCIvPiByZXByZXNlbnRzIGEgcHJvcGVyIHBlcm11dGF0aW9uLCA8Yz5mYWxzZTwvYz4gb3RoZXJ3aXNlLjwvcmV0dXJucz5cclxuICAgICAgICBzdGF0aWMgYm9vbCBDaGVja0ZvclByb3BlclBlcm11dGF0aW9uKGludFtdIGluZGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaWR4Q2hlY2sgPSBuZXcgYm9vbFtpbmRpY2VzLkxlbmd0aF07XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGluZGljZXMuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRpY2VzW2ldID49IGluZGljZXMuTGVuZ3RoIHx8IGluZGljZXNbaV0gPCAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZHhDaGVja1tpbmRpY2VzW2ldXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgaW5kaWNlcy5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlkeENoZWNrW2ldID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8vIDxjb3B5cmlnaHQgZmlsZT1cIlNvcnRpbmcuY3NcIiBjb21wYW55PVwiTWF0aC5ORVRcIj5cclxuLy8gTWF0aC5ORVQgTnVtZXJpY3MsIHBhcnQgb2YgdGhlIE1hdGguTkVUIFByb2plY3RcclxuLy8gaHR0cDovL251bWVyaWNzLm1hdGhkb3RuZXQuY29tXHJcbi8vIGh0dHA6Ly9naXRodWIuY29tL21hdGhuZXQvbWF0aG5ldC1udW1lcmljc1xyXG4vL1xyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNSBNYXRoLk5FVFxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxyXG4vLyBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4vLyBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuLy8gcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXHJcbi8vIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4vLyBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xyXG4vLyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4vLyBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXHJcbi8vIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbi8vIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXHJcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxyXG4vLyBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4vLyBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbi8vIDwvY29weXJpZ2h0PlxyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBTb3J0aW5nIGFsZ29yaXRobXMgZm9yIHNpbmdsZSwgdHVwbGUgYW5kIHRyaXBsZSBsaXN0cy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIFNvcnRpbmdcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNvcnQgYSBsaXN0IG9mIGtleXMsIGluIHBsYWNlIHVzaW5nIHRoZSBxdWljayBzb3J0IGFsZ29yaXRobSB1c2luZyB0aGUgcXVpY2sgc29ydCBhbGdvcml0aG0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHR5cGVwYXJhbSBuYW1lPVwiVFwiPlRoZSB0eXBlIG9mIGVsZW1lbnRzIGluIHRoZSBrZXkgbGlzdC48L3R5cGVwYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJrZXlzXCI+TGlzdCB0byBzb3J0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29tcGFyZXJcIj5Db21wYXJpc29uLCBkZWZpbmluZyB0aGUgc29ydCBvcmRlci48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBTb3J0PFQ+KElMaXN0PFQ+IGtleXMsIElDb21wYXJlcjxUPiBjb21wYXJlciA9IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgY291bnQgPSBrZXlzLkNvdW50O1xyXG4gICAgICAgICAgICBpZiAoY291bnQgPD0gMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobnVsbCA9PSBjb21wYXJlcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29tcGFyZXIgPSBDb21wYXJlcjxUPi5EZWZhdWx0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY291bnQgPT0gMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVyLkNvbXBhcmUoa2V5c1swXSwga2V5c1sxXSkgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VD4oa2V5cywgMCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGluc2VydGlvbiBzb3J0XHJcbiAgICAgICAgICAgIGlmIChjb3VudCA8PSAxMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBjb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBqID0gaSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPj0gMCAmJiBjb21wYXJlci5Db21wYXJlKGtleXNbal0sIGtleSkgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5c1tqICsgMV0gPSBrZXlzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGtleXNbaiArIDFdID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBhcnJheSBjYXNlXHJcbiAgICAgICAgICAgIHZhciBrZXlzQXJyYXkgPSBrZXlzIGFzIFRbXTtcclxuICAgICAgICAgICAgaWYgKG51bGwgIT0ga2V5c0FycmF5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Tb3J0PFQ+KGtleXNBcnJheSwgY29tcGFyZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBnZW5lcmljIGxpc3QgY2FzZVxyXG4gICAgICAgICAgICB2YXIga2V5c0xpc3QgPSBrZXlzIGFzIExpc3Q8VD47XHJcbiAgICAgICAgICAgIGlmIChudWxsICE9IGtleXNMaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXlzTGlzdC5Tb3J0KGNvbXBhcmVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gbG9jYWwgc29ydCBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICBRdWlja1NvcnQ8VD4oa2V5cywgY29tcGFyZXIsIDAsIGNvdW50IC0gMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNvcnQgYSBsaXN0IG9mIGtleXMgYW5kIGl0ZW1zIHdpdGggcmVzcGVjdCB0byB0aGUga2V5cywgaW4gcGxhY2UgdXNpbmcgdGhlIHF1aWNrIHNvcnQgYWxnb3JpdGhtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlRLZXlcIj5UaGUgdHlwZSBvZiBlbGVtZW50cyBpbiB0aGUga2V5IGxpc3QuPC90eXBlcGFyYW0+XHJcbiAgICAgICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlRJdGVtXCI+VGhlIHR5cGUgb2YgZWxlbWVudHMgaW4gdGhlIGl0ZW0gbGlzdC48L3R5cGVwYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJrZXlzXCI+TGlzdCB0byBzb3J0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaXRlbXNcIj5MaXN0IHRvIHBlcm11dGUgdGhlIHNhbWUgd2F5IGFzIHRoZSBrZXkgbGlzdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbXBhcmVyXCI+Q29tcGFyaXNvbiwgZGVmaW5pbmcgdGhlIHNvcnQgb3JkZXIuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgU29ydDxUS2V5LCBUSXRlbT4oSUxpc3Q8VEtleT4ga2V5cywgSUxpc3Q8VEl0ZW0+IGl0ZW1zLCBJQ29tcGFyZXI8VEtleT4gY29tcGFyZXIgPSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGNvdW50ID0ga2V5cy5Db3VudDtcclxuICAgICAgICAgICAgaWYgKGNvdW50IDw9IDEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG51bGwgPT0gY29tcGFyZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbXBhcmVyID0gQ29tcGFyZXI8VEtleT4uRGVmYXVsdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvdW50ID09IDIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlci5Db21wYXJlKGtleXNbMF0sIGtleXNbMV0pID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBTd2FwPFRLZXk+KGtleXMsIDAsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VEl0ZW0+KGl0ZW1zLCAwLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gaW5zZXJ0aW9uIHNvcnRcclxuICAgICAgICAgICAgaWYgKGNvdW50IDw9IDEwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IGNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgaiA9IGkgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqID49IDAgJiYgY29tcGFyZXIuQ29tcGFyZShrZXlzW2pdLCBrZXkpID4gMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXNbaiArIDFdID0ga2V5c1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaiArIDFdID0gaXRlbXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGotLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAga2V5c1tqICsgMV0gPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaiArIDFdID0gaXRlbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gYXJyYXkgY2FzZVxyXG4gICAgICAgICAgICB2YXIga2V5c0FycmF5ID0ga2V5cyBhcyBUS2V5W107XHJcbiAgICAgICAgICAgIHZhciBpdGVtc0FycmF5ID0gaXRlbXMgYXMgVEl0ZW1bXTtcclxuICAgICAgICAgICAgaWYgKChudWxsICE9IGtleXNBcnJheSkgJiYgKG51bGwgIT0gaXRlbXNBcnJheSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEFycmF5LlNvcnQ8VEtleSxUSXRlbT4oa2V5c0FycmF5LCBpdGVtc0FycmF5LCBjb21wYXJlcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGxvY2FsIHNvcnQgaW1wbGVtZW50YXRpb25cclxuICAgICAgICAgICAgUXVpY2tTb3J0PFRLZXksVEl0ZW0+KGtleXMsIGl0ZW1zLCBjb21wYXJlciwgMCwgY291bnQgLSAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29ydCBhIGxpc3Qgb2Yga2V5cywgaXRlbXMxIGFuZCBpdGVtczIgd2l0aCByZXNwZWN0IHRvIHRoZSBrZXlzLCBpbiBwbGFjZSB1c2luZyB0aGUgcXVpY2sgc29ydCBhbGdvcml0aG0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHR5cGVwYXJhbSBuYW1lPVwiVEtleVwiPlRoZSB0eXBlIG9mIGVsZW1lbnRzIGluIHRoZSBrZXkgbGlzdC48L3R5cGVwYXJhbT5cclxuICAgICAgICAvLy8gPHR5cGVwYXJhbSBuYW1lPVwiVEl0ZW0xXCI+VGhlIHR5cGUgb2YgZWxlbWVudHMgaW4gdGhlIGZpcnN0IGl0ZW0gbGlzdC48L3R5cGVwYXJhbT5cclxuICAgICAgICAvLy8gPHR5cGVwYXJhbSBuYW1lPVwiVEl0ZW0yXCI+VGhlIHR5cGUgb2YgZWxlbWVudHMgaW4gdGhlIHNlY29uZCBpdGVtIGxpc3QuPC90eXBlcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwia2V5c1wiPkxpc3QgdG8gc29ydC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIml0ZW1zMVwiPkZpcnN0IGxpc3QgdG8gcGVybXV0ZSB0aGUgc2FtZSB3YXkgYXMgdGhlIGtleSBsaXN0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaXRlbXMyXCI+U2Vjb25kIGxpc3QgdG8gcGVybXV0ZSB0aGUgc2FtZSB3YXkgYXMgdGhlIGtleSBsaXN0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29tcGFyZXJcIj5Db21wYXJpc29uLCBkZWZpbmluZyB0aGUgc29ydCBvcmRlci48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBTb3J0PFRLZXksIFRJdGVtMSwgVEl0ZW0yPihJTGlzdDxUS2V5PiBrZXlzLCBJTGlzdDxUSXRlbTE+IGl0ZW1zMSwgSUxpc3Q8VEl0ZW0yPiBpdGVtczIsIElDb21wYXJlcjxUS2V5PiBjb21wYXJlciA9IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgY291bnQgPSBrZXlzLkNvdW50O1xyXG4gICAgICAgICAgICBpZiAoY291bnQgPD0gMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobnVsbCA9PSBjb21wYXJlcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29tcGFyZXIgPSBDb21wYXJlcjxUS2V5Pi5EZWZhdWx0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY291bnQgPT0gMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVyLkNvbXBhcmUoa2V5c1swXSwga2V5c1sxXSkgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VEtleT4oa2V5cywgMCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgU3dhcDxUSXRlbTE+KGl0ZW1zMSwgMCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgU3dhcDxUSXRlbTI+KGl0ZW1zMiwgMCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGluc2VydGlvbiBzb3J0XHJcbiAgICAgICAgICAgIGlmIChjb3VudCA8PSAxMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBjb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtMSA9IGl0ZW1zMVtpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbTIgPSBpdGVtczJbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGogPSBpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA+PSAwICYmIGNvbXBhcmVyLkNvbXBhcmUoa2V5c1tqXSwga2V5KSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzW2ogKyAxXSA9IGtleXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zMVtqICsgMV0gPSBpdGVtczFbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zMltqICsgMV0gPSBpdGVtczJbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGotLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAga2V5c1tqICsgMV0gPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMxW2ogKyAxXSA9IGl0ZW0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zMltqICsgMV0gPSBpdGVtMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gbG9jYWwgc29ydCBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICBRdWlja1NvcnQ8VEtleSxUSXRlbTEsVEl0ZW0yPihrZXlzLCBpdGVtczEsIGl0ZW1zMiwgY29tcGFyZXIsIDAsIGNvdW50IC0gMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNvcnQgYSByYW5nZSBvZiBhIGxpc3Qgb2Yga2V5cywgaW4gcGxhY2UgdXNpbmcgdGhlIHF1aWNrIHNvcnQgYWxnb3JpdGhtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlRcIj5UaGUgdHlwZSBvZiBlbGVtZW50IGluIHRoZSBsaXN0LjwvdHlwZXBhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImtleXNcIj5MaXN0IHRvIHNvcnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmRleFwiPlRoZSB6ZXJvLWJhc2VkIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSByYW5nZSB0byBzb3J0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY291bnRcIj5UaGUgbGVuZ3RoIG9mIHRoZSByYW5nZSB0byBzb3J0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29tcGFyZXJcIj5Db21wYXJpc29uLCBkZWZpbmluZyB0aGUgc29ydCBvcmRlci48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBTb3J0PFQ+KElMaXN0PFQ+IGtleXMsIGludCBpbmRleCwgaW50IGNvdW50LCBJQ29tcGFyZXI8VD4gY29tcGFyZXIgPSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4IDwgMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImluZGV4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY291bnQgPCAwIHx8IGluZGV4ICsgY291bnQgPiBrZXlzLkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiY291bnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb3VudCA8PSAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChudWxsID09IGNvbXBhcmVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb21wYXJlciA9IENvbXBhcmVyPFQ+LkRlZmF1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb3VudCA9PSAyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZXIuQ29tcGFyZShrZXlzW2luZGV4XSwga2V5c1tpbmRleCArIDFdKSA+IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgU3dhcDxUPihrZXlzLCBpbmRleCwgaW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gaW5zZXJ0aW9uIHNvcnRcclxuICAgICAgICAgICAgaWYgKGNvdW50IDw9IDEwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgdG8gPSBpbmRleCArIGNvdW50O1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IGluZGV4ICsgMTsgaSA8IHRvOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGogPSBpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA+PSBpbmRleCAmJiBjb21wYXJlci5Db21wYXJlKGtleXNbal0sIGtleSkgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5c1tqICsgMV0gPSBrZXlzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGtleXNbaiArIDFdID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBhcnJheSBjYXNlXHJcbiAgICAgICAgICAgIHZhciBrZXlzQXJyYXkgPSBrZXlzIGFzIFRbXTtcclxuICAgICAgICAgICAgaWYgKG51bGwgIT0ga2V5c0FycmF5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Tb3J0PFQ+KGtleXNBcnJheSwgaW5kZXgsIGNvdW50LCBjb21wYXJlcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGdlbmVyaWMgbGlzdCBjYXNlXHJcbiAgICAgICAgICAgIHZhciBrZXlzTGlzdCA9IGtleXMgYXMgTGlzdDxUPjtcclxuICAgICAgICAgICAgaWYgKG51bGwgIT0ga2V5c0xpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleXNMaXN0LlNvcnQoaW5kZXgsIGNvdW50LCBjb21wYXJlcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGZhbGwgYmFjazogbG9jYWwgc29ydCBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICBRdWlja1NvcnQ8VD4oa2V5cywgY29tcGFyZXIsIGluZGV4LCBjb3VudCAtIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTb3J0IGEgbGlzdCBvZiBrZXlzIGFuZCBpdGVtcyB3aXRoIHJlc3BlY3QgdG8gdGhlIGtleXMsIGluIHBsYWNlIHVzaW5nIHRoZSBxdWljayBzb3J0IGFsZ29yaXRobS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dHlwZXBhcmFtIG5hbWU9XCJUS2V5XCI+VGhlIHR5cGUgb2YgZWxlbWVudHMgaW4gdGhlIGtleSBsaXN0LjwvdHlwZXBhcmFtPlxyXG4gICAgICAgIC8vLyA8dHlwZXBhcmFtIG5hbWU9XCJUSXRlbVwiPlRoZSB0eXBlIG9mIGVsZW1lbnRzIGluIHRoZSBpdGVtIGxpc3QuPC90eXBlcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwia2V5c1wiPkxpc3QgdG8gc29ydC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIml0ZW1zXCI+TGlzdCB0byBwZXJtdXRlIHRoZSBzYW1lIHdheSBhcyB0aGUga2V5IGxpc3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmRleFwiPlRoZSB6ZXJvLWJhc2VkIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSByYW5nZSB0byBzb3J0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY291bnRcIj5UaGUgbGVuZ3RoIG9mIHRoZSByYW5nZSB0byBzb3J0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29tcGFyZXJcIj5Db21wYXJpc29uLCBkZWZpbmluZyB0aGUgc29ydCBvcmRlci48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBTb3J0PFRLZXksIFRJdGVtPihJTGlzdDxUS2V5PiBrZXlzLCBJTGlzdDxUSXRlbT4gaXRlbXMsIGludCBpbmRleCwgaW50IGNvdW50LCBJQ29tcGFyZXI8VEtleT4gY29tcGFyZXIgPSBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4IDwgMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImluZGV4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY291bnQgPCAwIHx8IGluZGV4ICsgY291bnQgPiBrZXlzLkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiY291bnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb3VudCA8PSAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChudWxsID09IGNvbXBhcmVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb21wYXJlciA9IENvbXBhcmVyPFRLZXk+LkRlZmF1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb3VudCA9PSAyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZXIuQ29tcGFyZShrZXlzW2luZGV4XSwga2V5c1tpbmRleCArIDFdKSA+IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgU3dhcDxUS2V5PihrZXlzLCBpbmRleCwgaW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBTd2FwPFRJdGVtPihpdGVtcywgaW5kZXgsIGluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGluc2VydGlvbiBzb3J0XHJcbiAgICAgICAgICAgIGlmIChjb3VudCA8PSAxMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IHRvID0gaW5kZXggKyBjb3VudDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSBpbmRleCArIDE7IGkgPCB0bzsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGogPSBpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA+PSBpbmRleCAmJiBjb21wYXJlci5Db21wYXJlKGtleXNbal0sIGtleSkgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5c1tqICsgMV0gPSBrZXlzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tqICsgMV0gPSBpdGVtc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBrZXlzW2ogKyAxXSA9IGtleTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtc1tqICsgMV0gPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBhcnJheSBjYXNlXHJcbiAgICAgICAgICAgIHZhciBrZXlzQXJyYXkgPSBrZXlzIGFzIFRLZXlbXTtcclxuICAgICAgICAgICAgdmFyIGl0ZW1zQXJyYXkgPSBpdGVtcyBhcyBUSXRlbVtdO1xyXG4gICAgICAgICAgICBpZiAoKG51bGwgIT0ga2V5c0FycmF5KSAmJiAobnVsbCAhPSBpdGVtc0FycmF5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuU29ydDxUS2V5LFRJdGVtPihrZXlzQXJyYXksIGl0ZW1zQXJyYXksIGluZGV4LCBjb3VudCwgY29tcGFyZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBmYWxsIGJhY2s6IGxvY2FsIHNvcnQgaW1wbGVtZW50YXRpb25cclxuICAgICAgICAgICAgUXVpY2tTb3J0PFRLZXksVEl0ZW0+KGtleXMsIGl0ZW1zLCBjb21wYXJlciwgaW5kZXgsIGNvdW50IC0gMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNvcnQgYSBsaXN0IG9mIGtleXMsIGl0ZW1zMSBhbmQgaXRlbXMyIHdpdGggcmVzcGVjdCB0byB0aGUga2V5cywgaW4gcGxhY2UgdXNpbmcgdGhlIHF1aWNrIHNvcnQgYWxnb3JpdGhtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlRLZXlcIj5UaGUgdHlwZSBvZiBlbGVtZW50cyBpbiB0aGUga2V5IGxpc3QuPC90eXBlcGFyYW0+XHJcbiAgICAgICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlRJdGVtMVwiPlRoZSB0eXBlIG9mIGVsZW1lbnRzIGluIHRoZSBmaXJzdCBpdGVtIGxpc3QuPC90eXBlcGFyYW0+XHJcbiAgICAgICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlRJdGVtMlwiPlRoZSB0eXBlIG9mIGVsZW1lbnRzIGluIHRoZSBzZWNvbmQgaXRlbSBsaXN0LjwvdHlwZXBhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImtleXNcIj5MaXN0IHRvIHNvcnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpdGVtczFcIj5GaXJzdCBsaXN0IHRvIHBlcm11dGUgdGhlIHNhbWUgd2F5IGFzIHRoZSBrZXkgbGlzdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIml0ZW1zMlwiPlNlY29uZCBsaXN0IHRvIHBlcm11dGUgdGhlIHNhbWUgd2F5IGFzIHRoZSBrZXkgbGlzdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluZGV4XCI+VGhlIHplcm8tYmFzZWQgc3RhcnRpbmcgaW5kZXggb2YgdGhlIHJhbmdlIHRvIHNvcnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb3VudFwiPlRoZSBsZW5ndGggb2YgdGhlIHJhbmdlIHRvIHNvcnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb21wYXJlclwiPkNvbXBhcmlzb24sIGRlZmluaW5nIHRoZSBzb3J0IG9yZGVyLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIFNvcnQ8VEtleSwgVEl0ZW0xLCBUSXRlbTI+KElMaXN0PFRLZXk+IGtleXMsIElMaXN0PFRJdGVtMT4gaXRlbXMxLCBJTGlzdDxUSXRlbTI+IGl0ZW1zMiwgaW50IGluZGV4LCBpbnQgY291bnQsIElDb21wYXJlcjxUS2V5PiBjb21wYXJlciA9IG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiaW5kZXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb3VudCA8IDAgfHwgaW5kZXggKyBjb3VudCA+IGtleXMuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJjb3VudFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvdW50IDw9IDEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG51bGwgPT0gY29tcGFyZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbXBhcmVyID0gQ29tcGFyZXI8VEtleT4uRGVmYXVsdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvdW50ID09IDIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlci5Db21wYXJlKGtleXNbaW5kZXhdLCBrZXlzW2luZGV4ICsgMV0pID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBTd2FwPFRLZXk+KGtleXMsIGluZGV4LCBpbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VEl0ZW0xPihpdGVtczEsIGluZGV4LCBpbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VEl0ZW0yPihpdGVtczIsIGluZGV4LCBpbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpbnNlcnRpb24gc29ydFxyXG4gICAgICAgICAgICBpZiAoY291bnQgPD0gMTApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCB0byA9IGluZGV4ICsgY291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gaW5kZXggKyAxOyBpIDwgdG87IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbTEgPSBpdGVtczFbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0yID0gaXRlbXMyW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBqID0gaSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPj0gaW5kZXggJiYgY29tcGFyZXIuQ29tcGFyZShrZXlzW2pdLCBrZXkpID4gMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXNbaiArIDFdID0ga2V5c1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMxW2ogKyAxXSA9IGl0ZW1zMVtqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMyW2ogKyAxXSA9IGl0ZW1zMltqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBrZXlzW2ogKyAxXSA9IGtleTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtczFbaiArIDFdID0gaXRlbTE7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMyW2ogKyAxXSA9IGl0ZW0yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBmYWxsIGJhY2s6IGxvY2FsIHNvcnQgaW1wbGVtZW50YXRpb25cclxuICAgICAgICAgICAgUXVpY2tTb3J0PFRLZXksVEl0ZW0xLFRJdGVtMj4oa2V5cywgaXRlbXMxLCBpdGVtczIsIGNvbXBhcmVyLCBpbmRleCwgY291bnQgLSAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29ydCBhIGxpc3Qgb2Yga2V5cyBhbmQgaXRlbXMgd2l0aCByZXNwZWN0IHRvIHRoZSBrZXlzLCBpbiBwbGFjZSB1c2luZyB0aGUgcXVpY2sgc29ydCBhbGdvcml0aG0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHR5cGVwYXJhbSBuYW1lPVwiVDFcIj5UaGUgdHlwZSBvZiBlbGVtZW50cyBpbiB0aGUgcHJpbWFyeSBsaXN0LjwvdHlwZXBhcmFtPlxyXG4gICAgICAgIC8vLyA8dHlwZXBhcmFtIG5hbWU9XCJUMlwiPlRoZSB0eXBlIG9mIGVsZW1lbnRzIGluIHRoZSBzZWNvbmRhcnkgbGlzdC48L3R5cGVwYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcmltYXJ5XCI+TGlzdCB0byBzb3J0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2Vjb25kYXJ5XCI+TGlzdCB0byBzb3J0IG9uIGR1cGxpY2F0ZSBwcmltYXJ5IGl0ZW1zLCBhbmQgcGVybXV0ZSB0aGUgc2FtZSB3YXkgYXMgdGhlIGtleSBsaXN0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicHJpbWFyeUNvbXBhcmVyXCI+Q29tcGFyaXNvbiwgZGVmaW5pbmcgdGhlIHByaW1hcnkgc29ydCBvcmRlci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNlY29uZGFyeUNvbXBhcmVyXCI+Q29tcGFyaXNvbiwgZGVmaW5pbmcgdGhlIHNlY29uZGFyeSBzb3J0IG9yZGVyLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIFNvcnRBbGw8VDEsIFQyPihJTGlzdDxUMT4gcHJpbWFyeSwgSUxpc3Q8VDI+IHNlY29uZGFyeSwgSUNvbXBhcmVyPFQxPiBwcmltYXJ5Q29tcGFyZXIgPSBudWxsLCBJQ29tcGFyZXI8VDI+IHNlY29uZGFyeUNvbXBhcmVyID0gbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChudWxsID09IHByaW1hcnlDb21wYXJlcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcHJpbWFyeUNvbXBhcmVyID0gQ29tcGFyZXI8VDE+LkRlZmF1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChudWxsID09IHNlY29uZGFyeUNvbXBhcmVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzZWNvbmRhcnlDb21wYXJlciA9IENvbXBhcmVyPFQyPi5EZWZhdWx0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBsb2NhbCBzb3J0IGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgICAgIFF1aWNrU29ydEFsbDxUMSxUMj4ocHJpbWFyeSwgc2Vjb25kYXJ5LCBwcmltYXJ5Q29tcGFyZXIsIHNlY29uZGFyeUNvbXBhcmVyLCAwLCBwcmltYXJ5LkNvdW50IC0gMSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gZm9yIGFuIGluIHBsYWNlIHF1aWNrIHNvcnQgb24gYSBsaXN0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlRcIj5UaGUgdHlwZSBvZiB0aGUgbGlzdCBvbiB3aGljaCB0aGUgcXVpY2sgc29ydCBpcyBwZXJmb3JtZWQuPC90eXBlcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwia2V5c1wiPlRoZSBsaXN0IHdoaWNoIGlzIHNvcnRlZCB1c2luZyBxdWljayBzb3J0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29tcGFyZXJcIj5UaGUgbWV0aG9kIHdpdGggd2hpY2ggdG8gY29tcGFyZSB0d28gZWxlbWVudHMgb2YgdGhlIHF1aWNrIHNvcnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0XCI+VGhlIGxlZnQgYm91bmRhcnkgb2YgdGhlIHF1aWNrIHNvcnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFwiPlRoZSByaWdodCBib3VuZGFyeSBvZiB0aGUgcXVpY2sgc29ydC48L3BhcmFtPlxyXG4gICAgICAgIHN0YXRpYyB2b2lkIFF1aWNrU29ydDxUPihJTGlzdDxUPiBrZXlzLCBJQ29tcGFyZXI8VD4gY29tcGFyZXIsIGludCBsZWZ0LCBpbnQgcmlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBQaXZvdGluZ1xyXG4gICAgICAgICAgICAgICAgaW50IGEgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgaW50IGIgPSByaWdodDtcclxuICAgICAgICAgICAgICAgIGludCBwID0gYSArICgoYiAtIGEpID4+IDEpOyAvLyBtaWRwb2ludFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlci5Db21wYXJlKGtleXNbYV0sIGtleXNbcF0pID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBTd2FwPFQ+KGtleXMsIGEsIHApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlci5Db21wYXJlKGtleXNbYV0sIGtleXNbYl0pID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBTd2FwPFQ+KGtleXMsIGEsIGIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlci5Db21wYXJlKGtleXNbcF0sIGtleXNbYl0pID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBTd2FwPFQ+KGtleXMsIHAsIGIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIFQgcGl2b3QgPSBrZXlzW3BdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhvYXJlIFBhcnRpdGlvbmluZ1xyXG4gICAgICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZXIuQ29tcGFyZShrZXlzW2FdLCBwaXZvdCkgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmVyLkNvbXBhcmUocGl2b3QsIGtleXNbYl0pIDwgMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGItLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhID4gYilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCBiKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgU3dhcDxUPihrZXlzLCBhLCBiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGErKztcclxuICAgICAgICAgICAgICAgICAgICBiLS07XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChhIDw9IGIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGxpbWl0IHRoZSByZWN1cnNpb24gZGVwdGggdG8gbG9nKG4pLCB3ZSBzb3J0IHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gc2hvcnRlciBwYXJ0aXRpb24gcmVjdXJzaXZlbHkgYW5kIHRoZSBsb25nZXIgcGFydGl0aW9uIGl0ZXJhdGl2ZWx5LlxyXG4gICAgICAgICAgICAgICAgaWYgKChiIC0gbGVmdCkgPD0gKHJpZ2h0IC0gYSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPCBiKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUXVpY2tTb3J0KGtleXMsIGNvbXBhcmVyLCBsZWZ0LCBiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhIDwgcmlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBRdWlja1NvcnQoa2V5cywgY29tcGFyZXIsIGEsIHJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAobGVmdCA8IHJpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIGZvciBhbiBpbiBwbGFjZSBxdWljayBzb3J0IG9uIGEgbGlzdCB3aGlsZSByZW9yZGVyaW5nIG9uZSBvdGhlciBsaXN0IGFjY29yZGluZ2x5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlRcIj5UaGUgdHlwZSBvZiB0aGUgbGlzdCBvbiB3aGljaCB0aGUgcXVpY2sgc29ydCBpcyBwZXJmb3JtZWQuPC90eXBlcGFyYW0+XHJcbiAgICAgICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlRJdGVtc1wiPlRoZSB0eXBlIG9mIHRoZSBsaXN0IHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgcmVvcmRlcmVkIGFjY29yZGluZ2x5LjwvdHlwZXBhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImtleXNcIj5UaGUgbGlzdCB3aGljaCBpcyBzb3J0ZWQgdXNpbmcgcXVpY2sgc29ydC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIml0ZW1zXCI+VGhlIGxpc3Qgd2hpY2ggaXMgYXV0b21hdGljYWxseSByZW9yZGVyZWQgYWNjb3JkaW5nbHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb21wYXJlclwiPlRoZSBtZXRob2Qgd2l0aCB3aGljaCB0byBjb21wYXJlIHR3byBlbGVtZW50cyBvZiB0aGUgcXVpY2sgc29ydC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRcIj5UaGUgbGVmdCBib3VuZGFyeSBvZiB0aGUgcXVpY2sgc29ydC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0XCI+VGhlIHJpZ2h0IGJvdW5kYXJ5IG9mIHRoZSBxdWljayBzb3J0LjwvcGFyYW0+XHJcbiAgICAgICAgc3RhdGljIHZvaWQgUXVpY2tTb3J0PFQsIFRJdGVtcz4oSUxpc3Q8VD4ga2V5cywgSUxpc3Q8VEl0ZW1zPiBpdGVtcywgSUNvbXBhcmVyPFQ+IGNvbXBhcmVyLCBpbnQgbGVmdCwgaW50IHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gUGl2b3RpbmdcclxuICAgICAgICAgICAgICAgIGludCBhID0gbGVmdDtcclxuICAgICAgICAgICAgICAgIGludCBiID0gcmlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpbnQgcCA9IGEgKyAoKGIgLSBhKSA+PiAxKTsgLy8gbWlkcG9pbnRcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZXIuQ29tcGFyZShrZXlzW2FdLCBrZXlzW3BdKSA+IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgU3dhcDxUPihrZXlzLCBhLCBwKTtcclxuICAgICAgICAgICAgICAgICAgICBTd2FwPFRJdGVtcz4oaXRlbXMsIGEsIHApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlci5Db21wYXJlKGtleXNbYV0sIGtleXNbYl0pID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBTd2FwPFQ+KGtleXMsIGEsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VEl0ZW1zPihpdGVtcywgYSwgYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVyLkNvbXBhcmUoa2V5c1twXSwga2V5c1tiXSkgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VD4oa2V5cywgcCwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgU3dhcDxUSXRlbXM+KGl0ZW1zLCBwLCBiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBUIHBpdm90ID0ga2V5c1twXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIb2FyZSBQYXJ0aXRpb25pbmdcclxuICAgICAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmVyLkNvbXBhcmUoa2V5c1thXSwgcGl2b3QpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGErKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlci5Db21wYXJlKHBpdm90LCBrZXlzW2JdKSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYSA+IGIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhIDwgYilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFN3YXA8VD4oa2V5cywgYSwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFN3YXA8VEl0ZW1zPihpdGVtcywgYSwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhKys7XHJcbiAgICAgICAgICAgICAgICAgICAgYi0tO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoYSA8PSBiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbiBvcmRlciB0byBsaW1pdCB0aGUgcmVjdXJzaW9uIGRlcHRoIHRvIGxvZyhuKSwgd2Ugc29ydCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHNob3J0ZXIgcGFydGl0aW9uIHJlY3Vyc2l2ZWx5IGFuZCB0aGUgbG9uZ2VyIHBhcnRpdGlvbiBpdGVyYXRpdmVseS5cclxuICAgICAgICAgICAgICAgIGlmICgoYiAtIGxlZnQpIDw9IChyaWdodCAtIGEpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0IDwgYilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFF1aWNrU29ydChrZXlzLCBpdGVtcywgY29tcGFyZXIsIGxlZnQsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCByaWdodClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFF1aWNrU29ydChrZXlzLCBpdGVtcywgY29tcGFyZXIsIGEsIHJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAobGVmdCA8IHJpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIGZvciBhbiBpbiBwbGFjZSBxdWljayBzb3J0IG9uIG9uZSBsaXN0IHdoaWxlIHJlb3JkZXJpbmcgdHdvIG90aGVyIGxpc3RzIGFjY29yZGluZ2x5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlRcIj5UaGUgdHlwZSBvZiB0aGUgbGlzdCBvbiB3aGljaCB0aGUgcXVpY2sgc29ydCBpcyBwZXJmb3JtZWQuPC90eXBlcGFyYW0+XHJcbiAgICAgICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlRJdGVtczFcIj5UaGUgdHlwZSBvZiB0aGUgZmlyc3QgbGlzdCB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IHJlb3JkZXJlZCBhY2NvcmRpbmdseS48L3R5cGVwYXJhbT5cclxuICAgICAgICAvLy8gPHR5cGVwYXJhbSBuYW1lPVwiVEl0ZW1zMlwiPlRoZSB0eXBlIG9mIHRoZSBzZWNvbmQgbGlzdCB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IHJlb3JkZXJlZCBhY2NvcmRpbmdseS48L3R5cGVwYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJrZXlzXCI+VGhlIGxpc3Qgd2hpY2ggaXMgc29ydGVkIHVzaW5nIHF1aWNrIHNvcnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpdGVtczFcIj5UaGUgZmlyc3QgbGlzdCB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IHJlb3JkZXJlZCBhY2NvcmRpbmdseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIml0ZW1zMlwiPlRoZSBzZWNvbmQgbGlzdCB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IHJlb3JkZXJlZCBhY2NvcmRpbmdseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbXBhcmVyXCI+VGhlIG1ldGhvZCB3aXRoIHdoaWNoIHRvIGNvbXBhcmUgdHdvIGVsZW1lbnRzIG9mIHRoZSBxdWljayBzb3J0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFwiPlRoZSBsZWZ0IGJvdW5kYXJ5IG9mIHRoZSBxdWljayBzb3J0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRcIj5UaGUgcmlnaHQgYm91bmRhcnkgb2YgdGhlIHF1aWNrIHNvcnQuPC9wYXJhbT5cclxuICAgICAgICBzdGF0aWMgdm9pZCBRdWlja1NvcnQ8VCwgVEl0ZW1zMSwgVEl0ZW1zMj4oXHJcbiAgICAgICAgICAgIElMaXN0PFQ+IGtleXMsIElMaXN0PFRJdGVtczE+IGl0ZW1zMSwgSUxpc3Q8VEl0ZW1zMj4gaXRlbXMyLFxyXG4gICAgICAgICAgICBJQ29tcGFyZXI8VD4gY29tcGFyZXIsXHJcbiAgICAgICAgICAgIGludCBsZWZ0LCBpbnQgcmlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBQaXZvdGluZ1xyXG4gICAgICAgICAgICAgICAgaW50IGEgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgaW50IGIgPSByaWdodDtcclxuICAgICAgICAgICAgICAgIGludCBwID0gYSArICgoYiAtIGEpID4+IDEpOyAvLyBtaWRwb2ludFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlci5Db21wYXJlKGtleXNbYV0sIGtleXNbcF0pID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBTd2FwPFQ+KGtleXMsIGEsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VEl0ZW1zMT4oaXRlbXMxLCBhLCBwKTtcclxuICAgICAgICAgICAgICAgICAgICBTd2FwPFRJdGVtczI+KGl0ZW1zMiwgYSwgcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVyLkNvbXBhcmUoa2V5c1thXSwga2V5c1tiXSkgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VD4oa2V5cywgYSwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgU3dhcDxUSXRlbXMxPihpdGVtczEsIGEsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VEl0ZW1zMj4oaXRlbXMyLCBhLCBiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZXIuQ29tcGFyZShrZXlzW3BdLCBrZXlzW2JdKSA+IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgU3dhcDxUPihrZXlzLCBwLCBiKTtcclxuICAgICAgICAgICAgICAgICAgICBTd2FwPFRJdGVtczE+KGl0ZW1zMSwgcCwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgU3dhcDxUSXRlbXMyPihpdGVtczIsIHAsIGIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIFQgcGl2b3QgPSBrZXlzW3BdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhvYXJlIFBhcnRpdGlvbmluZ1xyXG4gICAgICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZXIuQ29tcGFyZShrZXlzW2FdLCBwaXZvdCkgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmVyLkNvbXBhcmUocGl2b3QsIGtleXNbYl0pIDwgMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGItLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhID4gYilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCBiKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgU3dhcDxUPihrZXlzLCBhLCBiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgU3dhcDxUSXRlbXMxPihpdGVtczEsIGEsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBTd2FwPFRJdGVtczI+KGl0ZW1zMiwgYSwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhKys7XHJcbiAgICAgICAgICAgICAgICAgICAgYi0tO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoYSA8PSBiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbiBvcmRlciB0byBsaW1pdCB0aGUgcmVjdXJzaW9uIGRlcHRoIHRvIGxvZyhuKSwgd2Ugc29ydCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHNob3J0ZXIgcGFydGl0aW9uIHJlY3Vyc2l2ZWx5IGFuZCB0aGUgbG9uZ2VyIHBhcnRpdGlvbiBpdGVyYXRpdmVseS5cclxuICAgICAgICAgICAgICAgIGlmICgoYiAtIGxlZnQpIDw9IChyaWdodCAtIGEpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0IDwgYilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFF1aWNrU29ydChrZXlzLCBpdGVtczEsIGl0ZW1zMiwgY29tcGFyZXIsIGxlZnQsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCByaWdodClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFF1aWNrU29ydChrZXlzLCBpdGVtczEsIGl0ZW1zMiwgY29tcGFyZXIsIGEsIHJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAobGVmdCA8IHJpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIGZvciBhbiBpbiBwbGFjZSBxdWljayBzb3J0IG9uIHRoZSBwcmltYXJ5IGFuZCB0aGVuIGJ5IHRoZSBzZWNvbmRhcnkgbGlzdCB3aGlsZSByZW9yZGVyaW5nIG9uZSBzZWNvbmRhcnkgbGlzdCBhY2NvcmRpbmdseS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dHlwZXBhcmFtIG5hbWU9XCJUMVwiPlRoZSB0eXBlIG9mIHRoZSBwcmltYXJ5IGxpc3QuPC90eXBlcGFyYW0+XHJcbiAgICAgICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlQyXCI+VGhlIHR5cGUgb2YgdGhlIHNlY29uZGFyeSBsaXN0LjwvdHlwZXBhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInByaW1hcnlcIj5UaGUgbGlzdCB3aGljaCBpcyBzb3J0ZWQgdXNpbmcgcXVpY2sgc29ydC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNlY29uZGFyeVwiPlRoZSBsaXN0IHdoaWNoIGlzIHNvcnRlZCBzZWNvbmRhcmlseSAob24gcHJpbWFyeSBkdXBsaWNhdGVzKSBhbmQgYXV0b21hdGljYWxseSByZW9yZGVyZWQgYWNjb3JkaW5nbHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcmltYXJ5Q29tcGFyZXJcIj5UaGUgbWV0aG9kIHdpdGggd2hpY2ggdG8gY29tcGFyZSB0d28gZWxlbWVudHMgb2YgdGhlIHByaW1hcnkgbGlzdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNlY29uZGFyeUNvbXBhcmVyXCI+VGhlIG1ldGhvZCB3aXRoIHdoaWNoIHRvIGNvbXBhcmUgdHdvIGVsZW1lbnRzIG9mIHRoZSBzZWNvbmRhcnkgbGlzdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRcIj5UaGUgbGVmdCBib3VuZGFyeSBvZiB0aGUgcXVpY2sgc29ydC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0XCI+VGhlIHJpZ2h0IGJvdW5kYXJ5IG9mIHRoZSBxdWljayBzb3J0LjwvcGFyYW0+XHJcbiAgICAgICAgc3RhdGljIHZvaWQgUXVpY2tTb3J0QWxsPFQxLCBUMj4oXHJcbiAgICAgICAgICAgIElMaXN0PFQxPiBwcmltYXJ5LCBJTGlzdDxUMj4gc2Vjb25kYXJ5LFxyXG4gICAgICAgICAgICBJQ29tcGFyZXI8VDE+IHByaW1hcnlDb21wYXJlciwgSUNvbXBhcmVyPFQyPiBzZWNvbmRhcnlDb21wYXJlcixcclxuICAgICAgICAgICAgaW50IGxlZnQsIGludCByaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFBpdm90aW5nXHJcbiAgICAgICAgICAgICAgICBpbnQgYSA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICBpbnQgYiA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaW50IHAgPSBhICsgKChiIC0gYSkgPj4gMSk7IC8vIG1pZHBvaW50XHJcblxyXG4gICAgICAgICAgICAgICAgaW50IGFwID0gcHJpbWFyeUNvbXBhcmVyLkNvbXBhcmUocHJpbWFyeVthXSwgcHJpbWFyeVtwXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXAgPiAwIHx8IGFwID09IDAgJiYgc2Vjb25kYXJ5Q29tcGFyZXIuQ29tcGFyZShzZWNvbmRhcnlbYV0sIHNlY29uZGFyeVtwXSkgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VDE+KHByaW1hcnksIGEsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VDI+KHNlY29uZGFyeSwgYSwgcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaW50IGFiID0gcHJpbWFyeUNvbXBhcmVyLkNvbXBhcmUocHJpbWFyeVthXSwgcHJpbWFyeVtiXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWIgPiAwIHx8IGFiID09IDAgJiYgc2Vjb25kYXJ5Q29tcGFyZXIuQ29tcGFyZShzZWNvbmRhcnlbYV0sIHNlY29uZGFyeVtiXSkgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VDE+KHByaW1hcnksIGEsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VDI+KHNlY29uZGFyeSwgYSwgYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaW50IHBiID0gcHJpbWFyeUNvbXBhcmVyLkNvbXBhcmUocHJpbWFyeVtwXSwgcHJpbWFyeVtiXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGIgPiAwIHx8IHBiID09IDAgJiYgc2Vjb25kYXJ5Q29tcGFyZXIuQ29tcGFyZShzZWNvbmRhcnlbcF0sIHNlY29uZGFyeVtiXSkgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VDE+KHByaW1hcnksIHAsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIFN3YXA8VDI+KHNlY29uZGFyeSwgcCwgYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgVDEgcGl2b3QxID0gcHJpbWFyeVtwXTtcclxuICAgICAgICAgICAgICAgIFQyIHBpdm90MiA9IHNlY29uZGFyeVtwXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIb2FyZSBQYXJ0aXRpb25pbmdcclxuICAgICAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGF4O1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoYXggPSBwcmltYXJ5Q29tcGFyZXIuQ29tcGFyZShwcmltYXJ5W2FdLCBwaXZvdDEpKSA8IDAgfHwgYXggPT0gMCAmJiBzZWNvbmRhcnlDb21wYXJlci5Db21wYXJlKHNlY29uZGFyeVthXSwgcGl2b3QyKSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbnQgeGI7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCh4YiA9IHByaW1hcnlDb21wYXJlci5Db21wYXJlKHBpdm90MSwgcHJpbWFyeVtiXSkpIDwgMCB8fCB4YiA9PSAwICYmIHNlY29uZGFyeUNvbXBhcmVyLkNvbXBhcmUocGl2b3QyLCBzZWNvbmRhcnlbYl0pIDwgMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGItLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhID4gYilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCBiKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgU3dhcDxUMT4ocHJpbWFyeSwgYSwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFN3YXA8VDI+KHNlY29uZGFyeSwgYSwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhKys7XHJcbiAgICAgICAgICAgICAgICAgICAgYi0tO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoYSA8PSBiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbiBvcmRlciB0byBsaW1pdCB0aGUgcmVjdXJzaW9uIGRlcHRoIHRvIGxvZyhuKSwgd2Ugc29ydCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHNob3J0ZXIgcGFydGl0aW9uIHJlY3Vyc2l2ZWx5IGFuZCB0aGUgbG9uZ2VyIHBhcnRpdGlvbiBpdGVyYXRpdmVseS5cclxuICAgICAgICAgICAgICAgIGlmICgoYiAtIGxlZnQpIDw9IChyaWdodCAtIGEpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0IDwgYilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFF1aWNrU29ydEFsbChwcmltYXJ5LCBzZWNvbmRhcnksIHByaW1hcnlDb21wYXJlciwgc2Vjb25kYXJ5Q29tcGFyZXIsIGxlZnQsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCByaWdodClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFF1aWNrU29ydEFsbChwcmltYXJ5LCBzZWNvbmRhcnksIHByaW1hcnlDb21wYXJlciwgc2Vjb25kYXJ5Q29tcGFyZXIsIGEsIHJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAobGVmdCA8IHJpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUGVyZm9ybXMgYW4gaW4gcGxhY2Ugc3dhcCBvZiB0d28gZWxlbWVudHMgaW4gYSBsaXN0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlRcIj5UaGUgdHlwZSBvZiBlbGVtZW50cyBzdG9yZWQgaW4gdGhlIGxpc3QuPC90eXBlcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwia2V5c1wiPlRoZSBsaXN0IGluIHdoaWNoIHRoZSBlbGVtZW50cyBhcmUgc3RvcmVkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYVwiPlRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgc3dhcC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJcIj5UaGUgaW5kZXggb2YgdGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSBzd2FwLjwvcGFyYW0+XHJcbiAgICAgICAgc3RhdGljIHZvaWQgU3dhcDxUPihJTGlzdDxUPiBrZXlzLCBpbnQgYSwgaW50IGIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoYSA9PSBiKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFQgbG9jYWwgPSBrZXlzW2FdO1xyXG4gICAgICAgICAgICBrZXlzW2FdID0ga2V5c1tiXTtcclxuICAgICAgICAgICAga2V5c1tiXSA9IGxvY2FsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJ1c2luZyBCcmlkZ2U7XHJcbnVzaW5nIE5ld3RvbnNvZnQuSnNvbjtcclxudXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhO1xyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlLk1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYTtcclxudXNpbmcgU3lzdGVtO1xyXG5cclxubmFtZXNwYWNlIE1hdGhOZXROdW1lcmljc1xyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgQXBwXHJcbiAgICB7XHJcbiAgICAgICAgc3RhdGljIFZlY3RvckJ1aWxkZXI8ZG91YmxlPiB2X2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8ZG91YmxlPi5WZWN0b3I7XHJcbiAgICAgICAgc3RhdGljIE1hdHJpeEJ1aWxkZXI8ZG91YmxlPiBtX2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8ZG91YmxlPi5NYXRyaXg7XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTWF0cml4PGRvdWJsZT4gSGF0KFZlY3Rvcjxkb3VibGU+IGspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXg8ZG91YmxlPiBraGF0ID0gbV9idWlsZGVyLkRlbnNlKDMsIDMpO1xyXG4gICAgICAgICAgICBraGF0WzAsIDFdID0gLWtbMl07XHJcbiAgICAgICAgICAgIGtoYXRbMCwgMl0gPSBrWzFdO1xyXG4gICAgICAgICAgICBraGF0WzEsIDBdID0ga1syXTtcclxuICAgICAgICAgICAga2hhdFsxLCAyXSA9IC1rWzBdO1xyXG4gICAgICAgICAgICBraGF0WzIsIDBdID0gLWtbMV07XHJcbiAgICAgICAgICAgIGtoYXRbMiwgMV0gPSBrWzBdO1xyXG4gICAgICAgICAgICByZXR1cm4ga2hhdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBNYWluKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFdyaXRlIGEgbWVzc2FnZSB0byB0aGUgQ29uc29sZVxyXG4gICAgICAgICAgICBDb25zb2xlLldyaXRlTGluZShcIldlbGNvbWUgdG8gQnJpZGdlLk5FVFwiKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3Rvcjxkb3VibGU+IGsgPSB2X2J1aWxkZXIuRGVuc2VPZkFycmF5KG5ld1tdIHsgMS4wLCAwLjAsIDAuMCB9KTtcclxuICAgICAgICAgICAgTWF0cml4PGRvdWJsZT4gSSA9IG1fYnVpbGRlci5EZW5zZUlkZW50aXR5KDMpO1xyXG4gICAgICAgICAgICBNYXRyaXg8ZG91YmxlPiBraGF0ID0gSGF0KGspO1xyXG4gICAgICAgICAgICBNYXRyaXg8ZG91YmxlPiBraGF0MiA9IGtoYXQuTXVsdGlwbHkoa2hhdCk7XHJcbiAgICAgICAgICAgIENvbnNvbGUuV3JpdGVMaW5lKEkgKyBraGF0ICsga2hhdDIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWZ0ZXIgYnVpbGRpbmcgKEN0cmwgKyBTaGlmdCArIEIpIHRoaXMgcHJvamVjdCwgXHJcbiAgICAgICAgICAgIC8vIGJyb3dzZSB0byB0aGUgL2Jpbi9EZWJ1ZyBvciAvYmluL1JlbGVhc2UgZm9sZGVyLlxyXG5cclxuICAgICAgICAgICAgLy8gQSBuZXcgYnJpZGdlLyBmb2xkZXIgaGFzIGJlZW4gY3JlYXRlZCBhbmRcclxuICAgICAgICAgICAgLy8gY29udGFpbnMgeW91ciBwcm9qZWN0cyBKYXZhU2NyaXB0IGZpbGVzLiBcclxuXHJcbiAgICAgICAgICAgIC8vIE9wZW4gdGhlIGJyaWRnZS9pbmRleC5odG1sIGZpbGUgaW4gYSBicm93c2VyIGJ5XHJcbiAgICAgICAgICAgIC8vIFJpZ2h0LUNsaWNrID4gT3BlbiBXaXRoLi4uLCB0aGVuIGNob29zZSBhXHJcbiAgICAgICAgICAgIC8vIHdlYiBicm93c2VyIGZyb20gdGhlIGxpc3RcclxuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgYXBwbGljYXRpb24gd2lsbCB0aGVuIHJ1biBpbiB0aGUgYnJvd3Nlci5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uTGlucTtcclxudXNpbmcgU3lzdGVtLlRleHQ7XHJcbnVzaW5nIFN5c3RlbS5UaHJlYWRpbmcuVGFza3M7XHJcbnVzaW5nIFN5c3RlbS5JTztcclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0TnVtZXJpY3Ncclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBCdWZmZXJcclxuICAgIHtcclxuICAgICAgICBpbnRlcm5hbCBzdGF0aWMgdm9pZCBCbG9ja0NvcHkoYnl0ZVtdIHJlY2J1ZiwgaW50IHYxLCBieXRlW10gbmV3YnVmLCBpbnQgdjIsIGludCB2MylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFycmF5LkNvcHkocmVjYnVmLCB2MSwgbmV3YnVmLCB2MiwgdjMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgc3RhdGljIGludCBCeXRlTGVuZ3RoKEFycmF5IGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUeXBlQ29kZSB0ID0gVHlwZS5HZXRUeXBlQ29kZShhLkdldFR5cGUoKS5HZXRFbGVtZW50VHlwZSgpKTtcclxuICAgICAgICAgICAgc3dpdGNoICh0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVDb2RlLkRvdWJsZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gOCAqIGEuTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5TaW5nbGU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQgKiBhLkxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZUNvZGUuQnl0ZTpcclxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZUNvZGUuU0J5dGU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5VSW50MTY6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVDb2RlLkludDE2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyICogYS5MZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVDb2RlLlVJbnQzMjpcclxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZUNvZGUuSW50MzI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQgKiBhLkxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZUNvZGUuVUludDY0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5JbnQ2NDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gOCAqIGEuTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5Cb29sZWFuOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLkxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiSW52YWxpZCBhcnJheSB0eXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBzdGF0aWMgdm9pZCBCbG9ja0NvcHkoQXJyYXkgYSwgaW50IHYsIGJ5dGVbXSBtZW1idWYsIGludCBwb3NpdGlvbiwgaW50IGJsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBuZXcgQmluYXJ5V3JpdGVyKG5ldyBNZW1vcnlTdHJlYW0obWVtYnVmLCBwb3NpdGlvbiwgYmwpKTtcclxuICAgICAgICAgICAgVHlwZUNvZGUgdCA9IFR5cGUuR2V0VHlwZUNvZGUoYS5HZXRUeXBlKCkuR2V0RWxlbWVudFR5cGUoKSk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5Eb3VibGU6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSAoZG91YmxlW10pYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBibCAvIDg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuV3JpdGUoYTFbaSArIHZdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5TaW5nbGU6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSAoZmxvYXRbXSlhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGJsIC8gNDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5Xcml0ZShhMVtpICsgdl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVDb2RlLkJ5dGU6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSAoYnl0ZVtdKWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgYmw7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuV3JpdGUoYTFbaSArIHZdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5TQnl0ZTpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhMSA9IChzYnl0ZVtdKWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgYmw7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuV3JpdGUoYTFbaSArIHZdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5VSW50MTY6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSAodXNob3J0W10pYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBibCAvIDI7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuV3JpdGUoYTFbaSArIHZdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5JbnQxNjpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhMSA9IChzaG9ydFtdKWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgYmwgLyAyOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLldyaXRlKGExW2kgKyB2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZUNvZGUuVUludDMyOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGExID0gKHVpbnRbXSlhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGJsIC8gNDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5Xcml0ZShhMVtpICsgdl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVDb2RlLkludDMyOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGExID0gKGludFtdKWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgYmwgLyA0OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLldyaXRlKGExW2kgKyB2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZUNvZGUuVUludDY0OlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGExID0gKHVsb25nW10pYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBibCAvIDg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuV3JpdGUoYTFbaSArIHZdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5JbnQ2NDpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhMSA9IChsb25nW10pYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBibCAvIDg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuV3JpdGUoYTFbaSArIHZdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5Cb29sZWFuOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGExID0gKGJvb2xbXSlhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGJsOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLldyaXRlKGExW2kgKyB2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiSW52YWxpZCBhcnJheSB0eXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBzdGF0aWMgdm9pZCBCbG9ja0NvcHkoYnl0ZVtdIG1lbWJ1ZiwgaW50IHBvc2l0aW9uLCBBcnJheSBhLCBpbnQgdiwgaW50IGJsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBuZXcgQmluYXJ5UmVhZGVyKG5ldyBNZW1vcnlTdHJlYW0obWVtYnVmLCBwb3NpdGlvbiwgYmwpKTtcclxuICAgICAgICAgICAgVHlwZUNvZGUgdCA9IFR5cGUuR2V0VHlwZUNvZGUoYS5HZXRUeXBlKCkuR2V0RWxlbWVudFR5cGUoKSk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5Eb3VibGU6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSAoZG91YmxlW10pYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBibCAvIDg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGExW2kgKyB2XSA9IGIuUmVhZERvdWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVDb2RlLlNpbmdsZTpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhMSA9IChmbG9hdFtdKWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgYmwgLyA0OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMVtpICsgdl0gPSBiLlJlYWRTaW5nbGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5CeXRlOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGExID0gKGJ5dGVbXSlhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGJsOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMVtpICsgdl0gPSBiLlJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZUNvZGUuU0J5dGU6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSAoc2J5dGVbXSlhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGJsOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMVtpICsgdl0gPSBiLlJlYWRTQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVDb2RlLlVJbnQxNjpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhMSA9ICh1c2hvcnRbXSlhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGJsIC8gMjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTFbaSArIHZdID0gYi5SZWFkVUludDE2KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZUNvZGUuSW50MTY6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSAoc2hvcnRbXSlhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGJsIC8gMjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTFbaSArIHZdID0gYi5SZWFkSW50MTYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5VSW50MzI6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSAodWludFtdKWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgYmwgLyA0OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMVtpICsgdl0gPSBiLlJlYWRVSW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5JbnQzMjpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhMSA9IChpbnRbXSlhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGJsIC8gNDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTFbaSArIHZdID0gYi5SZWFkSW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlQ29kZS5VSW50NjQ6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSAodWxvbmdbXSlhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGJsIC8gODsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTFbaSArIHZdID0gYi5SZWFkVUludDY0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZUNvZGUuSW50NjQ6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSAobG9uZ1tdKWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgYmwgLyA4OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhMVtpICsgdl0gPSBiLlJlYWRJbnQ2NCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVDb2RlLkJvb2xlYW46XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSAoYm9vbFtdKWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgYmw7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGExW2kgKyB2XSA9IGIuUmVhZEJvb2xlYW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJJbnZhbGlkIGFycmF5IHR5cGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uTGlucTtcclxudXNpbmcgU3lzdGVtLlRleHQ7XHJcbnVzaW5nIFN5c3RlbS5UaHJlYWRpbmcuVGFza3M7XHJcblxyXG5uYW1lc3BhY2UgTWF0aE5ldE51bWVyaWNzXHJcbntcclxuICAgIGNsYXNzIE1hbmFnZWRMaW5lYXJBbGdlYnJhUHJvdmlkZXJcclxuXHJcbiAgICB7XHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIHZvaWQgU3ZkU29sdmVGYWN0b3JlZChpbnQgcm93c0EsIGludCBjb2x1bW5zQSwgZG91YmxlW10gcywgZG91YmxlW10gdSwgZG91YmxlW10gdnQsIGRvdWJsZVtdIGIsIGludCBjb2x1bW5zQiwgZG91YmxlW10geClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJzXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwidVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZ0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJ2dFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGIgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImJcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh4ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJ4XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodS5MZW5ndGggIT0gcm93c0EgKiByb3dzQSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50QXJyYXlzU2FtZUxlbmd0aFwiLCBcInVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh2dC5MZW5ndGggIT0gY29sdW1uc0EgKiBjb2x1bW5zQSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50QXJyYXlzU2FtZUxlbmd0aFwiLCBcInZ0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocy5MZW5ndGggIT0gTWF0aC5NaW4ocm93c0EsIGNvbHVtbnNBKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50QXJyYXlzU2FtZUxlbmd0aFwiLCBcInNcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChiLkxlbmd0aCAhPSByb3dzQSAqIGNvbHVtbnNCKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRBcnJheXNTYW1lTGVuZ3RoXCIsIFwiYlwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHguTGVuZ3RoICE9IGNvbHVtbnNBICogY29sdW1uc0IpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudEFycmF5c1NhbWVMZW5ndGhcIiwgXCJiXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbW4gPSBNYXRoLk1pbihyb3dzQSwgY29sdW1uc0EpO1xyXG4gICAgICAgICAgICB2YXIgdG1wID0gbmV3IGRvdWJsZVtjb2x1bW5zQV07XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNvbHVtbnNCOyBrKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uc0E7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkb3VibGUgdmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgbW4pXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3NBOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHVbKGogKiByb3dzQSkgKyBpXSAqIGJbKGsgKiByb3dzQSkgKyBpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgLz0gc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRtcFtqXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uc0E7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkb3VibGUgdmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uc0E7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHZ0WyhqICogY29sdW1uc0EpICsgaV0gKiB0bXBbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB4WyhrICogY29sdW1uc0EpICsgal0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCB2b2lkIFNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uKGJvb2wgY29tcHV0ZVZlY3RvcnMsIGRvdWJsZVtdIGEsIGludCByb3dzQSwgaW50IGNvbHVtbnNBLCBkb3VibGVbXSBzLCBkb3VibGVbXSB1LCBkb3VibGVbXSB2dClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChhID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJhXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocyA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwic1wiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh2dCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwidnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh1Lkxlbmd0aCAhPSByb3dzQSAqIHJvd3NBKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRBcnJheXNTYW1lTGVuZ3RoXCIsIFwidVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZ0Lkxlbmd0aCAhPSBjb2x1bW5zQSAqIGNvbHVtbnNBKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRBcnJheXNTYW1lTGVuZ3RoXCIsIFwidnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzLkxlbmd0aCAhPSBNYXRoLk1pbihyb3dzQSwgY29sdW1uc0EpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRBcnJheXNTYW1lTGVuZ3RoXCIsIFwic1wiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHdvcmsgPSBuZXcgZG91YmxlW3Jvd3NBXTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGludCBtYXhpdGVyID0gMTAwMDtcclxuXHJcbiAgICAgICAgICAgIHZhciBlID0gbmV3IGRvdWJsZVtjb2x1bW5zQV07XHJcbiAgICAgICAgICAgIHZhciB2ID0gbmV3IGRvdWJsZVt2dC5MZW5ndGhdO1xyXG4gICAgICAgICAgICB2YXIgc3RlbXAgPSBuZXcgZG91YmxlW01hdGguTWluKHJvd3NBICsgMSwgY29sdW1uc0EpXTtcclxuXHJcbiAgICAgICAgICAgIGludCBpLCBqLCBsLCBscDE7XHJcblxyXG4gICAgICAgICAgICBkb3VibGUgdDtcclxuXHJcbiAgICAgICAgICAgIHZhciBuY3UgPSByb3dzQTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlZHVjZSBtYXRyaXggdG8gYmlkaWFnb25hbCBmb3JtLCBzdG9yaW5nIHRoZSBkaWFnb25hbCBlbGVtZW50c1xyXG4gICAgICAgICAgICAvLyBpbiBcInNcIiBhbmQgdGhlIHN1cGVyLWRpYWdvbmFsIGVsZW1lbnRzIGluIFwiZVwiLlxyXG4gICAgICAgICAgICB2YXIgbmN0ID0gTWF0aC5NaW4ocm93c0EgLSAxLCBjb2x1bW5zQSk7XHJcbiAgICAgICAgICAgIHZhciBucnQgPSBNYXRoLk1heCgwLCBNYXRoLk1pbihjb2x1bW5zQSAtIDIsIHJvd3NBKSk7XHJcbiAgICAgICAgICAgIHZhciBsdSA9IE1hdGguTWF4KG5jdCwgbnJ0KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobCA9IDA7IGwgPCBsdTsgbCsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBscDEgPSBsICsgMTtcclxuICAgICAgICAgICAgICAgIGlmIChsIDwgbmN0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHRyYW5zZm9ybWF0aW9uIGZvciB0aGUgbC10aCBjb2x1bW4gYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgdGhlIGwtdGggZGlhZ29uYWwgaW4gdmVjdG9yIHNbbF0uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpMSA9IGw7IGkxIDwgcm93c0E7IGkxKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gYVsobCAqIHJvd3NBKSArIGkxXSAqIGFbKGwgKiByb3dzQSkgKyBpMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzdGVtcFtsXSA9IE1hdGguU3FydChzdW0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlbXBbbF0gIT0gMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbKGwgKiByb3dzQSkgKyBsXSAhPSAwLjApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZW1wW2xdID0gTWF0aC5BYnMoc3RlbXBbbF0pICogKGFbKGwgKiByb3dzQSkgKyBsXSAvIE1hdGguQWJzKGFbKGwgKiByb3dzQSkgKyBsXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHBhcnQgb2YgY29sdW1uIFwibFwiIG9mIE1hdHJpeCBBIGZyb20gcm93IFwibFwiIHRvIGVuZCBtdWx0aXBseSBieSAxLjAgLyBzW2xdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGw7IGkgPCByb3dzQTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhWyhsICogcm93c0EpICsgaV0gPSBhWyhsICogcm93c0EpICsgaV0gKiAoMS4wIC8gc3RlbXBbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhWyhsICogcm93c0EpICsgbF0gPSAxLjAgKyBhWyhsICogcm93c0EpICsgbF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzdGVtcFtsXSA9IC1zdGVtcFtsXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBscDE7IGogPCBjb2x1bW5zQTsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsIDwgbmN0KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZW1wW2xdICE9IDAuMClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIHRyYW5zZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGw7IGkgPCByb3dzQTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgKz0gYVsoaiAqIHJvd3NBKSArIGldICogYVsobCAqIHJvd3NBKSArIGldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAtdCAvIGFbKGwgKiByb3dzQSkgKyBsXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IGw7IGlpIDwgcm93c0E7IGlpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVsoaiAqIHJvd3NBKSArIGlpXSArPSB0ICogYVsobCAqIHJvd3NBKSArIGlpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgdGhlIGwtdGggcm93IG9mIG1hdHJpeCBpbnRvIFwiZVwiIGZvciB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdWJzZXF1ZW50IGNhbGN1bGF0aW9uIG9mIHRoZSByb3cgdHJhbnNmb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgZVtqXSA9IGFbKGogKiByb3dzQSkgKyBsXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZVZlY3RvcnMgJiYgbCA8IG5jdClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZSB0aGUgdHJhbnNmb3JtYXRpb24gaW4gXCJ1XCIgZm9yIHN1YnNlcXVlbnQgYmFjayBtdWx0aXBsaWNhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBsOyBpIDwgcm93c0E7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVbKGwgKiByb3dzQSkgKyBpXSA9IGFbKGwgKiByb3dzQSkgKyBpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGwgPj0gbnJ0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGwtdGggcm93IHRyYW5zZm9ybWF0aW9uIGFuZCBwbGFjZSB0aGUgbC10aCBzdXBlci1kaWFnb25hbCBpbiBlKGwpLlxyXG4gICAgICAgICAgICAgICAgdmFyIGVub3JtID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbHAxOyBpIDwgZS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBlbm9ybSArPSBlW2ldICogZVtpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlW2xdID0gTWF0aC5TcXJ0KGVub3JtKTtcclxuICAgICAgICAgICAgICAgIGlmIChlW2xdICE9IDAuMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZVtscDFdICE9IDAuMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVbbF0gPSBNYXRoLkFicyhlW2xdKSAqIChlW2xwMV0gLyBNYXRoLkFicyhlW2xwMV0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNjYWxlIHZlY3RvciBcImVcIiBmcm9tIFwibHAxXCIgYnkgMS4wIC8gZVtsXVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGxwMTsgaSA8IGUuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlW2ldID0gZVtpXSAqICgxLjAgLyBlW2xdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGVbbHAxXSA9IDEuMCArIGVbbHAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlW2xdID0gLWVbbF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxwMSA8IHJvd3NBICYmIGVbbF0gIT0gMC4wKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSB0cmFuc2Zvcm1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBscDE7IGkgPCByb3dzQTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya1tpXSA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGxwMTsgaiA8IGNvbHVtbnNBOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IGxwMTsgaWkgPCByb3dzQTsgaWkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya1tpaV0gKz0gZVtqXSAqIGFbKGogKiByb3dzQSkgKyBpaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGxwMTsgaiA8IGNvbHVtbnNBOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3cgPSAtZVtqXSAvIGVbbHAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSBscDE7IGlpIDwgcm93c0E7IGlpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbKGogKiByb3dzQSkgKyBpaV0gKz0gd3cgKiB3b3JrW2lpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXB1dGVWZWN0b3JzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFBsYWNlIHRoZSB0cmFuc2Zvcm1hdGlvbiBpbiB2IGZvciBzdWJzZXF1ZW50IGJhY2sgbXVsdGlwbGljYXRpb24uXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBscDE7IGkgPCBjb2x1bW5zQTsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZbKGwgKiBjb2x1bW5zQSkgKyBpXSA9IGVbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgZmluYWwgYmlkaWFnb25hbCBtYXRyaXggb3Igb3JkZXIgbS5cclxuICAgICAgICAgICAgdmFyIG0gPSBNYXRoLk1pbihjb2x1bW5zQSwgcm93c0EgKyAxKTtcclxuICAgICAgICAgICAgdmFyIG5jdHAxID0gbmN0ICsgMTtcclxuICAgICAgICAgICAgdmFyIG5ydHAxID0gbnJ0ICsgMTtcclxuICAgICAgICAgICAgaWYgKG5jdCA8IGNvbHVtbnNBKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdGVtcFtuY3RwMSAtIDFdID0gYVsoKG5jdHAxIC0gMSkgKiByb3dzQSkgKyAobmN0cDEgLSAxKV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyb3dzQSA8IG0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0ZW1wW20gLSAxXSA9IDAuMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG5ydHAxIDwgbSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZVtucnRwMSAtIDFdID0gYVsoKG0gLSAxKSAqIHJvd3NBKSArIChucnRwMSAtIDEpXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZVttIC0gMV0gPSAwLjA7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiByZXF1aXJlZCwgZ2VuZXJhdGUgXCJ1XCIuXHJcbiAgICAgICAgICAgIGlmIChjb21wdXRlVmVjdG9ycylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gbmN0cDEgLSAxOyBqIDwgbmN1OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3NBOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1WyhqICogcm93c0EpICsgaV0gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB1WyhqICogcm93c0EpICsgal0gPSAxLjA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsID0gbmN0IC0gMTsgbCA+PSAwOyBsLS0pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZW1wW2xdICE9IDAuMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGwgKyAxOyBqIDwgbmN1OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBsOyBpIDwgcm93c0E7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICs9IHVbKGogKiByb3dzQSkgKyBpXSAqIHVbKGwgKiByb3dzQSkgKyBpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gLXQgLyB1WyhsICogcm93c0EpICsgbF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSBsOyBpaSA8IHJvd3NBOyBpaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVbKGogKiByb3dzQSkgKyBpaV0gKz0gdCAqIHVbKGwgKiByb3dzQSkgKyBpaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgcGFydCBvZiBjb2x1bW4gXCJsXCIgb2YgbWF0cml4IEEgZnJvbSByb3cgXCJsXCIgdG8gZW5kIG11bHRpcGx5IGJ5IC0xLjBcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gbDsgaSA8IHJvd3NBOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVbKGwgKiByb3dzQSkgKyBpXSA9IHVbKGwgKiByb3dzQSkgKyBpXSAqIC0xLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVbKGwgKiByb3dzQSkgKyBsXSA9IDEuMCArIHVbKGwgKiByb3dzQSkgKyBsXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdVsobCAqIHJvd3NBKSArIGldID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzQTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1WyhsICogcm93c0EpICsgaV0gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVbKGwgKiByb3dzQSkgKyBsXSA9IDEuMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGl0IGlzIHJlcXVpcmVkLCBnZW5lcmF0ZSB2LlxyXG4gICAgICAgICAgICBpZiAoY29tcHV0ZVZlY3RvcnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAobCA9IGNvbHVtbnNBIC0gMTsgbCA+PSAwOyBsLS0pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbHAxID0gbCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwgPCBucnQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtsXSAhPSAwLjApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGxwMTsgaiA8IGNvbHVtbnNBOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBscDE7IGkgPCBjb2x1bW5zQTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCArPSB2WyhqICogY29sdW1uc0EpICsgaV0gKiB2WyhsICogY29sdW1uc0EpICsgaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gLXQgLyB2WyhsICogY29sdW1uc0EpICsgbHAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IGw7IGlpIDwgY29sdW1uc0E7IGlpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2WyhqICogY29sdW1uc0EpICsgaWldICs9IHQgKiB2WyhsICogY29sdW1uc0EpICsgaWldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnNBOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2WyhsICogY29sdW1uc0EpICsgaV0gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2WyhsICogY29sdW1uc0EpICsgbF0gPSAxLjA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBcInNcIiBhbmQgXCJlXCIgc28gdGhhdCB0aGV5IGFyZSBkb3VibGVcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG07IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIHI7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RlbXBbaV0gIT0gMC4wKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSBzdGVtcFtpXTtcclxuICAgICAgICAgICAgICAgICAgICByID0gc3RlbXBbaV0gLyB0O1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ZW1wW2ldID0gdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IG0gLSAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVtpXSA9IGVbaV0gLyByO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVWZWN0b3JzKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBwYXJ0IG9mIGNvbHVtbiBcImlcIiBvZiBtYXRyaXggVSBmcm9tIHJvdyAwIHRvIGVuZCBtdWx0aXBseSBieSByXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCByb3dzQTsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1WyhpICogcm93c0EpICsgal0gPSB1WyhpICogcm93c0EpICsgal0gKiByO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV4aXRcclxuICAgICAgICAgICAgICAgIGlmIChpID09IG0gLSAxKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlW2ldID09IDAuMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0ID0gZVtpXTtcclxuICAgICAgICAgICAgICAgIHIgPSB0IC8gZVtpXTtcclxuICAgICAgICAgICAgICAgIGVbaV0gPSB0O1xyXG4gICAgICAgICAgICAgICAgc3RlbXBbaSArIDFdID0gc3RlbXBbaSArIDFdICogcjtcclxuICAgICAgICAgICAgICAgIGlmICghY29tcHV0ZVZlY3RvcnMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQSBwYXJ0IG9mIGNvbHVtbiBcImkrMVwiIG9mIG1hdHJpeCBWVCBmcm9tIHJvdyAwIHRvIGVuZCBtdWx0aXBseSBieSByXHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29sdW1uc0E7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2WygoaSArIDEpICogY29sdW1uc0EpICsgal0gPSB2WygoaSArIDEpICogY29sdW1uc0EpICsgal0gKiByO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYWluIGl0ZXJhdGlvbiBsb29wIGZvciB0aGUgc2luZ3VsYXIgdmFsdWVzLlxyXG4gICAgICAgICAgICB2YXIgbW4gPSBtO1xyXG4gICAgICAgICAgICB2YXIgaXRlciA9IDA7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAobSA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFF1aXQgaWYgYWxsIHRoZSBzaW5ndWxhciB2YWx1ZXMgaGF2ZSBiZWVuIGZvdW5kLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdG9vIG1hbnkgaXRlcmF0aW9ucyBoYXZlIGJlZW4gcGVyZm9ybWVkIHRocm93IGV4Y2VwdGlvbi5cclxuICAgICAgICAgICAgICAgIGlmIChpdGVyID49IG1heGl0ZXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiTm9uQ29udmVyZ2VuY2VFeGNlcHRpb25cIik7IFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2VjdGlvbiBvZiB0aGUgcHJvZ3JhbSBpbnNwZWN0cyBmb3IgbmVnbGlnaWJsZSBlbGVtZW50cyBpbiB0aGUgcyBhbmQgZSBhcnJheXMsXHJcbiAgICAgICAgICAgICAgICAvLyBvbiBjb21wbGV0aW9uIHRoZSB2YXJpYWJsZXMgY2FzZSBhbmQgbCBhcmUgc2V0IGFzIGZvbGxvd3M6XHJcbiAgICAgICAgICAgICAgICAvLyBjYXNlID0gMTogaWYgbVNbbV0gYW5kIGVbbC0xXSBhcmUgbmVnbGlnaWJsZSBhbmQgbCA8IG1cclxuICAgICAgICAgICAgICAgIC8vIGNhc2UgPSAyOiBpZiBtU1tsXSBpcyBuZWdsaWdpYmxlIGFuZCBsIDwgbVxyXG4gICAgICAgICAgICAgICAgLy8gY2FzZSA9IDM6IGlmIGVbbC0xXSBpcyBuZWdsaWdpYmxlLCBsIDwgbSwgYW5kIG1TW2wsIC4uLiwgbVNbbV0gYXJlIG5vdCBuZWdsaWdpYmxlIChxciBzdGVwKS5cclxuICAgICAgICAgICAgICAgIC8vIGNhc2UgPSA0OiBpZiBlW20tMV0gaXMgbmVnbGlnaWJsZSAoY29udmVyZ2VuY2UpLlxyXG4gICAgICAgICAgICAgICAgZG91YmxlIHp0ZXN0O1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIHRlc3Q7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGwgPSBtIC0gMjsgbCA+PSAwOyBsLS0pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdCA9IE1hdGguQWJzKHN0ZW1wW2xdKSArIE1hdGguQWJzKHN0ZW1wW2wgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgenRlc3QgPSB0ZXN0ICsgTWF0aC5BYnMoZVtsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFsbW9zdEVxdWFscyh6dGVzdCx0ZXN0KSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVbbF0gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpbnQga2FzZTtcclxuICAgICAgICAgICAgICAgIGlmIChsID09IG0gLSAyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGthc2UgPSA0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBscztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxzID0gbSAtIDE7IGxzID4gbDsgbHMtLSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChscyAhPSBtIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdCA9IHRlc3QgKyBNYXRoLkFicyhlW2xzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChscyAhPSBsICsgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdCA9IHRlc3QgKyBNYXRoLkFicyhlW2xzIC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB6dGVzdCA9IHRlc3QgKyBNYXRoLkFicyhzdGVtcFtsc10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQWxtb3N0RXF1YWxzKHp0ZXN0LHRlc3QpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVtcFtsc10gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxzID09IGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrYXNlID0gMztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobHMgPT0gbSAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrYXNlID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2FzZSA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBscztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbCA9IGwgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIHRhc2sgaW5kaWNhdGVkIGJ5IGNhc2UuXHJcbiAgICAgICAgICAgICAgICBpbnQgaztcclxuICAgICAgICAgICAgICAgIGRvdWJsZSBmO1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIGNzO1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIHNuO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChrYXNlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmxhdGUgbmVnbGlnaWJsZSBzW21dLlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGVbbSAtIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlW20gLSAyXSA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG91YmxlIHQxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrayA9IGw7IGtrIDwgbSAtIDE7IGtrKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBtIC0gMiAtIGtrICsgbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gc3RlbXBba107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRHJvdGcocmVmIHQxLCByZWYgZiwgb3V0IGNzLCBvdXQgc24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlbXBba10gPSB0MTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrICE9IGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IC1zbiAqIGVbayAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVbayAtIDFdID0gY3MgKiBlW2sgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZVZlY3RvcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm90YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnNBOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeiA9IChjcyAqIHZbKGsgKiBjb2x1bW5zQSkgKyBpXSkgKyAoc24gKiB2WygobSAtIDEpICogY29sdW1uc0EpICsgaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2WygobSAtIDEpICogY29sdW1uc0EpICsgaV0gPSAoY3MgKiB2WygobSAtIDEpICogY29sdW1uc0EpICsgaV0pIC0gKHNuICogdlsoayAqIGNvbHVtbnNBKSArIGldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdlsoayAqIGNvbHVtbnNBKSArIGldID0gejtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTcGxpdCBhdCBuZWdsaWdpYmxlIHNbbF0uXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gZVtsIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVbbCAtIDFdID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSBsOyBrIDwgbTsgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MSA9IHN0ZW1wW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRHJvdGcocmVmIHQxLCByZWYgZiwgb3V0IGNzLCBvdXQgc24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlbXBba10gPSB0MTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAtc24gKiBlW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZVtrXSA9IGNzICogZVtrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wdXRlVmVjdG9ycylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcm93c0E7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6ID0gKGNzICogdVsoayAqIHJvd3NBKSArIGldKSArIChzbiAqIHVbKChsIC0gMSkgKiByb3dzQSkgKyBpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVbKChsIC0gMSkgKiByb3dzQSkgKyBpXSA9IChjcyAqIHVbKChsIC0gMSkgKiByb3dzQSkgKyBpXSkgLSAoc24gKiB1WyhrICogcm93c0EpICsgaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1WyhrICogcm93c0EpICsgaV0gPSB6O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gb25lIHFyIHN0ZXAuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzaGlmdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IE1hdGguTWF4KHNjYWxlLCBNYXRoLkFicyhzdGVtcFttIC0gMV0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBNYXRoLk1heChzY2FsZSwgTWF0aC5BYnMoc3RlbXBbbSAtIDJdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlID0gTWF0aC5NYXgoc2NhbGUsIE1hdGguQWJzKGVbbSAtIDJdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlID0gTWF0aC5NYXgoc2NhbGUsIE1hdGguQWJzKHN0ZW1wW2xdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlID0gTWF0aC5NYXgoc2NhbGUsIE1hdGguQWJzKGVbbF0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNtID0gc3RlbXBbbSAtIDFdIC8gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbW0xID0gc3RlbXBbbSAtIDJdIC8gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbW0xID0gZVttIC0gMl0gLyBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsID0gc3RlbXBbbF0gLyBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gZVtsXSAvIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9ICgoKHNtbTEgKyBzbSkgKiAoc21tMSAtIHNtKSkgKyAoZW1tMSAqIGVtbTEpKSAvIDIuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSAoc20gKiBlbW0xKSAqIChzbSAqIGVtbTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hpZnQgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiICE9IDAuMCB8fCBjICE9IDAuMClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBNYXRoLlNxcnQoKGIgKiBiKSArIGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgPCAwLjApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAtc2hpZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBjIC8gKGIgKyBzaGlmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAoKHNsICsgc20pICogKHNsIC0gc20pKSArIHNoaWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IHNsICogZWw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGFzZSB6ZXJvc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSBsOyBrIDwgbSAtIDE7IGsrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRHJvdGcocmVmIGYsIHJlZiBnLCBvdXQgY3MsIG91dCBzbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoayAhPSBsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVbayAtIDFdID0gZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gKGNzICogc3RlbXBba10pICsgKHNuICogZVtrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlW2tdID0gKGNzICogZVtrXSkgLSAoc24gKiBzdGVtcFtrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gc24gKiBzdGVtcFtrICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVtcFtrICsgMV0gPSBjcyAqIHN0ZW1wW2sgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wdXRlVmVjdG9ycylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uc0E7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6ID0gKGNzICogdlsoayAqIGNvbHVtbnNBKSArIGldKSArIChzbiAqIHZbKChrICsgMSkgKiBjb2x1bW5zQSkgKyBpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZbKChrICsgMSkgKiBjb2x1bW5zQSkgKyBpXSA9IChjcyAqIHZbKChrICsgMSkgKiBjb2x1bW5zQSkgKyBpXSkgLSAoc24gKiB2WyhrICogY29sdW1uc0EpICsgaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2WyhrICogY29sdW1uc0EpICsgaV0gPSB6O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEcm90ZyhyZWYgZiwgcmVmIGcsIG91dCBjcywgb3V0IHNuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZW1wW2tdID0gZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAoY3MgKiBlW2tdKSArIChzbiAqIHN0ZW1wW2sgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVtcFtrICsgMV0gPSAtKHNuICogZVtrXSkgKyAoY3MgKiBzdGVtcFtrICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHNuICogZVtrICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlW2sgKyAxXSA9IGNzICogZVtrICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZVZlY3RvcnMgJiYgayA8IHJvd3NBKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzQTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHogPSAoY3MgKiB1WyhrICogcm93c0EpICsgaV0pICsgKHNuICogdVsoKGsgKyAxKSAqIHJvd3NBKSArIGldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdVsoKGsgKyAxKSAqIHJvd3NBKSArIGldID0gKGNzICogdVsoKGsgKyAxKSAqIHJvd3NBKSArIGldKSAtIChzbiAqIHVbKGsgKiByb3dzQSkgKyBpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVbKGsgKiByb3dzQSkgKyBpXSA9IHo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlW20gLSAyXSA9IGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXIgPSBpdGVyICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcmdlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgc2luZ3VsYXIgdmFsdWUgIHBvc2l0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGVtcFtsXSA8IDAuMClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlbXBbbF0gPSAtc3RlbXBbbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZVZlY3RvcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBwYXJ0IG9mIGNvbHVtbiBcImxcIiBvZiBtYXRyaXggVlQgZnJvbSByb3cgMCB0byBlbmQgbXVsdGlwbHkgYnkgLTFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uc0E7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZbKGwgKiBjb2x1bW5zQSkgKyBpXSA9IHZbKGwgKiBjb2x1bW5zQSkgKyBpXSAqIC0xLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcmRlciB0aGUgc2luZ3VsYXIgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsICE9IG1uIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZW1wW2xdID49IHN0ZW1wW2wgKyAxXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gc3RlbXBbbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVtcFtsXSA9IHN0ZW1wW2wgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZW1wW2wgKyAxXSA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZVZlY3RvcnMgJiYgbCA8IGNvbHVtbnNBKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3YXAgY29sdW1ucyBsLCBsICsgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zQTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHogPSB2WyhsICogY29sdW1uc0EpICsgaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZbKGwgKiBjb2x1bW5zQSkgKyBpXSA9IHZbKChsICsgMSkgKiBjb2x1bW5zQSkgKyBpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdlsoKGwgKyAxKSAqIGNvbHVtbnNBKSArIGldID0gejtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVWZWN0b3JzICYmIGwgPCByb3dzQSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2FwIGNvbHVtbnMgbCwgbCArIDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcm93c0E7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6ID0gdVsobCAqIHJvd3NBKSArIGldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1WyhsICogcm93c0EpICsgaV0gPSB1WygobCArIDEpICogcm93c0EpICsgaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVbKChsICsgMSkgKiByb3dzQSkgKyBpXSA9IHo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBsICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBtIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb21wdXRlVmVjdG9ycylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSB0cmFuc3Bvc2UgXCJ2XCIgdG8gZ2V0IFwidnRcIiBtYXRyaXhcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zQTsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zQTsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdnRbKGogKiBjb2x1bW5zQSkgKyBpXSA9IHZbKGkgKiBjb2x1bW5zQSkgKyBqXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvcHkgc3RlbXAgdG8gcyB3aXRoIHNpemUgYWRqdXN0bWVudC4gV2UgYXJlIHVzaW5nIHBvcnRlZCBjb3B5IG9mIGxpbnBhY2sncyBzdmQgY29kZSBhbmQgaXQgdXNlc1xyXG4gICAgICAgICAgICAvLyBhIHNpbmd1bGFyIHZlY3RvciBvZiBsZW5ndGggcm93cysxIHdoZW4gcm93cyA8IGNvbHVtbnMuIFRoZSBsYXN0IGVsZW1lbnQgaXMgbm90IHVzZWQgYW5kIG5lZWRzIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBwb3J0IGxhcGFjaydzIHN2ZCByb3V0aW5lIHRvIHJlbW92ZSB0aGlzIHByb2JsZW0uXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBBcnJheS5Db3B5KHN0ZW1wLCAwLCBzLCAwLCBNYXRoLk1pbihyb3dzQSwgY29sdW1uc0EpICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBib29sIEFsbW9zdEVxdWFscyhkb3VibGUgdmFsMSwgZG91YmxlIHZhbDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5BYnModmFsMSAtIHZhbDIpIDwgKE1hdGguUG93KDEwLC04KSkpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgdm9pZCBEcm90ZyhyZWYgZG91YmxlIGRhLCByZWYgZG91YmxlIGRiLCBvdXQgZG91YmxlIGMsIG91dCBkb3VibGUgcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSByLCB6O1xyXG5cclxuICAgICAgICAgICAgdmFyIHJvZSA9IGRiO1xyXG4gICAgICAgICAgICB2YXIgYWJzZGEgPSBNYXRoLkFicyhkYSk7XHJcbiAgICAgICAgICAgIHZhciBhYnNkYiA9IE1hdGguQWJzKGRiKTtcclxuICAgICAgICAgICAgaWYgKGFic2RhID4gYWJzZGIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJvZSA9IGRhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBhYnNkYSArIGFic2RiO1xyXG4gICAgICAgICAgICBpZiAoc2NhbGUgPT0gMC4wKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgcyA9IDAuMDtcclxuICAgICAgICAgICAgICAgIHIgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICB6ID0gMC4wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNkYSA9IGRhIC8gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2RiID0gZGIgLyBzY2FsZTtcclxuICAgICAgICAgICAgICAgIHIgPSBzY2FsZSAqIE1hdGguU3FydCgoc2RhICogc2RhKSArIChzZGIgKiBzZGIpKTtcclxuICAgICAgICAgICAgICAgIGlmIChyb2UgPCAwLjApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IC1yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGMgPSBkYSAvIHI7XHJcbiAgICAgICAgICAgICAgICBzID0gZGIgLyByO1xyXG4gICAgICAgICAgICAgICAgeiA9IDEuMDtcclxuICAgICAgICAgICAgICAgIGlmIChhYnNkYSA+IGFic2RiKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHogPSBzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhYnNkYiA+PSBhYnNkYSAmJiBjICE9IDAuMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB6ID0gMS4wIC8gYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGEgPSByO1xyXG4gICAgICAgICAgICBkYiA9IHo7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5MaW5xO1xyXG51c2luZyBTeXN0ZW0uVGV4dDtcclxudXNpbmcgU3lzdGVtLlRocmVhZGluZy5UYXNrcztcclxuXHJcbm5hbWVzcGFjZSBtYXRobmV0bnVtZXJpY3NicmlkZ2Vcclxue1xyXG4gICAgXHJcbiAgICAgICAgW1NlcmlhbGl6YWJsZV1cclxuICAgICAgICBbU3lzdGVtLlJ1bnRpbWUuQ29tcGlsZXJTZXJ2aWNlcy5UeXBlRm9yd2FyZGVkRnJvbShcIlN5c3RlbS5OdW1lcmljcywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWI3N2E1YzU2MTkzNGUwODlcIildXHJcblxyXG4gICAgICAgIHB1YmxpYyBzdHJ1Y3QgQ29tcGxleCA6IElFcXVhdGFibGU8Q29tcGxleD4sIElGb3JtYXR0YWJsZVxyXG4gICAge1xyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENvbXBsZXggWmVybyA9IG5ldyBDb21wbGV4KDAuMCwgMC4wKTtcclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyByZWFkb25seSBDb21wbGV4IE9uZSA9IG5ldyBDb21wbGV4KDEuMCwgMC4wKTtcclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyByZWFkb25seSBDb21wbGV4IEltYWdpbmFyeU9uZSA9IG5ldyBDb21wbGV4KDAuMCwgMS4wKTtcclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyByZWFkb25seSBDb21wbGV4IE5hTiA9IG5ldyBDb21wbGV4KGRvdWJsZS5OYU4sIGRvdWJsZS5OYU4pO1xyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENvbXBsZXggSW5maW5pdHkgPSBuZXcgQ29tcGxleChkb3VibGUuUG9zaXRpdmVJbmZpbml0eSwgZG91YmxlLlBvc2l0aXZlSW5maW5pdHkpO1xyXG5cclxuICAgICAgICAgICAgcHJpdmF0ZSBjb25zdCBkb3VibGUgSW52ZXJzZU9mTG9nMTAgPSAwLjQzNDI5NDQ4MTkwMzI1OyAvLyAxIC8gTG9nKDEwKVxyXG5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGFyZ2VzdCB4IGZvciB3aGljaCAoSHlwb3QoeCx4KSArIHgpIHdpbGwgbm90IG92ZXJmbG93LiBJdCBpcyB1c2VkIGZvciBicmFuY2hpbmcgaW5zaWRlIFNxcnQuXHJcbiAgICAgICAgICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGRvdWJsZSBzX3NxcnRSZXNjYWxlVGhyZXNob2xkID0gZG91YmxlLk1heFZhbHVlIC8gKE1hdGguU3FydCgyLjApICsgMS4wKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhcmdlc3QgeCBmb3Igd2hpY2ggMiB4XjIgd2lsbCBub3Qgb3ZlcmZsb3cuIEl0IGlzIHVzZWQgZm9yIGJyYW5jaGluZyBpbnNpZGUgQXNpbiBhbmQgQWNvcy5cclxuICAgICAgICAgICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgZG91YmxlIHNfYXNpbk92ZXJmbG93VGhyZXNob2xkID0gTWF0aC5TcXJ0KGRvdWJsZS5NYXhWYWx1ZSkgLyAyLjA7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGlzIHZhbHVlIGlzIHVzZWQgaW5zaWRlIEFzaW4gYW5kIEFjb3MuXHJcbiAgICAgICAgICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGRvdWJsZSBzX2xvZzIgPSBNYXRoLkxvZygyLjApO1xyXG5cclxuICAgICAgICAgICAgLy8gRG8gbm90IHJlbmFtZSwgdGhlc2UgZmllbGRzIGFyZSBuZWVkZWQgZm9yIGJpbmFyeSBzZXJpYWxpemF0aW9uXHJcbiAgICAgICAgICAgIHByaXZhdGUgZG91YmxlIG1fcmVhbDsgLy8gRG8gbm90IHJlbmFtZSAoYmluYXJ5IHNlcmlhbGl6YXRpb24pXHJcbiAgICAgICAgICAgIHByaXZhdGUgZG91YmxlIG1faW1hZ2luYXJ5OyAvLyBEbyBub3QgcmVuYW1lIChiaW5hcnkgc2VyaWFsaXphdGlvbilcclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBDb21wbGV4KGRvdWJsZSByZWFsLCBkb3VibGUgaW1hZ2luYXJ5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtX3JlYWwgPSByZWFsO1xyXG4gICAgICAgICAgICAgICAgbV9pbWFnaW5hcnkgPSBpbWFnaW5hcnk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBkb3VibGUgUmVhbCB7IGdldCB7IHJldHVybiBtX3JlYWw7IH0gfVxyXG4gICAgICAgICAgICBwdWJsaWMgZG91YmxlIEltYWdpbmFyeSB7IGdldCB7IHJldHVybiBtX2ltYWdpbmFyeTsgfSB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgZG91YmxlIE1hZ25pdHVkZSB7IGdldCB7IHJldHVybiBBYnModGhpcyk7IH0gfVxyXG4gICAgICAgICAgICBwdWJsaWMgZG91YmxlIFBoYXNlIHsgZ2V0IHsgcmV0dXJuIE1hdGguQXRhbjIobV9pbWFnaW5hcnksIG1fcmVhbCk7IH0gfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IEZyb21Qb2xhckNvb3JkaW5hdGVzKGRvdWJsZSBtYWduaXR1ZGUsIGRvdWJsZSBwaGFzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KG1hZ25pdHVkZSAqIE1hdGguQ29zKHBoYXNlKSwgbWFnbml0dWRlICogTWF0aC5TaW4ocGhhc2UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IE5lZ2F0ZShDb21wbGV4IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLXZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggQWRkKENvbXBsZXggbGVmdCwgQ29tcGxleCByaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgKyByaWdodDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IEFkZChDb21wbGV4IGxlZnQsIGRvdWJsZSByaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgKyByaWdodDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IEFkZChkb3VibGUgbGVmdCwgQ29tcGxleCByaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgKyByaWdodDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IFN1YnRyYWN0KENvbXBsZXggbGVmdCwgQ29tcGxleCByaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IFN1YnRyYWN0KENvbXBsZXggbGVmdCwgZG91YmxlIHJpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAtIHJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggU3VidHJhY3QoZG91YmxlIGxlZnQsIENvbXBsZXggcmlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0IC0gcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleCBNdWx0aXBseShDb21wbGV4IGxlZnQsIENvbXBsZXggcmlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICogcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleCBNdWx0aXBseShDb21wbGV4IGxlZnQsIGRvdWJsZSByaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgKiByaWdodDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IE11bHRpcGx5KGRvdWJsZSBsZWZ0LCBDb21wbGV4IHJpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAqIHJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggRGl2aWRlKENvbXBsZXggZGl2aWRlbmQsIENvbXBsZXggZGl2aXNvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IERpdmlkZShDb21wbGV4IGRpdmlkZW5kLCBkb3VibGUgZGl2aXNvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IERpdmlkZShkb3VibGUgZGl2aWRlbmQsIENvbXBsZXggZGl2aXNvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IG9wZXJhdG9yIC0oQ29tcGxleCB2YWx1ZSkgIC8qIFVuYXJ5IG5lZ2F0aW9uIG9mIGEgY29tcGxleCBudW1iZXIgKi9cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KC12YWx1ZS5tX3JlYWwsIC12YWx1ZS5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleCBvcGVyYXRvciArKENvbXBsZXggbGVmdCwgQ29tcGxleCByaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGxlZnQubV9yZWFsICsgcmlnaHQubV9yZWFsLCBsZWZ0Lm1faW1hZ2luYXJ5ICsgcmlnaHQubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggb3BlcmF0b3IgKyhDb21wbGV4IGxlZnQsIGRvdWJsZSByaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGxlZnQubV9yZWFsICsgcmlnaHQsIGxlZnQubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggb3BlcmF0b3IgKyhkb3VibGUgbGVmdCwgQ29tcGxleCByaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGxlZnQgKyByaWdodC5tX3JlYWwsIHJpZ2h0Lm1faW1hZ2luYXJ5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IG9wZXJhdG9yIC0oQ29tcGxleCBsZWZ0LCBDb21wbGV4IHJpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgobGVmdC5tX3JlYWwgLSByaWdodC5tX3JlYWwsIGxlZnQubV9pbWFnaW5hcnkgLSByaWdodC5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleCBvcGVyYXRvciAtKENvbXBsZXggbGVmdCwgZG91YmxlIHJpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgobGVmdC5tX3JlYWwgLSByaWdodCwgbGVmdC5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleCBvcGVyYXRvciAtKGRvdWJsZSBsZWZ0LCBDb21wbGV4IHJpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgobGVmdCAtIHJpZ2h0Lm1fcmVhbCwgLXJpZ2h0Lm1faW1hZ2luYXJ5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IG9wZXJhdG9yICooQ29tcGxleCBsZWZ0LCBDb21wbGV4IHJpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBNdWx0aXBsaWNhdGlvbjogIChhICsgYmkpKGMgKyBkaSkgPSAoYWMgLWJkKSArIChiYyArIGFkKWlcclxuICAgICAgICAgICAgICAgIGRvdWJsZSByZXN1bHRfcmVhbHBhcnQgPSAobGVmdC5tX3JlYWwgKiByaWdodC5tX3JlYWwpIC0gKGxlZnQubV9pbWFnaW5hcnkgKiByaWdodC5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgICAgICBkb3VibGUgcmVzdWx0X2ltYWdpbmFyeXBhcnQgPSAobGVmdC5tX2ltYWdpbmFyeSAqIHJpZ2h0Lm1fcmVhbCkgKyAobGVmdC5tX3JlYWwgKiByaWdodC5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgocmVzdWx0X3JlYWxwYXJ0LCByZXN1bHRfaW1hZ2luYXJ5cGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleCBvcGVyYXRvciAqKENvbXBsZXggbGVmdCwgZG91YmxlIHJpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvdWJsZS5Jc0Zpbml0ZShsZWZ0Lm1fcmVhbCkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb3VibGUuSXNGaW5pdGUobGVmdC5tX2ltYWdpbmFyeSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoZG91YmxlLk5hTiwgZG91YmxlLk5hTik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgobGVmdC5tX3JlYWwgKiByaWdodCwgZG91YmxlLk5hTik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFkb3VibGUuSXNGaW5pdGUobGVmdC5tX2ltYWdpbmFyeSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGRvdWJsZS5OYU4sIGxlZnQubV9pbWFnaW5hcnkgKiByaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGxlZnQubV9yZWFsICogcmlnaHQsIGxlZnQubV9pbWFnaW5hcnkgKiByaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleCBvcGVyYXRvciAqKGRvdWJsZSBsZWZ0LCBDb21wbGV4IHJpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvdWJsZS5Jc0Zpbml0ZShyaWdodC5tX3JlYWwpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG91YmxlLklzRmluaXRlKHJpZ2h0Lm1faW1hZ2luYXJ5KSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleChkb3VibGUuTmFOLCBkb3VibGUuTmFOKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleChsZWZ0ICogcmlnaHQubV9yZWFsLCBkb3VibGUuTmFOKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvdWJsZS5Jc0Zpbml0ZShyaWdodC5tX2ltYWdpbmFyeSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGRvdWJsZS5OYU4sIGxlZnQgKiByaWdodC5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGxlZnQgKiByaWdodC5tX3JlYWwsIGxlZnQgKiByaWdodC5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleCBvcGVyYXRvciAvKENvbXBsZXggbGVmdCwgQ29tcGxleCByaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gRGl2aXNpb24gOiBTbWl0aCdzIGZvcm11bGEuXHJcbiAgICAgICAgICAgICAgICBkb3VibGUgYSA9IGxlZnQubV9yZWFsO1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIGIgPSBsZWZ0Lm1faW1hZ2luYXJ5O1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIGMgPSByaWdodC5tX3JlYWw7XHJcbiAgICAgICAgICAgICAgICBkb3VibGUgZCA9IHJpZ2h0Lm1faW1hZ2luYXJ5O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGluZyBjICogYyArIGQgKiBkIHdpbGwgb3ZlcmZsb3cgZXZlbiBpbiBjYXNlcyB3aGVyZSB0aGUgYWN0dWFsIHJlc3VsdCBvZiB0aGUgZGl2aXNpb24gZG9lcyBub3Qgb3ZlcmZsb3cuXHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5BYnMoZCkgPCBNYXRoLkFicyhjKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkb3VibGUgZG9jID0gZCAvIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KChhICsgYiAqIGRvYykgLyAoYyArIGQgKiBkb2MpLCAoYiAtIGEgKiBkb2MpIC8gKGMgKyBkICogZG9jKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG91YmxlIGNvZCA9IGMgLyBkO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleCgoYiArIGEgKiBjb2QpIC8gKGQgKyBjICogY29kKSwgKC1hICsgYiAqIGNvZCkgLyAoZCArIGMgKiBjb2QpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IG9wZXJhdG9yIC8oQ29tcGxleCBsZWZ0LCBkb3VibGUgcmlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIElFRUUgcHJvaGliaXQgb3B0aW1pemF0aW9ucyB3aGljaCBhcmUgdmFsdWUgY2hhbmdpbmdcclxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIG1ha2Ugc3VyZSB0aGF0IGJlaGF2aW91ciBmb3IgdGhlIHNpbXBsaWZpZWQgdmVyc2lvbiBleGFjdGx5IG1hdGNoXHJcbiAgICAgICAgICAgICAgICAvLyBmdWxsIHZlcnNpb24uXHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQgPT0gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoZG91YmxlLk5hTiwgZG91YmxlLk5hTik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFkb3VibGUuSXNGaW5pdGUobGVmdC5tX3JlYWwpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG91YmxlLklzRmluaXRlKGxlZnQubV9pbWFnaW5hcnkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGRvdWJsZS5OYU4sIGRvdWJsZS5OYU4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGxlZnQubV9yZWFsIC8gcmlnaHQsIGRvdWJsZS5OYU4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZG91YmxlLklzRmluaXRlKGxlZnQubV9pbWFnaW5hcnkpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleChkb3VibGUuTmFOLCBsZWZ0Lm1faW1hZ2luYXJ5IC8gcmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhlcmUgdGhlIGFjdHVhbCBvcHRpbWl6ZWQgdmVyc2lvbiBvZiBjb2RlLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KGxlZnQubV9yZWFsIC8gcmlnaHQsIGxlZnQubV9pbWFnaW5hcnkgLyByaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleCBvcGVyYXRvciAvKGRvdWJsZSBsZWZ0LCBDb21wbGV4IHJpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBEaXZpc2lvbiA6IFNtaXRoJ3MgZm9ybXVsYS5cclxuICAgICAgICAgICAgICAgIGRvdWJsZSBhID0gbGVmdDtcclxuICAgICAgICAgICAgICAgIGRvdWJsZSBjID0gcmlnaHQubV9yZWFsO1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIGQgPSByaWdodC5tX2ltYWdpbmFyeTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRpbmcgYyAqIGMgKyBkICogZCB3aWxsIG92ZXJmbG93IGV2ZW4gaW4gY2FzZXMgd2hlcmUgdGhlIGFjdHVhbCByZXN1bHQgb2YgdGhlIGRpdmlzaW9uIGRvZXMgbm90IG92ZXJmbG93LlxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguQWJzKGQpIDwgTWF0aC5BYnMoYykpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG91YmxlIGRvYyA9IGQgLyBjO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleChhIC8gKGMgKyBkICogZG9jKSwgKC1hICogZG9jKSAvIChjICsgZCAqIGRvYykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZSBjb2QgPSBjIC8gZDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoYSAqIGNvZCAvIChkICsgYyAqIGNvZCksIC1hIC8gKGQgKyBjICogY29kKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgZG91YmxlIEFicyhDb21wbGV4IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSHlwb3QodmFsdWUubV9yZWFsLCB2YWx1ZS5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByaXZhdGUgc3RhdGljIGRvdWJsZSBIeXBvdChkb3VibGUgYSwgZG91YmxlIGIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFVzaW5nXHJcbiAgICAgICAgICAgICAgICAvLyAgIHNxcnQoYV4yICsgYl4yKSA9IHxhfCAqIHNxcnQoMSArIChiL2EpXjIpXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gZmFjdG9yIG91dCB0aGUgbGFyZ2VyIGNvbXBvbmVudCB0byBkb2RnZSBvdmVyZmxvdyBldmVuIHdoZW4gYSAqIGEgd291bGQgb3ZlcmZsb3cuXHJcblxyXG4gICAgICAgICAgICAgICAgYSA9IE1hdGguQWJzKGEpO1xyXG4gICAgICAgICAgICAgICAgYiA9IE1hdGguQWJzKGIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGRvdWJsZSBzbWFsbCwgbGFyZ2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoYSA8IGIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc21hbGwgPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhcmdlID0gYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzbWFsbCA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFyZ2UgPSBhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzbWFsbCA9PSAwLjApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChsYXJnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkb3VibGUuSXNQb3NpdGl2ZUluZmluaXR5KGxhcmdlKSAmJiAhZG91YmxlLklzTmFOKHNtYWxsKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgTmFOIHRlc3QgaXMgbmVjZXNzYXJ5IHNvIHdlIGRvbid0IHJldHVybiAraW5mIHdoZW4gc21hbGw9TmFOIGFuZCBsYXJnZT0raW5mLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5hTiBpbiBhbnkgb3RoZXIgcGxhY2UgcmV0dXJucyBOYU4gd2l0aG91dCBhbnkgc3BlY2lhbCBoYW5kbGluZy5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGRvdWJsZS5Qb3NpdGl2ZUluZmluaXR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkb3VibGUgcmF0aW8gPSBzbWFsbCAvIGxhcmdlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobGFyZ2UgKiBNYXRoLlNxcnQoMS4wICsgcmF0aW8gKiByYXRpbykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHByaXZhdGUgc3RhdGljIGRvdWJsZSBMb2cxUChkb3VibGUgeClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBsb2coMSArIHgpIHdpdGhvdXQgbG9zcyBvZiBhY2N1cmFjeSB3aGVuIHggaXMgc21hbGwuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gT3VyIG9ubHkgdXNlIGNhc2Ugc28gZmFyIGlzIGZvciBwb3NpdGl2ZSB2YWx1ZXMsIHNvIHRoaXMgaXNuJ3QgY29kZWQgdG8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgIGRvdWJsZSB4cDEgPSAxLjAgKyB4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHhwMSA9PSAxLjApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4IDwgMC43NSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFjY3VyYXRlIHRvIHdpdGhpbiA1IHVscCB3aXRoIGFueSBmbG9hdGluZy1wb2ludCBzeXN0ZW0gdGhhdCB1c2VzIGEgZ3VhcmQgZGlnaXQsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgcHJvdmVuIGluIFRoZW9yZW0gNCBvZiBcIldoYXQgRXZlcnkgQ29tcHV0ZXIgU2NpZW50aXN0IFNob3VsZCBLbm93IEFib3V0IEZsb2F0aW5nLVBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJpdGhtZXRpY1wiIChodHRwczovL2RvY3Mub3JhY2xlLmNvbS9jZC9FMTk5NTctMDEvODA2LTM1NjgvbmNnX2dvbGRiZXJnLmh0bWwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggKiBNYXRoLkxvZyh4cDEpIC8gKHhwMSAtIDEuMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguTG9nKHhwMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggQ29uanVnYXRlKENvbXBsZXggdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIENvbmp1Z2F0ZSBvZiBhIENvbXBsZXggbnVtYmVyOiB0aGUgY29uanVnYXRlIG9mIHgraSp5IGlzIHgtaSp5XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgodmFsdWUubV9yZWFsLCAtdmFsdWUubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggUmVjaXByb2NhbChDb21wbGV4IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWNpcHJvY2FsIG9mIGEgQ29tcGxleCBudW1iZXIgOiB0aGUgcmVjaXByb2NhbCBvZiB4K2kqeSBpcyAxLyh4K2kqeSlcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5tX3JlYWwgPT0gMCAmJiB2YWx1ZS5tX2ltYWdpbmFyeSA9PSAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBaZXJvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9uZSAvIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgb3BlcmF0b3IgPT0oQ29tcGxleCBsZWZ0LCBDb21wbGV4IHJpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdC5tX3JlYWwgPT0gcmlnaHQubV9yZWFsICYmIGxlZnQubV9pbWFnaW5hcnkgPT0gcmlnaHQubV9pbWFnaW5hcnk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBvcGVyYXRvciAhPShDb21wbGV4IGxlZnQsIENvbXBsZXggcmlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0Lm1fcmVhbCAhPSByaWdodC5tX3JlYWwgfHwgbGVmdC5tX2ltYWdpbmFyeSAhPSByaWdodC5tX2ltYWdpbmFyeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBFcXVhbHMob2JqZWN0PyBvYmopXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghKG9iaiBpcyBDb21wbGV4KSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVxdWFscygoQ29tcGxleClvYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHB1YmxpYyBib29sIEVxdWFscyhDb21wbGV4IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbV9yZWFsLkVxdWFscyh2YWx1ZS5tX3JlYWwpICYmIG1faW1hZ2luYXJ5LkVxdWFscyh2YWx1ZS5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBvdmVycmlkZSBpbnQgR2V0SGFzaENvZGUoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgbjEgPSA5OTk5OTk5NztcclxuICAgICAgICAgICAgICAgIGludCByZWFsSGFzaCA9IG1fcmVhbC5HZXRIYXNoQ29kZSgpICUgbjE7XHJcbiAgICAgICAgICAgICAgICBpbnQgaW1hZ2luYXJ5SGFzaCA9IG1faW1hZ2luYXJ5LkdldEhhc2hDb2RlKCk7XHJcbiAgICAgICAgICAgICAgICBpbnQgZmluYWxIYXNoID0gKGludCkgTWF0aC5Qb3cocmVhbEhhc2gsIGltYWdpbmFyeUhhc2gpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsSGFzaDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIG92ZXJyaWRlIHN0cmluZyBUb1N0cmluZygpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcuRm9ybWF0KCBcIih7MH0sIHsxfSlcIiwgbV9yZWFsLCBtX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdHJpbmcgVG9TdHJpbmcoc3RyaW5nIHN0cmluZ2luLCBJRm9ybWF0UHJvdmlkZXIgcHJvdmlkZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcuRm9ybWF0KHByb3ZpZGVyLCBcIih7MH0sIHsxfSlcIiwgbV9yZWFsLCBtX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IFNpbihDb21wbGV4IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIGJvdGggc2luaCBhbmQgY29zaCBvZiBpbWFnaW5hcnkgcGFydC4gVG8gYXZvaWQgbXVsdGlwbGUgY2FsbHMgdG8gTWF0aC5FeHAgd2l0aCB0aGUgc2FtZSB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIC8vIHdlIGNvbXB1dGUgdGhlbSBib3RoIGhlcmUgZnJvbSBhIHNpbmdsZSBjYWxsIHRvIE1hdGguRXhwLlxyXG4gICAgICAgICAgICAgICAgZG91YmxlIHAgPSBNYXRoLkV4cCh2YWx1ZS5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgICAgICBkb3VibGUgcSA9IDEuMCAvIHA7XHJcbiAgICAgICAgICAgICAgICBkb3VibGUgc2luaCA9IChwIC0gcSkgKiAwLjU7XHJcbiAgICAgICAgICAgICAgICBkb3VibGUgY29zaCA9IChwICsgcSkgKiAwLjU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5TaW4odmFsdWUubV9yZWFsKSAqIGNvc2gsIE1hdGguQ29zKHZhbHVlLm1fcmVhbCkgKiBzaW5oKTtcclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEga25vd24gbGltaXRhdGlvbiB3aXRoIHRoaXMgYWxnb3JpdGhtOiBpbnB1dHMgdGhhdCBjYXVzZSBzaW5oIGFuZCBjb3NoIHRvIG92ZXJmbG93LCBidXQgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBzaW4gb3IgY29zIGFyZSBzbWFsbCBlbm91Z2ggdGhhdCBzaW4gKiBjb3NoIG9yIGNvcyAqIHNpbmggYXJlIHN0aWxsIHJlcHJlc2VudGFibGUsIG5vbmV0aGVsZXNzXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWNlIG92ZXJmbG93LiBGb3IgZXhhbXBsZSwgU2luKCgwLjAxLCA3MTEuMCkpIHNob3VsZCBwcm9kdWNlICh+My4wRTMwNiwgUG9zaXRpdmVJbmZpbml0eSksIGJ1dFxyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBwcm9kdWNlcyAoUG9zaXRpdmVJbmZpbml0eSwgUG9zaXRpdmVJbmZpbml0eSkuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggU2luaChDb21wbGV4IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBVc2Ugc2luaCh6KSA9IC1pIHNpbihpeikgdG8gY29tcHV0ZSB2aWEgc2luKHopLlxyXG4gICAgICAgICAgICAgICAgQ29tcGxleCBzaW4gPSBTaW4obmV3IENvbXBsZXgoLXZhbHVlLm1faW1hZ2luYXJ5LCB2YWx1ZS5tX3JlYWwpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleChzaW4ubV9pbWFnaW5hcnksIC1zaW4ubV9yZWFsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IEFzaW4oQ29tcGxleCB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIGIsIGJQcmltZSwgdjtcclxuICAgICAgICAgICAgICAgIEFzaW5fSW50ZXJuYWwoTWF0aC5BYnModmFsdWUuUmVhbCksIE1hdGguQWJzKHZhbHVlLkltYWdpbmFyeSksIG91dCBiLCBvdXQgYlByaW1lLCBvdXQgdik7XHJcblxyXG4gICAgICAgICAgICAgICAgZG91YmxlIHU7XHJcbiAgICAgICAgICAgICAgICBpZiAoYlByaW1lIDwgMC4wKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHUgPSBNYXRoLkFzaW4oYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IE1hdGguQXRhbihiUHJpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5SZWFsIDwgMC4wKSB1ID0gLXU7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuSW1hZ2luYXJ5IDwgMC4wKSB2ID0gLXY7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHUsIHYpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggQ29zKENvbXBsZXggdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRvdWJsZSBwID0gTWF0aC5FeHAodmFsdWUubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIHEgPSAxLjAgLyBwO1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIHNpbmggPSAocCAtIHEpICogMC41O1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIGNvc2ggPSAocCArIHEpICogMC41O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KE1hdGguQ29zKHZhbHVlLm1fcmVhbCkgKiBjb3NoLCAtTWF0aC5TaW4odmFsdWUubV9yZWFsKSAqIHNpbmgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggQ29zaChDb21wbGV4IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgY29zaCh6KSA9IGNvcyhpeikgdG8gY29tcHV0ZSB2aWEgY29zKHopLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvcyhuZXcgQ29tcGxleCgtdmFsdWUubV9pbWFnaW5hcnksIHZhbHVlLm1fcmVhbCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggQWNvcyhDb21wbGV4IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkb3VibGUgYiwgYlByaW1lLCB2O1xyXG4gICAgICAgICAgICAgICAgQXNpbl9JbnRlcm5hbChNYXRoLkFicyh2YWx1ZS5SZWFsKSwgTWF0aC5BYnModmFsdWUuSW1hZ2luYXJ5KSwgb3V0IGIsIG91dCBiUHJpbWUsIG91dCB2KTtcclxuXHJcbiAgICAgICAgICAgICAgICBkb3VibGUgdTtcclxuICAgICAgICAgICAgICAgIGlmIChiUHJpbWUgPCAwLjApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IE1hdGguQWNvcyhiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB1ID0gTWF0aC5BdGFuKDEuMCAvIGJQcmltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLlJlYWwgPCAwLjApIHUgPSBNYXRoLlBJIC0gdTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5JbWFnaW5hcnkgPiAwLjApIHYgPSAtdjtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgodSwgdik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleCBUYW4oQ29tcGxleCB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gdGFuIHogPSBzaW4geiAvIGNvcyB6LCBidXQgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmVwZWF0ZWQgdHJpZyBjb21wdXRhdGlvbnMsIHVzZVxyXG4gICAgICAgICAgICAgICAgLy8gICB0YW4geiA9IChzaW4oMngpICsgaSBzaW5oKDJ5KSkgLyAoY29zKDJ4KSArIGNvc2goMnkpKVxyXG4gICAgICAgICAgICAgICAgLy8gKHNlZSBBYnJhbW93aXR6ICYgU3RlZ3VuIDQuMy41NyBvciBkZXJpdmUgYnkgaGFuZCksIGFuZCBjb21wdXRlIHRyaWcgZnVuY3Rpb25zIGhlcmUuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhcHByb2FjaCBkb2VzIG5vdCB3b3JrIGZvciB8eXwgPiB+MzU1LCBiZWNhdXNlIHNpbmgoMnkpIGFuZCBjb3NoKDJ5KSBvdmVyZmxvdyxcclxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gdGhvdWdoIHRoZWlyIHJhdGlvIGRvZXMgbm90LiBJbiB0aGF0IGNhc2UsIGRpdmlkZSB0aHJvdWdoIGJ5IGNvc2ggdG8gZ2V0OlxyXG4gICAgICAgICAgICAgICAgLy8gICB0YW4geiA9IChzaW4oMngpIC8gY29zaCgyeSkgKyBpIFxcdGFuaCgyeSkpIC8gKDEgKyBjb3MoMngpIC8gY29zaCgyeSkpXHJcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBjb3JyZWN0bHkgY29tcHV0ZXMgdGhlICh0aW55KSByZWFsIHBhcnQgYW5kIHRoZSAobm9ybWFsLXNpemVkKSBpbWFnaW5hcnkgcGFydC5cclxuXHJcbiAgICAgICAgICAgICAgICBkb3VibGUgeDIgPSAyLjAgKiB2YWx1ZS5tX3JlYWw7XHJcbiAgICAgICAgICAgICAgICBkb3VibGUgeTIgPSAyLjAgKiB2YWx1ZS5tX2ltYWdpbmFyeTtcclxuICAgICAgICAgICAgICAgIGRvdWJsZSBwID0gTWF0aC5FeHAoeTIpO1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIHEgPSAxLjAgLyBwO1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIGNvc2ggPSAocCArIHEpICogMC41O1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguQWJzKHZhbHVlLm1faW1hZ2luYXJ5KSA8PSA0LjApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG91YmxlIHNpbmggPSAocCAtIHEpICogMC41O1xyXG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZSBEID0gTWF0aC5Db3MoeDIpICsgY29zaDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5TaW4oeDIpIC8gRCwgc2luaCAvIEQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZSBEID0gMS4wICsgTWF0aC5Db3MoeDIpIC8gY29zaDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoTWF0aC5TaW4oeDIpIC8gY29zaCAvIEQsIE1hdGguVGFuaCh5MikgLyBEKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleCBUYW5oKENvbXBsZXggdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSB0YW5oKHopID0gLWkgdGFuKGl6KSB0byBjb21wdXRlIHZpYSB0YW4oeikuXHJcbiAgICAgICAgICAgICAgICBDb21wbGV4IHRhbiA9IFRhbihuZXcgQ29tcGxleCgtdmFsdWUubV9pbWFnaW5hcnksIHZhbHVlLm1fcmVhbCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHRhbi5tX2ltYWdpbmFyeSwgLXRhbi5tX3JlYWwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggQXRhbihDb21wbGV4IHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb21wbGV4IHR3byA9IG5ldyBDb21wbGV4KDIuMCwgMC4wKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoSW1hZ2luYXJ5T25lIC8gdHdvKSAqIChMb2coT25lIC0gSW1hZ2luYXJ5T25lICogdmFsdWUpIC0gTG9nKE9uZSArIEltYWdpbmFyeU9uZSAqIHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgQXNpbl9JbnRlcm5hbChkb3VibGUgeCwgZG91YmxlIHksIG91dCBkb3VibGUgYiwgb3V0IGRvdWJsZSBiUHJpbWUsIG91dCBkb3VibGUgdilcclxuICAgICAgICAgICAge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWV0aG9kIGZvciB0aGUgaW52ZXJzZSBjb21wbGV4IHNpbmUgKGFuZCBjb3NpbmUpIGlzIGRlc2NyaWJlZCBpbiBIdWxsLCBGYWlyZ3JpZXZlLFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIFRhbmcsIFwiSW1wbGVtZW50aW5nIHRoZSBDb21wbGV4IEFyY3NpbmUgYW5kIEFyY2Nvc2luZSBGdW5jdGlvbnMgVXNpbmcgRXhjZXB0aW9uIEhhbmRsaW5nXCIsXHJcbiAgICAgICAgICAgICAgICAvLyBBQ00gVHJhbnNhY3Rpb25zIG9uIE1hdGhlbWF0aWNhbCBTb2Z0d2FyZSAoMTk5NylcclxuICAgICAgICAgICAgICAgIC8vIChodHRwczovL3d3dy5yZXNlYXJjaGdhdGUubmV0L3Byb2ZpbGUvUGluZ19UYW5nMy9wdWJsaWNhdGlvbi8yMjA0OTMzMzBfSW1wbGVtZW50aW5nX3RoZV9Db21wbGV4X0FyY3NpbmVfYW5kX0FyY2Nvc2luZV9GdW5jdGlvbnNfVXNpbmdfRXhjZXB0aW9uX0hhbmRsaW5nL2xpbmtzLzU1YjI0NGIyMDhhZTkyODlhMDg1MjQ1ZC5wZGYpXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmlyc3QsIHRoZSBiYXNpY3M6IHN0YXJ0IHdpdGggc2luKHcpID0gKGVee2l3fSAtIGVeey1pd30pIC8gKDJpKSA9IHouIEhlcmUgeiBpcyB0aGUgaW5wdXRcclxuICAgICAgICAgICAgICAgIC8vIGFuZCB3IGlzIHRoZSBvdXRwdXQuIFRvIHNvbHZlIGZvciB3LCBkZWZpbmUgdCA9IGVee2kgd30gYW5kIG11bHRpcGx5IHRocm91Z2ggYnkgdCB0b1xyXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBxdWFkcmF0aWMgZXF1YXRpb24gdF4yIC0gMiBpIHogdCAtIDEgPSAwLiBUaGUgc29sdXRpb24gaXMgdCA9IGkgeiArIHNxcnQoMSAtIHpeMiksIHNvXHJcbiAgICAgICAgICAgICAgICAvLyAgIHcgPSBhcmNzaW4oeikgPSAtIGkgbG9nKCBpIHogKyBzcXJ0KDEgLSB6XjIpIClcclxuICAgICAgICAgICAgICAgIC8vIERlY29tcG9zZSB6ID0geCArIGkgeSwgbXVsdGlwbHkgb3V0IGkgeiArIHNxcnQoMSAtIHpeMiksIHVzZSBsb2cocykgPSB8c3wgKyBpIGFyZyhzKSwgYW5kIGRvIGFcclxuICAgICAgICAgICAgICAgIC8vIGJ1bmNoIG9mIGFsZ2VicmEgdG8gZ2V0IHRoZSBjb21wb25lbnRzIG9mIHcgPSBhcmNzaW4oeikgPSB1ICsgaSB2XHJcbiAgICAgICAgICAgICAgICAvLyAgIHUgPSBhcmNzaW4oYmV0YSkgIHYgPSBzaWduKHkpIGxvZyhhbHBoYSArIHNxcnQoYWxwaGFeMiAtIDEpKVxyXG4gICAgICAgICAgICAgICAgLy8gd2hlcmVcclxuICAgICAgICAgICAgICAgIC8vICAgYWxwaGEgPSAocmhvICsgc2lnbWEpIC8gMiAgICAgIGJldGEgPSAocmhvIC0gc2lnbWEpIC8gMlxyXG4gICAgICAgICAgICAgICAgLy8gICByaG8gPSBzcXJ0KCh4ICsgMSleMiArIHleMikgICAgc2lnbWEgPSBzcXJ0KCh4IC0gMSleMiArIHleMilcclxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGZvcm11bGFzIGFwcGVhciBpbiBETE1GIHNlY3Rpb24gNC4yMy4gKGh0dHA6Ly9kbG1mLm5pc3QuZ292LzQuMjMpLCBhbG9uZyB3aXRoIHRoZSBhbmFsb2dvdXNcclxuICAgICAgICAgICAgICAgIC8vICAgYXJjY29zKHcpID0gYXJjY29zKGJldGEpIC0gaSBzaWduKHkpIGxvZyhhbHBoYSArIHNxcnQoYWxwaGFeMiAtIDEpKVxyXG4gICAgICAgICAgICAgICAgLy8gU28gYWxwaGEgYW5kIGJldGEgdG9nZXRoZXIgZ2l2ZSB1cyBhcmNzaW4odykgYW5kIGFyY2Nvcyh3KS5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBcyB3cml0dGVuLCBhbHBoYSBpcyBub3Qgc3VzY2VwdGlibGUgdG8gY2FuY2VsYXRpb24gZXJyb3JzLCBidXQgYmV0YSBpcy4gVG8gYXZvaWQgY2FuY2VsYXRpb24sIG5vdGVcclxuICAgICAgICAgICAgICAgIC8vICAgYmV0YSA9IChyaG9eMiAtIHNpZ21hXjIpIC8gKHJobyArIHNpZ21hKSAvIDIgPSAoMiB4KSAvIChyaG8gKyBzaWdtYSkgPSB4IC8gYWxwaGFcclxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIG5vdCBzdWJqZWN0IHRvIGNhbmNlbGF0aW9uLiBOb3RlIGFscGhhID49IDEgYW5kIHxiZXRhfCA8PSAxLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZvciBhbHBoYSB+IDEsIHRoZSBhcmd1bWVudCBvZiB0aGUgbG9nIGlzIG5lYXIgdW5pdHksIHNvIHdlIGNvbXB1dGUgKGFscGhhIC0gMSkgaW5zdGVhZCxcclxuICAgICAgICAgICAgICAgIC8vIHdyaXRlIHRoZSBhcmd1bWVudCBhcyAxICsgKGFscGhhIC0gMSkgKyBzcXJ0KChhbHBoYSAtIDEpKGFscGhhICsgMSkpLCBhbmQgdXNlIHRoZSBsb2cxcCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSB0aGUgbG9nIHdpdGhvdXQgbG9zcyBvZiBhY2N1cmFjeS5cclxuICAgICAgICAgICAgICAgIC8vIEZvciBiZXRhIH4gMSwgYXJjY29zIGRvZXMgbm90IGFjY3VyYXRlbHkgcmVzb2x2ZSBzbWFsbCBhbmdsZXMsIHNvIHdlIGNvbXB1dGUgdGhlIHRhbmdlbnQgb2YgdGhlIGFuZ2xlXHJcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkLlxyXG4gICAgICAgICAgICAgICAgLy8gSHVsbCwgRmFpcmdyaWV2ZSwgYW5kIFRhbmcgZGVyaXZlIGZvcm11bGFzIGZvciAoYWxwaGEgLSAxKSBhbmQgYmV0YScgPSB0YW4odSkgdGhhdCBkbyBub3Qgc3VmZmVyXHJcbiAgICAgICAgICAgICAgICAvLyBmcm9tIGNhbmNlbGF0aW9uIGluIHRoZXNlIGNhc2VzLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZvciBzaW1wbGljaXR5LCB3ZSBhc3N1bWUgYWxsIHBvc2l0aXZlIGlucHV0cyBhbmQgcmV0dXJuIGFsbCBwb3NpdGl2ZSBvdXRwdXRzLiBUaGUgY2FsbGVyIHNob3VsZFxyXG4gICAgICAgICAgICAgICAgLy8gYXNzaWduIHNpZ25zIGFwcHJvcHJpYXRlIHRvIHRoZSBkZXNpcmVkIGN1dCBjb252ZW50aW9ucy4gV2UgcmV0dXJuIHYgZGlyZWN0bHkgc2luY2UgaXRzIG1hZ25pdHVkZVxyXG4gICAgICAgICAgICAgICAgLy8gaXMgdGhlIHNhbWUgZm9yIGJvdGggYXJjc2luIGFuZCBhcmNjb3MuIEluc3RlYWQgb2YgdSwgd2UgdXN1YWxseSByZXR1cm4gYmV0YSBhbmQgc29tZXRpbWVzIGJldGEnLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgYmV0YScgaXMgbm90IGNvbXB1dGVkLCBpdCBpcyBzZXQgdG8gLTE7IGlmIGl0IGlzIGNvbXB1dGVkLCBpdCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIGJldGFcclxuICAgICAgICAgICAgICAgIC8vIHRvIGRldGVybWluZSB1LiBDb21wdXRlIHUgPSBhcmNzaW4oYmV0YSkgb3IgdSA9IGFyY3RhbihiZXRhJykgZm9yIGFyY3NpbiwgdSA9IGFyY2NvcyhiZXRhKVxyXG4gICAgICAgICAgICAgICAgLy8gb3IgYXJjdGFuKDEvYmV0YScpIGZvciBhcmNjb3MuXHJcblxyXG4gICAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRm9yIHggb3IgeSBsYXJnZSBlbm91Z2ggdG8gb3ZlcmZsb3cgYWxwaGFeMiwgd2UgY2FuIHNpbXBsaWZ5IG91ciBmb3JtdWxhcyBhbmQgYXZvaWQgb3ZlcmZsb3cuXHJcbiAgICAgICAgICAgICAgICBpZiAoKHggPiBzX2FzaW5PdmVyZmxvd1RocmVzaG9sZCkgfHwgKHkgPiBzX2FzaW5PdmVyZmxvd1RocmVzaG9sZCkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IC0xLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgYlByaW1lID0geCAvIHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZSBzbWFsbCwgYmlnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4IDwgeSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtYWxsID0geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmlnID0geTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc21hbGwgPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaWcgPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkb3VibGUgcmF0aW8gPSBzbWFsbCAvIGJpZztcclxuICAgICAgICAgICAgICAgICAgICB2ID0gc19sb2cyICsgTWF0aC5Mb2coYmlnKSArIDAuNSAqIExvZzFQKHJhdGlvICogcmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZSByID0gSHlwb3QoKHggKyAxLjApLCB5KTtcclxuICAgICAgICAgICAgICAgICAgICBkb3VibGUgcyA9IEh5cG90KCh4IC0gMS4wKSwgeSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZSBhID0gKHIgKyBzKSAqIDAuNTtcclxuICAgICAgICAgICAgICAgICAgICBiID0geCAvIGE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiID4gMC43NSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4IDw9IDEuMClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG91YmxlIGFteCA9ICh5ICogeSAvIChyICsgKHggKyAxLjApKSArIChzICsgKDEuMCAtIHgpKSkgKiAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiUHJpbWUgPSB4IC8gTWF0aC5TcXJ0KChhICsgeCkgKiBhbXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBhbXggfiB5XjIuIFNpbmNlIHdlIHRha2UgdGhlIHNxdWFyZSByb290IG9mIGFteCwgd2Ugc2hvdWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwdWxsIHkgb3V0IGZyb20gdW5kZXIgdGhlIHNxdWFyZSByb290IHNvIHdlIGRvbid0IGxvc2UgaXRzIGNvbnRyaWJ1dGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB5XjIgdW5kZXJmbG93cy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZSB0ID0gKDEuMCAvIChyICsgKHggKyAxLjApKSArIDEuMCAvIChzICsgKHggLSAxLjApKSkgKiAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiUHJpbWUgPSB4IC8geSAvIE1hdGguU3FydCgoYSArIHgpICogdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYlByaW1lID0gLTEuMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhIDwgMS41KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggPCAxLjApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW5vdGhlciBjYXNlIHdoZXJlIG91ciBleHByZXNzaW9uIGlzIHByb3BvcnRpb25hbCB0byB5XjIgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB0YWtlIGl0cyBzcXVhcmUgcm9vdCwgc28gYWdhaW4gd2UgcHVsbCBvdXQgYSBmYWN0b3Igb2YgeSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmRlciB0aGUgc3F1YXJlIHJvb3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3VibGUgdCA9ICgxLjAgLyAociArICh4ICsgMS4wKSkgKyAxLjAgLyAocyArICgxLjAgLSB4KSkpICogMC41O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG91YmxlIGFtMSA9IHkgKiB5ICogdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBMb2cxUChhbTEgKyB5ICogTWF0aC5TcXJ0KHQgKiAoYSArIDEuMCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZSBhbTEgPSAoeSAqIHkgLyAociArICh4ICsgMS4wKSkgKyAocyArICh4IC0gMS4wKSkpICogMC41O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IExvZzFQKGFtMSArIE1hdGguU3FydChhbTEgKiAoYSArIDEuMCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIG9mIHRoZSB0ZXN0IGFib3ZlLCB3ZSBjYW4gYmUgc3VyZSB0aGF0IGEgKiBhIHdpbGwgbm90IG92ZXJmbG93LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gTWF0aC5Mb2coYSArIE1hdGguU3FydCgoYSAtIDEuMCkgKiAoYSArIDEuMCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxucHVibGljIHN0YXRpYyBib29sIElzRmluaXRlKENvbXBsZXggdmFsdWUpXHJcbntcclxuICAgIHJldHVybiBkb3VibGUuSXNGaW5pdGUodmFsdWUubV9yZWFsKSAmJiBkb3VibGUuSXNGaW5pdGUodmFsdWUubV9pbWFnaW5hcnkpO1xyXG59cHVibGljIHN0YXRpYyBib29sIElzSW5maW5pdHkoQ29tcGxleCB2YWx1ZSlcclxue1xyXG4gICAgcmV0dXJuIGRvdWJsZS5Jc0luZmluaXR5KHZhbHVlLm1fcmVhbCkgfHwgZG91YmxlLklzSW5maW5pdHkodmFsdWUubV9pbWFnaW5hcnkpO1xyXG59cHVibGljIHN0YXRpYyBib29sIElzTmFOKENvbXBsZXggdmFsdWUpXHJcbntcclxuICAgIHJldHVybiAhSXNJbmZpbml0eSh2YWx1ZSkgJiYgIUlzRmluaXRlKHZhbHVlKTtcclxufVxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggTG9nKENvbXBsZXggdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleChNYXRoLkxvZyhBYnModmFsdWUpKSwgTWF0aC5BdGFuMih2YWx1ZS5tX2ltYWdpbmFyeSwgdmFsdWUubV9yZWFsKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleCBMb2coQ29tcGxleCB2YWx1ZSwgZG91YmxlIGJhc2VWYWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvZyh2YWx1ZSkgLyBMb2coYmFzZVZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IExvZzEwKENvbXBsZXggdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvbXBsZXggdGVtcExvZyA9IExvZyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU2NhbGUodGVtcExvZywgSW52ZXJzZU9mTG9nMTApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXggRXhwKENvbXBsZXggdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRvdWJsZSBleHBSZWFsID0gTWF0aC5FeHAodmFsdWUubV9yZWFsKTtcclxuICAgICAgICAgICAgICAgIGRvdWJsZSBjb3NJbWFnaW5hcnkgPSBleHBSZWFsICogTWF0aC5Db3ModmFsdWUubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIHNpbkltYWdpbmFyeSA9IGV4cFJlYWwgKiBNYXRoLlNpbih2YWx1ZS5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoY29zSW1hZ2luYXJ5LCBzaW5JbWFnaW5hcnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IFNxcnQoQ29tcGxleCB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5tX2ltYWdpbmFyeSA9PSAwLjApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSB0cml2aWFsIGNhc2UgcXVpY2tseS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubV9yZWFsIDwgMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KDAuMCwgTWF0aC5TcXJ0KC12YWx1ZS5tX3JlYWwpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KE1hdGguU3FydCh2YWx1ZS5tX3JlYWwpLCAwLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT25lIHdheSB0byBjb21wdXRlIFNxcnQoeikgaXMganVzdCB0byBjYWxsIFBvdyh6LCAwLjUpLCB3aGljaCBjb3ZlcnRzIHRvIHBvbGFyIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKHNxcnQgKyBhdGFuKSwgaGFsdmVzIHRoZSBwaGFzZSwgYW5kIHJlY29udmVydHMgdG8gY2FydGVzaWFuIGNvb3JkaW5hdGVzIChjb3MgKyBzaW4pLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBvbmx5IGlzIHRoaXMgbW9yZSBleHBlbnNpdmUgdGhhbiBuZWNlc3NhcnksIGl0IGFsc28gZmFpbHMgdG8gcHJlc2VydmUgY2VydGFpbiBleHBlY3RlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN5bW1ldHJpZXMsIHN1Y2ggYXMgdGhhdCB0aGUgc3F1YXJlIHJvb3Qgb2YgYSBwdXJlIG5lZ2F0aXZlIGlzIGEgcHVyZSBpbWFnaW5hcnksIGFuZCB0aGF0IHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNxdWFyZSByb290IG9mIGEgcHVyZSBpbWFnaW5hcnkgaGFzIGV4YWN0bHkgZXF1YWwgcmVhbCBhbmQgaW1hZ2luYXJ5IHBhcnRzLiBUaGlzIGFsbCBnb2VzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFjayB0byB0aGUgZmFjdCB0aGF0IE1hdGguUEkgaXMgbm90IHN0b3JlZCB3aXRoIGluZmluaXRlIHByZWNpc2lvbiwgc28gdGFraW5nIGhhbGYgb2YgTWF0aC5QSVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGxhbmQgdXMgb24gYW4gYXJndW1lbnQgd2l0aCBjb3NpbmUgZXhhY3RseSBlcXVhbCB0byB6ZXJvLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBmaW5kIGEgZmFzdCBhbmQgc3ltbWV0cnktcmVzcGVjdGluZyBmb3JtdWxhIGZvciBjb21wbGV4IHNxdWFyZSByb290LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGUgeCArIGkgeSA9IFxcc3FydHthICsgaSBifSBpbXBsaWVzIHheMiArIDIgaSB4IHkgLSB5XjIgPSBhICsgaSBiLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHheMiAtIHleMiA9IGEgYW5kIDIgeCB5ID0gYi4gQ3Jvc3Mtc3Vic3RpdHV0ZSBhbmQgdXNlIHRoZSBxdWFkcmF0aWMgZm9ybXVsYSB0byBvYnRhaW5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgIHggPSBcXHNxcnR7XFxmcmFje1xcc3FydHthXjIgKyBiXjJ9ICsgYX17Mn19ICB5ID0gXFxwbSBcXHNxcnR7XFxmcmFje1xcc3FydHthXjIgKyBiXjJ9IC0gYX17Mn19XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMganVzdCBvbmUgY29tcGxpY2F0aW9uOiBkZXBlbmRpbmcgb24gdGhlIHNpZ24gb24gYSwgZWl0aGVyIHggb3IgeSBzdWZmZXJzIGZyb21cclxuICAgICAgICAgICAgICAgICAgICAvLyBjYW5jZWxhdGlvbiB3aGVuIHxifCA8PCB8YXwuIFdlIGNhbiBnZXQgYXJvdWQgdGhpcyBieSBub3RpbmcgdGhhdCBvdXIgZm9ybXVsYXMgaW1wbHlcclxuICAgICAgICAgICAgICAgICAgICAvLyB4XjIgeV4yID0gYl4yIC8gNCwgc28gfHh8IHx5fCA9IHxifCAvIDIuIFNvIGFmdGVyIGNvbXB1dGluZyB0aGUgb25lIHRoYXQgZG9lc24ndCBzdWZmZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIGNhbmNlbGF0aW9uLCB3ZSBjYW4gY29tcHV0ZSB0aGUgb3RoZXIgd2l0aCBqdXN0IGEgZGl2aXNpb24uIFRoaXMgaXMgYmFzaWNhbGx5IGp1c3RcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmlnaHQgd2F5IHRvIGV2YWx1YXRlIHRoZSBxdWFkcmF0aWMgZm9ybXVsYSB3aXRob3V0IGNhbmNlbGF0aW9uLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBbGwgdGhpcyByZWR1Y2VzIG91ciB0b3RhbCBjb3N0IHRvIHR3byBzcXJ0cyBhbmQgYSBmZXcgZmxvcHMsIGFuZCBpdCByZXNwZWN0cyB0aGUgZGVzaXJlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN5bW1ldHJpZXMuIE11Y2ggYmV0dGVyIHRoYW4gYXRhbiArIGNvcyArIHNpbiFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNpZ25zIGFyZSBhIG1hdHRlciBvZiBjaG9pY2Ugb2YgYnJhbmNoIGN1dCwgd2hpY2ggaXMgdHJhZGl0aW9uYWxseSB0YWtlbiBzbyB4ID4gMCBhbmQgc2lnbih5KSA9IHNpZ24oYikuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb21wb25lbnRzIGFyZSB0b28gbGFyZ2UsIEh5cG90IHdpbGwgb3ZlcmZsb3csIGV2ZW4gdGhvdWdoIHRoZSBzdWJzZXF1ZW50IHNxcnQgd291bGRcclxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHRoZSByZXN1bHQgcmVwcmVzZW50YWJsZS4gVG8gYXZvaWQgdGhpcywgd2UgcmUtc2NhbGUgKGJ5IGV4YWN0IHBvd2VycyBvZiAyIGZvciBhY2N1cmFjeSlcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHdlIGVuY291bnRlciB2ZXJ5IGxhcmdlIGNvbXBvbmVudHMgdG8gYXZvaWQgaW50ZXJtZWRpYXRlIGluZmluaXRpZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgYm9vbCByZXNjYWxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChNYXRoLkFicyh2YWx1ZS5tX3JlYWwpID49IHNfc3FydFJlc2NhbGVUaHJlc2hvbGQpIHx8IChNYXRoLkFicyh2YWx1ZS5tX2ltYWdpbmFyeSkgPj0gc19zcXJ0UmVzY2FsZVRocmVzaG9sZCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG91YmxlLklzSW5maW5pdHkodmFsdWUubV9pbWFnaW5hcnkpICYmICFkb3VibGUuSXNOYU4odmFsdWUubV9yZWFsKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgaW5maW5pdGUgaW1hZ2luYXJ5IHBhcnRzIHNwZWNpYWxseSBiZWNhdXNlIG90aGVyd2lzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3VyIGZvcm11bGFzIGJlbG93IHByb2R1Y2UgaW5mL2luZiA9IE5hTi4gVGhlIE5hTiB0ZXN0IGlzIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSByZXR1cm4gTmFOIHJhdGhlciB0aGFuICgraW5mLGluZikgZm9yIChOYU4saW5mKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobmV3IENvbXBsZXgoZG91YmxlLlBvc2l0aXZlSW5maW5pdHksIHZhbHVlLm1faW1hZ2luYXJ5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5tX3JlYWwgKj0gMC4yNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLm1faW1hZ2luYXJ5ICo9IDAuMjU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNjYWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgY29yZSBvZiB0aGUgYWxnb3JpdGhtLiBFdmVyeXRoaW5nIGVsc2UgaXMgc3BlY2lhbCBjYXNlIGhhbmRsaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZSB4LCB5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5tX3JlYWwgPj0gMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IE1hdGguU3FydCgoSHlwb3QodmFsdWUubV9yZWFsLCB2YWx1ZS5tX2ltYWdpbmFyeSkgKyB2YWx1ZS5tX3JlYWwpICogMC41KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHZhbHVlLm1faW1hZ2luYXJ5IC8gKDIuMCAqIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gTWF0aC5TcXJ0KChIeXBvdCh2YWx1ZS5tX3JlYWwsIHZhbHVlLm1faW1hZ2luYXJ5KSAtIHZhbHVlLm1fcmVhbCkgKiAwLjUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubV9pbWFnaW5hcnkgPCAwLjApIHkgPSAteTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHZhbHVlLm1faW1hZ2luYXJ5IC8gKDIuMCAqIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2NhbGUpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ICo9IDIuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSAqPSAyLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgoeCwgeSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IFBvdyhDb21wbGV4IHZhbHVlLCBDb21wbGV4IHBvd2VyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG93ZXIgPT0gWmVybylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT25lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBaZXJvKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBaZXJvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGRvdWJsZSB2YWx1ZVJlYWwgPSB2YWx1ZS5tX3JlYWw7XHJcbiAgICAgICAgICAgICAgICBkb3VibGUgdmFsdWVJbWFnaW5hcnkgPSB2YWx1ZS5tX2ltYWdpbmFyeTtcclxuICAgICAgICAgICAgICAgIGRvdWJsZSBwb3dlclJlYWwgPSBwb3dlci5tX3JlYWw7XHJcbiAgICAgICAgICAgICAgICBkb3VibGUgcG93ZXJJbWFnaW5hcnkgPSBwb3dlci5tX2ltYWdpbmFyeTtcclxuXHJcbiAgICAgICAgICAgICAgICBkb3VibGUgcmhvID0gQWJzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGRvdWJsZSB0aGV0YSA9IE1hdGguQXRhbjIodmFsdWVJbWFnaW5hcnksIHZhbHVlUmVhbCk7XHJcbiAgICAgICAgICAgICAgICBkb3VibGUgbmV3UmhvID0gcG93ZXJSZWFsICogdGhldGEgKyBwb3dlckltYWdpbmFyeSAqIE1hdGguTG9nKHJobyk7XHJcblxyXG4gICAgICAgICAgICAgICAgZG91YmxlIHQgPSBNYXRoLlBvdyhyaG8sIHBvd2VyUmVhbCkgKiBNYXRoLlBvdyhNYXRoLkUsIC1wb3dlckltYWdpbmFyeSAqIHRoZXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgodCAqIE1hdGguQ29zKG5ld1JobyksIHQgKiBNYXRoLlNpbihuZXdSaG8pKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4IFBvdyhDb21wbGV4IHZhbHVlLCBkb3VibGUgcG93ZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQb3codmFsdWUsIG5ldyBDb21wbGV4KHBvd2VyLCAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByaXZhdGUgc3RhdGljIENvbXBsZXggU2NhbGUoQ29tcGxleCB2YWx1ZSwgZG91YmxlIGZhY3RvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIHJlYWxSZXN1bHQgPSBmYWN0b3IgKiB2YWx1ZS5tX3JlYWw7XHJcbiAgICAgICAgICAgICAgICBkb3VibGUgaW1hZ2luYXJ5UmVzdWlsdCA9IGZhY3RvciAqIHZhbHVlLm1faW1hZ2luYXJ5O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHJlYWxSZXN1bHQsIGltYWdpbmFyeVJlc3VpbHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIGltcGxpY2l0IG9wZXJhdG9yIENvbXBsZXgoc2hvcnQgdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleCh2YWx1ZSwgMC4wKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBpbXBsaWNpdCBvcGVyYXRvciBDb21wbGV4KGludCB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHZhbHVlLCAwLjApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIGltcGxpY2l0IG9wZXJhdG9yIENvbXBsZXgobG9uZyB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHZhbHVlLCAwLjApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBbQ0xTQ29tcGxpYW50KGZhbHNlKV1cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBpbXBsaWNpdCBvcGVyYXRvciBDb21wbGV4KHVzaG9ydCB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHZhbHVlLCAwLjApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBbQ0xTQ29tcGxpYW50KGZhbHNlKV1cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBpbXBsaWNpdCBvcGVyYXRvciBDb21wbGV4KHVpbnQgdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleCh2YWx1ZSwgMC4wKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgW0NMU0NvbXBsaWFudChmYWxzZSldXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgaW1wbGljaXQgb3BlcmF0b3IgQ29tcGxleCh1bG9uZyB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHZhbHVlLCAwLjApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBbQ0xTQ29tcGxpYW50KGZhbHNlKV1cclxuICAgICAgICAgICAgcHVibGljIHN0YXRpYyBpbXBsaWNpdCBvcGVyYXRvciBDb21wbGV4KHNieXRlIHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgodmFsdWUsIDAuMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgaW1wbGljaXQgb3BlcmF0b3IgQ29tcGxleChieXRlIHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgodmFsdWUsIDAuMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgaW1wbGljaXQgb3BlcmF0b3IgQ29tcGxleChmbG9hdCB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KHZhbHVlLCAwLjApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIGltcGxpY2l0IG9wZXJhdG9yIENvbXBsZXgoZG91YmxlIHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgodmFsdWUsIDAuMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIGV4cGxpY2l0IG9wZXJhdG9yIENvbXBsZXgoZGVjaW1hbCB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KChkb3VibGUpdmFsdWUsIDAuMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBcclxufVxyXG4iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uTGlucTtcclxudXNpbmcgU3lzdGVtLlRleHQ7XHJcbnVzaW5nIFN5c3RlbS5UaHJlYWRpbmcuVGFza3M7XHJcblxyXG5uYW1lc3BhY2UgbWF0aG5ldG51bWVyaWNzYnJpZGdlXHJcbntcclxuXHJcbiAgICBbU2VyaWFsaXphYmxlXVxyXG4gICAgW1N5c3RlbS5SdW50aW1lLkNvbXBpbGVyU2VydmljZXMuVHlwZUZvcndhcmRlZEZyb20oXCJTeXN0ZW0uTnVtZXJpY3MsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5XCIpXVxyXG4gICAgcHVibGljIHN0cnVjdCBDb21wbGV4MzIgOiBJRXF1YXRhYmxlPENvbXBsZXgzMj4sIElGb3JtYXR0YWJsZVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQ29tcGxleDMyIFplcm8gPSBuZXcgQ29tcGxleDMyKDAuMGYsIDAuMGYpO1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQ29tcGxleDMyIE9uZSA9IG5ldyBDb21wbGV4MzIoMS4wZiwgMC4wZik7XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyByZWFkb25seSBDb21wbGV4MzIgSW1hZ2luYXJ5T25lID0gbmV3IENvbXBsZXgzMigwLjBmLCAxLjBmKTtcclxuICAgICAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENvbXBsZXgzMiBOYU4gPSBuZXcgQ29tcGxleDMyKGZsb2F0Lk5hTiwgZmxvYXQuTmFOKTtcclxuICAgICAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENvbXBsZXgzMiBJbmZpbml0eSA9IG5ldyBDb21wbGV4MzIoZmxvYXQuUG9zaXRpdmVJbmZpbml0eSwgZmxvYXQuUG9zaXRpdmVJbmZpbml0eSk7XHJcblxyXG4gICAgICAgIHByaXZhdGUgY29uc3QgZmxvYXQgSW52ZXJzZU9mTG9nMTAgPSAoZmxvYXQpMC40MzQyOTQ0ODsgLy8gMSAvIExvZygxMClcclxuXHJcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGFyZ2VzdCB4IGZvciB3aGljaCAoSHlwb3QoeCx4KSArIHgpIHdpbGwgbm90IG92ZXJmbG93LiBJdCBpcyB1c2VkIGZvciBicmFuY2hpbmcgaW5zaWRlIFNxcnQuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgZmxvYXQgc19zcXJ0UmVzY2FsZVRocmVzaG9sZCA9IGZsb2F0Lk1heFZhbHVlIC8oZmxvYXQpIChNYXRoLlNxcnQoMi4wKSArIDEuMCk7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhcmdlc3QgeCBmb3Igd2hpY2ggMiB4XjIgd2lsbCBub3Qgb3ZlcmZsb3cuIEl0IGlzIHVzZWQgZm9yIGJyYW5jaGluZyBpbnNpZGUgQXNpbiBhbmQgQWNvcy5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBmbG9hdCBzX2FzaW5PdmVyZmxvd1RocmVzaG9sZCA9IChmbG9hdClNYXRoLlNxcnQoZmxvYXQuTWF4VmFsdWUpIC8gKGZsb2F0KTIuMDtcclxuXHJcbiAgICAgICAgLy8gVGhpcyB2YWx1ZSBpcyB1c2VkIGluc2lkZSBBc2luIGFuZCBBY29zLlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGZsb2F0IHNfbG9nMiA9IChmbG9hdClNYXRoLkxvZygyLjApO1xyXG5cclxuICAgICAgICAvLyBEbyBub3QgcmVuYW1lLCB0aGVzZSBmaWVsZHMgYXJlIG5lZWRlZCBmb3IgYmluYXJ5IHNlcmlhbGl6YXRpb25cclxuICAgICAgICBwcml2YXRlIGZsb2F0IG1fcmVhbDsgLy8gRG8gbm90IHJlbmFtZSAoYmluYXJ5IHNlcmlhbGl6YXRpb24pXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBtX2ltYWdpbmFyeTsgLy8gRG8gbm90IHJlbmFtZSAoYmluYXJ5IHNlcmlhbGl6YXRpb24pXHJcblxyXG4gICAgICAgIHB1YmxpYyBDb21wbGV4MzIoZmxvYXQgcmVhbCwgZmxvYXQgaW1hZ2luYXJ5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbV9yZWFsID0gcmVhbDtcclxuICAgICAgICAgICAgbV9pbWFnaW5hcnkgPSBpbWFnaW5hcnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgUmVhbCB7IGdldCB7IHJldHVybiBtX3JlYWw7IH0gfVxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBJbWFnaW5hcnkgeyBnZXQgeyByZXR1cm4gbV9pbWFnaW5hcnk7IH0gfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWFnbml0dWRlIHsgZ2V0IHsgcmV0dXJuIEFicyh0aGlzKTsgfSB9XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFBoYXNlIHsgZ2V0IHsgcmV0dXJuIChmbG9hdClNYXRoLkF0YW4yKG1faW1hZ2luYXJ5LCBtX3JlYWwpOyB9IH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgRnJvbVBvbGFyQ29vcmRpbmF0ZXMoZmxvYXQgbWFnbml0dWRlLCBmbG9hdCBwaGFzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleDMyKChmbG9hdCltYWduaXR1ZGUgKiAoZmxvYXQpTWF0aC5Db3MocGhhc2UpLCAoZmxvYXQpbWFnbml0dWRlICogKGZsb2F0KU1hdGguU2luKHBoYXNlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXgzMiBOZWdhdGUoQ29tcGxleDMyIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIC12YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleDMyIEFkZChDb21wbGV4MzIgbGVmdCwgQ29tcGxleDMyIHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnQgKyByaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleDMyIEFkZChDb21wbGV4MzIgbGVmdCwgZmxvYXQgcmlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdCArIHJpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgQWRkKGZsb2F0IGxlZnQsIENvbXBsZXgzMiByaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0ICsgcmlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXgzMiBTdWJ0cmFjdChDb21wbGV4MzIgbGVmdCwgQ29tcGxleDMyIHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleDMyIFN1YnRyYWN0KENvbXBsZXgzMiBsZWZ0LCBmbG9hdCByaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0IC0gcmlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXgzMiBTdWJ0cmFjdChmbG9hdCBsZWZ0LCBDb21wbGV4MzIgcmlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdCAtIHJpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgTXVsdGlwbHkoQ29tcGxleDMyIGxlZnQsIENvbXBsZXgzMiByaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0ICogcmlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXgzMiBNdWx0aXBseShDb21wbGV4MzIgbGVmdCwgZmxvYXQgcmlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdCAqIHJpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgTXVsdGlwbHkoZmxvYXQgbGVmdCwgQ29tcGxleDMyIHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnQgKiByaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleDMyIERpdmlkZShDb21wbGV4MzIgZGl2aWRlbmQsIENvbXBsZXgzMiBkaXZpc29yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleDMyIERpdmlkZShDb21wbGV4MzIgZGl2aWRlbmQsIGZsb2F0IGRpdmlzb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2aWRlbmQgLyBkaXZpc29yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgRGl2aWRlKGZsb2F0IGRpdmlkZW5kLCBDb21wbGV4MzIgZGl2aXNvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXZpZGVuZCAvIGRpdmlzb3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXgzMiBvcGVyYXRvciAtKENvbXBsZXgzMiB2YWx1ZSkgIC8qIFVuYXJ5IG5lZ2F0aW9uIG9mIGEgQ29tcGxleDMyIG51bWJlciAqL1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIoLXZhbHVlLm1fcmVhbCwgLXZhbHVlLm1faW1hZ2luYXJ5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleDMyIG9wZXJhdG9yICsoQ29tcGxleDMyIGxlZnQsIENvbXBsZXgzMiByaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleDMyKGxlZnQubV9yZWFsICsgcmlnaHQubV9yZWFsLCBsZWZ0Lm1faW1hZ2luYXJ5ICsgcmlnaHQubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgb3BlcmF0b3IgKyhDb21wbGV4MzIgbGVmdCwgZmxvYXQgcmlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMihsZWZ0Lm1fcmVhbCArIHJpZ2h0LCBsZWZ0Lm1faW1hZ2luYXJ5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleDMyIG9wZXJhdG9yICsoZmxvYXQgbGVmdCwgQ29tcGxleDMyIHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIobGVmdCArIHJpZ2h0Lm1fcmVhbCwgcmlnaHQubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgb3BlcmF0b3IgLShDb21wbGV4MzIgbGVmdCwgQ29tcGxleDMyIHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIobGVmdC5tX3JlYWwgLSByaWdodC5tX3JlYWwsIGxlZnQubV9pbWFnaW5hcnkgLSByaWdodC5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXgzMiBvcGVyYXRvciAtKENvbXBsZXgzMiBsZWZ0LCBmbG9hdCByaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleDMyKGxlZnQubV9yZWFsIC0gcmlnaHQsIGxlZnQubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgb3BlcmF0b3IgLShmbG9hdCBsZWZ0LCBDb21wbGV4MzIgcmlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMihsZWZ0IC0gcmlnaHQubV9yZWFsLCAtcmlnaHQubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgb3BlcmF0b3IgKihDb21wbGV4MzIgbGVmdCwgQ29tcGxleDMyIHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gTXVsdGlwbGljYXRpb246ICAoYSArIGJpKShjICsgZGkpID0gKGFjIC1iZCkgKyAoYmMgKyBhZClpXHJcbiAgICAgICAgICAgIGZsb2F0IHJlc3VsdF9yZWFscGFydCA9IChsZWZ0Lm1fcmVhbCAqIHJpZ2h0Lm1fcmVhbCkgLSAobGVmdC5tX2ltYWdpbmFyeSAqIHJpZ2h0Lm1faW1hZ2luYXJ5KTtcclxuICAgICAgICAgICAgZmxvYXQgcmVzdWx0X2ltYWdpbmFyeXBhcnQgPSAobGVmdC5tX2ltYWdpbmFyeSAqIHJpZ2h0Lm1fcmVhbCkgKyAobGVmdC5tX3JlYWwgKiByaWdodC5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleDMyKHJlc3VsdF9yZWFscGFydCwgcmVzdWx0X2ltYWdpbmFyeXBhcnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgb3BlcmF0b3IgKihDb21wbGV4MzIgbGVmdCwgZmxvYXQgcmlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIWZsb2F0LklzRmluaXRlKGxlZnQubV9yZWFsKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmbG9hdC5Jc0Zpbml0ZShsZWZ0Lm1faW1hZ2luYXJ5KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMihmbG9hdC5OYU4sIGZsb2F0Lk5hTik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIobGVmdC5tX3JlYWwgKiByaWdodCwgZmxvYXQuTmFOKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFmbG9hdC5Jc0Zpbml0ZShsZWZ0Lm1faW1hZ2luYXJ5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIoZmxvYXQuTmFOLCBsZWZ0Lm1faW1hZ2luYXJ5ICogcmlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMihsZWZ0Lm1fcmVhbCAqIHJpZ2h0LCBsZWZ0Lm1faW1hZ2luYXJ5ICogcmlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgb3BlcmF0b3IgKihmbG9hdCBsZWZ0LCBDb21wbGV4MzIgcmlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIWZsb2F0LklzRmluaXRlKHJpZ2h0Lm1fcmVhbCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghZmxvYXQuSXNGaW5pdGUocmlnaHQubV9pbWFnaW5hcnkpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleDMyKGZsb2F0Lk5hTiwgZmxvYXQuTmFOKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMihsZWZ0ICogcmlnaHQubV9yZWFsLCBmbG9hdC5OYU4pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWZsb2F0LklzRmluaXRlKHJpZ2h0Lm1faW1hZ2luYXJ5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIoZmxvYXQuTmFOLCBsZWZ0ICogcmlnaHQubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMihsZWZ0ICogcmlnaHQubV9yZWFsLCBsZWZ0ICogcmlnaHQubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgb3BlcmF0b3IgLyhDb21wbGV4MzIgbGVmdCwgQ29tcGxleDMyIHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRGl2aXNpb24gOiBTbWl0aCdzIGZvcm11bGEuXHJcbiAgICAgICAgICAgIGZsb2F0IGEgPSBsZWZ0Lm1fcmVhbDtcclxuICAgICAgICAgICAgZmxvYXQgYiA9IGxlZnQubV9pbWFnaW5hcnk7XHJcbiAgICAgICAgICAgIGZsb2F0IGMgPSByaWdodC5tX3JlYWw7XHJcbiAgICAgICAgICAgIGZsb2F0IGQgPSByaWdodC5tX2ltYWdpbmFyeTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGluZyBjICogYyArIGQgKiBkIHdpbGwgb3ZlcmZsb3cgZXZlbiBpbiBjYXNlcyB3aGVyZSB0aGUgYWN0dWFsIHJlc3VsdCBvZiB0aGUgZGl2aXNpb24gZG9lcyBub3Qgb3ZlcmZsb3cuXHJcbiAgICAgICAgICAgIGlmIChNYXRoLkFicyhkKSA8IE1hdGguQWJzKGMpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBkb2MgPSBkIC8gYztcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleDMyKChhICsgYiAqIGRvYykgLyAoYyArIGQgKiBkb2MpLCAoYiAtIGEgKiBkb2MpIC8gKGMgKyBkICogZG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBjb2QgPSBjIC8gZDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleDMyKChiICsgYSAqIGNvZCkgLyAoZCArIGMgKiBjb2QpLCAoLWEgKyBiICogY29kKSAvIChkICsgYyAqIGNvZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXgzMiBvcGVyYXRvciAvKENvbXBsZXgzMiBsZWZ0LCBmbG9hdCByaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIElFRUUgcHJvaGliaXQgb3B0aW1pemF0aW9ucyB3aGljaCBhcmUgdmFsdWUgY2hhbmdpbmdcclxuICAgICAgICAgICAgLy8gc28gd2UgbWFrZSBzdXJlIHRoYXQgYmVoYXZpb3VyIGZvciB0aGUgc2ltcGxpZmllZCB2ZXJzaW9uIGV4YWN0bHkgbWF0Y2hcclxuICAgICAgICAgICAgLy8gZnVsbCB2ZXJzaW9uLlxyXG4gICAgICAgICAgICBpZiAocmlnaHQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIoZmxvYXQuTmFOLCBmbG9hdC5OYU4pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWZsb2F0LklzRmluaXRlKGxlZnQubV9yZWFsKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmbG9hdC5Jc0Zpbml0ZShsZWZ0Lm1faW1hZ2luYXJ5KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMihmbG9hdC5OYU4sIGZsb2F0Lk5hTik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIobGVmdC5tX3JlYWwgLyByaWdodCwgZmxvYXQuTmFOKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFmbG9hdC5Jc0Zpbml0ZShsZWZ0Lm1faW1hZ2luYXJ5KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIoZmxvYXQuTmFOLCBsZWZ0Lm1faW1hZ2luYXJ5IC8gcmlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBIZXJlIHRoZSBhY3R1YWwgb3B0aW1pemVkIHZlcnNpb24gb2YgY29kZS5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIobGVmdC5tX3JlYWwgLyByaWdodCwgbGVmdC5tX2ltYWdpbmFyeSAvIHJpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleDMyIG9wZXJhdG9yIC8oZmxvYXQgbGVmdCwgQ29tcGxleDMyIHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRGl2aXNpb24gOiBTbWl0aCdzIGZvcm11bGEuXHJcbiAgICAgICAgICAgIGZsb2F0IGEgPSBsZWZ0O1xyXG4gICAgICAgICAgICBmbG9hdCBjID0gcmlnaHQubV9yZWFsO1xyXG4gICAgICAgICAgICBmbG9hdCBkID0gcmlnaHQubV9pbWFnaW5hcnk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRpbmcgYyAqIGMgKyBkICogZCB3aWxsIG92ZXJmbG93IGV2ZW4gaW4gY2FzZXMgd2hlcmUgdGhlIGFjdHVhbCByZXN1bHQgb2YgdGhlIGRpdmlzaW9uIGRvZXMgbm90IG92ZXJmbG93LlxyXG4gICAgICAgICAgICBpZiAoTWF0aC5BYnMoZCkgPCBNYXRoLkFicyhjKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZG9jID0gZCAvIGM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMihhIC8gKGMgKyBkICogZG9jKSwgKC1hICogZG9jKSAvIChjICsgZCAqIGRvYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgY29kID0gYyAvIGQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMihhICogY29kIC8gKGQgKyBjICogY29kKSwgLWEgLyAoZCArIGMgKiBjb2QpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBmbG9hdCBBYnMoQ29tcGxleDMyIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEh5cG90KHZhbHVlLm1fcmVhbCwgdmFsdWUubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZmxvYXQgSHlwb3QoZmxvYXQgYSwgZmxvYXQgYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFVzaW5nXHJcbiAgICAgICAgICAgIC8vICAgc3FydChhXjIgKyBiXjIpID0gfGF8ICogc3FydCgxICsgKGIvYSleMilcclxuICAgICAgICAgICAgLy8gd2UgY2FuIGZhY3RvciBvdXQgdGhlIGxhcmdlciBjb21wb25lbnQgdG8gZG9kZ2Ugb3ZlcmZsb3cgZXZlbiB3aGVuIGEgKiBhIHdvdWxkIG92ZXJmbG93LlxyXG5cclxuICAgICAgICAgICAgYSA9IChmbG9hdClNYXRoLkFicyhhKTtcclxuICAgICAgICAgICAgYiA9IChmbG9hdClNYXRoLkFicyhiKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHNtYWxsLCBsYXJnZTtcclxuICAgICAgICAgICAgaWYgKGEgPCBiKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzbWFsbCA9IGE7XHJcbiAgICAgICAgICAgICAgICBsYXJnZSA9IGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzbWFsbCA9IGI7XHJcbiAgICAgICAgICAgICAgICBsYXJnZSA9IGE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzbWFsbCA9PSAwLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAobGFyZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZsb2F0LklzUG9zaXRpdmVJbmZpbml0eShsYXJnZSkgJiYgIWZsb2F0LklzTmFOKHNtYWxsKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIE5hTiB0ZXN0IGlzIG5lY2Vzc2FyeSBzbyB3ZSBkb24ndCByZXR1cm4gK2luZiB3aGVuIHNtYWxsPU5hTiBhbmQgbGFyZ2U9K2luZi5cclxuICAgICAgICAgICAgICAgIC8vIE5hTiBpbiBhbnkgb3RoZXIgcGxhY2UgcmV0dXJucyBOYU4gd2l0aG91dCBhbnkgc3BlY2lhbCBoYW5kbGluZy5cclxuICAgICAgICAgICAgICAgIHJldHVybiAoZmxvYXQuUG9zaXRpdmVJbmZpbml0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCByYXRpbyA9IHNtYWxsIC8gbGFyZ2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGZsb2F0KShsYXJnZSAqIE1hdGguU3FydCgxLjAgKyByYXRpbyAqIHJhdGlvKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZmxvYXQgTG9nMVAoZmxvYXQgeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbG9nKDEgKyB4KSB3aXRob3V0IGxvc3Mgb2YgYWNjdXJhY3kgd2hlbiB4IGlzIHNtYWxsLlxyXG5cclxuICAgICAgICAgICAgLy8gT3VyIG9ubHkgdXNlIGNhc2Ugc28gZmFyIGlzIGZvciBwb3NpdGl2ZSB2YWx1ZXMsIHNvIHRoaXMgaXNuJ3QgY29kZWQgdG8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlcy5cclxuXHJcblxyXG4gICAgICAgICAgICBmbG9hdCB4cDEgPSAxLjBmICsgeDtcclxuICAgICAgICAgICAgaWYgKHhwMSA9PSAxLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHggPCAwLjc1KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFjY3VyYXRlIHRvIHdpdGhpbiA1IHVscCB3aXRoIGFueSBmbG9hdGluZy1wb2ludCBzeXN0ZW0gdGhhdCB1c2VzIGEgZ3VhcmQgZGlnaXQsXHJcbiAgICAgICAgICAgICAgICAvLyBhcyBwcm92ZW4gaW4gVGhlb3JlbSA0IG9mIFwiV2hhdCBFdmVyeSBDb21wdXRlciBTY2llbnRpc3QgU2hvdWxkIEtub3cgQWJvdXQgRmxvYXRpbmctUG9pbnRcclxuICAgICAgICAgICAgICAgIC8vIEFyaXRobWV0aWNcIiAoaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vY2QvRTE5OTU3LTAxLzgwNi0zNTY4L25jZ19nb2xkYmVyZy5odG1sKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHggKiAoZmxvYXQpTWF0aC5Mb2coeHAxKSAvIChmbG9hdCkoeHAxIC0gMS4wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoZmxvYXQpTWF0aC5Mb2coeHAxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleDMyIENvbmp1Z2F0ZShDb21wbGV4MzIgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBDb25qdWdhdGUgb2YgYSBDb21wbGV4MzIgbnVtYmVyOiB0aGUgY29uanVnYXRlIG9mIHgraSp5IGlzIHgtaSp5XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleDMyKHZhbHVlLm1fcmVhbCwgLXZhbHVlLm1faW1hZ2luYXJ5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIElzWmVybyhDb21wbGV4MzIgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBDb25qdWdhdGUgb2YgYSBDb21wbGV4IG51bWJlcjogdGhlIGNvbmp1Z2F0ZSBvZiB4K2kqeSBpcyB4LWkqeVxyXG4gICAgICAgICAgICBpZiAodmFsdWUuUmVhbCA9PSAwLjBmICYmIHZhbHVlLkltYWdpbmFyeSA9PSAwLjBmKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleDMyIFJlY2lwcm9jYWwoQ29tcGxleDMyIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gUmVjaXByb2NhbCBvZiBhIENvbXBsZXgzMiBudW1iZXIgOiB0aGUgcmVjaXByb2NhbCBvZiB4K2kqeSBpcyAxLyh4K2kqeSlcclxuICAgICAgICAgICAgaWYgKHZhbHVlLm1fcmVhbCA9PSAwICYmIHZhbHVlLm1faW1hZ2luYXJ5ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBaZXJvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBPbmUgLyB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBvcGVyYXRvciA9PShDb21wbGV4MzIgbGVmdCwgQ29tcGxleDMyIHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnQubV9yZWFsID09IHJpZ2h0Lm1fcmVhbCAmJiBsZWZ0Lm1faW1hZ2luYXJ5ID09IHJpZ2h0Lm1faW1hZ2luYXJ5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIG9wZXJhdG9yICE9KENvbXBsZXgzMiBsZWZ0LCBDb21wbGV4MzIgcmlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdC5tX3JlYWwgIT0gcmlnaHQubV9yZWFsIHx8IGxlZnQubV9pbWFnaW5hcnkgIT0gcmlnaHQubV9pbWFnaW5hcnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgRXF1YWxzKG9iamVjdD8gb2JqKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCEob2JqIGlzIENvbXBsZXgzMikpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIEVxdWFscygoQ29tcGxleDMyKW9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICovXHJcbiAgICAgICAgcHVibGljIGJvb2wgRXF1YWxzKENvbXBsZXgzMiB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBtX3JlYWwuRXF1YWxzKHZhbHVlLm1fcmVhbCkgJiYgbV9pbWFnaW5hcnkuRXF1YWxzKHZhbHVlLm1faW1hZ2luYXJ5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBpbnQgR2V0SGFzaENvZGUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IG4xID0gOTk5OTk5OTc7XHJcbiAgICAgICAgICAgIGludCByZWFsSGFzaCA9IG1fcmVhbC5HZXRIYXNoQ29kZSgpICUgbjE7XHJcbiAgICAgICAgICAgIGludCBpbWFnaW5hcnlIYXNoID0gbV9pbWFnaW5hcnkuR2V0SGFzaENvZGUoKTtcclxuICAgICAgICAgICAgaW50IGZpbmFsSGFzaCA9IHJlYWxIYXNoIF4gaW1hZ2luYXJ5SGFzaDtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsSGFzaDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBzdHJpbmcgVG9TdHJpbmcoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5Gb3JtYXQoIFwiKHswfSwgezF9KVwiLCBtX3JlYWwsIG1faW1hZ2luYXJ5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICBwdWJsaWMgc3RyaW5nIFRvU3RyaW5nKHN0cmluZyBzdHJpbmdpbiwgSUZvcm1hdFByb3ZpZGVyIHByb3ZpZGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5Gb3JtYXQocHJvdmlkZXIsIFwiKHswfSwgezF9KVwiLCBtX3JlYWwsIG1faW1hZ2luYXJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleDMyIFNpbihDb21wbGV4MzIgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBXZSBuZWVkIGJvdGggc2luaCBhbmQgY29zaCBvZiBpbWFnaW5hcnkgcGFydC4gVG8gYXZvaWQgbXVsdGlwbGUgY2FsbHMgdG8gTWF0aC5FeHAgd2l0aCB0aGUgc2FtZSB2YWx1ZSxcclxuICAgICAgICAgICAgLy8gd2UgY29tcHV0ZSB0aGVtIGJvdGggaGVyZSBmcm9tIGEgc2luZ2xlIGNhbGwgdG8gTWF0aC5FeHAuXHJcbiAgICAgICAgICAgIGZsb2F0IHAgPSAoZmxvYXQpTWF0aC5FeHAodmFsdWUubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgICAgICBmbG9hdCBxID0gMS4wZiAvIHA7XHJcbiAgICAgICAgICAgIGZsb2F0IHNpbmggPSAocCAtIHEpICogMC41ZjtcclxuICAgICAgICAgICAgZmxvYXQgY29zaCA9IChwICsgcSkgKiAwLjVmO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMigoZmxvYXQpTWF0aC5TaW4odmFsdWUubV9yZWFsKSAqIGNvc2gsIChmbG9hdClNYXRoLkNvcyh2YWx1ZS5tX3JlYWwpICogc2luaCk7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEga25vd24gbGltaXRhdGlvbiB3aXRoIHRoaXMgYWxnb3JpdGhtOiBpbnB1dHMgdGhhdCBjYXVzZSBzaW5oIGFuZCBjb3NoIHRvIG92ZXJmbG93LCBidXQgZm9yXHJcbiAgICAgICAgICAgIC8vIHdoaWNoIHNpbiBvciBjb3MgYXJlIHNtYWxsIGVub3VnaCB0aGF0IHNpbiAqIGNvc2ggb3IgY29zICogc2luaCBhcmUgc3RpbGwgcmVwcmVzZW50YWJsZSwgbm9uZXRoZWxlc3NcclxuICAgICAgICAgICAgLy8gcHJvZHVjZSBvdmVyZmxvdy4gRm9yIGV4YW1wbGUsIFNpbigoMC4wMSwgNzExLjApKSBzaG91bGQgcHJvZHVjZSAofjMuMEUzMDYsIFBvc2l0aXZlSW5maW5pdHkpLCBidXRcclxuICAgICAgICAgICAgLy8gaW5zdGVhZCBwcm9kdWNlcyAoUG9zaXRpdmVJbmZpbml0eSwgUG9zaXRpdmVJbmZpbml0eSkuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgU2luaChDb21wbGV4MzIgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBVc2Ugc2luaCh6KSA9IC1pIHNpbihpeikgdG8gY29tcHV0ZSB2aWEgc2luKHopLlxyXG4gICAgICAgICAgICBDb21wbGV4MzIgc2luID0gU2luKG5ldyBDb21wbGV4MzIoLXZhbHVlLm1faW1hZ2luYXJ5LCB2YWx1ZS5tX3JlYWwpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIoc2luLm1faW1hZ2luYXJ5LCAtc2luLm1fcmVhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXgzMiBBc2luKENvbXBsZXgzMiB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IGIsIGJQcmltZSwgdjtcclxuICAgICAgICAgICAgQXNpbl9JbnRlcm5hbCgoZmxvYXQpTWF0aC5BYnModmFsdWUuUmVhbCksIChmbG9hdClNYXRoLkFicyh2YWx1ZS5JbWFnaW5hcnkpLCBvdXQgYiwgb3V0IGJQcmltZSwgb3V0IHYpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgdTtcclxuICAgICAgICAgICAgaWYgKGJQcmltZSA8IDAuMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdSA9IChmbG9hdClNYXRoLkFzaW4oYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB1ID0gKGZsb2F0KU1hdGguQXRhbihiUHJpbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmFsdWUuUmVhbCA8IDAuMCkgdSA9IC11O1xyXG4gICAgICAgICAgICBpZiAodmFsdWUuSW1hZ2luYXJ5IDwgMC4wKSB2ID0gLXY7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMih1LCB2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQ29tcGxleDMyIENvcyhDb21wbGV4MzIgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBwID0gKGZsb2F0KU1hdGguRXhwKHZhbHVlLm1faW1hZ2luYXJ5KTtcclxuICAgICAgICAgICAgZmxvYXQgcSA9IDEuMGYgLyBwO1xyXG4gICAgICAgICAgICBmbG9hdCBzaW5oID0gKHAgLSBxKSAqIDAuNWY7XHJcbiAgICAgICAgICAgIGZsb2F0IGNvc2ggPSAocCArIHEpICogMC41ZjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIoKGZsb2F0KU1hdGguQ29zKHZhbHVlLm1fcmVhbCkgKiBjb3NoLCAoZmxvYXQpLU1hdGguU2luKHZhbHVlLm1fcmVhbCkgKiBzaW5oKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXgzMiBDb3NoKENvbXBsZXgzMiB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFVzZSBjb3NoKHopID0gY29zKGl6KSB0byBjb21wdXRlIHZpYSBjb3MoeikuXHJcbiAgICAgICAgICAgIHJldHVybiBDb3MobmV3IENvbXBsZXgzMigtdmFsdWUubV9pbWFnaW5hcnksIHZhbHVlLm1fcmVhbCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgQWNvcyhDb21wbGV4MzIgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBiLCBiUHJpbWUsIHY7XHJcbiAgICAgICAgICAgIEFzaW5fSW50ZXJuYWwoKGZsb2F0KU1hdGguQWJzKHZhbHVlLlJlYWwpLCAoZmxvYXQpTWF0aC5BYnModmFsdWUuSW1hZ2luYXJ5KSwgb3V0IGIsIG91dCBiUHJpbWUsIG91dCB2KTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHU7XHJcbiAgICAgICAgICAgIGlmIChiUHJpbWUgPCAwLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHUgPSAoZmxvYXQpTWF0aC5BY29zKGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdSA9IChmbG9hdClNYXRoLkF0YW4oMS4wIC8gYlByaW1lKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlLlJlYWwgPCAwLjApIHUgPSAoZmxvYXQpTWF0aC5QSSAtIHU7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5JbWFnaW5hcnkgPiAwLjApIHYgPSAtdjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleDMyKHUsIHYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgVGFuKENvbXBsZXgzMiB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIHRhbiB6ID0gc2luIHogLyBjb3MgeiwgYnV0IHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJlcGVhdGVkIHRyaWcgY29tcHV0YXRpb25zLCB1c2VcclxuICAgICAgICAgICAgLy8gICB0YW4geiA9IChzaW4oMngpICsgaSBzaW5oKDJ5KSkgLyAoY29zKDJ4KSArIGNvc2goMnkpKVxyXG4gICAgICAgICAgICAvLyAoc2VlIEFicmFtb3dpdHogJiBTdGVndW4gNC4zLjU3IG9yIGRlcml2ZSBieSBoYW5kKSwgYW5kIGNvbXB1dGUgdHJpZyBmdW5jdGlvbnMgaGVyZS5cclxuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgYXBwcm9hY2ggZG9lcyBub3Qgd29yayBmb3IgfHl8ID4gfjM1NSwgYmVjYXVzZSBzaW5oKDJ5KSBhbmQgY29zaCgyeSkgb3ZlcmZsb3csXHJcbiAgICAgICAgICAgIC8vIGV2ZW4gdGhvdWdoIHRoZWlyIHJhdGlvIGRvZXMgbm90LiBJbiB0aGF0IGNhc2UsIGRpdmlkZSB0aHJvdWdoIGJ5IGNvc2ggdG8gZ2V0OlxyXG4gICAgICAgICAgICAvLyAgIHRhbiB6ID0gKHNpbigyeCkgLyBjb3NoKDJ5KSArIGkgXFx0YW5oKDJ5KSkgLyAoMSArIGNvcygyeCkgLyBjb3NoKDJ5KSlcclxuICAgICAgICAgICAgLy8gd2hpY2ggY29ycmVjdGx5IGNvbXB1dGVzIHRoZSAodGlueSkgcmVhbCBwYXJ0IGFuZCB0aGUgKG5vcm1hbC1zaXplZCkgaW1hZ2luYXJ5IHBhcnQuXHJcblxyXG4gICAgICAgICAgICBmbG9hdCB4MiA9IDIuMGYgKiB2YWx1ZS5tX3JlYWw7XHJcbiAgICAgICAgICAgIGZsb2F0IHkyID0gMi4wZiogdmFsdWUubV9pbWFnaW5hcnk7XHJcbiAgICAgICAgICAgIGZsb2F0IHAgPSAoZmxvYXQpTWF0aC5FeHAoeTIpO1xyXG4gICAgICAgICAgICBmbG9hdCBxID0gMS4wZiAvIHA7XHJcbiAgICAgICAgICAgIGZsb2F0IGNvc2ggPSAocCArIHEpICogMC41ZjtcclxuICAgICAgICAgICAgaWYgKE1hdGguQWJzKHZhbHVlLm1faW1hZ2luYXJ5KSA8PSA0LjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHNpbmggPSAocCAtIHEpICogMC41ZjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IEQgPSAoZmxvYXQpTWF0aC5Db3MoeDIpICsgY29zaDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleDMyKChmbG9hdClNYXRoLlNpbih4MikgLyBELCBzaW5oIC8gRCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBEID0gMS4wZiArIChmbG9hdClNYXRoLkNvcyh4MikgLyBjb3NoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIoKGZsb2F0KU1hdGguU2luKHgyKSAvIGNvc2ggLyBELCAoZmxvYXQpTWF0aC5UYW5oKHkyKSAvIEQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgVGFuaChDb21wbGV4MzIgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBVc2UgdGFuaCh6KSA9IC1pIHRhbihpeikgdG8gY29tcHV0ZSB2aWEgdGFuKHopLlxyXG4gICAgICAgICAgICBDb21wbGV4MzIgdGFuID0gVGFuKG5ldyBDb21wbGV4MzIoLXZhbHVlLm1faW1hZ2luYXJ5LCB2YWx1ZS5tX3JlYWwpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIodGFuLm1faW1hZ2luYXJ5LCAtdGFuLm1fcmVhbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXgzMiBBdGFuKENvbXBsZXgzMiB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvbXBsZXgzMiB0d28gPSBuZXcgQ29tcGxleDMyKDIuMGYsIDAuMGYpO1xyXG4gICAgICAgICAgICByZXR1cm4gKEltYWdpbmFyeU9uZSAvIHR3bykgKiAoTG9nKE9uZSAtIEltYWdpbmFyeU9uZSAqIHZhbHVlKSAtIExvZyhPbmUgKyBJbWFnaW5hcnlPbmUgKiB2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBBc2luX0ludGVybmFsKGZsb2F0IHgsIGZsb2F0IHksIG91dCBmbG9hdCBiLCBvdXQgZmxvYXQgYlByaW1lLCBvdXQgZmxvYXQgdilcclxuICAgICAgICB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGlzIG1ldGhvZCBmb3IgdGhlIGludmVyc2UgQ29tcGxleDMyIHNpbmUgKGFuZCBjb3NpbmUpIGlzIGRlc2NyaWJlZCBpbiBIdWxsLCBGYWlyZ3JpZXZlLFxyXG4gICAgICAgICAgICAvLyBhbmQgVGFuZywgXCJJbXBsZW1lbnRpbmcgdGhlIENvbXBsZXgzMiBBcmNzaW5lIGFuZCBBcmNjb3NpbmUgRnVuY3Rpb25zIFVzaW5nIEV4Y2VwdGlvbiBIYW5kbGluZ1wiLFxyXG4gICAgICAgICAgICAvLyBBQ00gVHJhbnNhY3Rpb25zIG9uIE1hdGhlbWF0aWNhbCBTb2Z0d2FyZSAoMTk5NylcclxuICAgICAgICAgICAgLy8gKGh0dHBzOi8vd3d3LnJlc2VhcmNoZ2F0ZS5uZXQvcHJvZmlsZS9QaW5nX1RhbmczL3B1YmxpY2F0aW9uLzIyMDQ5MzMzMF9JbXBsZW1lbnRpbmdfdGhlX0NvbXBsZXgzMl9BcmNzaW5lX2FuZF9BcmNjb3NpbmVfRnVuY3Rpb25zX1VzaW5nX0V4Y2VwdGlvbl9IYW5kbGluZy9saW5rcy81NWIyNDRiMjA4YWU5Mjg5YTA4NTI0NWQucGRmKVxyXG5cclxuICAgICAgICAgICAgLy8gRmlyc3QsIHRoZSBiYXNpY3M6IHN0YXJ0IHdpdGggc2luKHcpID0gKGVee2l3fSAtIGVeey1pd30pIC8gKDJpKSA9IHouIEhlcmUgeiBpcyB0aGUgaW5wdXRcclxuICAgICAgICAgICAgLy8gYW5kIHcgaXMgdGhlIG91dHB1dC4gVG8gc29sdmUgZm9yIHcsIGRlZmluZSB0ID0gZV57aSB3fSBhbmQgbXVsdGlwbHkgdGhyb3VnaCBieSB0IHRvXHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgcXVhZHJhdGljIGVxdWF0aW9uIHReMiAtIDIgaSB6IHQgLSAxID0gMC4gVGhlIHNvbHV0aW9uIGlzIHQgPSBpIHogKyBzcXJ0KDEgLSB6XjIpLCBzb1xyXG4gICAgICAgICAgICAvLyAgIHcgPSBhcmNzaW4oeikgPSAtIGkgbG9nKCBpIHogKyBzcXJ0KDEgLSB6XjIpIClcclxuICAgICAgICAgICAgLy8gRGVjb21wb3NlIHogPSB4ICsgaSB5LCBtdWx0aXBseSBvdXQgaSB6ICsgc3FydCgxIC0gel4yKSwgdXNlIGxvZyhzKSA9IHxzfCArIGkgYXJnKHMpLCBhbmQgZG8gYVxyXG4gICAgICAgICAgICAvLyBidW5jaCBvZiBhbGdlYnJhIHRvIGdldCB0aGUgY29tcG9uZW50cyBvZiB3ID0gYXJjc2luKHopID0gdSArIGkgdlxyXG4gICAgICAgICAgICAvLyAgIHUgPSBhcmNzaW4oYmV0YSkgIHYgPSBzaWduKHkpIGxvZyhhbHBoYSArIHNxcnQoYWxwaGFeMiAtIDEpKVxyXG4gICAgICAgICAgICAvLyB3aGVyZVxyXG4gICAgICAgICAgICAvLyAgIGFscGhhID0gKHJobyArIHNpZ21hKSAvIDIgICAgICBiZXRhID0gKHJobyAtIHNpZ21hKSAvIDJcclxuICAgICAgICAgICAgLy8gICByaG8gPSBzcXJ0KCh4ICsgMSleMiArIHleMikgICAgc2lnbWEgPSBzcXJ0KCh4IC0gMSleMiArIHleMilcclxuICAgICAgICAgICAgLy8gVGhlc2UgZm9ybXVsYXMgYXBwZWFyIGluIERMTUYgc2VjdGlvbiA0LjIzLiAoaHR0cDovL2RsbWYubmlzdC5nb3YvNC4yMyksIGFsb25nIHdpdGggdGhlIGFuYWxvZ291c1xyXG4gICAgICAgICAgICAvLyAgIGFyY2Nvcyh3KSA9IGFyY2NvcyhiZXRhKSAtIGkgc2lnbih5KSBsb2coYWxwaGEgKyBzcXJ0KGFscGhhXjIgLSAxKSlcclxuICAgICAgICAgICAgLy8gU28gYWxwaGEgYW5kIGJldGEgdG9nZXRoZXIgZ2l2ZSB1cyBhcmNzaW4odykgYW5kIGFyY2Nvcyh3KS5cclxuXHJcbiAgICAgICAgICAgIC8vIEFzIHdyaXR0ZW4sIGFscGhhIGlzIG5vdCBzdXNjZXB0aWJsZSB0byBjYW5jZWxhdGlvbiBlcnJvcnMsIGJ1dCBiZXRhIGlzLiBUbyBhdm9pZCBjYW5jZWxhdGlvbiwgbm90ZVxyXG4gICAgICAgICAgICAvLyAgIGJldGEgPSAocmhvXjIgLSBzaWdtYV4yKSAvIChyaG8gKyBzaWdtYSkgLyAyID0gKDIgeCkgLyAocmhvICsgc2lnbWEpID0geCAvIGFscGhhXHJcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIG5vdCBzdWJqZWN0IHRvIGNhbmNlbGF0aW9uLiBOb3RlIGFscGhhID49IDEgYW5kIHxiZXRhfCA8PSAxLlxyXG5cclxuICAgICAgICAgICAgLy8gRm9yIGFscGhhIH4gMSwgdGhlIGFyZ3VtZW50IG9mIHRoZSBsb2cgaXMgbmVhciB1bml0eSwgc28gd2UgY29tcHV0ZSAoYWxwaGEgLSAxKSBpbnN0ZWFkLFxyXG4gICAgICAgICAgICAvLyB3cml0ZSB0aGUgYXJndW1lbnQgYXMgMSArIChhbHBoYSAtIDEpICsgc3FydCgoYWxwaGEgLSAxKShhbHBoYSArIDEpKSwgYW5kIHVzZSB0aGUgbG9nMXAgZnVuY3Rpb25cclxuICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSB0aGUgbG9nIHdpdGhvdXQgbG9zcyBvZiBhY2N1cmFjeS5cclxuICAgICAgICAgICAgLy8gRm9yIGJldGEgfiAxLCBhcmNjb3MgZG9lcyBub3QgYWNjdXJhdGVseSByZXNvbHZlIHNtYWxsIGFuZ2xlcywgc28gd2UgY29tcHV0ZSB0aGUgdGFuZ2VudCBvZiB0aGUgYW5nbGVcclxuICAgICAgICAgICAgLy8gaW5zdGVhZC5cclxuICAgICAgICAgICAgLy8gSHVsbCwgRmFpcmdyaWV2ZSwgYW5kIFRhbmcgZGVyaXZlIGZvcm11bGFzIGZvciAoYWxwaGEgLSAxKSBhbmQgYmV0YScgPSB0YW4odSkgdGhhdCBkbyBub3Qgc3VmZmVyXHJcbiAgICAgICAgICAgIC8vIGZyb20gY2FuY2VsYXRpb24gaW4gdGhlc2UgY2FzZXMuXHJcblxyXG4gICAgICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgd2UgYXNzdW1lIGFsbCBwb3NpdGl2ZSBpbnB1dHMgYW5kIHJldHVybiBhbGwgcG9zaXRpdmUgb3V0cHV0cy4gVGhlIGNhbGxlciBzaG91bGRcclxuICAgICAgICAgICAgLy8gYXNzaWduIHNpZ25zIGFwcHJvcHJpYXRlIHRvIHRoZSBkZXNpcmVkIGN1dCBjb252ZW50aW9ucy4gV2UgcmV0dXJuIHYgZGlyZWN0bHkgc2luY2UgaXRzIG1hZ25pdHVkZVxyXG4gICAgICAgICAgICAvLyBpcyB0aGUgc2FtZSBmb3IgYm90aCBhcmNzaW4gYW5kIGFyY2Nvcy4gSW5zdGVhZCBvZiB1LCB3ZSB1c3VhbGx5IHJldHVybiBiZXRhIGFuZCBzb21ldGltZXMgYmV0YScuXHJcbiAgICAgICAgICAgIC8vIElmIGJldGEnIGlzIG5vdCBjb21wdXRlZCwgaXQgaXMgc2V0IHRvIC0xOyBpZiBpdCBpcyBjb21wdXRlZCwgaXQgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBvZiBiZXRhXHJcbiAgICAgICAgICAgIC8vIHRvIGRldGVybWluZSB1LiBDb21wdXRlIHUgPSBhcmNzaW4oYmV0YSkgb3IgdSA9IGFyY3RhbihiZXRhJykgZm9yIGFyY3NpbiwgdSA9IGFyY2NvcyhiZXRhKVxyXG4gICAgICAgICAgICAvLyBvciBhcmN0YW4oMS9iZXRhJykgZm9yIGFyY2Nvcy5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gRm9yIHggb3IgeSBsYXJnZSBlbm91Z2ggdG8gb3ZlcmZsb3cgYWxwaGFeMiwgd2UgY2FuIHNpbXBsaWZ5IG91ciBmb3JtdWxhcyBhbmQgYXZvaWQgb3ZlcmZsb3cuXHJcbiAgICAgICAgICAgIGlmICgoeCA+IHNfYXNpbk92ZXJmbG93VGhyZXNob2xkKSB8fCAoeSA+IHNfYXNpbk92ZXJmbG93VGhyZXNob2xkKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYiA9IC0xLjBmO1xyXG4gICAgICAgICAgICAgICAgYlByaW1lID0geCAvIHk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgc21hbGwsIGJpZztcclxuICAgICAgICAgICAgICAgIGlmICh4IDwgeSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzbWFsbCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgYmlnID0geTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzbWFsbCA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmlnID0geDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZsb2F0IHJhdGlvID0gc21hbGwgLyBiaWc7XHJcbiAgICAgICAgICAgICAgICB2ID0gc19sb2cyICsgKGZsb2F0KU1hdGguTG9nKGJpZykgKyAwLjVmICogTG9nMVAocmF0aW8gKiByYXRpbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCByID0gSHlwb3QoKHggKyAxLjBmKSwgeSk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBzID0gSHlwb3QoKHggLSAxLjBmKSwgeSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgYSA9IChyICsgcykgKiAwLjVmO1xyXG4gICAgICAgICAgICAgICAgYiA9IHggLyBhO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChiID4gMC43NSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA8PSAxLjApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBhbXggPSAoeSAqIHkgLyAociArICh4ICsgMS4wZikpICsgKHMgKyAoMS4wZiAtIHgpKSkgKiAwLjVmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiUHJpbWUgPSB4IC8gKGZsb2F0KU1hdGguU3FydCgoYSArIHgpICogYW14KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBhbXggfiB5XjIuIFNpbmNlIHdlIHRha2UgdGhlIHNxdWFyZSByb290IG9mIGFteCwgd2Ugc2hvdWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1bGwgeSBvdXQgZnJvbSB1bmRlciB0aGUgc3F1YXJlIHJvb3Qgc28gd2UgZG9uJ3QgbG9zZSBpdHMgY29udHJpYnV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4geV4yIHVuZGVyZmxvd3MuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHQgPSAoMS4wZiAvIChyICsgKHggKyAxLjBmKSkgKyAxLjBmIC8gKHMgKyAoeCAtIDEuMGYpKSkgKiAwLjVmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiUHJpbWUgPSB4IC8geSAvIChmbG9hdClNYXRoLlNxcnQoKGEgKyB4KSAqIHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBiUHJpbWUgPSAtMS4wZjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYSA8IDEuNSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA8IDEuMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW5vdGhlciBjYXNlIHdoZXJlIG91ciBleHByZXNzaW9uIGlzIHByb3BvcnRpb25hbCB0byB5XjIgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHRha2UgaXRzIHNxdWFyZSByb290LCBzbyBhZ2FpbiB3ZSBwdWxsIG91dCBhIGZhY3RvciBvZiB5IGZyb21cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5kZXIgdGhlIHNxdWFyZSByb290LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB0ID0gKDEuMGYgLyAociArICh4ICsgMS4wZikpICsgMS4wZiAvIChzICsgKDEuMGYgLSB4KSkpICogMC41ZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgYW0xID0geSAqIHkgKiB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gTG9nMVAoYW0xICsgeSAqIChmbG9hdClNYXRoLlNxcnQodCAqIChhICsgMS4wZikpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgYW0xID0gKHkgKiB5IC8gKHIgKyAoeCArIDEuMGYpKSArIChzICsgKHggLSAxLjBmKSkpICogMC41ZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IExvZzFQKGFtMSArIChmbG9hdClNYXRoLlNxcnQoYW0xICogKGEgKyAxLjApKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2Ugb2YgdGhlIHRlc3QgYWJvdmUsIHdlIGNhbiBiZSBzdXJlIHRoYXQgYSAqIGEgd2lsbCBub3Qgb3ZlcmZsb3cuXHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IChmbG9hdClNYXRoLkxvZyhhICsgTWF0aC5TcXJ0KChhIC0gMS4wKSAqIChhICsgMS4wKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5wdWJsaWMgc3RhdGljIGJvb2wgSXNGaW5pdGUoQ29tcGxleDMyIHZhbHVlKVxyXG57XHJcbiAgICByZXR1cm4gZmxvYXQuSXNGaW5pdGUodmFsdWUubV9yZWFsKSAmJiBmbG9hdC5Jc0Zpbml0ZSh2YWx1ZS5tX2ltYWdpbmFyeSk7XHJcbn1wdWJsaWMgc3RhdGljIGJvb2wgSXNJbmZpbml0eShDb21wbGV4MzIgdmFsdWUpXHJcbntcclxuICAgIHJldHVybiBmbG9hdC5Jc0luZmluaXR5KHZhbHVlLm1fcmVhbCkgfHwgZmxvYXQuSXNJbmZpbml0eSh2YWx1ZS5tX2ltYWdpbmFyeSk7XHJcbn1wdWJsaWMgc3RhdGljIGJvb2wgSXNOYU4oQ29tcGxleDMyIHZhbHVlKVxyXG57XHJcbiAgICByZXR1cm4gIUlzSW5maW5pdHkodmFsdWUpICYmICFJc0Zpbml0ZSh2YWx1ZSk7XHJcbn1cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXgzMiBMb2coQ29tcGxleDMyIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIoKGZsb2F0KU1hdGguTG9nKEFicyh2YWx1ZSkpLCAoZmxvYXQpTWF0aC5BdGFuMih2YWx1ZS5tX2ltYWdpbmFyeSwgdmFsdWUubV9yZWFsKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXgzMiBMb2coQ29tcGxleDMyIHZhbHVlLCBmbG9hdCBiYXNlVmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9nKHZhbHVlKSAvIExvZyhiYXNlVmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgTG9nMTAoQ29tcGxleDMyIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ29tcGxleDMyIHRlbXBMb2cgPSBMb2codmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gU2NhbGUodGVtcExvZywgSW52ZXJzZU9mTG9nMTApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgRXhwKENvbXBsZXgzMiB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IGV4cFJlYWwgPSAoZmxvYXQpTWF0aC5FeHAodmFsdWUubV9yZWFsKTtcclxuICAgICAgICAgICAgZmxvYXQgY29zSW1hZ2luYXJ5ID0gZXhwUmVhbCAqIChmbG9hdClNYXRoLkNvcyh2YWx1ZS5tX2ltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgIGZsb2F0IHNpbkltYWdpbmFyeSA9IGV4cFJlYWwgKiAoZmxvYXQpTWF0aC5TaW4odmFsdWUubV9pbWFnaW5hcnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMihjb3NJbWFnaW5hcnksIHNpbkltYWdpbmFyeSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgU3FydChDb21wbGV4MzIgdmFsdWUpXHJcbiAgICAgICAge1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlLm1faW1hZ2luYXJ5ID09IDAuMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSB0cml2aWFsIGNhc2UgcXVpY2tseS5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5tX3JlYWwgPCAwLjApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIoMC4wZiwgKGZsb2F0KU1hdGguU3FydCgtdmFsdWUubV9yZWFsKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIoKGZsb2F0KU1hdGguU3FydCh2YWx1ZS5tX3JlYWwpLCAwLjBmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBPbmUgd2F5IHRvIGNvbXB1dGUgU3FydCh6KSBpcyBqdXN0IHRvIGNhbGwgUG93KHosIDAuNSksIHdoaWNoIGNvdmVydHMgdG8gcG9sYXIgY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgICAgIC8vIChzcXJ0ICsgYXRhbiksIGhhbHZlcyB0aGUgcGhhc2UsIGFuZCByZWNvbnZlcnRzIHRvIGNhcnRlc2lhbiBjb29yZGluYXRlcyAoY29zICsgc2luKS5cclxuICAgICAgICAgICAgICAgIC8vIE5vdCBvbmx5IGlzIHRoaXMgbW9yZSBleHBlbnNpdmUgdGhhbiBuZWNlc3NhcnksIGl0IGFsc28gZmFpbHMgdG8gcHJlc2VydmUgY2VydGFpbiBleHBlY3RlZFxyXG4gICAgICAgICAgICAgICAgLy8gc3ltbWV0cmllcywgc3VjaCBhcyB0aGF0IHRoZSBzcXVhcmUgcm9vdCBvZiBhIHB1cmUgbmVnYXRpdmUgaXMgYSBwdXJlIGltYWdpbmFyeSwgYW5kIHRoYXQgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBzcXVhcmUgcm9vdCBvZiBhIHB1cmUgaW1hZ2luYXJ5IGhhcyBleGFjdGx5IGVxdWFsIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0cy4gVGhpcyBhbGwgZ29lc1xyXG4gICAgICAgICAgICAgICAgLy8gYmFjayB0byB0aGUgZmFjdCB0aGF0IE1hdGguUEkgaXMgbm90IHN0b3JlZCB3aXRoIGluZmluaXRlIHByZWNpc2lvbiwgc28gdGFraW5nIGhhbGYgb2YgTWF0aC5QSVxyXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgbGFuZCB1cyBvbiBhbiBhcmd1bWVudCB3aXRoIGNvc2luZSBleGFjdGx5IGVxdWFsIHRvIHplcm8uXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVG8gZmluZCBhIGZhc3QgYW5kIHN5bW1ldHJ5LXJlc3BlY3RpbmcgZm9ybXVsYSBmb3IgQ29tcGxleDMyIHNxdWFyZSByb290LFxyXG4gICAgICAgICAgICAgICAgLy8gbm90ZSB4ICsgaSB5ID0gXFxzcXJ0e2EgKyBpIGJ9IGltcGxpZXMgeF4yICsgMiBpIHggeSAtIHleMiA9IGEgKyBpIGIsXHJcbiAgICAgICAgICAgICAgICAvLyBzbyB4XjIgLSB5XjIgPSBhIGFuZCAyIHggeSA9IGIuIENyb3NzLXN1YnN0aXR1dGUgYW5kIHVzZSB0aGUgcXVhZHJhdGljIGZvcm11bGEgdG8gb2J0YWluXHJcbiAgICAgICAgICAgICAgICAvLyAgIHggPSBcXHNxcnR7XFxmcmFje1xcc3FydHthXjIgKyBiXjJ9ICsgYX17Mn19ICB5ID0gXFxwbSBcXHNxcnR7XFxmcmFje1xcc3FydHthXjIgKyBiXjJ9IC0gYX17Mn19XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBqdXN0IG9uZSBjb21wbGljYXRpb246IGRlcGVuZGluZyBvbiB0aGUgc2lnbiBvbiBhLCBlaXRoZXIgeCBvciB5IHN1ZmZlcnMgZnJvbVxyXG4gICAgICAgICAgICAgICAgLy8gY2FuY2VsYXRpb24gd2hlbiB8YnwgPDwgfGF8LiBXZSBjYW4gZ2V0IGFyb3VkIHRoaXMgYnkgbm90aW5nIHRoYXQgb3VyIGZvcm11bGFzIGltcGx5XHJcbiAgICAgICAgICAgICAgICAvLyB4XjIgeV4yID0gYl4yIC8gNCwgc28gfHh8IHx5fCA9IHxifCAvIDIuIFNvIGFmdGVyIGNvbXB1dGluZyB0aGUgb25lIHRoYXQgZG9lc24ndCBzdWZmZXJcclxuICAgICAgICAgICAgICAgIC8vIGZyb20gY2FuY2VsYXRpb24sIHdlIGNhbiBjb21wdXRlIHRoZSBvdGhlciB3aXRoIGp1c3QgYSBkaXZpc2lvbi4gVGhpcyBpcyBiYXNpY2FsbHkganVzdFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJpZ2h0IHdheSB0byBldmFsdWF0ZSB0aGUgcXVhZHJhdGljIGZvcm11bGEgd2l0aG91dCBjYW5jZWxhdGlvbi5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgdGhpcyByZWR1Y2VzIG91ciB0b3RhbCBjb3N0IHRvIHR3byBzcXJ0cyBhbmQgYSBmZXcgZmxvcHMsIGFuZCBpdCByZXNwZWN0cyB0aGUgZGVzaXJlZFxyXG4gICAgICAgICAgICAgICAgLy8gc3ltbWV0cmllcy4gTXVjaCBiZXR0ZXIgdGhhbiBhdGFuICsgY29zICsgc2luIVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBzaWducyBhcmUgYSBtYXR0ZXIgb2YgY2hvaWNlIG9mIGJyYW5jaCBjdXQsIHdoaWNoIGlzIHRyYWRpdGlvbmFsbHkgdGFrZW4gc28geCA+IDAgYW5kIHNpZ24oeSkgPSBzaWduKGIpLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb21wb25lbnRzIGFyZSB0b28gbGFyZ2UsIEh5cG90IHdpbGwgb3ZlcmZsb3csIGV2ZW4gdGhvdWdoIHRoZSBzdWJzZXF1ZW50IHNxcnQgd291bGRcclxuICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlc3VsdCByZXByZXNlbnRhYmxlLiBUbyBhdm9pZCB0aGlzLCB3ZSByZS1zY2FsZSAoYnkgZXhhY3QgcG93ZXJzIG9mIDIgZm9yIGFjY3VyYWN5KVxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB3ZSBlbmNvdW50ZXIgdmVyeSBsYXJnZSBjb21wb25lbnRzIHRvIGF2b2lkIGludGVybWVkaWF0ZSBpbmZpbml0aWVzLlxyXG4gICAgICAgICAgICAgICAgYm9vbCByZXNjYWxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoKE1hdGguQWJzKHZhbHVlLm1fcmVhbCkgPj0gc19zcXJ0UmVzY2FsZVRocmVzaG9sZCkgfHwgKE1hdGguQWJzKHZhbHVlLm1faW1hZ2luYXJ5KSA+PSBzX3NxcnRSZXNjYWxlVGhyZXNob2xkKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmxvYXQuSXNJbmZpbml0eSh2YWx1ZS5tX2ltYWdpbmFyeSkgJiYgIWZsb2F0LklzTmFOKHZhbHVlLm1fcmVhbCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBpbmZpbml0ZSBpbWFnaW5hcnkgcGFydHMgc3BlY2lhbGx5IGJlY2F1c2Ugb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG91ciBmb3JtdWxhcyBiZWxvdyBwcm9kdWNlIGluZi9pbmYgPSBOYU4uIFRoZSBOYU4gdGVzdCBpcyBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSByZXR1cm4gTmFOIHJhdGhlciB0aGFuICgraW5mLGluZikgZm9yIChOYU4saW5mKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgQ29tcGxleDMyKGZsb2F0LlBvc2l0aXZlSW5maW5pdHksIHZhbHVlLm1faW1hZ2luYXJ5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLm1fcmVhbCAqPSAwLjI1ZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUubV9pbWFnaW5hcnkgKj0gMC4yNWY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2NhbGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBjb3JlIG9mIHRoZSBhbGdvcml0aG0uIEV2ZXJ5dGhpbmcgZWxzZSBpcyBzcGVjaWFsIGNhc2UgaGFuZGxpbmcuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCB4LCB5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLm1fcmVhbCA+PSAwLjBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSAoZmxvYXQpTWF0aC5TcXJ0KChIeXBvdCh2YWx1ZS5tX3JlYWwsIHZhbHVlLm1faW1hZ2luYXJ5KSArIHZhbHVlLm1fcmVhbCkgKiAwLjUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSB2YWx1ZS5tX2ltYWdpbmFyeSAvICgyLjBmICogeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IChmbG9hdClNYXRoLlNxcnQoKEh5cG90KHZhbHVlLm1fcmVhbCwgdmFsdWUubV9pbWFnaW5hcnkpIC0gdmFsdWUubV9yZWFsKSAqIDAuNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLm1faW1hZ2luYXJ5IDwgMC4wZikgeSA9IC15O1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSB2YWx1ZS5tX2ltYWdpbmFyeSAvICgyLjBmICogeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc2NhbGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCAqPSAyLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgKj0gMi4wZjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMih4LCB5KTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbXBsZXgzMiBQb3coQ29tcGxleDMyIHZhbHVlLCBDb21wbGV4MzIgcG93ZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocG93ZXIgPT0gWmVybylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9uZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFplcm8pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBaZXJvO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmbG9hdCB2YWx1ZVJlYWwgPSB2YWx1ZS5tX3JlYWw7XHJcbiAgICAgICAgICAgIGZsb2F0IHZhbHVlSW1hZ2luYXJ5ID0gdmFsdWUubV9pbWFnaW5hcnk7XHJcbiAgICAgICAgICAgIGZsb2F0IHBvd2VyUmVhbCA9IHBvd2VyLm1fcmVhbDtcclxuICAgICAgICAgICAgZmxvYXQgcG93ZXJJbWFnaW5hcnkgPSBwb3dlci5tX2ltYWdpbmFyeTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHJobyA9IEFicyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGZsb2F0IHRoZXRhID0gKGZsb2F0KU1hdGguQXRhbjIodmFsdWVJbWFnaW5hcnksIHZhbHVlUmVhbCk7XHJcbiAgICAgICAgICAgIGZsb2F0IG5ld1JobyA9IHBvd2VyUmVhbCAqIHRoZXRhICsgcG93ZXJJbWFnaW5hcnkgKiAoZmxvYXQpTWF0aC5Mb2cocmhvKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHQgPSAoZmxvYXQpTWF0aC5Qb3cocmhvLCBwb3dlclJlYWwpICogKGZsb2F0KU1hdGguUG93KE1hdGguRSwgLXBvd2VySW1hZ2luYXJ5ICogdGhldGEpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIodCAqIChmbG9hdClNYXRoLkNvcyhuZXdSaG8pLCB0ICogKGZsb2F0KU1hdGguU2luKG5ld1JobykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb21wbGV4MzIgUG93KENvbXBsZXgzMiB2YWx1ZSwgZmxvYXQgcG93ZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUG93KHZhbHVlLCBuZXcgQ29tcGxleDMyKHBvd2VyLCAwKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBDb21wbGV4MzIgU2NhbGUoQ29tcGxleDMyIHZhbHVlLCBmbG9hdCBmYWN0b3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCByZWFsUmVzdWx0ID0gZmFjdG9yICogdmFsdWUubV9yZWFsO1xyXG4gICAgICAgICAgICBmbG9hdCBpbWFnaW5hcnlSZXN1aWx0ID0gZmFjdG9yICogdmFsdWUubV9pbWFnaW5hcnk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleDMyKHJlYWxSZXN1bHQsIGltYWdpbmFyeVJlc3VpbHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbXBsaWNpdCBvcGVyYXRvciBDb21wbGV4MzIoc2hvcnQgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMih2YWx1ZSwgMC4wZik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGltcGxpY2l0IG9wZXJhdG9yIENvbXBsZXgzMihpbnQgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMih2YWx1ZSwgMC4wZik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGltcGxpY2l0IG9wZXJhdG9yIENvbXBsZXgzMihsb25nIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIodmFsdWUsIDAuMGYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgW0NMU0NvbXBsaWFudChmYWxzZSldXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbXBsaWNpdCBvcGVyYXRvciBDb21wbGV4MzIodXNob3J0IHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIodmFsdWUsIDAuMGYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgW0NMU0NvbXBsaWFudChmYWxzZSldXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbXBsaWNpdCBvcGVyYXRvciBDb21wbGV4MzIodWludCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleDMyKHZhbHVlLCAwLjBmKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFtDTFNDb21wbGlhbnQoZmFsc2UpXVxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgaW1wbGljaXQgb3BlcmF0b3IgQ29tcGxleDMyKHVsb25nIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIodmFsdWUsIDAuMGYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgW0NMU0NvbXBsaWFudChmYWxzZSldXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbXBsaWNpdCBvcGVyYXRvciBDb21wbGV4MzIoc2J5dGUgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMih2YWx1ZSwgMC4wZik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGltcGxpY2l0IG9wZXJhdG9yIENvbXBsZXgzMihieXRlIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4MzIodmFsdWUsIDAuMGYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbXBsaWNpdCBvcGVyYXRvciBDb21wbGV4MzIoZmxvYXQgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMih2YWx1ZSwgMC4wZik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBcclxuXHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZXhwbGljaXQgb3BlcmF0b3IgQ29tcGxleDMyKGRlY2ltYWwgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgzMigoZmxvYXQpdmFsdWUsIDAuMGYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiTWF0cml4LmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTUgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkRvdWJsZS5GYWN0b3JpemF0aW9uO1xyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRmFjdG9yaXphdGlvbjtcclxudXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLlN0b3JhZ2U7XHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGUuTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhO1xyXG5cclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyA8Yz5kb3VibGU8L2M+IHZlcnNpb24gb2YgdGhlIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4gY2xhc3MuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgW1NlcmlhbGl6YWJsZV1cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBjbGFzcyBNYXRyaXggOiBNYXRyaXg8ZG91YmxlPlxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3JCdWlsZGVyPGRvdWJsZT4gdl9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPGRvdWJsZT4uVmVjdG9yO1xyXG4gICAgICAgIHB1YmxpYyBNYXRyaXhCdWlsZGVyPGRvdWJsZT4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPGRvdWJsZT4uTWF0cml4O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBNYXRyaXggY2xhc3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcm90ZWN0ZWQgTWF0cml4KE1hdHJpeFN0b3JhZ2U8ZG91YmxlPiBzdG9yYWdlKVxyXG4gICAgICAgICAgICA6IGJhc2Uoc3RvcmFnZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCBhbGwgdmFsdWVzIHdob3NlIGFic29sdXRlIHZhbHVlIGlzIHNtYWxsZXIgdGhhbiB0aGUgdGhyZXNob2xkIHRvIHplcm8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBDb2VyY2VaZXJvKGRvdWJsZSB0aHJlc2hvbGQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXBJbnBsYWNlKChGdW5jPGRvdWJsZSxkb3VibGU+KSh4ID0+IE1hdGguQWJzKHgpIDwgdGhyZXNob2xkID8gMGQgOiB4KSwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgY29uanVnYXRlIHRyYW5zcG9zZSBvZiB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgY29uanVnYXRlIHRyYW5zcG9zZSBvZiB0aGlzIG1hdHJpeC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHNlYWxlZCBvdmVycmlkZSBNYXRyaXg8ZG91YmxlPiBDb25qdWdhdGVUcmFuc3Bvc2UoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRyYW5zcG9zZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQdXRzIHRoZSBjb25qdWdhdGUgdHJhbnNwb3NlIG9mIHRoaXMgbWF0cml4IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc2VhbGVkIG92ZXJyaWRlIHZvaWQgQ29uanVnYXRlVHJhbnNwb3NlKE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRyYW5zcG9zZShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wbGV4IGNvbmp1Z2F0ZXMgZWFjaCBlbGVtZW50IG9mIHRoaXMgbWF0cml4IGFuZCBwbGFjZSB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgY29uanVnYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgc2VhbGVkIG92ZXJyaWRlIHZvaWQgRG9Db25qdWdhdGUoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCByZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIENvcHlUbyhyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOZWdhdGUgZWFjaCBlbGVtZW50IG9mIHRoaXMgbWF0cml4IGFuZCBwbGFjZSB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbmVnYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb05lZ2F0ZShNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gLXgpLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZCBhIHNjYWxhciB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIGFkZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb0FkZChkb3VibGUgc2NhbGFyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4geCArIHNjYWxhciksIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgYW5vdGhlciBtYXRyaXggdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gYWRkIHRvIHRoaXMgbWF0cml4LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiB0aGUgb3RoZXIgbWF0cml4IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgdGhlIHR3byBtYXRyaWNlcyBkb24ndCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9BZGQoTWF0cml4PGRvdWJsZT4gb3RoZXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KSgoeCwgeSkgPT4geCArIHkpLCBvdGhlciwgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgYSBzY2FsYXIgZnJvbSBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIHN1YnRyYWN0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvU3VidHJhY3QoZG91YmxlIHNjYWxhciwgTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KSh4ID0+IHggLSBzY2FsYXIpLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgYW5vdGhlciBtYXRyaXggZnJvbSB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB0byBzdWJ0cmFjdCB0byB0aGlzIG1hdHJpeC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiB0aGUgb3RoZXIgbWF0cml4IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgdGhlIHR3byBtYXRyaWNlcyBkb24ndCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9TdWJ0cmFjdChNYXRyaXg8ZG91YmxlPiBvdGhlciwgTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwMigoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKCh4LCB5KSA9PiB4IC0geSksIG90aGVyLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIgYW5kIHBsYWNlcyByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIG11bHRpcGx5IHRoZSBtYXRyaXggd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb011bHRpcGx5KGRvdWJsZSBzY2FsYXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiB4KnNjYWxhciksIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyB0aGlzIG1hdHJpeCB3aXRoIGEgdmVjdG9yIGFuZCBwbGFjZXMgdGhlIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSB2ZWN0b3IgdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9NdWx0aXBseShWZWN0b3I8ZG91YmxlPiByaWdodFNpZGUsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyArPSBBdChpLCBqKSpyaWdodFNpZGVbal07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERpdmlkZXMgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIgYW5kIHBsYWNlcyByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHNjYWxhciB0byBkaXZpZGUgdGhlIG1hdHJpeCB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvRGl2aWRlKGRvdWJsZSBkaXZpc29yLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4geC9kaXZpc29yKSwgcmVzdWx0LCBkaXZpc29yID09IDAuMCA/IFplcm9zLkluY2x1ZGUgOiBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEaXZpZGVzIGEgc2NhbGFyIGJ5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHNjYWxhciB0byBkaXZpZGUgYnkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGRpdmlzaW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9EaXZpZGVCeVRoaXMoZG91YmxlIGRpdmlkZW5kLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gZGl2aWRlbmQveCksIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9NdWx0aXBseShNYXRyaXg8ZG91YmxlPiBvdGhlciwgTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG90aGVyLkNvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBDb2x1bW5Db3VudDsgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBBdChpLCBrKSpvdGhlci5BdChrLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KGksIGosIHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhpcyBtYXRyaXggd2l0aCB0cmFuc3Bvc2Ugb2YgYW5vdGhlciBtYXRyaXggYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvVHJhbnNwb3NlQW5kTXVsdGlwbHkoTWF0cml4PGRvdWJsZT4gb3RoZXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3RoZXIuUm93Q291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgQ29sdW1uQ291bnQ7IGsrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gQXQoaSwgaykqb3RoZXIuQXQoaiwgayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpLCBqLCBzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoaXMgbWF0cml4IHdpdGggdGhlIGNvbmp1Z2F0ZSB0cmFuc3Bvc2Ugb2YgYW5vdGhlciBtYXRyaXggYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBzZWFsZWQgb3ZlcnJpZGUgdm9pZCBEb0Nvbmp1Z2F0ZVRyYW5zcG9zZUFuZE11bHRpcGx5KE1hdHJpeDxkb3VibGU+IG90aGVyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEb1RyYW5zcG9zZUFuZE11bHRpcGx5KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9UcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkoTWF0cml4PGRvdWJsZT4gb3RoZXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3RoZXIuQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDb2x1bW5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgUm93Q291bnQ7IGsrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gQXQoaywgaSkqb3RoZXIuQXQoaywgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpLCBqLCBzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIHNlYWxlZCBvdmVycmlkZSB2b2lkIERvQ29uanVnYXRlVHJhbnNwb3NlVGhpc0FuZE11bHRpcGx5KE1hdHJpeDxkb3VibGU+IG90aGVyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEb1RyYW5zcG9zZVRoaXNBbmRNdWx0aXBseShvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyB0aGUgdHJhbnNwb3NlIG9mIHRoaXMgbWF0cml4IHdpdGggYSB2ZWN0b3IgYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1RyYW5zcG9zZVRoaXNBbmRNdWx0aXBseShWZWN0b3I8ZG91YmxlPiByaWdodFNpZGUsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyArPSBBdChpLCBqKSpyaWdodFNpZGVbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbal0gPSBzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhlIGNvbmp1Z2F0ZSB0cmFuc3Bvc2Ugb2YgdGhpcyBtYXRyaXggd2l0aCBhIHZlY3RvciBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgdmVjdG9yIHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBzZWFsZWQgb3ZlcnJpZGUgdm9pZCBEb0Nvbmp1Z2F0ZVRyYW5zcG9zZVRoaXNBbmRNdWx0aXBseShWZWN0b3I8ZG91YmxlPiByaWdodFNpZGUsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERvVHJhbnNwb3NlVGhpc0FuZE11bHRpcGx5KHJpZ2h0U2lkZSwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGNhbm9uaWNhbCBtb2R1bHVzLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aXNvcixcclxuICAgICAgICAvLy8gZm9yIHRoZSBnaXZlbiBkaXZpc29yIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBzY2FsYXIgZGVub21pbmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+TWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Nb2R1bHVzKGRvdWJsZSBkaXZpc29yLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gRXVjbGlkLk1vZHVsdXMoeCwgZGl2aXNvcikpLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgY2Fub25pY2FsIG1vZHVsdXMsIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpc29yLFxyXG4gICAgICAgIC8vLyBmb3IgdGhlIGdpdmVuIGRpdmlkZW5kIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHNjYWxhciBudW1lcmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+QSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb01vZHVsdXNCeVRoaXMoZG91YmxlIGRpdmlkZW5kLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gRXVjbGlkLk1vZHVsdXMoZGl2aWRlbmQsIHgpKSwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gZm9yIHRoZSBnaXZlbiBkaXZpc29yIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBzY2FsYXIgZGVub21pbmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+TWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9SZW1haW5kZXIoZG91YmxlIGRpdmlzb3IsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiBFdWNsaWQuUmVtYWluZGVyKHgsIGRpdmlzb3IpKSwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gZm9yIHRoZSBnaXZlbiBkaXZpZGVuZCBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpZGVuZFwiPlRoZSBzY2FsYXIgbnVtZXJhdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPkEgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9SZW1haW5kZXJCeVRoaXMoZG91YmxlIGRpdmlkZW5kLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gRXVjbGlkLlJlbWFpbmRlcihkaXZpZGVuZCwgeCkpLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgbXVsdGlwbGllcyB0aGlzIG1hdHJpeCB3aXRoIGFub3RoZXIgbWF0cml4IGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIHBvaW50d2lzZSBtdWx0aXBseSB3aXRoIHRoaXMgb25lLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludHdpc2UgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZU11bHRpcGx5KE1hdHJpeDxkb3VibGU+IG90aGVyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAyKChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPikoKHgsIHkpID0+IHgqeSksIG90aGVyLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBkaXZpZGUgdGhpcyBtYXRyaXggYnkgYW5vdGhlciBtYXRyaXggYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIG1hdHJpeCB0byBwb2ludHdpc2UgZGl2aWRlIHRoaXMgb25lIGJ5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludHdpc2UgZGl2aXNpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZURpdmlkZShNYXRyaXg8ZG91YmxlPiBkaXZpc29yLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAyKChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPikoKHgsIHkpID0+IHgveSksIGRpdmlzb3IsIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSByYWlzZSB0aGlzIG1hdHJpeCB0byBhbiBleHBvbmVudCBhbmQgc3RvcmUgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXhwb25lbnRcIj5UaGUgZXhwb25lbnQgdG8gcmFpc2UgdGhpcyBtYXRyaXggdmFsdWVzIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludHdpc2UgcG93ZXIuPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZVBvd2VyKGRvdWJsZSBleHBvbmVudCwgTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KSh4ID0+IE1hdGguUG93KHgsIGV4cG9uZW50KSksIHJlc3VsdCwgZXhwb25lbnQgPiAwLjAgPyBaZXJvcy5BbGxvd1NraXAgOiBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIHJhaXNlIHRoaXMgbWF0cml4IHRvIGFuIGV4cG9uZW50IGFuZCBzdG9yZSB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJleHBvbmVudFwiPlRoZSBleHBvbmVudCB0byByYWlzZSB0aGlzIG1hdHJpeCB2YWx1ZXMgdG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50d2lzZSBwb3dlci48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlUG93ZXIoTWF0cml4PGRvdWJsZT4gZXhwb25lbnQsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KU1hdGguUG93LCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgY2Fub25pY2FsIG1vZHVsdXMsIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpc29yLFxyXG4gICAgICAgIC8vLyBvZiB0aGlzIG1hdHJpeCB3aXRoIGFub3RoZXIgbWF0cml4IGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBwb2ludHdpc2UgZGVub21pbmF0b3IgbWF0cml4IHRvIHVzZTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbW9kdWx1cy48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlTW9kdWx1cyhNYXRyaXg8ZG91YmxlPiBkaXZpc29yLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAyKChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPilFdWNsaWQuTW9kdWx1cywgZGl2aXNvciwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gb2YgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgcG9pbnR3aXNlIGRlbm9taW5hdG9yIG1hdHJpeCB0byB1c2U8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG1vZHVsdXMuPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZVJlbWFpbmRlcihNYXRyaXg8ZG91YmxlPiBkaXZpc29yLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAyKChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPilFdWNsaWQuUmVtYWluZGVyLCBkaXZpc29yLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgZXhwb25lbnRpYWwgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdC48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlRXhwKE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPilNYXRoLkV4cCwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQuPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUxvZyhNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5Mb2csIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUFicyhNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5BYnMsIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VBY29zKE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPilNYXRoLkFjb3MsIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlQXNpbihNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5Bc2luLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlQXRhbihNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5BdGFuLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlQXRhbjIoTWF0cml4PGRvdWJsZT4gb3RoZXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KU1hdGguQXRhbjIsIG90aGVyLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUNlaWxpbmcoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KU1hdGguQ2VpbGluZywgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUNvcyhNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5Db3MsIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlQ29zaChNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5Db3NoLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUZsb29yKE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPilNYXRoLkZsb29yLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlTG9nMTAoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KU1hdGguTG9nMTAsIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlUm91bmQoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KU1hdGguUm91bmQsIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VTaWduKE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiAoZG91YmxlKU1hdGguU2lnbih4KSksIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VTaW4oTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KU1hdGguU2luLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlU2luaChNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5TaW5oLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlU3FydChNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5TcXJ0LCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlVGFuKE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPilNYXRoLlRhbiwgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZVRhbmgoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KU1hdGguVGFuaCwgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgTW9vcmUtUGVucm9zZSBQc2V1ZG8tSW52ZXJzZSBvZiB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBNYXRyaXg8ZG91YmxlPiBQc2V1ZG9JbnZlcnNlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdmQgPSBTdmQodHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciB3ID0gc3ZkLlc7XHJcbiAgICAgICAgICAgIHZhciBzID0gc3ZkLlM7XHJcbiAgICAgICAgICAgIGRvdWJsZSB0b2xlcmFuY2UgPSBNYXRoLk1heChSb3dDb3VudCwgQ29sdW1uQ291bnQpICogc3ZkLkwyTm9ybSAqIGRvdWJsZS5FcHNpbG9uO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNbaV0gPSBzW2ldIDwgdG9sZXJhbmNlID8gMCA6IDEvc1tpXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdy5TZXREaWFnb25hbChzKTtcclxuICAgICAgICAgICAgcmV0dXJuIChzdmQuVSAqIHcgKiBzdmQuVlQpLlRyYW5zcG9zZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgdHJhY2Ugb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHRyYWNlIG9mIHRoaXMgbWF0cml4PC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZTwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgVHJhY2UoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFJvd0NvdW50ICE9IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRNYXRyaXhTcXVhcmVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzdW0gPSAwLjA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3VtICs9IEF0KGksIGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VNaW5pbXVtKGRvdWJsZSBzY2FsYXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiBNYXRoLk1pbihzY2FsYXIsIHgpKSwgcmVzdWx0LCBzY2FsYXIgPj0gMGQgPyBaZXJvcy5BbGxvd1NraXAgOiBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlTWF4aW11bShkb3VibGUgc2NhbGFyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gTWF0aC5NYXgoc2NhbGFyLCB4KSksIHJlc3VsdCwgc2NhbGFyIDw9IDBkID8gWmVyb3MuQWxsb3dTa2lwIDogWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUFic29sdXRlTWluaW11bShkb3VibGUgc2NhbGFyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkb3VibGUgYWJzb2x1dGUgPSBNYXRoLkFicyhzY2FsYXIpO1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gTWF0aC5NaW4oYWJzb2x1dGUsIE1hdGguQWJzKHgpKSksIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlQWJzb2x1dGVNYXhpbXVtKGRvdWJsZSBzY2FsYXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSBhYnNvbHV0ZSA9IE1hdGguQWJzKHNjYWxhcik7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiBNYXRoLk1heChhYnNvbHV0ZSwgTWF0aC5BYnMoeCkpKSwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlTWluaW11bShNYXRyaXg8ZG91YmxlPiBvdGhlciwgTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwMigoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pTWF0aC5NaW4sIG90aGVyLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZU1heGltdW0oTWF0cml4PGRvdWJsZT4gb3RoZXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KU1hdGguTWF4LCBvdGhlciwgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VBYnNvbHV0ZU1pbmltdW0oTWF0cml4PGRvdWJsZT4gb3RoZXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KSgoeCwgeSkgPT4gTWF0aC5NaW4oTWF0aC5BYnMoeCksIE1hdGguQWJzKHkpKSksIG90aGVyLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUFic29sdXRlTWF4aW11bShNYXRyaXg8ZG91YmxlPiBvdGhlciwgTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwMigoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKCh4LCB5KSA9PiBNYXRoLk1heChNYXRoLkFicyh4KSwgTWF0aC5BYnMoeSkpKSwgb3RoZXIsIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5DYWxjdWxhdGVzIHRoZSBpbmR1Y2VkIEwxIG5vcm0gb2YgdGhpcyBtYXRyaXguPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbWF4aW11bSBhYnNvbHV0ZSBjb2x1bW4gc3VtIG9mIHRoZSBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgTDFOb3JtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBub3JtID0gMGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSAwZDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzICs9IE1hdGguQWJzKEF0KGksIGopKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5vcm0gPSBNYXRoLk1heChub3JtLCBzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5DYWxjdWxhdGVzIHRoZSBpbmR1Y2VkIGluZmluaXR5IG5vcm0gb2YgdGhpcyBtYXRyaXguPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbWF4aW11bSBhYnNvbHV0ZSByb3cgc3VtIG9mIHRoZSBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgSW5maW5pdHlOb3JtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBub3JtID0gMGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSAwZDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzICs9IE1hdGguQWJzKEF0KGksIGopKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5vcm0gPSBNYXRoLk1heChub3JtLCBzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5DYWxjdWxhdGVzIHRoZSBlbnRyeS13aXNlIEZyb2Jlbml1cyBub3JtIG9mIHRoaXMgbWF0cml4Ljwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHNxdWFyZSByb290IG9mIHRoZSBzdW0gb2YgdGhlIHNxdWFyZWQgdmFsdWVzLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZG91YmxlIEZyb2Jlbml1c05vcm0oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHRyYW5zcG9zZSA9IFRyYW5zcG9zZSgpO1xyXG4gICAgICAgICAgICB2YXIgYWF0ID0gdGhpcyp0cmFuc3Bvc2U7XHJcbiAgICAgICAgICAgIHZhciBub3JtID0gMGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbm9ybSArPSBhYXQuQXQoaSwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguU3FydChub3JtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsY3VsYXRlcyB0aGUgcC1ub3JtcyBvZiBhbGwgcm93IHZlY3RvcnMuXHJcbiAgICAgICAgLy8vIFR5cGljYWwgdmFsdWVzIGZvciBwIGFyZSAxLjAgKEwxLCBNYW5oYXR0YW4gbm9ybSksIDIuMCAoTDIsIEV1Y2xpZGVhbiBub3JtKSBhbmQgcG9zaXRpdmUgaW5maW5pdHkgKGluZmluaXR5IG5vcm0pXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yPGRvdWJsZT4gUm93Tm9ybXMoZG91YmxlIG5vcm0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobm9ybSA8PSAwLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJub3JtXCIsIFwiUmVzb3VyY2VzLkFyZ3VtZW50TXVzdEJlUG9zaXRpdmVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXQgPSBuZXcgZG91YmxlW1Jvd0NvdW50XTtcclxuICAgICAgICAgICAgaWYgKG5vcm0gPT0gMi4wKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBTdG9yYWdlLkZvbGRCeVJvd1VuY2hlY2tlZDxkb3VibGU+KHJldCwgKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KSgocywgeCkgPT4gcyArIHgqeCksIChGdW5jPGRvdWJsZSxpbnQsZG91YmxlPikoKHgsIGMpID0+IE1hdGguU3FydCh4KSksIHJldCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub3JtID09IDEuMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU3RvcmFnZS5Gb2xkQnlSb3dVbmNoZWNrZWQ8ZG91YmxlPihyZXQsIChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPikoKHMsIHgpID0+IHMgKyBNYXRoLkFicyh4KSksIChGdW5jPGRvdWJsZSxpbnQsZG91YmxlPikoKHgsIGMpID0+IHgpLCByZXQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZG91YmxlLklzUG9zaXRpdmVJbmZpbml0eShub3JtKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU3RvcmFnZS5Gb2xkQnlSb3dVbmNoZWNrZWQ8ZG91YmxlPihyZXQsIChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPikoKHMsIHgpID0+IE1hdGguTWF4KHMsIE1hdGguQWJzKHgpKSksIChGdW5jPGRvdWJsZSxpbnQsZG91YmxlPikoKHgsIGMpID0+IHgpLCByZXQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkb3VibGUgaW52bm9ybSA9IDEuMC9ub3JtO1xyXG4gICAgICAgICAgICAgICAgU3RvcmFnZS5Gb2xkQnlSb3dVbmNoZWNrZWQ8ZG91YmxlPihyZXQsIChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPikoKHMsIHgpID0+IHMgKyBNYXRoLlBvdyhNYXRoLkFicyh4KSwgbm9ybSkpLCAoRnVuYzxkb3VibGUsaW50LGRvdWJsZT4pKCh4LCBjKSA9PiBNYXRoLlBvdyh4LCBpbnZub3JtKSksIHJldCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdl9idWlsZGVyLkRlbnNlKHJldCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIHAtbm9ybXMgb2YgYWxsIGNvbHVtbiB2ZWN0b3JzLlxyXG4gICAgICAgIC8vLyBUeXBpY2FsIHZhbHVlcyBmb3IgcCBhcmUgMS4wIChMMSwgTWFuaGF0dGFuIG5vcm0pLCAyLjAgKEwyLCBFdWNsaWRlYW4gbm9ybSkgYW5kIHBvc2l0aXZlIGluZmluaXR5IChpbmZpbml0eSBub3JtKVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3Rvcjxkb3VibGU+IENvbHVtbk5vcm1zKGRvdWJsZSBub3JtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKG5vcm0gPD0gMC4wKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwibm9ybVwiLCBcIlJlc291cmNlcy5Bcmd1bWVudE11c3RCZVBvc2l0aXZlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IGRvdWJsZVtDb2x1bW5Db3VudF07XHJcbiAgICAgICAgICAgIGlmIChub3JtID09IDIuMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU3RvcmFnZS5Gb2xkQnlDb2x1bW5VbmNoZWNrZWQ8ZG91YmxlPihyZXQsIChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPikoKHMsIHgpID0+IHMgKyB4KngpLCAoRnVuYzxkb3VibGUsaW50LGRvdWJsZT4pKCh4LCBjKSA9PiBNYXRoLlNxcnQoeCkpLCByZXQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9ybSA9PSAxLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFN0b3JhZ2UuRm9sZEJ5Q29sdW1uVW5jaGVja2VkPGRvdWJsZT4ocmV0LCAoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKChzLCB4KSA9PiBzICsgTWF0aC5BYnMoeCkpLCAoRnVuYzxkb3VibGUsaW50LGRvdWJsZT4pKCh4LCBjKSA9PiB4KSwgcmV0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRvdWJsZS5Jc1Bvc2l0aXZlSW5maW5pdHkobm9ybSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFN0b3JhZ2UuRm9sZEJ5Q29sdW1uVW5jaGVja2VkPGRvdWJsZT4ocmV0LCAoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKChzLCB4KSA9PiBNYXRoLk1heChzLCBNYXRoLkFicyh4KSkpLCAoRnVuYzxkb3VibGUsaW50LGRvdWJsZT4pKCh4LCBjKSA9PiB4KSwgcmV0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIGludm5vcm0gPSAxLjAvbm9ybTtcclxuICAgICAgICAgICAgICAgIFN0b3JhZ2UuRm9sZEJ5Q29sdW1uVW5jaGVja2VkPGRvdWJsZT4ocmV0LCAoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKChzLCB4KSA9PiBzICsgTWF0aC5Qb3coTWF0aC5BYnMoeCksIG5vcm0pKSwgKEZ1bmM8ZG91YmxlLGludCxkb3VibGU+KSgoeCwgYykgPT4gTWF0aC5Qb3coeCwgaW52bm9ybSkpLCByZXQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZfYnVpbGRlci5EZW5zZShyZXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOb3JtYWxpemVzIGFsbCByb3cgdmVjdG9ycyB0byBhIHVuaXQgcC1ub3JtLlxyXG4gICAgICAgIC8vLyBUeXBpY2FsIHZhbHVlcyBmb3IgcCBhcmUgMS4wIChMMSwgTWFuaGF0dGFuIG5vcm0pLCAyLjAgKEwyLCBFdWNsaWRlYW4gbm9ybSkgYW5kIHBvc2l0aXZlIGluZmluaXR5IChpbmZpbml0eSBub3JtKVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHNlYWxlZCBvdmVycmlkZSBNYXRyaXg8ZG91YmxlPiBOb3JtYWxpemVSb3dzKGRvdWJsZSBub3JtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG5vcm1pbnYgPSAoKERlbnNlVmVjdG9yU3RvcmFnZTxkb3VibGU+KVJvd05vcm1zKG5vcm0pLlN0b3JhZ2UpLkRhdGE7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbm9ybWludi5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbm9ybWludltpXSA9IG5vcm1pbnZbaV0gPT0gMGQgPyAxZCA6IDFkL25vcm1pbnZbaV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtX2J1aWxkZXIuU2FtZUFzPGRvdWJsZT4odGhpcywgUm93Q291bnQsIENvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgU3RvcmFnZS5NYXBJbmRleGVkVG88ZG91YmxlPihyZXN1bHQuU3RvcmFnZSwgKEZ1bmM8aW50LGludCxkb3VibGUsZG91YmxlPikoKGksIGosIHgpID0+IG5vcm1pbnZbaV0qeCksIFplcm9zLkFsbG93U2tpcCwgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTm9ybWFsaXplcyBhbGwgY29sdW1uIHZlY3RvcnMgdG8gYSB1bml0IHAtbm9ybS5cclxuICAgICAgICAvLy8gVHlwaWNhbCB2YWx1ZXMgZm9yIHAgYXJlIDEuMCAoTDEsIE1hbmhhdHRhbiBub3JtKSwgMi4wIChMMiwgRXVjbGlkZWFuIG5vcm0pIGFuZCBwb3NpdGl2ZSBpbmZpbml0eSAoaW5maW5pdHkgbm9ybSlcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzZWFsZWQgb3ZlcnJpZGUgTWF0cml4PGRvdWJsZT4gTm9ybWFsaXplQ29sdW1ucyhkb3VibGUgbm9ybSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBub3JtaW52ID0gKChEZW5zZVZlY3RvclN0b3JhZ2U8ZG91YmxlPilDb2x1bW5Ob3Jtcyhub3JtKS5TdG9yYWdlKS5EYXRhO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG5vcm1pbnYuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5vcm1pbnZbaV0gPSBub3JtaW52W2ldID09IDBkID8gMWQgOiAxZC9ub3JtaW52W2ldO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxkb3VibGU+KHRoaXMsIFJvd0NvdW50LCBDb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuTWFwSW5kZXhlZFRvPGRvdWJsZT4ocmVzdWx0LlN0b3JhZ2UsIChGdW5jPGludCxpbnQsZG91YmxlLGRvdWJsZT4pKChpLCBqLCB4KSA9PiBub3JtaW52W2pdKngpLCBaZXJvcy5BbGxvd1NraXAsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIHZhbHVlIHN1bSBvZiBlYWNoIHJvdyB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yPGRvdWJsZT4gUm93U3VtcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IGRvdWJsZVtSb3dDb3VudF07XHJcbiAgICAgICAgICAgIFN0b3JhZ2UuRm9sZEJ5Um93VW5jaGVja2VkPGRvdWJsZT4ocmV0LCAoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKChzLCB4KSA9PiBzICsgeCksIChGdW5jPGRvdWJsZSxpbnQsZG91YmxlPikoKHgsIGMpID0+IHgpLCByZXQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2X2J1aWxkZXIuRGVuc2UocmV0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsY3VsYXRlcyB0aGUgYWJzb2x1dGUgdmFsdWUgc3VtIG9mIGVhY2ggcm93IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3I8ZG91YmxlPiBSb3dBYnNvbHV0ZVN1bXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBkb3VibGVbUm93Q291bnRdO1xyXG4gICAgICAgICAgICBTdG9yYWdlLkZvbGRCeVJvd1VuY2hlY2tlZDxkb3VibGU+KHJldCwgKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KSgocywgeCkgPT4gcyArIE1hdGguQWJzKHgpKSwgKEZ1bmM8ZG91YmxlLGludCxkb3VibGU+KSgoeCwgYykgPT4geCksIHJldCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZfYnVpbGRlci5EZW5zZShyZXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYWxjdWxhdGVzIHRoZSB2YWx1ZSBzdW0gb2YgZWFjaCBjb2x1bW4gdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3Rvcjxkb3VibGU+IENvbHVtblN1bXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBkb3VibGVbQ29sdW1uQ291bnRdO1xyXG4gICAgICAgICAgICBTdG9yYWdlLkZvbGRCeUNvbHVtblVuY2hlY2tlZDxkb3VibGU+KHJldCwgKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KSgocywgeCkgPT4gcyArIHgpLCAoRnVuYzxkb3VibGUsaW50LGRvdWJsZT4pKCh4LCBjKSA9PiB4KSwgcmV0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgICAgICByZXR1cm4gdl9idWlsZGVyLkRlbnNlKHJldCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIGFic29sdXRlIHZhbHVlIHN1bSBvZiBlYWNoIGNvbHVtbiB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yPGRvdWJsZT4gQ29sdW1uQWJzb2x1dGVTdW1zKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSBuZXcgZG91YmxlW0NvbHVtbkNvdW50XTtcclxuICAgICAgICAgICAgU3RvcmFnZS5Gb2xkQnlDb2x1bW5VbmNoZWNrZWQ8ZG91YmxlPihyZXQsIChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPikoKHMsIHgpID0+IHMgKyBNYXRoLkFicyh4KSksIChGdW5jPGRvdWJsZSxpbnQsZG91YmxlPikoKHgsIGMpID0+IHgpLCByZXQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2X2J1aWxkZXIuRGVuc2UocmV0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRXZhbHVhdGVzIHdoZXRoZXIgdGhpcyBtYXRyaXggaXMgSGVybWl0aWFuIChjb25qdWdhdGUgc3ltbWV0cmljKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzZWFsZWQgb3ZlcnJpZGUgYm9vbCBJc0hlcm1pdGlhbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gSXNTeW1tZXRyaWMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgU3ZkPGRvdWJsZT4gU3ZkKGJvb2wgY29tcHV0ZVZlY3RvcnMgPSB0cnVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFVzZXJTdmQuQ3JlYXRlKHRoaXMsIGNvbXB1dGVWZWN0b3JzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFxyXG4gICAgfVxyXG59XHJcbiIsIi8vIDxjb3B5cmlnaHQgZmlsZT1cIlZlY3Rvci5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDE1IE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5TdG9yYWdlO1xyXG5cclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyA8Yz5kb3VibGU8L2M+IHZlcnNpb24gb2YgdGhlIDxzZWUgY3JlZj1cIlZlY3RvcntUfVwiLz4gY2xhc3MuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgW1NlcmlhbGl6YWJsZV1cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBjbGFzcyBWZWN0b3IgOiBWZWN0b3I8ZG91YmxlPlxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFZlY3RvciBjbGFzcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByb3RlY3RlZCBWZWN0b3IoVmVjdG9yU3RvcmFnZTxkb3VibGU+IHN0b3JhZ2UpXHJcbiAgICAgICAgICAgIDogYmFzZShzdG9yYWdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IGFsbCB2YWx1ZXMgd2hvc2UgYWJzb2x1dGUgdmFsdWUgaXMgc21hbGxlciB0aGFuIHRoZSB0aHJlc2hvbGQgdG8gemVyby5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIENvZXJjZVplcm8oZG91YmxlIHRocmVzaG9sZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcElucGxhY2UoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gTWF0aC5BYnMoeCkgPCB0aHJlc2hvbGQgPyAwZCA6IHgpLCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb25qdWdhdGVzIHZlY3RvciBhbmQgc2F2ZSByZXN1bHQgdG8gPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UYXJnZXQgdmVjdG9yPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgc2VhbGVkIG92ZXJyaWRlIHZvaWQgRG9Db25qdWdhdGUoVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCByZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIENvcHlUbyhyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOZWdhdGVzIHZlY3RvciBhbmQgc2F2ZXMgcmVzdWx0IHRvIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGFyZ2V0IHZlY3RvcjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9OZWdhdGUoVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KSh4ID0+IC14KSwgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGRzIGEgc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlxyXG4gICAgICAgIC8vLyBUaGUgc2NhbGFyIHRvIGFkZC5cclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5cclxuICAgICAgICAvLy8gVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi5cclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb0FkZChkb3VibGUgc2NhbGFyLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4geCArIHNjYWxhciksIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgYW5vdGhlciB2ZWN0b3IgdG8gdGhpcyB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlxyXG4gICAgICAgIC8vLyBUaGUgdmVjdG9yIHRvIGFkZCB0byB0aGlzIG9uZS5cclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5cclxuICAgICAgICAvLy8gVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi5cclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb0FkZChWZWN0b3I8ZG91YmxlPiBvdGhlciwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwMigoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKCh4LCB5KSA9PiB4ICsgeSksIG90aGVyLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN1YnRyYWN0cyBhIHNjYWxhciBmcm9tIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlxyXG4gICAgICAgIC8vLyBUaGUgc2NhbGFyIHRvIHN1YnRyYWN0LlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlxyXG4gICAgICAgIC8vLyBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvU3VidHJhY3QoZG91YmxlIHNjYWxhciwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KSh4ID0+IHggLSBzY2FsYXIpLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgYW5vdGhlciB2ZWN0b3IgdG8gdGhpcyB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlxyXG4gICAgICAgIC8vLyBUaGUgdmVjdG9yIHRvIHN1YnRyYWN0IGZyb20gdGhpcyBvbmUuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+XHJcbiAgICAgICAgLy8vIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24uXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9TdWJ0cmFjdChWZWN0b3I8ZG91YmxlPiBvdGhlciwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwMigoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKCh4LCB5KSA9PiB4IC0geSksIG90aGVyLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgYSBzY2FsYXIgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+XHJcbiAgICAgICAgLy8vIFRoZSBzY2FsYXIgdG8gbXVsdGlwbHkuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+XHJcbiAgICAgICAgLy8vIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9NdWx0aXBseShkb3VibGUgc2NhbGFyLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4geCpzY2FsYXIpLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERpdmlkZXMgZWFjaCBlbGVtZW50IG9mIHRoZSB2ZWN0b3IgYnkgYSBzY2FsYXIgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlxyXG4gICAgICAgIC8vLyBUaGUgc2NhbGFyIHRvIGRpdmlkZSB3aXRoLlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlxyXG4gICAgICAgIC8vLyBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGRpdmlzaW9uLlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvRGl2aWRlKGRvdWJsZSBkaXZpc29yLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4geC9kaXZpc29yKSwgcmVzdWx0LCBkaXZpc29yID09IDAuMCA/IFplcm9zLkluY2x1ZGUgOiBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEaXZpZGVzIGEgc2NhbGFyIGJ5IGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHNjYWxhciB0byBkaXZpZGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGRpdmlzaW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9EaXZpZGVCeVRoaXMoZG91YmxlIGRpdmlkZW5kLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gZGl2aWRlbmQveCksIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBtdWx0aXBsaWVzIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSB2ZWN0b3IgdG8gcG9pbnR3aXNlIG11bHRpcGx5IHdpdGggdGhpcyBvbmUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50d2lzZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlTXVsdGlwbHkoVmVjdG9yPGRvdWJsZT4gb3RoZXIsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KSgoeCwgeSkgPT4geCp5KSwgb3RoZXIsIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGRpdmlkZSB0aGlzIHZlY3RvciB3aXRoIGFub3RoZXIgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSB2ZWN0b3IgdG8gcG9pbnR3aXNlIGRpdmlkZSB0aGlzIG9uZSBieS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgcG9pbnR3aXNlIGRpdmlzaW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VEaXZpZGUoVmVjdG9yPGRvdWJsZT4gZGl2aXNvciwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwMigoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKCh4LCB5KSA9PiB4L3kpLCBkaXZpc29yLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgcmFpc2UgdGhpcyB2ZWN0b3IgdG8gYW4gZXhwb25lbnQgYW5kIHN0b3JlIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImV4cG9uZW50XCI+VGhlIGV4cG9uZW50IHRvIHJhaXNlIHRoaXMgdmVjdG9yIHZhbHVlcyB0by48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgcG9pbnR3aXNlIHBvd2VyLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VQb3dlcihkb3VibGUgZXhwb25lbnQsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiBNYXRoLlBvdyh4LCBleHBvbmVudCkpLCByZXN1bHQsIGV4cG9uZW50ID4gMC4wID8gWmVyb3MuQWxsb3dTa2lwIDogWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSByYWlzZSB0aGlzIHZlY3RvciB0byBhbiBleHBvbmVudCB2ZWN0b3IgYW5kIHN0b3JlIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImV4cG9uZW50XCI+VGhlIGV4cG9uZW50IHZlY3RvciB0byByYWlzZSB0aGlzIHZlY3RvciB2YWx1ZXMgdG8uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50d2lzZSBwb3dlci48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlUG93ZXIoVmVjdG9yPGRvdWJsZT4gZXhwb25lbnQsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KU1hdGguUG93LCBleHBvbmVudCwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGNhbm9uaWNhbCBtb2R1bHVzLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aXNvcixcclxuICAgICAgICAvLy8gb2YgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgcG9pbnR3aXNlIGRlbm9taW5hdG9yIHZlY3RvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtb2R1bHVzLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VNb2R1bHVzKFZlY3Rvcjxkb3VibGU+IGRpdmlzb3IsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KUV1Y2xpZC5Nb2R1bHVzLCBkaXZpc29yLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgcmVtYWluZGVyICglIG9wZXJhdG9yKSwgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlkZW5kLFxyXG4gICAgICAgIC8vLyBvZiB0aGlzIHZlY3RvciB3aXRoIGFub3RoZXIgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBwb2ludHdpc2UgZGVub21pbmF0b3IgdmVjdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG1vZHVsdXMuPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZVJlbWFpbmRlcihWZWN0b3I8ZG91YmxlPiBkaXZpc29yLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAyKChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPilFdWNsaWQuUmVtYWluZGVyLCBkaXZpc29yLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgYXBwbGllcyB0aGUgZXhwb25lbnRpYWwgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdC48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlRXhwKFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPilNYXRoLkV4cCwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnR3aXNlIGFwcGxpZXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQuPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUxvZyhWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5Mb2csIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUFicyhWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5BYnMsIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VBY29zKFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPilNYXRoLkFjb3MsIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlQXNpbihWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5Bc2luLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlQXRhbihWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5BdGFuLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlQXRhbjIoVmVjdG9yPGRvdWJsZT4gb3RoZXIsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KU1hdGguQXRhbjIsIG90aGVyLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUF0YW4yKGRvdWJsZSBzY2FsYXIsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiBNYXRoLkF0YW4yKHgsIHNjYWxhcikpLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUNlaWxpbmcoVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KU1hdGguQ2VpbGluZywgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUNvcyhWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5Db3MsIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlQ29zaChWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5Db3NoLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUZsb29yKFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPilNYXRoLkZsb29yLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlTG9nMTAoVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KU1hdGguTG9nMTAsIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlUm91bmQoVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KU1hdGguUm91bmQsIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VTaWduKFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiAoZG91YmxlKU1hdGguU2lnbih4KSksIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VTaW4oVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KU1hdGguU2luLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlU2luaChWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5TaW5oLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlU3FydChWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pTWF0aC5TcXJ0LCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlVGFuKFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPilNYXRoLlRhbiwgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZVRhbmgoVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KU1hdGguVGFuaCwgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBvdGhlciB2ZWN0b3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHN1bSBvZiBhW2ldKmJbaV0gZm9yIGFsbCBpLjwvcmV0dXJucz5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZG91YmxlIERvRG90UHJvZHVjdChWZWN0b3I8ZG91YmxlPiBvdGhlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkb3QgPSAwLjA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZG90ICs9IEF0KGkpICogb3RoZXIuQXQoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRvdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdGhlIGNvbmp1Z2F0ZSBvZiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBvdGhlciB2ZWN0b3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHN1bSBvZiBjb25qKGFbaV0pKmJbaV0gZm9yIGFsbCBpLjwvcmV0dXJucz5cclxuICAgICAgICBwcm90ZWN0ZWQgc2VhbGVkIG92ZXJyaWRlIGRvdWJsZSBEb0Nvbmp1Z2F0ZURvdFByb2R1Y3QoVmVjdG9yPGRvdWJsZT4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRG9Eb3RQcm9kdWN0KG90aGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGNhbm9uaWNhbCBtb2R1bHVzLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aXNvcixcclxuICAgICAgICAvLy8gZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGZvciB0aGUgZ2l2ZW4gZGl2aXNvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgc2NhbGFyIGRlbm9taW5hdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPkEgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Nb2R1bHVzKGRvdWJsZSBkaXZpc29yLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gRXVjbGlkLk1vZHVsdXMoeCwgZGl2aXNvcikpLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgY2Fub25pY2FsIG1vZHVsdXMsIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpc29yLFxyXG4gICAgICAgIC8vLyBmb3IgdGhlIGdpdmVuIGRpdmlkZW5kIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHNjYWxhciBudW1lcmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+QSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb01vZHVsdXNCeVRoaXMoZG91YmxlIGRpdmlkZW5kLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gRXVjbGlkLk1vZHVsdXMoZGl2aWRlbmQsIHgpKSwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGZvciB0aGUgZ2l2ZW4gZGl2aXNvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgc2NhbGFyIGRlbm9taW5hdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPkEgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9SZW1haW5kZXIoZG91YmxlIGRpdmlzb3IsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiBFdWNsaWQuUmVtYWluZGVyKHgsIGRpdmlzb3IpKSwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gZm9yIHRoZSBnaXZlbiBkaXZpZGVuZCBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpZGVuZFwiPlRoZSBzY2FsYXIgbnVtZXJhdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPkEgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9SZW1haW5kZXJCeVRoaXMoZG91YmxlIGRpdmlkZW5kLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gRXVjbGlkLlJlbWFpbmRlcihkaXZpZGVuZCwgeCkpLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VNaW5pbXVtKGRvdWJsZSBzY2FsYXIsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiBNYXRoLk1pbihzY2FsYXIsIHgpKSwgcmVzdWx0LCBzY2FsYXIgPj0gMGQgPyBaZXJvcy5BbGxvd1NraXAgOiBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlTWF4aW11bShkb3VibGUgc2NhbGFyLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gTWF0aC5NYXgoc2NhbGFyLCB4KSksIHJlc3VsdCwgc2NhbGFyIDw9IDBkID8gWmVyb3MuQWxsb3dTa2lwIDogWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUFic29sdXRlTWluaW11bShkb3VibGUgc2NhbGFyLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkb3VibGUgYWJzb2x1dGUgPSBNYXRoLkFicyhzY2FsYXIpO1xyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gTWF0aC5NaW4oYWJzb2x1dGUsIE1hdGguQWJzKHgpKSksIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlQWJzb2x1dGVNYXhpbXVtKGRvdWJsZSBzY2FsYXIsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSBhYnNvbHV0ZSA9IE1hdGguQWJzKHNjYWxhcik7XHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiBNYXRoLk1heChhYnNvbHV0ZSwgTWF0aC5BYnMoeCkpKSwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlTWluaW11bShWZWN0b3I8ZG91YmxlPiBvdGhlciwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwMigoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pTWF0aC5NaW4sIG90aGVyLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZU1heGltdW0oVmVjdG9yPGRvdWJsZT4gb3RoZXIsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KU1hdGguTWF4LCBvdGhlciwgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VBYnNvbHV0ZU1pbmltdW0oVmVjdG9yPGRvdWJsZT4gb3RoZXIsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KSgoeCwgeSkgPT4gTWF0aC5NaW4oTWF0aC5BYnMoeCksIE1hdGguQWJzKHkpKSksIG90aGVyLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZUFic29sdXRlTWF4aW11bShWZWN0b3I8ZG91YmxlPiBvdGhlciwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwMigoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKCh4LCB5KSA9PiBNYXRoLk1heChNYXRoLkFicyh4KSwgTWF0aC5BYnMoeSkpKSwgb3RoZXIsIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGFic29sdXRlIG1pbmltdW0gZWxlbWVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgdmFsdWUgb2YgdGhlIGFic29sdXRlIG1pbmltdW0gZWxlbWVudC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGRvdWJsZSBBYnNvbHV0ZU1pbmltdW0oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguQWJzKEF0KEFic29sdXRlTWluaW11bUluZGV4KCkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGFic29sdXRlIG1pbmltdW0gZWxlbWVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgaW5kZXggb2YgYWJzb2x1dGUgbWluaW11bSBlbGVtZW50LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IEFic29sdXRlTWluaW11bUluZGV4KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLkFicyhBdChpbmRleCkpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IENvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXN0ID0gTWF0aC5BYnMoQXQoaSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlc3QgPCBtaW4pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHRlc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGFic29sdXRlIG1heGltdW0gZWxlbWVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgdmFsdWUgb2YgdGhlIGFic29sdXRlIG1heGltdW0gZWxlbWVudC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGRvdWJsZSBBYnNvbHV0ZU1heGltdW0oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguQWJzKEF0KEFic29sdXRlTWF4aW11bUluZGV4KCkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGFic29sdXRlIG1heGltdW0gZWxlbWVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgaW5kZXggb2YgYWJzb2x1dGUgbWF4aW11bSBlbGVtZW50LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IEFic29sdXRlTWF4aW11bUluZGV4KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSBNYXRoLkFicyhBdChpbmRleCkpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IENvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXN0ID0gTWF0aC5BYnMoQXQoaSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlc3QgPiBtYXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IHRlc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgdmVjdG9yJ3MgZWxlbWVudHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHN1bSBvZiB0aGUgdmVjdG9yJ3MgZWxlbWVudHMuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgU3VtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdW0gPSAwLjA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3VtICs9IEF0KGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIEwxIG5vcm0gb2YgdGhlIHZlY3RvciwgYWxzbyBrbm93biBhcyBNYW5oYXR0YW4gbm9ybS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgc3VtIG9mIHRoZSBhYnNvbHV0ZSB2YWx1ZXMuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgTDFOb3JtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdW0gPSAwLjA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3VtICs9IE1hdGguQWJzKEF0KGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYWxjdWxhdGVzIHRoZSBMMiBub3JtIG9mIHRoZSB2ZWN0b3IsIGFsc28ga25vd24gYXMgRXVjbGlkZWFuIG5vcm0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHNxdWFyZSByb290IG9mIHRoZSBzdW0gb2YgdGhlIHNxdWFyZWQgdmFsdWVzLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZG91YmxlIEwyTm9ybSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5TcXJ0KERvRG90UHJvZHVjdCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIGluZmluaXR5IG5vcm0gb2YgdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbWF4aW11bSBhYnNvbHV0ZSB2YWx1ZS48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGRvdWJsZSBJbmZpbml0eU5vcm0oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZG91YmxlIG1heCA9IDAuMDtcclxuICAgICAgICAgICAgZm9yKGludCBpPTA7IGkgPCBDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5BYnMoQXQoaSkpID4gbWF4KSBtYXggPSBBdChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHAtTm9ybS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBcIj5cclxuICAgICAgICAvLy8gVGhlIHAgdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8Yz5TY2FsYXIgcmV0ID0gKCDiiJF8QXQoaSl8XnAgKV4oMS9wKTwvYz5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgTm9ybShkb3VibGUgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChwIDwgMGQpIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJwXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHAgPT0gMWQpIHJldHVybiBMMU5vcm0oKTtcclxuICAgICAgICAgICAgaWYgKHAgPT0gMmQpIHJldHVybiBMMk5vcm0oKTtcclxuICAgICAgICAgICAgaWYgKGRvdWJsZS5Jc1Bvc2l0aXZlSW5maW5pdHkocCkpIHJldHVybiBJbmZpbml0eU5vcm0oKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdW0gPSAwZDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IENvdW50OyBpbmRleCsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdW0gKz0gTWF0aC5Qb3coTWF0aC5BYnMoQXQoaW5kZXgpKSwgcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguUG93KHN1bSwgMS4wL3ApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF4aW11bSBlbGVtZW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBpbmRleCBvZiBtYXhpbXVtIGVsZW1lbnQuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBpbnQgTWF4aW11bUluZGV4KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSBBdChpbmRleCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlc3QgPSBBdChpKTtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXN0ID4gbWF4KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSB0ZXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtaW5pbXVtIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGluZGV4IG9mIG1pbmltdW0gZWxlbWVudC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGludCBNaW5pbXVtSW5kZXgoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgdmFyIG1pbiA9IEF0KGluZGV4KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVzdCA9IEF0KGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlc3QgPCBtaW4pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHRlc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTm9ybWFsaXplcyB0aGlzIHZlY3RvciB0byBhIHVuaXQgdmVjdG9yIHdpdGggcmVzcGVjdCB0byB0aGUgcC1ub3JtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicFwiPlxyXG4gICAgICAgIC8vLyBUaGUgcCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIFRoaXMgdmVjdG9yIG5vcm1hbGl6ZWQgdG8gYSB1bml0IHZlY3RvciB3aXRoIHJlc3BlY3QgdG8gdGhlIHAtbm9ybS5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3I8ZG91YmxlPiBOb3JtYWxpemUoZG91YmxlIHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocCA8IDBkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwicFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZG91YmxlIG5vcm0gPSBOb3JtKHApO1xyXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBDbG9uZSgpO1xyXG4gICAgICAgICAgICBpZiAobm9ybSA9PSAwZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjbG9uZS5NdWx0aXBseSgxZCAvIG5vcm0sIGNsb25lKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiTFUuY3NcIiBjb21wYW55PVwiTWF0aC5ORVRcIj5cclxuLy8gTWF0aC5ORVQgTnVtZXJpY3MsIHBhcnQgb2YgdGhlIE1hdGguTkVUIFByb2plY3RcclxuLy8gaHR0cDovL251bWVyaWNzLm1hdGhkb3RuZXQuY29tXHJcbi8vIGh0dHA6Ly9naXRodWIuY29tL21hdGhuZXQvbWF0aG5ldC1udW1lcmljc1xyXG4vL1xyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMyBNYXRoLk5FVFxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxyXG4vLyBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4vLyBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuLy8gcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXHJcbi8vIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4vLyBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xyXG4vLyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4vLyBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXHJcbi8vIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbi8vIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXHJcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxyXG4vLyBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4vLyBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbi8vIDwvY29weXJpZ2h0PlxyXG5cclxudXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkRvdWJsZS5NYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmE7XHJcbnVzaW5nIFN5c3RlbTtcclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRmFjdG9yaXphdGlvblxyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gPHBhcmE+QSBjbGFzcyB3aGljaCBlbmNhcHN1bGF0ZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gTFUgZmFjdG9yaXphdGlvbi48L3BhcmE+XHJcbiAgICAvLy8gPHBhcmE+Rm9yIGEgbWF0cml4IEEsIHRoZSBMVSBmYWN0b3JpemF0aW9uIGlzIGEgcGFpciBvZiBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeCBMIGFuZFxyXG4gICAgLy8vIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4IFUgc28gdGhhdCBBID0gTCpVLjwvcGFyYT5cclxuICAgIC8vLyA8cGFyYT5JbiB0aGUgTWF0aC5OZXQgaW1wbGVtZW50YXRpb24gd2UgYWxzbyBzdG9yZSBhIHNldCBvZiBwaXZvdCBlbGVtZW50cyBmb3IgaW5jcmVhc2VkXHJcbiAgICAvLy8gbnVtZXJpY2FsIHN0YWJpbGl0eS4gVGhlIHBpdm90IGVsZW1lbnRzIGVuY29kZSBhIHBlcm11dGF0aW9uIG1hdHJpeCBQIHN1Y2ggdGhhdCBQKkEgPSBMKlUuPC9wYXJhPlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIC8vLyA8cmVtYXJrcz5cclxuICAgIC8vLyBUaGUgY29tcHV0YXRpb24gb2YgdGhlIExVIGZhY3Rvcml6YXRpb24gaXMgZG9uZSBhdCBjb25zdHJ1Y3Rpb24gdGltZS5cclxuICAgIC8vLyA8L3JlbWFya3M+XHJcbiAgICAvLy8gPHR5cGVwYXJhbSBuYW1lPVwiVFwiPlN1cHBvcnRlZCBkYXRhIHR5cGVzIGFyZSBkb3VibGUsIHNpbmdsZSwgPHNlZSBjcmVmPVwiQ29tcGxleFwiLz4sIGFuZCA8c2VlIGNyZWY9XCJDb21wbGV4MzJcIi8+LjwvdHlwZXBhcmFtPlxyXG4gICAgcHVibGljIGFic3RyYWN0IGNsYXNzIExVPFQ+IDogSVNvbHZlcjxUPlxyXG4gICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3JCdWlsZGVyPFQ+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3I7XHJcbiAgICAgICAgcHVibGljIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICBzdGF0aWMgcmVhZG9ubHkgVCBPbmUgPSBCdWlsZGVySW5zdGFuY2U8VD4uTWF0cml4Lk9uZTtcclxuXHJcbiAgICAgICAgcmVhZG9ubHkgTWF0cml4PFQ+IF9sYXp5TDtcclxuICAgICAgICByZWFkb25seSBNYXRyaXg8VD4gX2xhenlVO1xyXG4gICAgICAgIHJlYWRvbmx5IFBlcm11dGF0aW9uIF9sYXp5UDtcclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIHJlYWRvbmx5IE1hdHJpeDxUPiBGYWN0b3JzO1xyXG4gICAgICAgIHByb3RlY3RlZCByZWFkb25seSBpbnRbXSBQaXZvdHM7XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBMVShNYXRyaXg8VD4gZmFjdG9ycywgaW50W10gcGl2b3RzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRmFjdG9ycyA9IGZhY3RvcnM7XHJcbiAgICAgICAgICAgIFBpdm90cyA9IHBpdm90cztcclxuXHJcbiAgICAgICAgICAgIF9sYXp5TCA9IENvbXB1dGVMKCk7XHJcbiAgICAgICAgICAgIF9sYXp5VSA9IEZhY3RvcnMuVXBwZXJUcmlhbmdsZSgpO1xyXG4gICAgICAgICAgICBfbGF6eVAgPSBQZXJtdXRhdGlvbi5Gcm9tSW52ZXJzaW9ucyhQaXZvdHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTWF0cml4PFQ+IENvbXB1dGVMKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBGYWN0b3JzLkxvd2VyVHJpYW5nbGUoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkF0KGksIGksIE9uZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgbG93ZXIgdHJpYW5ndWxhciBmYWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IExcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbGF6eUw7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgdXBwZXIgdHJpYW5ndWxhciBmYWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IFVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbGF6eVU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgcGVybXV0YXRpb24gYXBwbGllZCB0byBMVSBmYWN0b3JpemF0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFBlcm11dGF0aW9uIFBcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbGF6eVA7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhlIG1hdHJpeCBmb3Igd2hpY2ggdGhlIExVIGZhY3Rvcml6YXRpb24gd2FzIGNvbXB1dGVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IFQgRGV0ZXJtaW5hbnQgeyBnZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTb2x2ZXMgYSBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucywgPGI+QVggPSBCPC9iPiwgd2l0aCBBIExVIGZhY3Rvcml6ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnB1dFwiPlRoZSByaWdodCBoYW5kIHNpZGUgPHNlZSBjcmVmPVwiTWF0cml4e1R9XCIvPiwgPGI+QjwvYj4uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGxlZnQgaGFuZCBzaWRlIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4sIDxiPlg8L2I+LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBNYXRyaXg8VD4gU29sdmUoTWF0cml4PFQ+IGlucHV0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHggPSBtX2J1aWxkZXIuU2FtZUFzPFQ+KGlucHV0LCBpbnB1dC5Sb3dDb3VudCwgaW5wdXQuQ29sdW1uQ291bnQsIGZ1bGx5TXV0YWJsZTogdHJ1ZSk7XHJcbiAgICAgICAgICAgIFNvbHZlKGlucHV0LCB4KTtcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNvbHZlcyBhIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zLCA8Yj5BWCA9IEI8L2I+LCB3aXRoIEEgTFUgZmFjdG9yaXplZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlucHV0XCI+VGhlIHJpZ2h0IGhhbmQgc2lkZSA8c2VlIGNyZWY9XCJNYXRyaXh7VH1cIi8+LCA8Yj5CPC9iPi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBsZWZ0IGhhbmQgc2lkZSA8c2VlIGNyZWY9XCJNYXRyaXh7VH1cIi8+LCA8Yj5YPC9iPi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCB2b2lkIFNvbHZlKE1hdHJpeDxUPiBpbnB1dCwgTWF0cml4PFQ+IHJlc3VsdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29sdmVzIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMsIDxiPkF4ID0gYjwvYj4sIHdpdGggQSBMVSBmYWN0b3JpemVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5wdXRcIj5UaGUgcmlnaHQgaGFuZCBzaWRlIHZlY3RvciwgPGI+YjwvYj4uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGxlZnQgaGFuZCBzaWRlIDxzZWUgY3JlZj1cIlZlY3RvcntUfVwiLz4sIDxiPng8L2I+LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBWZWN0b3I8VD4gU29sdmUoVmVjdG9yPFQ+IGlucHV0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHggPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KGlucHV0LCBpbnB1dC5Db3VudCk7XHJcbiAgICAgICAgICAgIFNvbHZlKGlucHV0LCB4KTtcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNvbHZlcyBhIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zLCA8Yj5BeCA9IGI8L2I+LCB3aXRoIEEgTFUgZmFjdG9yaXplZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlucHV0XCI+VGhlIHJpZ2h0IGhhbmQgc2lkZSB2ZWN0b3IsIDxiPmI8L2I+LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIGxlZnQgaGFuZCBzaWRlIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4sIDxiPng8L2I+LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IHZvaWQgU29sdmUoVmVjdG9yPFQ+IGlucHV0LCBWZWN0b3I8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoaXMgbWF0cml4LiBUaGUgaW52ZXJzZSBpcyBjYWxjdWxhdGVkIHVzaW5nIExVIGRlY29tcG9zaXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGludmVyc2Ugb2YgdGhpcyBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBNYXRyaXg8VD4gSW52ZXJzZSgpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vIDxjb3B5cmlnaHQgZmlsZT1cIlN2ZC5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDE1IE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGUuTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhO1xyXG5cclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRmFjdG9yaXphdGlvblxyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gPHBhcmE+QSBjbGFzcyB3aGljaCBlbmNhcHN1bGF0ZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gKFNWRCkuPC9wYXJhPlxyXG4gICAgLy8vIDxwYXJhPlN1cHBvc2UgTSBpcyBhbiBtLWJ5LW4gbWF0cml4IHdob3NlIGVudHJpZXMgYXJlIHJlYWwgbnVtYmVycy5cclxuICAgIC8vLyBUaGVuIHRoZXJlIGV4aXN0cyBhIGZhY3Rvcml6YXRpb24gb2YgdGhlIGZvcm0gTSA9IFXOo1ZUIHdoZXJlOlxyXG4gICAgLy8vIC0gVSBpcyBhbiBtLWJ5LW0gdW5pdGFyeSBtYXRyaXg7XHJcbiAgICAvLy8gLSDOoyBpcyBtLWJ5LW4gZGlhZ29uYWwgbWF0cml4IHdpdGggbm9ubmVnYXRpdmUgcmVhbCBudW1iZXJzIG9uIHRoZSBkaWFnb25hbDtcclxuICAgIC8vLyAtIFZUIGRlbm90ZXMgdHJhbnNwb3NlIG9mIFYsIGFuIG4tYnktbiB1bml0YXJ5IG1hdHJpeDtcclxuICAgIC8vLyBTdWNoIGEgZmFjdG9yaXphdGlvbiBpcyBjYWxsZWQgYSBzaW5ndWxhci12YWx1ZSBkZWNvbXBvc2l0aW9uIG9mIE0uIEEgY29tbW9uIGNvbnZlbnRpb24gaXMgdG8gb3JkZXIgdGhlIGRpYWdvbmFsXHJcbiAgICAvLy8gZW50cmllcyDOoyhpLGkpIGluIGRlc2NlbmRpbmcgb3JkZXIuIEluIHRoaXMgY2FzZSwgdGhlIGRpYWdvbmFsIG1hdHJpeCDOoyBpcyB1bmlxdWVseSBkZXRlcm1pbmVkXHJcbiAgICAvLy8gYnkgTSAodGhvdWdoIHRoZSBtYXRyaWNlcyBVIGFuZCBWIGFyZSBub3QpLiBUaGUgZGlhZ29uYWwgZW50cmllcyBvZiDOoyBhcmUga25vd24gYXMgdGhlIHNpbmd1bGFyIHZhbHVlcyBvZiBNLjwvcGFyYT5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAvLy8gPHJlbWFya3M+XHJcbiAgICAvLy8gVGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBzaW5ndWxhciB2YWx1ZSBkZWNvbXBvc2l0aW9uIGlzIGRvbmUgYXQgY29uc3RydWN0aW9uIHRpbWUuXHJcbiAgICAvLy8gPC9yZW1hcmtzPlxyXG4gICAgLy8vIDx0eXBlcGFyYW0gbmFtZT1cIlRcIj5TdXBwb3J0ZWQgZGF0YSB0eXBlcyBhcmUgZG91YmxlLCBzaW5nbGUsIDxzZWUgY3JlZj1cIkNvbXBsZXhcIi8+LCBhbmQgPHNlZSBjcmVmPVwiQ29tcGxleDMyXCIvPi48L3R5cGVwYXJhbT5cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBjbGFzcyBTdmQ8VD4gOiBJU29sdmVyPFQ+XHJcbiAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICB7XHJcbiAgICAgICAgVmVjdG9yQnVpbGRlcjxUPiB2X2J1aWxkZXIgPSBCdWlsZGVySW5zdGFuY2U8VD4uVmVjdG9yO1xyXG4gICAgICAgIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuICAgICAgICByZWFkb25seSBNYXRyaXg8VD4gX2xhenlXO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+SW5kaWNhdGluZyB3aGV0aGVyIFUgYW5kIFZUIG1hdHJpY2VzIGhhdmUgYmVlbiBjb21wdXRlZCBkdXJpbmcgU1ZEIGZhY3Rvcml6YXRpb24uPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByb3RlY3RlZCByZWFkb25seSBib29sIFZlY3RvcnNDb21wdXRlZDtcclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIFN2ZChWZWN0b3I8VD4gcywgTWF0cml4PFQ+IHUsIE1hdHJpeDxUPiB2dCwgYm9vbCB2ZWN0b3JzQ29tcHV0ZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTID0gcztcclxuICAgICAgICAgICAgVSA9IHU7XHJcbiAgICAgICAgICAgIFZUID0gdnQ7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3JzQ29tcHV0ZWQgPSB2ZWN0b3JzQ29tcHV0ZWQ7XHJcblxyXG4gICAgICAgICAgIE1hdHJpeDxUPiBfbGF6eVcgPSBDb21wdXRlVygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTWF0cml4PFQ+IENvbXB1dGVXKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByb3dzID0gVS5Sb3dDb3VudDtcclxuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBWVC5Db2x1bW5Db3VudDtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1fYnVpbGRlci5TYW1lQXM8VD4oVSwgcm93cywgY29sdW1ucywgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IGopXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQoaSwgaSwgU1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBzaW5ndWxhciB2YWx1ZXMgKM6jKSBvZiBtYXRyaXggaW4gYXNjZW5kaW5nIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjxUPiBTIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIGxlZnQgc2luZ3VsYXIgdmVjdG9ycyAoVSAtIG0tYnktbSB1bml0YXJ5IG1hdHJpeClcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gVSB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSB0cmFuc3Bvc2UgcmlnaHQgc2luZ3VsYXIgdmVjdG9ycyAodHJhbnNwb3NlIG9mIFYsIGFuIG4tYnktbiB1bml0YXJ5IG1hdHJpeClcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gVlQgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgc2luZ3VsYXIgdmFsdWVzIGFzIGEgZGlhZ29uYWwgPHNlZSBjcmVmPVwiTWF0cml4e1R9XCIvPi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgc2luZ3VsYXIgdmFsdWVzIGFzIGEgZGlhZ29uYWwgPHNlZSBjcmVmPVwiTWF0cml4e1R9XCIvPi48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeDxUPiBXXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2xhenlXOyB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBlZmZlY3RpdmUgbnVtZXJpY2FsIG1hdHJpeCByYW5rLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgbnVtYmVyIG9mIG5vbi1uZWdsaWdpYmxlIHNpbmd1bGFyIHZhbHVlcy48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBpbnQgUmFuayB7IGdldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIHR3byBub3JtIG9mIHRoZSA8c2VlIGNyZWY9XCJNYXRyaXh7VH1cIi8+LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSAyLW5vcm0gb2YgdGhlIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4uPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBkb3VibGUgTDJOb3JtIHsgZ2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgY29uZGl0aW9uIG51bWJlciA8Yj5tYXgoUykgLyBtaW4oUyk8L2I+XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGNvbmRpdGlvbiBudW1iZXIuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBUIENvbmRpdGlvbk51bWJlciB7IGdldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIGRldGVybWluYW50IG9mIHRoZSBzcXVhcmUgbWF0cml4IGZvciB3aGljaCB0aGUgU1ZEIHdhcyBjb21wdXRlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBUIERldGVybWluYW50IHsgZ2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29sdmVzIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMsIDxiPkFYID0gQjwvYj4sIHdpdGggQSBTVkQgZmFjdG9yaXplZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlucHV0XCI+VGhlIHJpZ2h0IGhhbmQgc2lkZSA8c2VlIGNyZWY9XCJNYXRyaXh7VH1cIi8+LCA8Yj5CPC9iPi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbGVmdCBoYW5kIHNpZGUgPHNlZSBjcmVmPVwiTWF0cml4e1R9XCIvPiwgPGI+WDwvYj4uPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIE1hdHJpeDxUPiBTb2x2ZShNYXRyaXg8VD4gaW5wdXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIVZlY3RvcnNDb21wdXRlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcGVyYXRpb25FeGNlcHRpb24oXCJSZXNvdXJjZXMuU2luZ3VsYXJWZWN0b3JzTm90Q29tcHV0ZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gbV9idWlsZGVyLlNhbWVBczxUPihVLCBWVC5Db2x1bW5Db3VudCwgaW5wdXQuQ29sdW1uQ291bnQsIGZ1bGx5TXV0YWJsZTogdHJ1ZSk7XHJcbiAgICAgICAgICAgIFNvbHZlKGlucHV0LCB4KTtcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNvbHZlcyBhIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zLCA8Yj5BWCA9IEI8L2I+LCB3aXRoIEEgU1ZEIGZhY3Rvcml6ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnB1dFwiPlRoZSByaWdodCBoYW5kIHNpZGUgPHNlZSBjcmVmPVwiTWF0cml4e1R9XCIvPiwgPGI+QjwvYj4uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbGVmdCBoYW5kIHNpZGUgPHNlZSBjcmVmPVwiTWF0cml4e1R9XCIvPiwgPGI+WDwvYj4uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3Qgdm9pZCBTb2x2ZShNYXRyaXg8VD4gaW5wdXQsIE1hdHJpeDxUPiByZXN1bHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNvbHZlcyBhIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zLCA8Yj5BeCA9IGI8L2I+LCB3aXRoIEEgU1ZEIGZhY3Rvcml6ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnB1dFwiPlRoZSByaWdodCBoYW5kIHNpZGUgdmVjdG9yLCA8Yj5iPC9iPi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbGVmdCBoYW5kIHNpZGUgPHNlZSBjcmVmPVwiVmVjdG9ye1R9XCIvPiwgPGI+eDwvYj4uPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIFZlY3RvcjxUPiBTb2x2ZShWZWN0b3I8VD4gaW5wdXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIVZlY3RvcnNDb21wdXRlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcGVyYXRpb25FeGNlcHRpb24oXCJSZXNvdXJjZXMuU2luZ3VsYXJWZWN0b3JzTm90Q29tcHV0ZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gdl9idWlsZGVyLlNhbWVBczxUPihVLCBWVC5Db2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIFNvbHZlKGlucHV0LCB4KTtcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNvbHZlcyBhIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zLCA8Yj5BeCA9IGI8L2I+LCB3aXRoIEEgU1ZEIGZhY3Rvcml6ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnB1dFwiPlRoZSByaWdodCBoYW5kIHNpZGUgdmVjdG9yLCA8Yj5iPC9iPi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBsZWZ0IGhhbmQgc2lkZSA8c2VlIGNyZWY9XCJNYXRyaXh7VH1cIi8+LCA8Yj54PC9iPi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCB2b2lkIFNvbHZlKFZlY3RvcjxUPiBpbnB1dCwgVmVjdG9yPFQ+IHJlc3VsdCk7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiRXZkLmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTMgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkRvdWJsZS5NYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmE7XHJcblxyXG5uYW1lc3BhY2UgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkZhY3Rvcml6YXRpb25cclxue1xyXG4gICAgdXNpbmcgTnVtZXJpY3M7XHJcbiAgICB1c2luZyBDb21wbGV4ID0gbWF0aG5ldG51bWVyaWNzYnJpZGdlLkNvbXBsZXg7XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEVpZ2VudmFsdWVzIGFuZCBlaWdlbnZlY3RvcnMgb2YgYSByZWFsIG1hdHJpeC5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAvLy8gPHJlbWFya3M+XHJcbiAgICAvLy8gSWYgQSBpcyBzeW1tZXRyaWMsIHRoZW4gQSA9IFYqRCpWJyB3aGVyZSB0aGUgZWlnZW52YWx1ZSBtYXRyaXggRCBpc1xyXG4gICAgLy8vIGRpYWdvbmFsIGFuZCB0aGUgZWlnZW52ZWN0b3IgbWF0cml4IFYgaXMgb3J0aG9nb25hbC5cclxuICAgIC8vLyBJLmUuIEEgPSBWKkQqVicgYW5kIFYqVlQ9SS5cclxuICAgIC8vLyBJZiBBIGlzIG5vdCBzeW1tZXRyaWMsIHRoZW4gdGhlIGVpZ2VudmFsdWUgbWF0cml4IEQgaXMgYmxvY2sgZGlhZ29uYWxcclxuICAgIC8vLyB3aXRoIHRoZSByZWFsIGVpZ2VudmFsdWVzIGluIDEtYnktMSBibG9ja3MgYW5kIGFueSBjb21wbGV4IGVpZ2VudmFsdWVzLFxyXG4gICAgLy8vIGxhbWJkYSArIGkqbXUsIGluIDItYnktMiBibG9ja3MsIFtsYW1iZGEsIG11OyAtbXUsIGxhbWJkYV0uICBUaGVcclxuICAgIC8vLyBjb2x1bW5zIG9mIFYgcmVwcmVzZW50IHRoZSBlaWdlbnZlY3RvcnMgaW4gdGhlIHNlbnNlIHRoYXQgQSpWID0gVipELFxyXG4gICAgLy8vIGkuZS4gQS5NdWx0aXBseShWKSBlcXVhbHMgVi5NdWx0aXBseShEKS4gIFRoZSBtYXRyaXggViBtYXkgYmUgYmFkbHlcclxuICAgIC8vLyBjb25kaXRpb25lZCwgb3IgZXZlbiBzaW5ndWxhciwgc28gdGhlIHZhbGlkaXR5IG9mIHRoZSBlcXVhdGlvblxyXG4gICAgLy8vIEEgPSBWKkQqSW52ZXJzZShWKSBkZXBlbmRzIHVwb24gVi5Db25kaXRpb24oKS5cclxuICAgIC8vLyA8L3JlbWFya3M+XHJcbiAgICAvLy8gPHR5cGVwYXJhbSBuYW1lPVwiVFwiPlN1cHBvcnRlZCBkYXRhIHR5cGVzIGFyZSBkb3VibGUsIHNpbmdsZSwgPHNlZSBjcmVmPVwiQ29tcGxleFwiLz4sIGFuZCA8c2VlIGNyZWY9XCJDb21wbGV4MzJcIi8+LjwvdHlwZXBhcmFtPlxyXG4gICAgcHVibGljIGFic3RyYWN0IGNsYXNzIEV2ZDxUPiA6IElTb2x2ZXI8VD5cclxuICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3JCdWlsZGVyPFQ+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxUPi5WZWN0b3I7XHJcbiAgICAgICAgcHVibGljIE1hdHJpeEJ1aWxkZXI8VD4gbV9idWlsZGVyID0gQnVpbGRlckluc3RhbmNlPFQ+Lk1hdHJpeDtcclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIEV2ZChNYXRyaXg8VD4gZWlnZW5WZWN0b3JzLCBWZWN0b3I8Q29tcGxleD4gZWlnZW5WYWx1ZXMsIE1hdHJpeDxUPiBibG9ja0RpYWdvbmFsLCBib29sIGlzU3ltbWV0cmljKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRWlnZW5WZWN0b3JzID0gZWlnZW5WZWN0b3JzO1xyXG4gICAgICAgICAgICBFaWdlblZhbHVlcyA9IGVpZ2VuVmFsdWVzO1xyXG4gICAgICAgICAgICBEID0gYmxvY2tEaWFnb25hbDtcclxuICAgICAgICAgICAgSXNTeW1tZXRyaWMgPSBpc1N5bW1ldHJpYztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBvciBzZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG1hdHJpeCBpcyBzeW1tZXRyaWMgb3Igbm90XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc1N5bW1ldHJpYyB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBkZXRlcm1pbmFudCBvZiB0aGUgc3F1YXJlIG1hdHJpeCBmb3Igd2hpY2ggdGhlIEVWRCB3YXMgY29tcHV0ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3QgVCBEZXRlcm1pbmFudCB7IGdldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIGVmZmVjdGl2ZSBudW1lcmljYWwgbWF0cml4IHJhbmsuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBudW1iZXIgb2Ygbm9uLW5lZ2xpZ2libGUgc2luZ3VsYXIgdmFsdWVzLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGludCBSYW5rIHsgZ2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgbWF0cml4IGlzIGZ1bGwgcmFuayBvciBub3QuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjxjPnRydWU8L2M+IGlmIHRoZSBtYXRyaXggaXMgZnVsbCByYW5rOyBvdGhlcndpc2UgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGJvb2wgSXNGdWxsUmFuayB7IGdldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyB0aGUgZWlnZW4gdmFsdWVzICjOuykgb2YgbWF0cml4IGluIGFzY2VuZGluZyB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3I8Q29tcGxleD4gRWlnZW5WYWx1ZXMgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBvciBzZXRzIGVpZ2VudmVjdG9ycy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXg8VD4gRWlnZW5WZWN0b3JzIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyB0aGUgYmxvY2sgZGlhZ29uYWwgZWlnZW52YWx1ZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4PFQ+IEQgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29sdmVzIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMsIDxiPkFYID0gQjwvYj4sIHdpdGggQSBFVkQgZmFjdG9yaXplZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlucHV0XCI+VGhlIHJpZ2h0IGhhbmQgc2lkZSA8c2VlIGNyZWY9XCJNYXRyaXh7VH1cIi8+LCA8Yj5CPC9iPi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbGVmdCBoYW5kIHNpZGUgPHNlZSBjcmVmPVwiTWF0cml4e1R9XCIvPiwgPGI+WDwvYj4uPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIE1hdHJpeDxUPiBTb2x2ZShNYXRyaXg8VD4gaW5wdXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgeCA9IG1fYnVpbGRlci5TYW1lQXM8VD4oRWlnZW5WZWN0b3JzLCBFaWdlblZlY3RvcnMuQ29sdW1uQ291bnQsIGlucHV0LkNvbHVtbkNvdW50LCBmdWxseU11dGFibGU6IHRydWUpO1xyXG4gICAgICAgICAgICBTb2x2ZShpbnB1dCwgeCk7XHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTb2x2ZXMgYSBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucywgPGI+QVggPSBCPC9iPiwgd2l0aCBBIEVWRCBmYWN0b3JpemVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5wdXRcIj5UaGUgcmlnaHQgaGFuZCBzaWRlIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4sIDxiPkI8L2I+LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIGxlZnQgaGFuZCBzaWRlIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4sIDxiPlg8L2I+LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IHZvaWQgU29sdmUoTWF0cml4PFQ+IGlucHV0LCBNYXRyaXg8VD4gcmVzdWx0KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTb2x2ZXMgYSBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucywgPGI+QXggPSBiPC9iPiwgd2l0aCBBIEVWRCBmYWN0b3JpemVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5wdXRcIj5UaGUgcmlnaHQgaGFuZCBzaWRlIHZlY3RvciwgPGI+YjwvYj4uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGxlZnQgaGFuZCBzaWRlIDxzZWUgY3JlZj1cIlZlY3RvcntUfVwiLz4sIDxiPng8L2I+LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBWZWN0b3I8VD4gU29sdmUoVmVjdG9yPFQ+IGlucHV0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHggPSB2X2J1aWxkZXIuU2FtZUFzPFQ+KEVpZ2VuVmVjdG9ycywgRWlnZW5WZWN0b3JzLkNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgU29sdmUoaW5wdXQsIHgpO1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29sdmVzIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMsIDxiPkF4ID0gYjwvYj4sIHdpdGggQSBFVkQgZmFjdG9yaXplZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlucHV0XCI+VGhlIHJpZ2h0IGhhbmQgc2lkZSB2ZWN0b3IsIDxiPmI8L2I+LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIGxlZnQgaGFuZCBzaWRlIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4sIDxiPng8L2I+LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IHZvaWQgU29sdmUoVmVjdG9yPFQ+IGlucHV0LCBWZWN0b3I8VD4gcmVzdWx0KTtcclxuICAgIH1cclxufVxyXG4iLCIvLyA8Y29weXJpZ2h0IGZpbGU9XCJEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZS5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDE1IE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlLk1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYTtcclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkxpbnE7XHJcbnVzaW5nIFN5c3RlbS5SdW50aW1lLlNlcmlhbGl6YXRpb247XHJcblxyXG5cclxubmFtZXNwYWNlIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5TdG9yYWdlXHJcbntcclxuICAgIFtTZXJpYWxpemFibGVdXHJcbiAgICBbRGF0YUNvbnRyYWN0KE5hbWVzcGFjZSA9IFwidXJuOk1hdGhOZXQvTnVtZXJpY3MvTGluZWFyQWxnZWJyYVwiKV1cclxuICAgIHB1YmxpYyBjbGFzcyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPiA6IE1hdHJpeFN0b3JhZ2U8VD5cclxuICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgIHtcclxuICAgICAgICAvLyBbcnVlZ2ddIHB1YmxpYyBmaWVsZHMgYXJlIE9LIGhlcmVcclxuXHJcbiAgICAgICAgW0RhdGFNZW1iZXIoT3JkZXIgPSAxKV1cclxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgVFtdIERhdGE7XHJcblxyXG4gICAgICAgIGludGVybmFsIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlKGludCByb3dzLCBpbnQgY29sdW1ucylcclxuICAgICAgICAgICAgOiBiYXNlKHJvd3MsIGNvbHVtbnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEYXRhID0gbmV3IFRbcm93cypjb2x1bW5zXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlKGludCByb3dzLCBpbnQgY29sdW1ucywgVFtdIGRhdGEpXHJcbiAgICAgICAgICAgIDogYmFzZShyb3dzLCBjb2x1bW5zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImRhdGFcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhLkxlbmd0aCAhPSByb3dzKmNvbHVtbnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJkYXRhXCIsIHN0cmluZy5Gb3JtYXQoXCJSZXNvdXJjZXMuQXJndW1lbnRBcnJheVdyb25nTGVuZ3RoLCByb3dzKmNvbHVtbnNcIikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEYXRhID0gZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVHJ1ZSBpZiB0aGUgbWF0cml4IHN0b3JhZ2UgZm9ybWF0IGlzIGRlbnNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgSXNEZW5zZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIHRydWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVHJ1ZSBpZiBhbGwgZmllbGRzIG9mIHRoaXMgbWF0cml4IGNhbiBiZSBzZXQgdG8gYW55IHZhbHVlLlxyXG4gICAgICAgIC8vLyBGYWxzZSBpZiBzb21lIGZpZWxkcyBhcmUgZml4ZWQsIGxpa2Ugb24gYSBkaWFnb25hbCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBJc0Z1bGx5TXV0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIHRydWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGZpZWxkIGNhbiBiZSBzZXQgdG8gYW55IHZhbHVlLlxyXG4gICAgICAgIC8vLyBGYWxzZSBpZiB0aGUgZmllbGQgaXMgZml4ZWQsIGxpa2UgYW4gb2ZmLWRpYWdvbmFsIGZpZWxkIG9uIGEgZGlhZ29uYWwgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgSXNNdXRhYmxlQXQoaW50IHJvdywgaW50IGNvbHVtbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXRyaWV2ZXMgdGhlIHJlcXVlc3RlZCBlbGVtZW50IHdpdGhvdXQgcmFuZ2UgY2hlY2tpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVCBBdChpbnQgcm93LCBpbnQgY29sdW1uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIERhdGFbKGNvbHVtbipSb3dDb3VudCkgKyByb3ddO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXRzIHRoZSBlbGVtZW50IHdpdGhvdXQgcmFuZ2UgY2hlY2tpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBBdChpbnQgcm93LCBpbnQgY29sdW1uLCBUIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGF0YVsoY29sdW1uKlJvd0NvdW50KSArIHJvd10gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRXZhbHVhdGUgdGhlIHJvdyBhbmQgY29sdW1uIGF0IGEgc3BlY2lmaWMgZGF0YSBpbmRleC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHZvaWQgUm93Q29sdW1uQXRJbmRleChpbnQgaW5kZXgsIG91dCBpbnQgcm93LCBvdXQgaW50IGNvbHVtbilcclxuICAgICAgICB7XHJcbiNpZiBORVRTVEFOREFSRDFfM1xyXG4gICAgICAgICAgICByb3cgPSBpbmRleCAlIFJvd0NvdW50O1xyXG4gICAgICAgICAgICBjb2x1bW4gPSBpbmRleCAvIFJvd0NvdW50O1xyXG4jZWxzZVxyXG4gICAgICAgICAgICBjb2x1bW4gPSBNYXRoLkRpdlJlbShpbmRleCwgUm93Q291bnQsIG91dCByb3cpO1xyXG4jZW5kaWZcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENMRUFSSU5HXHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIENsZWFyKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFycmF5LkNsZWFyPFQ+KERhdGEsIDAsIERhdGEuTGVuZ3RoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgQ2xlYXJVbmNoZWNrZWQoaW50IHJvd0luZGV4LCBpbnQgcm93Q291bnQsIGludCBjb2x1bW5JbmRleCwgaW50IGNvbHVtbkNvdW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJvd0luZGV4ID09IDAgJiYgY29sdW1uSW5kZXggPT0gMCAmJiByb3dDb3VudCA9PSBSb3dDb3VudCAmJiBjb2x1bW5Db3VudCA9PSBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ2xlYXI8VD4oRGF0YSwgMCwgRGF0YS5MZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gY29sdW1uSW5kZXg7IGogPCBjb2x1bW5JbmRleCArIGNvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEFycmF5LkNsZWFyPFQ+KERhdGEsIGoqUm93Q291bnQgKyByb3dJbmRleCwgcm93Q291bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIENsZWFyUm93c1VuY2hlY2tlZChpbnRbXSByb3dJbmRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgb2Zmc2V0ID0gaipSb3dDb3VudDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcm93SW5kaWNlcy5MZW5ndGg7IGsrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBEYXRhW29mZnNldCArIHJvd0luZGljZXNba11dID0gWmVybztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBDbGVhckNvbHVtbnNVbmNoZWNrZWQoaW50W10gY29sdW1uSW5kaWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGsgPSAwOyBrIDwgY29sdW1uSW5kaWNlcy5MZW5ndGg7IGsrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ2xlYXI8VD4oRGF0YSwgY29sdW1uSW5kaWNlc1trXSpSb3dDb3VudCwgUm93Q291bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJTklUSUFMSVpBVElPTlxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+IE9mTWF0cml4KE1hdHJpeFN0b3JhZ2U8VD4gbWF0cml4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBuZXcgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4obWF0cml4LlJvd0NvdW50LCBtYXRyaXguQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICBtYXRyaXguQ29weVRvVW5jaGVja2VkKHN0b3JhZ2UsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPiBPZlZhbHVlKGludCByb3dzLCBpbnQgY29sdW1ucywgVCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+KHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHN0b3JhZ2UuRGF0YTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGRhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPiBPZkluaXQoaW50IHJvd3MsIGludCBjb2x1bW5zLCBGdW5jPGludCwgaW50LCBUPiBpbml0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBuZXcgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4ocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgIGludCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLkRhdGFbaW5kZXgrK10gPSBpbml0KGksIGopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPiBPZkRpYWdvbmFsSW5pdChpbnQgcm93cywgaW50IGNvbHVtbnMsIEZ1bmM8aW50LCBUPiBpbml0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBuZXcgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4ocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgIGludCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGludCBzdHJpZGUgPSByb3dzICsgMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLk1pbihyb3dzLCBjb2x1bW5zKTsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlLkRhdGFbaW5kZXhdID0gaW5pdChpKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IHN0cmlkZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4gT2ZBcnJheShUWyxdIGFycmF5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBuZXcgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4oYXJyYXkuR2V0TGVuZ3RoKDApLCBhcnJheS5HZXRMZW5ndGgoMSkpO1xyXG4gICAgICAgICAgICBpbnQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0b3JhZ2UuQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yYWdlLlJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5EYXRhW2luZGV4KytdID0gYXJyYXlbaSwgal07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+IE9mQ29sdW1uQXJyYXlzKFRbXVtdIGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5MZW5ndGggPD0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImRhdGFcIiwgXCJSZXNvdXJjZXMuTWF0cml4Q2FuTm90QmVFbXB0eVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW50IGNvbHVtbnMgPSBkYXRhLkxlbmd0aDtcclxuICAgICAgICAgICAgaW50IHJvd3MgPSBkYXRhWzBdLkxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGFycmF5ID0gbmV3IFRbcm93cypjb2x1bW5zXTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBkYXRhLkxlbmd0aDsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KGRhdGFbal0sIDAsIGFycmF5LCBqKnJvd3MsIHJvd3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4ocm93cywgY29sdW1ucywgYXJyYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPiBPZlJvd0FycmF5cyhUW11bXSBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuTGVuZ3RoIDw9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJkYXRhXCIsIFwiUmVzb3VyY2VzLk1hdHJpeENhbk5vdEJlRW1wdHlcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludCByb3dzID0gZGF0YS5MZW5ndGg7XHJcbiAgICAgICAgICAgIGludCBjb2x1bW5zID0gZGF0YVswXS5MZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBUW3Jvd3MqY29sdW1uc107XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgY29sdW1uczsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgb2Zmc2V0ID0gaipyb3dzO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCByb3dzOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgaV0gPSBkYXRhW2ldW2pdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4ocm93cywgY29sdW1ucywgYXJyYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPiBPZkNvbHVtbk1ham9yQXJyYXkoaW50IHJvd3MsIGludCBjb2x1bW5zLCBUW10gZGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRbXSByZXQgPSBuZXcgVFtyb3dzKmNvbHVtbnNdO1xyXG4gICAgICAgICAgICBBcnJheS5Db3B5KGRhdGEsIDAsIHJldCwgMCwgTWF0aC5NaW4ocmV0Lkxlbmd0aCwgZGF0YS5MZW5ndGgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPihyb3dzLCBjb2x1bW5zLCByZXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPiBPZlJvd01ham9yQXJyYXkoaW50IHJvd3MsIGludCBjb2x1bW5zLCBUW10gZGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRbXSByZXQgPSBuZXcgVFtyb3dzKmNvbHVtbnNdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHJvd3M7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IG9mZnNldCA9IGkqY29sdW1ucztcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgY29sdW1uczsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldFsoaipyb3dzKSArIGldID0gZGF0YVtvZmZzZXQgKyBqXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+KHJvd3MsIGNvbHVtbnMsIHJldCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+IE9mQ29sdW1uVmVjdG9ycyhWZWN0b3JTdG9yYWdlPFQ+W10gZGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLkxlbmd0aCA8PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiZGF0YVwiLCBcIlJlc291cmNlcy5NYXRyaXhDYW5Ob3RCZUVtcHR5XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpbnQgY29sdW1ucyA9IGRhdGEuTGVuZ3RoO1xyXG4gICAgICAgICAgICBpbnQgcm93cyA9IGRhdGFbMF0uTGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgVFtyb3dzKmNvbHVtbnNdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGRhdGEuTGVuZ3RoOyBqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBkYXRhW2pdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbnNlQ29sdW1uID0gY29sdW1uIGFzIERlbnNlVmVjdG9yU3RvcmFnZTxUPjtcclxuICAgICAgICAgICAgICAgIGlmIChkZW5zZUNvbHVtbiAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LkNvcHkoZGVuc2VDb2x1bW4uRGF0YSwgMCwgYXJyYXksIGoqcm93cywgcm93cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRkFMTCBCQUNLXHJcbiAgICAgICAgICAgICAgICAgICAgaW50IG9mZnNldCA9IGoqcm93cztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHJvd3M7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIGldID0gY29sdW1uLkF0KGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+KHJvd3MsIGNvbHVtbnMsIGFycmF5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4gT2ZSb3dWZWN0b3JzKFZlY3RvclN0b3JhZ2U8VD5bXSBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuTGVuZ3RoIDw9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJkYXRhXCIsIFwiUmVzb3VyY2VzLk1hdHJpeENhbk5vdEJlRW1wdHlcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludCByb3dzID0gZGF0YS5MZW5ndGg7XHJcbiAgICAgICAgICAgIGludCBjb2x1bW5zID0gZGF0YVswXS5MZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBUW3Jvd3MqY29sdW1uc107XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgY29sdW1uczsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgb2Zmc2V0ID0gaipyb3dzO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCByb3dzOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgaV0gPSBkYXRhW2ldLkF0KGopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4ocm93cywgY29sdW1ucywgYXJyYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPiBPZkluZGV4ZWRFbnVtZXJhYmxlKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8VHVwbGU8aW50LCBpbnQsIFQ+PiBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGFycmF5ID0gbmV3IFRbcm93cypjb2x1bW5zXTtcclxuICAgICAgICAgICAgZm9yZWFjaCAodmFyIGl0ZW0gaW4gZGF0YSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbKGl0ZW0uSXRlbTIqcm93cykgKyBpdGVtLkl0ZW0xXSA9IGl0ZW0uSXRlbTM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPihyb3dzLCBjb2x1bW5zLCBhcnJheSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+IE9mQ29sdW1uTWFqb3JFbnVtZXJhYmxlKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8VD4gZGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBhcnJheURhdGEgPSBkYXRhIGFzIFRbXTtcclxuICAgICAgICAgICAgaWYgKGFycmF5RGF0YSAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT2ZDb2x1bW5NYWpvckFycmF5KHJvd3MsIGNvbHVtbnMsIGFycmF5RGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4ocm93cywgY29sdW1ucywgU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5Ub0FycmF5PFQ+KGRhdGEpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4gT2ZSb3dNYWpvckVudW1lcmFibGUoaW50IHJvd3MsIGludCBjb2x1bW5zLCBJRW51bWVyYWJsZTxUPiBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9mUm93TWFqb3JBcnJheShyb3dzLCBjb2x1bW5zLCBkYXRhIGFzIFRbXSA/PyBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlRvQXJyYXk8VD4oZGF0YSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPiBPZkNvbHVtbkVudW1lcmFibGVzKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8SUVudW1lcmFibGU8VD4+IGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgVFtyb3dzKmNvbHVtbnNdO1xyXG4gICAgICAgICAgICB1c2luZyAodmFyIGNvbHVtbkl0ZXJhdG9yID0gZGF0YS5HZXRFbnVtZXJhdG9yKCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGNvbHVtbiA9IDA7IGNvbHVtbiA8IGNvbHVtbnM7IGNvbHVtbisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29sdW1uSXRlcmF0b3IuTW92ZU5leHQoKSkgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImRhdGFcIiwgc3RyaW5nLkZvcm1hdChcIlJlc291cmNlcy5Bcmd1bWVudEFycmF5V3JvbmdMZW5ndGhcIiwgY29sdW1ucykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheUNvbHVtbiA9IGNvbHVtbkl0ZXJhdG9yLkN1cnJlbnQgYXMgVFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJheUNvbHVtbiAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuQ29weShhcnJheUNvbHVtbiwgMCwgYXJyYXksIGNvbHVtbipyb3dzLCByb3dzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXNpbmcgKHZhciByb3dJdGVyYXRvciA9IGNvbHVtbkl0ZXJhdG9yLkN1cnJlbnQuR2V0RW51bWVyYXRvcigpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gKGNvbHVtbiArIDEpKnJvd3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpbmRleCA9IGNvbHVtbipyb3dzOyBpbmRleCA8IGVuZDsgaW5kZXgrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJvd0l0ZXJhdG9yLk1vdmVOZXh0KCkpIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJkYXRhXCIsIHN0cmluZy5Gb3JtYXQoXCJSZXNvdXJjZXMuQXJndW1lbnRBcnJheVdyb25nTGVuZ3RoXCIsIHJvd3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtpbmRleF0gPSByb3dJdGVyYXRvci5DdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0l0ZXJhdG9yLk1vdmVOZXh0KCkpIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJkYXRhXCIsIHN0cmluZy5Gb3JtYXQoXCJSZXNvdXJjZXMuQXJndW1lbnRBcnJheVdyb25nTGVuZ3RoXCIsIHJvd3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5JdGVyYXRvci5Nb3ZlTmV4dCgpKSB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiZGF0YVwiLCBzdHJpbmcuRm9ybWF0KFwiUmVzb3VyY2VzLkFyZ3VtZW50QXJyYXlXcm9uZ0xlbmd0aFwiLCBjb2x1bW5zKSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4ocm93cywgY29sdW1ucywgYXJyYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPiBPZlJvd0VudW1lcmFibGVzKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8SUVudW1lcmFibGU8VD4+IGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgVFtyb3dzKmNvbHVtbnNdO1xyXG4gICAgICAgICAgICB1c2luZyAodmFyIHJvd0l0ZXJhdG9yID0gZGF0YS5HZXRFbnVtZXJhdG9yKCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHJvdyA9IDA7IHJvdyA8IHJvd3M7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcm93SXRlcmF0b3IuTW92ZU5leHQoKSkgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImRhdGFcIiwgc3RyaW5nLkZvcm1hdChcIlJlc291cmNlcy5Bcmd1bWVudEFycmF5V3JvbmdMZW5ndGhcIiwgcm93cykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVzaW5nICh2YXIgY29sdW1uSXRlcmF0b3IgPSByb3dJdGVyYXRvci5DdXJyZW50LkdldEVudW1lcmF0b3IoKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGluZGV4ID0gcm93OyBpbmRleCA8IGFycmF5Lkxlbmd0aDsgaW5kZXggKz0gcm93cylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2x1bW5JdGVyYXRvci5Nb3ZlTmV4dCgpKSB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiZGF0YVwiLCBzdHJpbmcuRm9ybWF0KFwiUmVzb3VyY2VzLkFyZ3VtZW50QXJyYXlXcm9uZ0xlbmd0aFwiLCBjb2x1bW5zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtpbmRleF0gPSBjb2x1bW5JdGVyYXRvci5DdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW5JdGVyYXRvci5Nb3ZlTmV4dCgpKSB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiZGF0YVwiLCBzdHJpbmcuRm9ybWF0KFwiUmVzb3VyY2VzLkFyZ3VtZW50QXJyYXlXcm9uZ0xlbmd0aFwiLCBjb2x1bW5zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJvd0l0ZXJhdG9yLk1vdmVOZXh0KCkpIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJkYXRhXCIsIHN0cmluZy5Gb3JtYXQoXCJSZXNvdXJjZXMuQXJndW1lbnRBcnJheVdyb25nTGVuZ3RoXCIsIHJvd3MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+KHJvd3MsIGNvbHVtbnMsIGFycmF5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1BVFJJWCBDT1BZXHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgQ29weVRvVW5jaGVja2VkKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29weVRvVW5jaGVja2VkKGRlbnNlVGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRkFMTCBCQUNLXHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMCwgb2Zmc2V0ID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyssIG9mZnNldCArPSBSb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5BdChpLCBqLCBEYXRhW2kgKyBvZmZzZXRdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBDb3B5VG9VbmNoZWNrZWQoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9CdWZmZXIuQmxvY2tDb3B5KERhdGEsIDAsIHRhcmdldC5EYXRhLCAwLCBEYXRhLkxlbmd0aCAqIFN5c3RlbS5SdW50aW1lLkludGVyb3BTZXJ2aWNlcy5NYXJzaGFsLlNpemVPZih0eXBlb2YoVCkpKTtcclxuICAgICAgICAgICAgQXJyYXkuQ29weShEYXRhLCAwLCB0YXJnZXQuRGF0YSwgMCwgRGF0YS5MZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBDb3B5U3ViTWF0cml4VG9VbmNoZWNrZWQoTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VSb3dJbmRleCwgaW50IHRhcmdldFJvd0luZGV4LCBpbnQgcm93Q291bnQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VDb2x1bW5JbmRleCwgaW50IHRhcmdldENvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQsXHJcbiAgICAgICAgICAgIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VUYXJnZXQgPSB0YXJnZXQgYXMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD47XHJcbiAgICAgICAgICAgIGlmIChkZW5zZVRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb3B5U3ViTWF0cml4VG9VbmNoZWNrZWQoZGVuc2VUYXJnZXQsIHNvdXJjZVJvd0luZGV4LCB0YXJnZXRSb3dJbmRleCwgcm93Q291bnQsIHNvdXJjZUNvbHVtbkluZGV4LCB0YXJnZXRDb2x1bW5JbmRleCwgY29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBQcm9wZXIgU3BhcnNlIEltcGxlbWVudGF0aW9uXHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSBzb3VyY2VDb2x1bW5JbmRleCwgamogPSB0YXJnZXRDb2x1bW5JbmRleDsgaiA8IHNvdXJjZUNvbHVtbkluZGV4ICsgY29sdW1uQ291bnQ7IGorKywgamorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGluZGV4ID0gc291cmNlUm93SW5kZXggKyBqKlJvd0NvdW50O1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaWkgPSB0YXJnZXRSb3dJbmRleDsgaWkgPCB0YXJnZXRSb3dJbmRleCArIHJvd0NvdW50OyBpaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5BdChpaSwgamosIERhdGFbaW5kZXgrK10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2b2lkIENvcHlTdWJNYXRyaXhUb1VuY2hlY2tlZChEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VSb3dJbmRleCwgaW50IHRhcmdldFJvd0luZGV4LCBpbnQgcm93Q291bnQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VDb2x1bW5JbmRleCwgaW50IHRhcmdldENvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gc291cmNlQ29sdW1uSW5kZXgsIGpqID0gdGFyZ2V0Q29sdW1uSW5kZXg7IGogPCBzb3VyY2VDb2x1bW5JbmRleCArIGNvbHVtbkNvdW50OyBqKyssIGpqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vQnVmZmVyLkJsb2NrQ29weShEYXRhLCBqKlJvd0NvdW50ICsgc291cmNlUm93SW5kZXgsIHRhcmdldC5EYXRhLCBqaip0YXJnZXQuUm93Q291bnQgKyB0YXJnZXRSb3dJbmRleCwgcm93Q291bnQgKiBTeXN0ZW0uUnVudGltZS5JbnRlcm9wU2VydmljZXMuTWFyc2hhbC5TaXplT2YodHlwZW9mKFQpKSk7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KERhdGEsIGoqUm93Q291bnQgKyBzb3VyY2VSb3dJbmRleCwgdGFyZ2V0LkRhdGEsIGpqKnRhcmdldC5Sb3dDb3VudCArIHRhcmdldFJvd0luZGV4LCByb3dDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJPVyBDT1BZXHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgQ29weVN1YlJvd1RvVW5jaGVja2VkKFZlY3RvclN0b3JhZ2U8VD4gdGFyZ2V0LCBpbnQgcm93SW5kZXgsIGludCBzb3VyY2VDb2x1bW5JbmRleCwgaW50IHRhcmdldENvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQsXHJcbiAgICAgICAgICAgIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0RGVuc2UgPSB0YXJnZXQgYXMgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0RGVuc2UgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBjb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldERlbnNlLkRhdGFbaiArIHRhcmdldENvbHVtbkluZGV4XSA9IERhdGFbKGogKyBzb3VyY2VDb2x1bW5JbmRleCkqUm93Q291bnQgKyByb3dJbmRleF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IHNvdXJjZUNvbHVtbkluZGV4LCBqaiA9IHRhcmdldENvbHVtbkluZGV4OyBqIDwgc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudDsgaisrLCBqaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQXQoamosIERhdGFbKGoqUm93Q291bnQpICsgcm93SW5kZXhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ09MVU1OIENPUFlcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBDb3B5U3ViQ29sdW1uVG9VbmNoZWNrZWQoVmVjdG9yU3RvcmFnZTxUPiB0YXJnZXQsIGludCBjb2x1bW5JbmRleCwgaW50IHNvdXJjZVJvd0luZGV4LCBpbnQgdGFyZ2V0Um93SW5kZXgsIGludCByb3dDb3VudCxcclxuICAgICAgICAgICAgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXREZW5zZSA9IHRhcmdldCBhcyBEZW5zZVZlY3RvclN0b3JhZ2U8VD47XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXREZW5zZSAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KERhdGEsIGNvbHVtbkluZGV4KlJvd0NvdW50ICsgc291cmNlUm93SW5kZXgsIHRhcmdldERlbnNlLkRhdGEsIHRhcmdldFJvd0luZGV4LCByb3dDb3VudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGNvbHVtbkluZGV4KlJvd0NvdW50O1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gc291cmNlUm93SW5kZXgsIGlpID0gdGFyZ2V0Um93SW5kZXg7IGkgPCBzb3VyY2VSb3dJbmRleCArIHJvd0NvdW50OyBpKyssIGlpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5BdChpaSwgRGF0YVtvZmZzZXQgKyBpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRSQU5TUE9TRVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFRyYW5zcG9zZVRvVW5jaGVja2VkKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVHJhbnNwb3NlVG9VbmNoZWNrZWQoZGVuc2VUYXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc3BhcnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICBpZiAoc3BhcnNlVGFyZ2V0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRyYW5zcG9zZVRvVW5jaGVja2VkKHNwYXJzZVRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDAsIG9mZnNldCA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrLCBvZmZzZXQgKz0gUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQoaiwgaSwgRGF0YVtpICsgb2Zmc2V0XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgVHJhbnNwb3NlVG9VbmNoZWNrZWQoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBqICogUm93Q291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkRhdGFbKGkgKiBDb2x1bW5Db3VudCkgKyBqXSA9IERhdGFbaW5kZXggKyBpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBUcmFuc3Bvc2VUb1VuY2hlY2tlZChTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPiB0YXJnZXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcm93UG9pbnRlcnMgPSB0YXJnZXQuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5JbmRpY2VzID0gbmV3IExpc3Q8aW50PigpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gbmV3IExpc3Q8VD4oKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcm93UG9pbnRlcnNbal0gPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBqICogUm93Q291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyhEYXRhW2luZGV4ICsgaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZChEYXRhW2luZGV4ICsgaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRpY2VzLkFkZChpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJvd1BvaW50ZXJzW0NvbHVtbkNvdW50XSA9IHZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgdGFyZ2V0LkNvbHVtbkluZGljZXMgPSBjb2x1bW5JbmRpY2VzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgdGFyZ2V0LlZhbHVlcyA9IHZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFRyYW5zcG9zZVNxdWFyZUlucGxhY2VVbmNoZWNrZWQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBqICogUm93Q291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGo7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBUIHN3YXAgPSBEYXRhW2luZGV4ICsgaV07XHJcbiAgICAgICAgICAgICAgICAgICAgRGF0YVtpbmRleCArIGldID0gRGF0YVtpKkNvbHVtbkNvdW50ICsgal07XHJcbiAgICAgICAgICAgICAgICAgICAgRGF0YVtpKkNvbHVtbkNvdW50ICsgal0gPSBzd2FwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFWFRSQUNUXHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBUW10gVG9Sb3dNYWpvckFycmF5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSBuZXcgVFtEYXRhLkxlbmd0aF07XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkqQ29sdW1uQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W29mZnNldCArIGpdID0gRGF0YVsoaipSb3dDb3VudCkgKyBpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFRbXSBUb0NvbHVtbk1ham9yQXJyYXkoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBUW0RhdGEuTGVuZ3RoXTtcclxuICAgICAgICAgICAgQXJyYXkuQ29weShEYXRhLCAwLCByZXQsIDAsIERhdGEuTGVuZ3RoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBUW11bXSBUb1Jvd0FycmF5cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFRbUm93Q291bnRdW107XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBuZXcgVFtDb2x1bW5Db3VudF07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93W2pdID0gRGF0YVtqKlJvd0NvdW50ICsgaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtpXSA9IHJvdztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVFtdW10gVG9Db2x1bW5BcnJheXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBUW0NvbHVtbkNvdW50XVtdO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gbmV3IFRbUm93Q291bnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LkNvcHkoRGF0YSwgaipSb3dDb3VudCwgY29sdW1uLCAwLCBSb3dDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W2pdID0gY29sdW1uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBUWyxdIFRvQXJyYXkoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBUW1Jvd0NvdW50LCBDb2x1bW5Db3VudF07XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldFtpLCBqXSA9IERhdGFbKGoqUm93Q291bnQpICsgaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBUW10gQXNDb2x1bW5NYWpvckFycmF5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBEYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRU5VTUVSQVRJT05cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIElFbnVtZXJhYmxlPFQ+IEVudW1lcmF0ZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBJRW51bWVyYWJsZTxUdXBsZTxpbnQsIGludCwgVD4+IEVudW1lcmF0ZUluZGV4ZWQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGluZGV4ID0gMDtcclxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVD4oaSwgaiwgRGF0YVtpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBJRW51bWVyYWJsZTxUPiBFbnVtZXJhdGVOb25aZXJvKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLldoZXJlPFQ+KERhdGEsKEZ1bmM8VCxib29sPikoeCA9PiAhWmVyby5FcXVhbHMoeCkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBJRW51bWVyYWJsZTxUdXBsZTxpbnQsIGludCwgVD4+IEVudW1lcmF0ZU5vblplcm9JbmRleGVkKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gRGF0YVtpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyh4KSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHJldHVybiBuZXcgVHVwbGU8aW50LCBpbnQsIFQ+KGksIGosIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGSU5EXHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBUdXBsZTxpbnQsIGludCwgVD4gRmluZChGdW5jPFQsIGJvb2w+IHByZWRpY2F0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoRGF0YVtpXSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IHJvdywgY29sdW1uO1xyXG4gICAgICAgICAgICAgICAgICAgIFJvd0NvbHVtbkF0SW5kZXgoaSwgb3V0IHJvdywgb3V0IGNvbHVtbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVD4ocm93LCBjb2x1bW4sIERhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgVHVwbGU8aW50LCBpbnQsIFQsIFRPdGhlcj4gRmluZDJVbmNoZWNrZWQ8VE90aGVyPihNYXRyaXhTdG9yYWdlPFRPdGhlcj4gb3RoZXIsIEZ1bmM8VCwgVE90aGVyLCBib29sPiBwcmVkaWNhdGUsIFplcm9zIHplcm9zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlT3RoZXIgPSBvdGhlciBhcyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUT3RoZXI+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUT3RoZXJbXSBvdGhlckRhdGEgPSBkZW5zZU90aGVyLkRhdGE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShEYXRhW2ldLCBvdGhlckRhdGFbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50IHJvdywgY29sdW1uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBSb3dDb2x1bW5BdEluZGV4KGksIG91dCByb3csIG91dCBjb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgaW50LCBULCBUT3RoZXI+KHJvdywgY29sdW1uLCBEYXRhW2ldLCBvdGhlckRhdGFbaV0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRpYWdvbmFsT3RoZXIgPSBvdGhlciBhcyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VE90aGVyPjtcclxuICAgICAgICAgICAgaWYgKGRpYWdvbmFsT3RoZXIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVE90aGVyW10gb3RoZXJEYXRhID0gZGlhZ29uYWxPdGhlci5EYXRhO1xyXG4gICAgICAgICAgICAgICAgVE90aGVyIG90aGVyWmVybyA9IEJ1aWxkZXJJbnN0YW5jZTxUT3RoZXI+Lk1hdHJpeC5aZXJvO1xyXG4gICAgICAgICAgICAgICAgaW50IGsgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoRGF0YVtrXSwgaSA9PSBqID8gb3RoZXJEYXRhW2ldIDogb3RoZXJaZXJvKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVCwgVE90aGVyPihpLCBqLCBEYXRhW2tdLCBpID09IGogPyBvdGhlckRhdGFbaV0gOiBvdGhlclplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNwYXJzZU90aGVyID0gb3RoZXIgYXMgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VE90aGVyPjtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZU90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludFtdIG90aGVyUm93UG9pbnRlcnMgPSBzcGFyc2VPdGhlci5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgICAgIGludFtdIG90aGVyQ29sdW1uSW5kaWNlcyA9IHNwYXJzZU90aGVyLkNvbHVtbkluZGljZXM7XHJcbiAgICAgICAgICAgICAgICBUT3RoZXJbXSBvdGhlclZhbHVlcyA9IHNwYXJzZU90aGVyLlZhbHVlcztcclxuICAgICAgICAgICAgICAgIFRPdGhlciBvdGhlclplcm8gPSBCdWlsZGVySW5zdGFuY2U8VE90aGVyPi5NYXRyaXguWmVybztcclxuICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBjb2wgPSAwOyBjb2wgPCBDb2x1bW5Db3VudDsgY29sKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoayA8IG90aGVyUm93UG9pbnRlcnNbcm93ICsgMV0gJiYgb3RoZXJDb2x1bW5JbmRpY2VzW2tdID09IGNvbClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShEYXRhW2NvbCpSb3dDb3VudCArIHJvd10sIG90aGVyVmFsdWVzW2tdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgaW50LCBULCBUT3RoZXI+KHJvdywgY29sLCBEYXRhW2NvbCpSb3dDb3VudCArIHJvd10sIG90aGVyVmFsdWVzW2tdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoRGF0YVtjb2wqUm93Q291bnQgKyByb3ddLCBvdGhlclplcm8pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGU8aW50LCBpbnQsIFQsIFRPdGhlcj4ocm93LCBjb2wsIERhdGFbY29sKlJvd0NvdW50ICsgcm93XSwgb3RoZXJWYWx1ZXNba10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJhc2UuRmluZDJVbmNoZWNrZWQ8VE90aGVyPihvdGhlciwgKEZ1bmM8VCxUT3RoZXIsYm9vbD4pcHJlZGljYXRlLCB6ZXJvcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGVU5DVElPTkFMIENPTUJJTkFUT1JTOiBNQVBcclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgTWFwSW5wbGFjZShGdW5jPFQsIFQ+IGYsIFplcm9zIHplcm9zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRGF0YVtpXSA9IGYoRGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBNYXBJbmRleGVkSW5wbGFjZShGdW5jPGludCwgaW50LCBULCBUPiBmLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaW50IGluZGV4ID0gMCpSb3dDb3VudDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEYXRhW2luZGV4XSA9IGYoaSwgaiwgRGF0YVtpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIE1hcFRvVW5jaGVja2VkPFRVPihNYXRyaXhTdG9yYWdlPFRVPiB0YXJnZXQsIEZ1bmM8VCwgVFU+IGYsXHJcbiAgICAgICAgICAgIFplcm9zIHplcm9zLCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFRVPjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlVGFyZ2V0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNlVGFyZ2V0LkRhdGFbaV0gPSBmKERhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIGludCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5BdChpLCBqLCBmKERhdGFbaW5kZXgrK10pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBNYXBJbmRleGVkVG9VbmNoZWNrZWQ8VFU+KE1hdHJpeFN0b3JhZ2U8VFU+IHRhcmdldCwgRnVuYzxpbnQsIGludCwgVCwgVFU+IGYsXHJcbiAgICAgICAgICAgIFplcm9zIHplcm9zLCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFRVPjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlVGFyZ2V0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGludCBpbmRleCA9IDAqUm93Q291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW5zZVRhcmdldC5EYXRhW2luZGV4XSA9IGYoaSwgaiwgRGF0YVtpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIGludCBpbmRleDIgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQoaSwgaiwgZihpLCBqLCBEYXRhW2luZGV4MisrXSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIE1hcFN1Yk1hdHJpeEluZGV4ZWRUb1VuY2hlY2tlZDxUVT4oTWF0cml4U3RvcmFnZTxUVT4gdGFyZ2V0LCBGdW5jPGludCwgaW50LCBULCBUVT4gZixcclxuICAgICAgICAgICAgaW50IHNvdXJjZVJvd0luZGV4LCBpbnQgdGFyZ2V0Um93SW5kZXgsIGludCByb3dDb3VudCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZUNvbHVtbkluZGV4LCBpbnQgdGFyZ2V0Q29sdW1uSW5kZXgsIGludCBjb2x1bW5Db3VudCxcclxuICAgICAgICAgICAgWmVyb3MgemVyb3MsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VUYXJnZXQgPSB0YXJnZXQgYXMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VFU+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBjb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50IHNvdXJjZUluZGV4ID0gc291cmNlUm93SW5kZXggKyAoaiArIHNvdXJjZUNvbHVtbkluZGV4KSpSb3dDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50IHRhcmdldEluZGV4ID0gdGFyZ2V0Um93SW5kZXggKyAoaiArIHRhcmdldENvbHVtbkluZGV4KSp0YXJnZXQuUm93Q291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVuc2VUYXJnZXQuRGF0YVt0YXJnZXRJbmRleCsrXSA9IGYodGFyZ2V0Um93SW5kZXggKyBpLCB0YXJnZXRDb2x1bW5JbmRleCArIGosIERhdGFbc291cmNlSW5kZXgrK10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IFByb3BlciBTcGFyc2UgSW1wbGVtZW50YXRpb25cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IHNvdXJjZUNvbHVtbkluZGV4LCBqaiA9IHRhcmdldENvbHVtbkluZGV4OyBqIDwgc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudDsgaisrLCBqaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgaW5kZXggPSBzb3VyY2VSb3dJbmRleCArIGoqUm93Q291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpaSA9IHRhcmdldFJvd0luZGV4OyBpaSA8IHRhcmdldFJvd0luZGV4ICsgcm93Q291bnQ7IGlpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkF0KGlpLCBqaiwgZihpaSwgamosIERhdGFbaW5kZXgrK10pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRlVOQ1RJT05BTCBDT01CSU5BVE9SUzogRk9MRFxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEZvbGRCeVJvd1VuY2hlY2tlZDxUVT4oVFVbXSB0YXJnZXQsIEZ1bmM8VFUsIFQsIFRVPiBmLCBGdW5jPFRVLCBpbnQsIFRVPiBmaW5hbGl6ZSwgVFVbXSBzdGF0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRVIHMgPSBzdGF0ZVtpXTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gZihzLCBEYXRhW2oqUm93Q291bnQgKyBpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBmaW5hbGl6ZShzLCBDb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgRm9sZEJ5Q29sdW1uVW5jaGVja2VkPFRVPihUVVtdIHRhcmdldCwgRnVuYzxUVSwgVCwgVFU+IGYsIEZ1bmM8VFUsIGludCwgVFU+IGZpbmFsaXplLCBUVVtdIHN0YXRlLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IG9mZnNldCA9IGoqUm93Q291bnQ7XHJcbiAgICAgICAgICAgICAgICBUVSBzID0gc3RhdGVbal07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IGYocywgRGF0YVtvZmZzZXQgKyBpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRbal0gPSBmaW5hbGl6ZShzLCBSb3dDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIFRTdGF0ZSBGb2xkMlVuY2hlY2tlZDxUT3RoZXIsIFRTdGF0ZT4oTWF0cml4U3RvcmFnZTxUT3RoZXI+IG90aGVyLCBGdW5jPFRTdGF0ZSwgVCwgVE90aGVyLCBUU3RhdGU+IGYsIFRTdGF0ZSBzdGF0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VPdGhlciA9IG90aGVyIGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFRPdGhlcj47XHJcbiAgICAgICAgICAgIGlmIChkZW5zZU90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRPdGhlcltdIG90aGVyRGF0YSA9IGRlbnNlT3RoZXIuRGF0YTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGYoc3RhdGUsIERhdGFbaV0sIG90aGVyRGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkaWFnb25hbE90aGVyID0gb3RoZXIgYXMgRGlhZ29uYWxNYXRyaXhTdG9yYWdlPFRPdGhlcj47XHJcbiAgICAgICAgICAgIGlmIChkaWFnb25hbE90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRPdGhlcltdIG90aGVyRGF0YSA9IGRpYWdvbmFsT3RoZXIuRGF0YTtcclxuICAgICAgICAgICAgICAgIFRPdGhlciBvdGhlclplcm8gPSBCdWlsZGVySW5zdGFuY2U8VE90aGVyPi5NYXRyaXguWmVybztcclxuICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGYoc3RhdGUsIERhdGFba10sIGkgPT0gaiA/IG90aGVyRGF0YVtpXSA6IG90aGVyWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VPdGhlciA9IG90aGVyIGFzIFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFRPdGhlcj47XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnRbXSBvdGhlclJvd1BvaW50ZXJzID0gc3BhcnNlT3RoZXIuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgICAgICBpbnRbXSBvdGhlckNvbHVtbkluZGljZXMgPSBzcGFyc2VPdGhlci5Db2x1bW5JbmRpY2VzO1xyXG4gICAgICAgICAgICAgICAgVE90aGVyW10gb3RoZXJWYWx1ZXMgPSBzcGFyc2VPdGhlci5WYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICBUT3RoZXIgb3RoZXJaZXJvID0gQnVpbGRlckluc3RhbmNlPFRPdGhlcj4uTWF0cml4Llplcm87XHJcbiAgICAgICAgICAgICAgICBpbnQgayA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgY29sID0gMDsgY29sIDwgQ29sdW1uQ291bnQ7IGNvbCsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGsgPCBvdGhlclJvd1BvaW50ZXJzW3JvdyArIDFdICYmIG90aGVyQ29sdW1uSW5kaWNlc1trXSA9PSBjb2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgRGF0YVtjb2wqUm93Q291bnQgKyByb3ddLCBvdGhlclZhbHVlc1trKytdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgRGF0YVtjb2wqUm93Q291bnQgKyByb3ddLCBvdGhlclplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlLkZvbGQyVW5jaGVja2VkPFRPdGhlcixUU3RhdGU+KG90aGVyLCAoRnVuYzxUU3RhdGUsVCxUT3RoZXIsVFN0YXRlPilmLCBzdGF0ZSwgemVyb3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvLyA8Y29weXJpZ2h0IGZpbGU9XCJEZW5zZVZlY3RvclN0b3JhZ2UuY3NcIiBjb21wYW55PVwiTWF0aC5ORVRcIj5cclxuLy8gTWF0aC5ORVQgTnVtZXJpY3MsIHBhcnQgb2YgdGhlIE1hdGguTkVUIFByb2plY3RcclxuLy8gaHR0cDovL251bWVyaWNzLm1hdGhkb3RuZXQuY29tXHJcbi8vIGh0dHA6Ly9naXRodWIuY29tL21hdGhuZXQvbWF0aG5ldC1udW1lcmljc1xyXG4vL1xyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNSBNYXRoLk5FVFxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxyXG4vLyBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4vLyBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuLy8gcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXHJcbi8vIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4vLyBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xyXG4vLyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4vLyBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXHJcbi8vIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbi8vIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXHJcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxyXG4vLyBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4vLyBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbi8vIDwvY29weXJpZ2h0PlxyXG5cclxudXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkRvdWJsZS5NYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmE7XHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5MaW5xO1xyXG51c2luZyBTeXN0ZW0uUnVudGltZS5TZXJpYWxpemF0aW9uO1xyXG5cclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuU3RvcmFnZVxyXG57XHJcbiAgICBbU2VyaWFsaXphYmxlXVxyXG4gICAgW0RhdGFDb250cmFjdChOYW1lc3BhY2UgPSBcInVybjpNYXRoTmV0L051bWVyaWNzL0xpbmVhckFsZ2VicmFcIildXHJcbiAgICBwdWJsaWMgY2xhc3MgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+IDogVmVjdG9yU3RvcmFnZTxUPlxyXG4gICAgICAgIHdoZXJlIFQgOiBzdHJ1Y3QsIElFcXVhdGFibGU8VD4sIElGb3JtYXR0YWJsZVxyXG4gICAge1xyXG4gICAgICAgIC8vIFtydWVnZ10gcHVibGljIGZpZWxkcyBhcmUgT0sgaGVyZVxyXG5cclxuICAgICAgICBbRGF0YU1lbWJlcihPcmRlciA9IDEpXVxyXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBUW10gRGF0YTtcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgRGVuc2VWZWN0b3JTdG9yYWdlKGludCBsZW5ndGgpXHJcbiAgICAgICAgICAgIDogYmFzZShsZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEYXRhID0gbmV3IFRbbGVuZ3RoXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIERlbnNlVmVjdG9yU3RvcmFnZShpbnQgbGVuZ3RoLCBUW10gZGF0YSlcclxuICAgICAgICAgICAgOiBiYXNlKGxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJkYXRhXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5MZW5ndGggIT0gbGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiZGF0YVwiLCBzdHJpbmcuRm9ybWF0KFwiUmVzb3VyY2VzLkFyZ3VtZW50QXJyYXlXcm9uZ0xlbmd0aCB7MH1cIiwgbGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERhdGEgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUcnVlIGlmIHRoZSB2ZWN0b3Igc3RvcmFnZSBmb3JtYXQgaXMgZGVuc2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBJc0RlbnNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXRyaWV2ZXMgdGhlIHJlcXVlc3RlZCBlbGVtZW50IHdpdGhvdXQgcmFuZ2UgY2hlY2tpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVCBBdChpbnQgaW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRGF0YVtpbmRleF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldHMgdGhlIGVsZW1lbnQgd2l0aG91dCByYW5nZSBjaGVja2luZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIEF0KGludCBpbmRleCwgVCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERhdGFbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDTEVBUklOR1xyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBDbGVhcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBcnJheS5DbGVhcjxUPihEYXRhLCAwLCBEYXRhLkxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBDbGVhcihpbnQgaW5kZXgsIGludCBjb3VudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFycmF5LkNsZWFyPFQ+KERhdGEsIGluZGV4LCBjb3VudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJTklUSUFMSVpBVElPTlxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlVmVjdG9yU3RvcmFnZTxUPiBPZlZlY3RvcihWZWN0b3JTdG9yYWdlPFQ+IHZlY3RvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IERlbnNlVmVjdG9yU3RvcmFnZTxUPih2ZWN0b3IuTGVuZ3RoKTtcclxuICAgICAgICAgICAgdmVjdG9yLkNvcHlUb1VuY2hlY2tlZChzdG9yYWdlLCBFeGlzdGluZ0RhdGEuQXNzdW1lWmVyb3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+IE9mVmFsdWUoaW50IGxlbmd0aCwgVCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwibGVuZ3RoXCIsIHN0cmluZy5Gb3JtYXQoXCJSZXNvdXJjZXMuQXJndW1lbnRMZXNzVGhhbk9uZVwiLCBsZW5ndGgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgVFtsZW5ndGhdO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgZGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhW2ldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+KGxlbmd0aCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlVmVjdG9yU3RvcmFnZTxUPiBPZkluaXQoaW50IGxlbmd0aCwgRnVuYzxpbnQsIFQ+IGluaXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDwgMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImxlbmd0aFwiLCBzdHJpbmcuRm9ybWF0KFwiUmVzb3VyY2VzLkFyZ3VtZW50TGVzc1RoYW5PbmUsezB9XCIsIGxlbmd0aCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBUW2xlbmd0aF07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBkYXRhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBpbml0KGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZVZlY3RvclN0b3JhZ2U8VD4obGVuZ3RoLCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+IE9mRW51bWVyYWJsZShJRW51bWVyYWJsZTxUPiBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImRhdGFcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBhcnJheURhdGEgPSBkYXRhIGFzIFRbXTtcclxuICAgICAgICAgICAgaWYgKGFycmF5RGF0YSAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29weSA9IG5ldyBUW2FycmF5RGF0YS5MZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ29weShhcnJheURhdGEsIDAsIGNvcHksIDAsIGFycmF5RGF0YS5MZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZVZlY3RvclN0b3JhZ2U8VD4oY29weS5MZW5ndGgsIGNvcHkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlRvQXJyYXk8VD4oZGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+KGFycmF5Lkxlbmd0aCwgYXJyYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZVZlY3RvclN0b3JhZ2U8VD4gT2ZJbmRleGVkRW51bWVyYWJsZShpbnQgbGVuZ3RoLCBJRW51bWVyYWJsZTxUdXBsZTxpbnQsIFQ+PiBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImRhdGFcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBUW2xlbmd0aF07XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKHZhciBpdGVtIGluIGRhdGEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFycmF5W2l0ZW0uSXRlbTFdID0gaXRlbS5JdGVtMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlVmVjdG9yU3RvcmFnZTxUPihhcnJheS5MZW5ndGgsIGFycmF5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFZFQ1RPUiBDT1BZXHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgQ29weVRvVW5jaGVja2VkKFZlY3RvclN0b3JhZ2U8VD4gdGFyZ2V0LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIERlbnNlVmVjdG9yU3RvcmFnZTxUPjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlVGFyZ2V0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghUmVmZXJlbmNlRXF1YWxzKHRoaXMsIGRlbnNlVGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBBcnJheS5Db3B5KERhdGEsIDAsIGRlbnNlVGFyZ2V0LkRhdGEsIDAsIERhdGEuTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VUYXJnZXQgPSB0YXJnZXQgYXMgU3BhcnNlVmVjdG9yU3RvcmFnZTxUPjtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyBMaXN0PGludD4oKTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgTGlzdDxUPigpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IERhdGFbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyhpdGVtKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5BZGQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXMuQWRkKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzcGFyc2VUYXJnZXQuSW5kaWNlcyA9IGluZGljZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgc3BhcnNlVGFyZ2V0LlZhbHVlcyA9IHZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBzcGFyc2VUYXJnZXQuVmFsdWVDb3VudCA9IHZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRkFMTCBCQUNLXHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5BdChpLCBEYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUk9XIENPUFlcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBDb3B5VG9Sb3dVbmNoZWNrZWQoTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsIGludCByb3dJbmRleCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZVRhcmdldCA9IHRhcmdldCBhcyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlVGFyZ2V0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgRGF0YS5MZW5ndGg7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkZW5zZVRhcmdldC5EYXRhW2oqdGFyZ2V0LlJvd0NvdW50ICsgcm93SW5kZXhdID0gRGF0YVtqXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRkFMTCBCQUNLXHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IExlbmd0aDsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQXQocm93SW5kZXgsIGosIERhdGFbal0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDT0xVTU4gQ09QWVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIENvcHlUb0NvbHVtblVuY2hlY2tlZChNYXRyaXhTdG9yYWdlPFQ+IHRhcmdldCwgaW50IGNvbHVtbkluZGV4LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ29weShEYXRhLCAwLCBkZW5zZVRhcmdldC5EYXRhLCBjb2x1bW5JbmRleCpkZW5zZVRhcmdldC5Sb3dDb3VudCwgRGF0YS5MZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5BdChpLCBjb2x1bW5JbmRleCwgRGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNVQi1WRUNUT1IgQ09QWVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIENvcHlTdWJWZWN0b3JUb1VuY2hlY2tlZChWZWN0b3JTdG9yYWdlPFQ+IHRhcmdldCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZUluZGV4LCBpbnQgdGFyZ2V0SW5kZXgsIGludCBjb3VudCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZVRhcmdldCA9IHRhcmdldCBhcyBEZW5zZVZlY3RvclN0b3JhZ2U8VD47XHJcbiAgICAgICAgICAgIGlmIChkZW5zZVRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KERhdGEsIHNvdXJjZUluZGV4LCBkZW5zZVRhcmdldC5EYXRhLCB0YXJnZXRJbmRleCwgY291bnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIGJhc2UuQ29weVN1YlZlY3RvclRvVW5jaGVja2VkKHRhcmdldCwgc291cmNlSW5kZXgsIHRhcmdldEluZGV4LCBjb3VudCwgZXhpc3RpbmdEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNVQi1ST1cgQ09QWVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIENvcHlUb1N1YlJvd1VuY2hlY2tlZChNYXRyaXhTdG9yYWdlPFQ+IHRhcmdldCwgaW50IHJvd0luZGV4LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlQ29sdW1uSW5kZXgsIGludCB0YXJnZXRDb2x1bW5JbmRleCwgaW50IGNvbHVtbkNvdW50LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBEYXRhLkxlbmd0aDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbnNlVGFyZ2V0LkRhdGFbKGogKyB0YXJnZXRDb2x1bW5JbmRleCkqdGFyZ2V0LlJvd0NvdW50ICsgcm93SW5kZXhdID0gRGF0YVtqICsgc291cmNlQ29sdW1uSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSBzb3VyY2VDb2x1bW5JbmRleCwgamogPSB0YXJnZXRDb2x1bW5JbmRleDsgaiA8IHNvdXJjZUNvbHVtbkluZGV4ICsgY29sdW1uQ291bnQ7IGorKywgamorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkF0KHJvd0luZGV4LCBqaiwgRGF0YVtqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNVQi1DT0xVTU4gQ09QWVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIENvcHlUb1N1YkNvbHVtblVuY2hlY2tlZChNYXRyaXhTdG9yYWdlPFQ+IHRhcmdldCwgaW50IGNvbHVtbkluZGV4LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlUm93SW5kZXgsIGludCB0YXJnZXRSb3dJbmRleCwgaW50IHJvd0NvdW50LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ29weShEYXRhLCBzb3VyY2VSb3dJbmRleCwgZGVuc2VUYXJnZXQuRGF0YSwgY29sdW1uSW5kZXgqZGVuc2VUYXJnZXQuUm93Q291bnQgKyB0YXJnZXRSb3dJbmRleCwgcm93Q291bnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBzb3VyY2VSb3dJbmRleCwgaWkgPSB0YXJnZXRSb3dJbmRleDsgaSA8IHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQ7IGkrKywgaWkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkF0KGlpLCBjb2x1bW5JbmRleCwgRGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVYVFJBQ1RcclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFRbXSBUb0FycmF5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSBuZXcgVFtEYXRhLkxlbmd0aF07XHJcbiAgICAgICAgICAgIEFycmF5LkNvcHkoRGF0YSwgMCwgcmV0LCAwLCBEYXRhLkxlbmd0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVFtdIEFzQXJyYXkoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIERhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFTlVNRVJBVElPTlxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgSUVudW1lcmFibGU8VD4gRW51bWVyYXRlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBEYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIElFbnVtZXJhYmxlPFR1cGxlPGludCwgVD4+IEVudW1lcmF0ZUluZGV4ZWQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN5c3RlbS5MaW5xLkVudW1lcmFibGUuU2VsZWN0PFQsVHVwbGU8aW50LFQ+PihEYXRhLChGdW5jPFQsaW50LFR1cGxlPGludCxUPj4pKCh0LCBpKSA9PiBuZXcgVHVwbGU8aW50LCBUPihpLCB0KSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIElFbnVtZXJhYmxlPFQ+IEVudW1lcmF0ZU5vblplcm8oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN5c3RlbS5MaW5xLkVudW1lcmFibGUuV2hlcmU8VD4oRGF0YSwoRnVuYzxULGJvb2w+KSh4ID0+ICFaZXJvLkVxdWFscyh4KSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIElFbnVtZXJhYmxlPFR1cGxlPGludCwgVD4+IEVudW1lcmF0ZU5vblplcm9JbmRleGVkKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyhEYXRhW2ldKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCByZXR1cm4gbmV3IFR1cGxlPGludCwgVD4oaSwgRGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZJTkRcclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFR1cGxlPGludCwgVD4gRmluZChGdW5jPFQsIGJvb2w+IHByZWRpY2F0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoRGF0YVtpXSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIFQ+KGksIERhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgVHVwbGU8aW50LCBULCBUT3RoZXI+IEZpbmQyVW5jaGVja2VkPFRPdGhlcj4oVmVjdG9yU3RvcmFnZTxUT3RoZXI+IG90aGVyLCBGdW5jPFQsIFRPdGhlciwgYm9vbD4gcHJlZGljYXRlLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZU90aGVyID0gb3RoZXIgYXMgRGVuc2VWZWN0b3JTdG9yYWdlPFRPdGhlcj47XHJcbiAgICAgICAgICAgIGlmIChkZW5zZU90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRPdGhlcltdIG90aGVyRGF0YSA9IGRlbnNlT3RoZXIuRGF0YTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKERhdGFbaV0sIG90aGVyRGF0YVtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgVCwgVE90aGVyPihpLCBEYXRhW2ldLCBvdGhlckRhdGFbaV0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNwYXJzZU90aGVyID0gb3RoZXIgYXMgU3BhcnNlVmVjdG9yU3RvcmFnZTxUT3RoZXI+O1xyXG4gICAgICAgICAgICBpZiAoc3BhcnNlT3RoZXIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50W10gb3RoZXJJbmRpY2VzID0gc3BhcnNlT3RoZXIuSW5kaWNlcztcclxuICAgICAgICAgICAgICAgIFRPdGhlcltdIG90aGVyVmFsdWVzID0gc3BhcnNlT3RoZXIuVmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgaW50IG90aGVyVmFsdWVDb3VudCA9IHNwYXJzZU90aGVyLlZhbHVlQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBUT3RoZXIgb3RoZXJaZXJvID0gQnVpbGRlckluc3RhbmNlPFRPdGhlcj4uTWF0cml4Llplcm87XHJcbiAgICAgICAgICAgICAgICBpbnQgayA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgPCBvdGhlclZhbHVlQ291bnQgJiYgb3RoZXJJbmRpY2VzW2tdID09IGkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKERhdGFbaV0sIG90aGVyVmFsdWVzW2tdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIFQsIFRPdGhlcj4oaSwgRGF0YVtpXSwgb3RoZXJWYWx1ZXNba10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShEYXRhW2ldLCBvdGhlclplcm8pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgVCwgVE90aGVyPihpLCBEYXRhW2ldLCBvdGhlclplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTExCQUNLXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5GaW5kMlVuY2hlY2tlZDxUT3RoZXI+KG90aGVyLCAoRnVuYzxULFRPdGhlcixib29sPilwcmVkaWNhdGUsIHplcm9zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZVTkNUSU9OQUwgQ09NQklOQVRPUlM6IE1BUFxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBNYXBJbnBsYWNlKEZ1bmM8VCwgVD4gZiwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBEYXRhW2ldID0gZihEYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBNYXBJbmRleGVkSW5wbGFjZShGdW5jPGludCwgVCwgVD4gZiwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBEYXRhW2ldID0gZihpLCBEYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIE1hcFRvVW5jaGVja2VkPFRVPihWZWN0b3JTdG9yYWdlPFRVPiB0YXJnZXQsIEZ1bmM8VCwgVFU+IGYsIFplcm9zIHplcm9zLCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIERlbnNlVmVjdG9yU3RvcmFnZTxUVT47XHJcbiAgICAgICAgICAgIGlmIChkZW5zZVRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0wOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNlVGFyZ2V0LkRhdGFbaV0gPSBmKERhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5BdChpLCBmKERhdGFbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBNYXBJbmRleGVkVG9VbmNoZWNrZWQ8VFU+KFZlY3RvclN0b3JhZ2U8VFU+IHRhcmdldCwgRnVuYzxpbnQsIFQsIFRVPiBmLCBaZXJvcyB6ZXJvcywgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZVRhcmdldCA9IHRhcmdldCBhcyBEZW5zZVZlY3RvclN0b3JhZ2U8VFU+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBEYXRhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVuc2VUYXJnZXQuRGF0YVtpXSA9IGYoaSwgRGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkF0KGksIGYoaSwgRGF0YVtpXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIE1hcDJUb1VuY2hlY2tlZChWZWN0b3JTdG9yYWdlPFQ+IHRhcmdldCwgVmVjdG9yU3RvcmFnZTxUPiBvdGhlciwgRnVuYzxULCBULCBUPiBmLCBaZXJvcyB6ZXJvcywgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgaXMgU3BhcnNlVmVjdG9yU3RvcmFnZTxUPilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlIHRvIGRlbnNlIHRhcmdldCBhdCBmaXJzdCwgc2luY2UgdGhlIG9wZXJhdGlvbiBpc1xyXG4gICAgICAgICAgICAgICAgLy8gZWZmZWN0aXZlbHkgZGVuc2UgYW55d2F5IGJlY2F1c2UgYXQgbGVhc3Qgb25lIG9wZXJhbmQgaXMgZGVuc2VcclxuICAgICAgICAgICAgICAgIHZhciBpbnRlcm1lZGlhdGUgPSBuZXcgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+KHRhcmdldC5MZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgTWFwMlRvVW5jaGVja2VkKGludGVybWVkaWF0ZSwgb3RoZXIsIChGdW5jPFQsVCxUPilmLCB6ZXJvcywgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZS5Db3B5VG8odGFyZ2V0LCBleGlzdGluZ0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGVuc2VUYXJnZXQgPSB0YXJnZXQgYXMgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VPdGhlciA9IG90aGVyIGFzIERlbnNlVmVjdG9yU3RvcmFnZTxUPjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlVGFyZ2V0ICE9IG51bGwgJiYgZGVuc2VPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5zZVRhcmdldC5EYXRhW2ldID0gZihEYXRhW2ldLCBkZW5zZU90aGVyLkRhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNwYXJzZU90aGVyID0gb3RoZXIgYXMgU3BhcnNlVmVjdG9yU3RvcmFnZTxUPjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlVGFyZ2V0ICE9IG51bGwgJiYgc3BhcnNlT3RoZXIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVFtdIHRhcmdldERhdGEgPSBkZW5zZVRhcmdldC5EYXRhO1xyXG4gICAgICAgICAgICAgICAgaW50W10gb3RoZXJJbmRpY2VzID0gc3BhcnNlT3RoZXIuSW5kaWNlcztcclxuICAgICAgICAgICAgICAgIFRbXSBvdGhlclZhbHVlcyA9IHNwYXJzZU90aGVyLlZhbHVlcztcclxuICAgICAgICAgICAgICAgIGludCBvdGhlclZhbHVlQ291bnQgPSBzcGFyc2VPdGhlci5WYWx1ZUNvdW50O1xyXG5cclxuICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoayA8IG90aGVyVmFsdWVDb3VudCAmJiBvdGhlckluZGljZXNba10gPT0gaSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldERhdGFbaV0gPSBmKERhdGFbaV0sIG90aGVyVmFsdWVzW2tdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXREYXRhW2ldID0gZihEYXRhW2ldLCBaZXJvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBiYXNlLk1hcDJUb1VuY2hlY2tlZCh0YXJnZXQsIG90aGVyLCAoRnVuYzxULFQsVD4pZiwgemVyb3MsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGVU5DVElPTkFMIENPTUJJTkFUT1JTOiBGT0xEXHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIFRTdGF0ZSBGb2xkMlVuY2hlY2tlZDxUT3RoZXIsIFRTdGF0ZT4oVmVjdG9yU3RvcmFnZTxUT3RoZXI+IG90aGVyLCBGdW5jPFRTdGF0ZSwgVCwgVE90aGVyLCBUU3RhdGU+IGYsIFRTdGF0ZSBzdGF0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VPdGhlciA9IG90aGVyIGFzIERlbnNlVmVjdG9yU3RvcmFnZTxUT3RoZXI+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJEYXRhID0gZGVuc2VPdGhlci5EYXRhO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBEYXRhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgRGF0YVtpXSwgb3RoZXJEYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VPdGhlciA9IG90aGVyIGFzIFNwYXJzZVZlY3RvclN0b3JhZ2U8VE90aGVyPjtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZU90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludFtdIG90aGVySW5kaWNlcyA9IHNwYXJzZU90aGVyLkluZGljZXM7XHJcbiAgICAgICAgICAgICAgICBUT3RoZXJbXSBvdGhlclZhbHVlcyA9IHNwYXJzZU90aGVyLlZhbHVlcztcclxuICAgICAgICAgICAgICAgIGludCBvdGhlclZhbHVlQ291bnQgPSBzcGFyc2VPdGhlci5WYWx1ZUNvdW50O1xyXG4gICAgICAgICAgICAgICAgVE90aGVyIG90aGVyWmVybyA9IEJ1aWxkZXJJbnN0YW5jZTxUT3RoZXI+LlZlY3Rvci5aZXJvO1xyXG5cclxuICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoayA8IG90aGVyVmFsdWVDb3VudCAmJiBvdGhlckluZGljZXNba10gPT0gaSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgRGF0YVtpXSwgb3RoZXJWYWx1ZXNba10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgRGF0YVtpXSwgb3RoZXJaZXJvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5Gb2xkMlVuY2hlY2tlZDxUT3RoZXIsVFN0YXRlPihvdGhlciwgKEZ1bmM8VFN0YXRlLFQsVE90aGVyLFRTdGF0ZT4pZiwgc3RhdGUsIHplcm9zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiRGlhZ29uYWxNYXRyaXhTdG9yYWdlLmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTUgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGUuTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhO1xyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uTGlucTtcclxudXNpbmcgU3lzdGVtLlJ1bnRpbWUuU2VyaWFsaXphdGlvbjtcclxuXHJcblxyXG5uYW1lc3BhY2UgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLlN0b3JhZ2Vcclxue1xyXG4gICAgW1NlcmlhbGl6YWJsZV1cclxuICAgIFtEYXRhQ29udHJhY3QoTmFtZXNwYWNlID0gXCJ1cm46TWF0aE5ldC9OdW1lcmljcy9MaW5lYXJBbGdlYnJhXCIpXVxyXG4gICAgcHVibGljIGNsYXNzIERpYWdvbmFsTWF0cml4U3RvcmFnZTxUPiA6IE1hdHJpeFN0b3JhZ2U8VD5cclxuICAgICAgICB3aGVyZSBUIDogc3RydWN0LCBJRXF1YXRhYmxlPFQ+LCBJRm9ybWF0dGFibGVcclxuICAgIHtcclxuICAgICAgICAvLyBbcnVlZ2ddIHB1YmxpYyBmaWVsZHMgYXJlIE9LIGhlcmVcclxuXHJcbiAgICAgICAgW0RhdGFNZW1iZXIoT3JkZXIgPSAxKV1cclxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgVFtdIERhdGE7XHJcblxyXG4gICAgICAgIGludGVybmFsIERpYWdvbmFsTWF0cml4U3RvcmFnZShpbnQgcm93cywgaW50IGNvbHVtbnMpXHJcbiAgICAgICAgICAgIDogYmFzZShyb3dzLCBjb2x1bW5zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGF0YSA9IG5ldyBUW01hdGguTWluKHJvd3MsIGNvbHVtbnMpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIERpYWdvbmFsTWF0cml4U3RvcmFnZShpbnQgcm93cywgaW50IGNvbHVtbnMsIFRbXSBkYXRhKVxyXG4gICAgICAgICAgICA6IGJhc2Uocm93cywgY29sdW1ucylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJkYXRhXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5MZW5ndGggIT0gTWF0aC5NaW4ocm93cywgY29sdW1ucykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJkYXRhXCIsIHN0cmluZy5Gb3JtYXQoXCJSZXNvdXJjZXMuQXJndW1lbnRBcnJheVdyb25nTGVuZ3RoXCIsIE1hdGguTWluKHJvd3MsIGNvbHVtbnMpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERhdGEgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUcnVlIGlmIHRoZSBtYXRyaXggc3RvcmFnZSBmb3JtYXQgaXMgZGVuc2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBJc0RlbnNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gZmFsc2U7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVHJ1ZSBpZiBhbGwgZmllbGRzIG9mIHRoaXMgbWF0cml4IGNhbiBiZSBzZXQgdG8gYW55IHZhbHVlLlxyXG4gICAgICAgIC8vLyBGYWxzZSBpZiBzb21lIGZpZWxkcyBhcmUgZml4ZWQsIGxpa2Ugb24gYSBkaWFnb25hbCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBJc0Z1bGx5TXV0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRydWUgaWYgdGhlIHNwZWNpZmllZCBmaWVsZCBjYW4gYmUgc2V0IHRvIGFueSB2YWx1ZS5cclxuICAgICAgICAvLy8gRmFsc2UgaWYgdGhlIGZpZWxkIGlzIGZpeGVkLCBsaWtlIGFuIG9mZi1kaWFnb25hbCBmaWVsZCBvbiBhIGRpYWdvbmFsIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBib29sIElzTXV0YWJsZUF0KGludCByb3csIGludCBjb2x1bW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gcm93ID09IGNvbHVtbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0cmlldmVzIHRoZSByZXF1ZXN0ZWQgZWxlbWVudCB3aXRob3V0IHJhbmdlIGNoZWNraW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFQgQXQoaW50IHJvdywgaW50IGNvbHVtbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiByb3cgPT0gY29sdW1uID8gRGF0YVtyb3ddIDogWmVybztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0cyB0aGUgZWxlbWVudCB3aXRob3V0IHJhbmdlIGNoZWNraW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgQXQoaW50IHJvdywgaW50IGNvbHVtbiwgVCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyb3cgPT0gY29sdW1uKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEYXRhW3Jvd10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghWmVyby5FcXVhbHModmFsdWUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5kZXhPdXRPZlJhbmdlRXhjZXB0aW9uKFwiQ2Fubm90IHNldCBhbiBvZmYtZGlhZ29uYWwgZWxlbWVudCBpbiBhIGRpYWdvbmFsIG1hdHJpeC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIGhhc2ggY29kZSBmb3IgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gQSBoYXNoIGNvZGUgZm9yIHRoaXMgaW5zdGFuY2UsIHN1aXRhYmxlIGZvciB1c2UgaW4gaGFzaGluZyBhbGdvcml0aG1zIGFuZCBkYXRhIHN0cnVjdHVyZXMgbGlrZSBhIGhhc2ggdGFibGUuXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IEdldEhhc2hDb2RlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBoYXNoTnVtID0gTWF0aC5NaW4oRGF0YS5MZW5ndGgsIDI1KTtcclxuICAgICAgICAgICAgaW50IGhhc2ggPSAxNztcclxuICAgICAgICAgICAgdW5jaGVja2VkXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaE51bTsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSBoYXNoKjMxICsgRGF0YVtpXS5HZXRIYXNoQ29kZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ0xFQVJJTkdcclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgQ2xlYXIoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQXJyYXkuQ2xlYXI8VD4oRGF0YSwgMCwgRGF0YS5MZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBDbGVhclVuY2hlY2tlZChpbnQgcm93SW5kZXgsIGludCByb3dDb3VudCwgaW50IGNvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgYmVnaW5JbmNsdXNpdmUgPSBNYXRoLk1heChyb3dJbmRleCwgY29sdW1uSW5kZXgpO1xyXG4gICAgICAgICAgICB2YXIgZW5kRXhjbHVzaXZlID0gTWF0aC5NaW4ocm93SW5kZXggKyByb3dDb3VudCwgY29sdW1uSW5kZXggKyBjb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIGlmIChlbmRFeGNsdXNpdmUgPiBiZWdpbkluY2x1c2l2ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ2xlYXI8VD4oRGF0YSwgYmVnaW5JbmNsdXNpdmUsIGVuZEV4Y2x1c2l2ZSAtIGJlZ2luSW5jbHVzaXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBDbGVhclJvd3NVbmNoZWNrZWQoaW50W10gcm93SW5kaWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcm93SW5kaWNlcy5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGF0YVtyb3dJbmRpY2VzW2ldXSA9IFplcm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgQ2xlYXJDb2x1bW5zVW5jaGVja2VkKGludFtdIGNvbHVtbkluZGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGNvbHVtbkluZGljZXMuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERhdGFbY29sdW1uSW5kaWNlc1tpXV0gPSBaZXJvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJTklUSUFMSVpBVElPTlxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERpYWdvbmFsTWF0cml4U3RvcmFnZTxUPiBPZk1hdHJpeChNYXRyaXhTdG9yYWdlPFQ+IG1hdHJpeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IERpYWdvbmFsTWF0cml4U3RvcmFnZTxUPihtYXRyaXguUm93Q291bnQsIG1hdHJpeC5Db2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIG1hdHJpeC5Db3B5VG9VbmNoZWNrZWQoc3RvcmFnZSwgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERpYWdvbmFsTWF0cml4U3RvcmFnZTxUPiBPZkFycmF5KFRbLF0gYXJyYXkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VD4oYXJyYXkuR2V0TGVuZ3RoKDApLCBhcnJheS5HZXRMZW5ndGgoMSkpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3JhZ2UuUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdG9yYWdlLkNvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gailcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UuRGF0YVtpXSA9IGFycmF5W2ksIGpdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghWmVyby5FcXVhbHMoYXJyYXlbaSwgal0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiQ2Fubm90IHNldCBhbiBvZmYtZGlhZ29uYWwgZWxlbWVudCBpbiBhIGRpYWdvbmFsIG1hdHJpeC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VD4gT2ZWYWx1ZShpbnQgcm93cywgaW50IGNvbHVtbnMsIFQgZGlhZ29uYWxWYWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IERpYWdvbmFsTWF0cml4U3RvcmFnZTxUPihyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yYWdlLkRhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2UuRGF0YVtpXSA9IGRpYWdvbmFsVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERpYWdvbmFsTWF0cml4U3RvcmFnZTxUPiBPZkluaXQoaW50IHJvd3MsIGludCBjb2x1bW5zLCBGdW5jPGludCwgVD4gaW5pdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IERpYWdvbmFsTWF0cml4U3RvcmFnZTxUPihyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yYWdlLkRhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2UuRGF0YVtpXSA9IGluaXQoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERpYWdvbmFsTWF0cml4U3RvcmFnZTxUPiBPZkVudW1lcmFibGUoaW50IHJvd3MsIGludCBjb2x1bW5zLCBJRW51bWVyYWJsZTxUPiBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImRhdGFcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBhcnJheURhdGEgPSBkYXRhIGFzIFRbXTtcclxuICAgICAgICAgICAgaWYgKGFycmF5RGF0YSAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29weSA9IG5ldyBUW2FycmF5RGF0YS5MZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ29weShhcnJheURhdGEsIDAsIGNvcHksIDAsIGFycmF5RGF0YS5MZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VD4ocm93cywgY29sdW1ucywgY29weSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGlhZ29uYWxNYXRyaXhTdG9yYWdlPFQ+KHJvd3MsIGNvbHVtbnMsIFN5c3RlbS5MaW5xLkVudW1lcmFibGUuVG9BcnJheTxUPihkYXRhKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERpYWdvbmFsTWF0cml4U3RvcmFnZTxUPiBPZkluZGV4ZWRFbnVtZXJhYmxlKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8VHVwbGU8aW50LCBUPj4gZGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJkYXRhXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VD4ocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKHZhciBpdGVtIGluIGRhdGEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2UuRGF0YVtpdGVtLkl0ZW0xXSA9IGl0ZW0uSXRlbTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNQVRSSVggQ09QWVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIENvcHlUb1VuY2hlY2tlZChNYXRyaXhTdG9yYWdlPFQ+IHRhcmdldCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkaWFnb25hbFRhcmdldCA9IHRhcmdldCBhcyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VD47XHJcbiAgICAgICAgICAgIGlmIChkaWFnb25hbFRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb3B5VG9VbmNoZWNrZWQoZGlhZ29uYWxUYXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGVuc2VUYXJnZXQgPSB0YXJnZXQgYXMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD47XHJcbiAgICAgICAgICAgIGlmIChkZW5zZVRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb3B5VG9VbmNoZWNrZWQoZGVuc2VUYXJnZXQsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VUYXJnZXQgPSB0YXJnZXQgYXMgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD47XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29weVRvVW5jaGVja2VkKHNwYXJzZVRhcmdldCwgZXhpc3RpbmdEYXRhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRkFMTCBCQUNLXHJcblxyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdEYXRhID09IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkF0KGksIGksIERhdGFbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2b2lkIENvcHlUb1VuY2hlY2tlZChEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9CdWZmZXIuQmxvY2tDb3B5KERhdGEsIDAsIHRhcmdldC5EYXRhLCAwLCBEYXRhLkxlbmd0aCAqIFN5c3RlbS5SdW50aW1lLkludGVyb3BTZXJ2aWNlcy5NYXJzaGFsLlNpemVPZih0eXBlb2YoVCkpKTtcclxuICAgICAgICAgICAgQXJyYXkuQ29weShEYXRhLCAwLCB0YXJnZXQuRGF0YSwgMCwgRGF0YS5MZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBDb3B5VG9VbmNoZWNrZWQoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRGF0YSA9PSBFeGlzdGluZ0RhdGEuQ2xlYXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5DbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5BdChpLCBpLCBEYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBDb3B5VG9VbmNoZWNrZWQoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRGF0YSA9PSBFeGlzdGluZ0RhdGEuQ2xlYXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5DbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5EYXRhW2kqKHRhcmdldC5Sb3dDb3VudCArIDEpXSA9IERhdGFbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlUm93SW5kZXgsIGludCB0YXJnZXRSb3dJbmRleCwgaW50IHJvd0NvdW50LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlQ29sdW1uSW5kZXgsIGludCB0YXJnZXRDb2x1bW5JbmRleCwgaW50IGNvbHVtbkNvdW50LFxyXG4gICAgICAgICAgICBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKGRlbnNlVGFyZ2V0LCBzb3VyY2VSb3dJbmRleCwgdGFyZ2V0Um93SW5kZXgsIHJvd0NvdW50LCBzb3VyY2VDb2x1bW5JbmRleCwgdGFyZ2V0Q29sdW1uSW5kZXgsIGNvbHVtbkNvdW50LCBleGlzdGluZ0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlhZ29uYWxUYXJnZXQgPSB0YXJnZXQgYXMgRGlhZ29uYWxNYXRyaXhTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWxUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKGRpYWdvbmFsVGFyZ2V0LCBzb3VyY2VSb3dJbmRleCwgdGFyZ2V0Um93SW5kZXgsIHJvd0NvdW50LCBzb3VyY2VDb2x1bW5JbmRleCwgdGFyZ2V0Q29sdW1uSW5kZXgsIGNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVE9ETzogUHJvcGVyIFNwYXJzZSBJbXBsZW1lbnRhdGlvblxyXG5cclxuICAgICAgICAgICAgLy8gRkFMTCBCQUNLXHJcblxyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdEYXRhID09IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkNsZWFyVW5jaGVja2VkKHRhcmdldFJvd0luZGV4LCByb3dDb3VudCwgdGFyZ2V0Q29sdW1uSW5kZXgsIGNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNvdXJjZVJvd0luZGV4ID09IHNvdXJjZUNvbHVtbkluZGV4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGguTWluKGNvbHVtbkNvdW50LCByb3dDb3VudCk7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQodGFyZ2V0Um93SW5kZXggKyBpLCB0YXJnZXRDb2x1bW5JbmRleCArIGksIERhdGFbc291cmNlUm93SW5kZXggKyBpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlUm93SW5kZXggPiBzb3VyY2VDb2x1bW5JbmRleCAmJiBzb3VyY2VDb2x1bW5JbmRleCArIGNvbHVtbkNvdW50ID4gc291cmNlUm93SW5kZXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbHVtbiBieSBjb2x1bW4sIGJ1dCBza2lwIHJlc3VsdGluZyB6ZXJvIGNvbHVtbnMgYXQgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAgICAgICAgaW50IGNvbHVtbkluaXQgPSBzb3VyY2VSb3dJbmRleCAtIHNvdXJjZUNvbHVtbkluZGV4O1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLk1pbihjb2x1bW5Db3VudCAtIGNvbHVtbkluaXQsIHJvd0NvdW50KTsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5BdCh0YXJnZXRSb3dJbmRleCArIGksIGNvbHVtbkluaXQgKyB0YXJnZXRDb2x1bW5JbmRleCArIGksIERhdGFbc291cmNlUm93SW5kZXggKyBpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlUm93SW5kZXggPCBzb3VyY2VDb2x1bW5JbmRleCAmJiBzb3VyY2VSb3dJbmRleCArIHJvd0NvdW50ID4gc291cmNlQ29sdW1uSW5kZXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIHJvdyBieSByb3csIGJ1dCBza2lwIHJlc3VsdGluZyB6ZXJvIHJvd3MgYXQgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAgICAgICAgaW50IHJvd0luaXQgPSBzb3VyY2VDb2x1bW5JbmRleCAtIHNvdXJjZVJvd0luZGV4O1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLk1pbihjb2x1bW5Db3VudCwgcm93Q291bnQgLSByb3dJbml0KTsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5BdChyb3dJbml0ICsgdGFyZ2V0Um93SW5kZXggKyBpLCB0YXJnZXRDb2x1bW5JbmRleCArIGksIERhdGFbc291cmNlQ29sdW1uSW5kZXggKyBpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKERpYWdvbmFsTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VSb3dJbmRleCwgaW50IHRhcmdldFJvd0luZGV4LCBpbnQgcm93Q291bnQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VDb2x1bW5JbmRleCwgaW50IHRhcmdldENvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoc291cmNlUm93SW5kZXggLSBzb3VyY2VDb2x1bW5JbmRleCAhPSB0YXJnZXRSb3dJbmRleCAtIHRhcmdldENvbHVtbkluZGV4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5Bbnk8VD4oRGF0YSwoRnVuYzxULGJvb2w+KSh4ID0+ICFaZXJvLkVxdWFscyh4KSkpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQ2xlYXJVbmNoZWNrZWQodGFyZ2V0Um93SW5kZXgsIHJvd0NvdW50LCB0YXJnZXRDb2x1bW5JbmRleCwgY29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgYmVnaW5JbmNsdXNpdmUgPSBNYXRoLk1heChzb3VyY2VSb3dJbmRleCwgc291cmNlQ29sdW1uSW5kZXgpO1xyXG4gICAgICAgICAgICB2YXIgZW5kRXhjbHVzaXZlID0gTWF0aC5NaW4oc291cmNlUm93SW5kZXggKyByb3dDb3VudCwgc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIGlmIChlbmRFeGNsdXNpdmUgPiBiZWdpbkluY2x1c2l2ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJlZ2luVGFyZ2V0ID0gTWF0aC5NYXgodGFyZ2V0Um93SW5kZXgsIHRhcmdldENvbHVtbkluZGV4KTtcclxuICAgICAgICAgICAgICAgIEFycmF5LkNvcHkoRGF0YSwgYmVnaW5JbmNsdXNpdmUsIHRhcmdldC5EYXRhLCBiZWdpblRhcmdldCwgZW5kRXhjbHVzaXZlIC0gYmVnaW5JbmNsdXNpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2b2lkIENvcHlTdWJNYXRyaXhUb1VuY2hlY2tlZChEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUPiB0YXJnZXQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VSb3dJbmRleCwgaW50IHRhcmdldFJvd0luZGV4LCBpbnQgcm93Q291bnQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VDb2x1bW5JbmRleCwgaW50IHRhcmdldENvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQsXHJcbiAgICAgICAgICAgIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdEYXRhID09IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkNsZWFyVW5jaGVja2VkKHRhcmdldFJvd0luZGV4LCByb3dDb3VudCwgdGFyZ2V0Q29sdW1uSW5kZXgsIGNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNvdXJjZVJvd0luZGV4ID4gc291cmNlQ29sdW1uSW5kZXggJiYgc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudCA+IHNvdXJjZVJvd0luZGV4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb2x1bW4gYnkgY29sdW1uLCBidXQgc2tpcCByZXN1bHRpbmcgemVybyBjb2x1bW5zIGF0IHRoZSBiZWdpbm5pbmdcclxuXHJcbiAgICAgICAgICAgICAgICBpbnQgY29sdW1uSW5pdCA9IHNvdXJjZVJvd0luZGV4IC0gc291cmNlQ29sdW1uSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpbnQgb2Zmc2V0ID0gKGNvbHVtbkluaXQgKyB0YXJnZXRDb2x1bW5JbmRleCkqdGFyZ2V0LlJvd0NvdW50ICsgdGFyZ2V0Um93SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpbnQgc3RlcCA9IHRhcmdldC5Sb3dDb3VudCArIDE7XHJcbiAgICAgICAgICAgICAgICBpbnQgZW5kID0gTWF0aC5NaW4oY29sdW1uQ291bnQgLSBjb2x1bW5Jbml0LCByb3dDb3VudCkgKyBzb3VyY2VSb3dJbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gc291cmNlUm93SW5kZXgsIGogPSBvZmZzZXQ7IGkgPCBlbmQ7IGkrKywgaiArPSBzdGVwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5EYXRhW2pdID0gRGF0YVtpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VSb3dJbmRleCA8IHNvdXJjZUNvbHVtbkluZGV4ICYmIHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQgPiBzb3VyY2VDb2x1bW5JbmRleClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gcm93IGJ5IHJvdywgYnV0IHNraXAgcmVzdWx0aW5nIHplcm8gcm93cyBhdCB0aGUgYmVnaW5uaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgaW50IHJvd0luaXQgPSBzb3VyY2VDb2x1bW5JbmRleCAtIHNvdXJjZVJvd0luZGV4O1xyXG4gICAgICAgICAgICAgICAgaW50IG9mZnNldCA9IHRhcmdldENvbHVtbkluZGV4KnRhcmdldC5Sb3dDb3VudCArIHJvd0luaXQgKyB0YXJnZXRSb3dJbmRleDtcclxuICAgICAgICAgICAgICAgIGludCBzdGVwID0gdGFyZ2V0LlJvd0NvdW50ICsgMTtcclxuICAgICAgICAgICAgICAgIGludCBlbmQgPSBNYXRoLk1pbihjb2x1bW5Db3VudCwgcm93Q291bnQgLSByb3dJbml0KSArIHNvdXJjZUNvbHVtbkluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSBzb3VyY2VDb2x1bW5JbmRleCwgaiA9IG9mZnNldDsgaSA8IGVuZDsgaSsrLCBqICs9IHN0ZXApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkRhdGFbal0gPSBEYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IG9mZnNldCA9IHRhcmdldENvbHVtbkluZGV4KnRhcmdldC5Sb3dDb3VudCArIHRhcmdldFJvd0luZGV4O1xyXG4gICAgICAgICAgICAgICAgaW50IHN0ZXAgPSB0YXJnZXQuUm93Q291bnQgKyAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IE1hdGguTWluKGNvbHVtbkNvdW50LCByb3dDb3VudCkgKyBzb3VyY2VSb3dJbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gc291cmNlUm93SW5kZXgsIGogPSBvZmZzZXQ7IGkgPCBlbmQ7IGkrKywgaiArPSBzdGVwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5EYXRhW2pdID0gRGF0YVtpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUk9XIENPUFlcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBDb3B5U3ViUm93VG9VbmNoZWNrZWQoVmVjdG9yU3RvcmFnZTxUPiB0YXJnZXQsIGludCByb3dJbmRleCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZUNvbHVtbkluZGV4LCBpbnQgdGFyZ2V0Q29sdW1uSW5kZXgsIGludCBjb2x1bW5Db3VudCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0RhdGEgPT0gRXhpc3RpbmdEYXRhLkNsZWFyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQ2xlYXIodGFyZ2V0Q29sdW1uSW5kZXgsIGNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJvd0luZGV4ID49IHNvdXJjZUNvbHVtbkluZGV4ICYmIHJvd0luZGV4IDwgc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudCAmJiByb3dJbmRleCA8IERhdGEuTGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQXQocm93SW5kZXggLSBzb3VyY2VDb2x1bW5JbmRleCArIHRhcmdldENvbHVtbkluZGV4LCBEYXRhW3Jvd0luZGV4XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENPTFVNTiBDT1BZXHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgQ29weVN1YkNvbHVtblRvVW5jaGVja2VkKFZlY3RvclN0b3JhZ2U8VD4gdGFyZ2V0LCBpbnQgY29sdW1uSW5kZXgsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VSb3dJbmRleCwgaW50IHRhcmdldFJvd0luZGV4LCBpbnQgcm93Q291bnQsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdEYXRhID09IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkNsZWFyKHRhcmdldFJvd0luZGV4LCByb3dDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb2x1bW5JbmRleCA+PSBzb3VyY2VSb3dJbmRleCAmJiBjb2x1bW5JbmRleCA8IHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQgJiYgY29sdW1uSW5kZXggPCBEYXRhLkxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkF0KGNvbHVtbkluZGV4IC0gc291cmNlUm93SW5kZXggKyB0YXJnZXRSb3dJbmRleCwgRGF0YVtjb2x1bW5JbmRleF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUUkFOU1BPU0VcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBUcmFuc3Bvc2VUb1VuY2hlY2tlZChNYXRyaXhTdG9yYWdlPFQ+IHRhcmdldCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvcHlUb1VuY2hlY2tlZCh0YXJnZXQsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFRyYW5zcG9zZVNxdWFyZUlucGxhY2VVbmNoZWNrZWQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRVhUUkFDVFxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVFtdIFRvUm93TWFqb3JBcnJheSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFRbUm93Q291bnQqQ29sdW1uQ291bnRdO1xyXG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gQ29sdW1uQ291bnQgKyAxO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldFtpKnN0cmlkZV0gPSBEYXRhW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVFtdIFRvQ29sdW1uTWFqb3JBcnJheSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFRbUm93Q291bnQqQ29sdW1uQ291bnRdO1xyXG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gUm93Q291bnQgKyAxO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldFtpKnN0cmlkZV0gPSBEYXRhW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVFtdW10gVG9Sb3dBcnJheXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBUW1Jvd0NvdW50XVtdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldFtpXSA9IG5ldyBUW0NvbHVtbkNvdW50XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldFtpXVtpXSA9IERhdGFbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBUW11bXSBUb0NvbHVtbkFycmF5cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFRbQ29sdW1uQ291bnRdW107XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0W2pdID0gbmV3IFRbUm93Q291bnRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0W2ldW2ldID0gRGF0YVtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFRbLF0gVG9BcnJheSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFRbUm93Q291bnQsIENvbHVtbkNvdW50XTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBEYXRhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXRbaSwgaV0gPSBEYXRhW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFTlVNRVJBVElPTlxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgSUVudW1lcmFibGU8VD4gRW51bWVyYXRlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBFUkY6IGNvbnNpZGVyIHRvIGJyZWFrIHVwIGxvb3AgdG8gYXZvaWQgYnJhbmNoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgcmV0dXJuIGkgPT0gaiA/IERhdGFbaV0gOiBaZXJvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgSUVudW1lcmFibGU8VHVwbGU8aW50LCBpbnQsIFQ+PiBFbnVtZXJhdGVJbmRleGVkKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBFUkY6IGNvbnNpZGVyIHRvIGJyZWFrIHVwIGxvb3AgdG8gYXZvaWQgYnJhbmNoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgcmV0dXJuIGkgPT0galxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBUdXBsZTxpbnQsIGludCwgVD4oaSwgaSwgRGF0YVtpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgVHVwbGU8aW50LCBpbnQsIFQ+KGksIGosIFplcm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgSUVudW1lcmFibGU8VD4gRW51bWVyYXRlTm9uWmVybygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5XaGVyZTxUPihEYXRhLChGdW5jPFQsYm9vbD4pKHggPT4gIVplcm8uRXF1YWxzKHgpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgSUVudW1lcmFibGU8VHVwbGU8aW50LCBpbnQsIFQ+PiBFbnVtZXJhdGVOb25aZXJvSW5kZXhlZCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoRGF0YVtpXSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVD4oaSwgaSwgRGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZJTkRcclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFR1cGxlPGludCwgaW50LCBUPiBGaW5kKEZ1bmM8VCwgYm9vbD4gcHJlZGljYXRlLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShEYXRhW2ldKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgaW50LCBUPihpLCBpLCBEYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoemVyb3MgPT0gWmVyb3MuSW5jbHVkZSAmJiAoUm93Q291bnQgPiAxIHx8IENvbHVtbkNvdW50ID4gMSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoWmVybykpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVD4oUm93Q291bnQgPiAxID8gMSA6IDAsIFJvd0NvdW50ID4gMSA/IDAgOiAxLCBaZXJvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIFR1cGxlPGludCwgaW50LCBULCBUT3RoZXI+IEZpbmQyVW5jaGVja2VkPFRPdGhlcj4oTWF0cml4U3RvcmFnZTxUT3RoZXI+IG90aGVyLCBGdW5jPFQsIFRPdGhlciwgYm9vbD4gcHJlZGljYXRlLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZU90aGVyID0gb3RoZXIgYXMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VE90aGVyPjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlT3RoZXIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVE90aGVyW10gb3RoZXJEYXRhID0gZGVuc2VPdGhlci5EYXRhO1xyXG4gICAgICAgICAgICAgICAgaW50IGsgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoaSA9PSBqID8gRGF0YVtpXSA6IFplcm8sIG90aGVyRGF0YVtrXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGU8aW50LCBpbnQsIFQsIFRPdGhlcj4oaSwgaiwgaSA9PSBqID8gRGF0YVtpXSA6IFplcm8sIG90aGVyRGF0YVtrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlhZ29uYWxPdGhlciA9IG90aGVyIGFzIERpYWdvbmFsTWF0cml4U3RvcmFnZTxUT3RoZXI+O1xyXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWxPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUT3RoZXJbXSBvdGhlckRhdGEgPSBkaWFnb25hbE90aGVyLkRhdGE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShEYXRhW2ldLCBvdGhlckRhdGFbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVCwgVE90aGVyPihpLCBpLCBEYXRhW2ldLCBvdGhlckRhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh6ZXJvcyA9PSBaZXJvcy5JbmNsdWRlICYmIChSb3dDb3VudCA+IDEgfHwgQ29sdW1uQ291bnQgPiAxKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBUT3RoZXIgb3RoZXJaZXJvID0gQnVpbGRlckluc3RhbmNlPFRPdGhlcj4uTWF0cml4Llplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShaZXJvLCBvdGhlclplcm8pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVCwgVE90aGVyPihSb3dDb3VudCA+IDEgPyAxIDogMCwgUm93Q291bnQgPiAxID8gMCA6IDEsIFplcm8sIG90aGVyWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VPdGhlciA9IG90aGVyIGFzIFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFRPdGhlcj47XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnRbXSBvdGhlclJvd1BvaW50ZXJzID0gc3BhcnNlT3RoZXIuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgICAgICBpbnRbXSBvdGhlckNvbHVtbkluZGljZXMgPSBzcGFyc2VPdGhlci5Db2x1bW5JbmRpY2VzO1xyXG4gICAgICAgICAgICAgICAgVE90aGVyW10gb3RoZXJWYWx1ZXMgPSBzcGFyc2VPdGhlci5WYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICBUT3RoZXIgb3RoZXJaZXJvID0gQnVpbGRlckluc3RhbmNlPFRPdGhlcj4uTWF0cml4Llplcm87XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9vbCBkaWFnb25hbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gb3RoZXJSb3dQb2ludGVyc1tyb3ddO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IG90aGVyUm93UG9pbnRlcnNbcm93ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0SW5kZXg7IGogPCBlbmRJbmRleDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyQ29sdW1uSW5kaWNlc1tqXSA9PSByb3cpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoRGF0YVtyb3ddLCBvdGhlclZhbHVlc1tqXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVCwgVE90aGVyPihyb3csIHJvdywgRGF0YVtyb3ddLCBvdGhlclZhbHVlc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKFplcm8sIG90aGVyVmFsdWVzW2pdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgaW50LCBULCBUT3RoZXI+KHJvdywgb3RoZXJDb2x1bW5JbmRpY2VzW2pdLCBaZXJvLCBvdGhlclZhbHVlc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWFnb25hbCAmJiByb3cgPCBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoRGF0YVtyb3ddLCBvdGhlclplcm8pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgaW50LCBULCBUT3RoZXI+KHJvdywgcm93LCBEYXRhW3Jvd10sIG90aGVyWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoemVyb3MgPT0gWmVyb3MuSW5jbHVkZSAmJiBzcGFyc2VPdGhlci5WYWx1ZUNvdW50IDwgKFJvd0NvdW50ICogQ29sdW1uQ291bnQpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoWmVybywgb3RoZXJaZXJvKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBjb2wgPSAwOyBjb2wgPCBDb2x1bW5Db3VudDsgY29sKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGsgPCBvdGhlclJvd1BvaW50ZXJzW3JvdyArIDFdICYmIG90aGVyQ29sdW1uSW5kaWNlc1trXSA9PSBjb2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJvdyAhPSBjb2wpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgaW50LCBULCBUT3RoZXI+KHJvdywgY29sLCBaZXJvLCBvdGhlclplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlLkZpbmQyVW5jaGVja2VkPFRPdGhlcj4ob3RoZXIsIChGdW5jPFQsVE90aGVyLGJvb2w+KXByZWRpY2F0ZSwgemVyb3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRlVOQ1RJT05BTCBDT01CSU5BVE9SUzogTUFQXHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIE1hcElucGxhY2UoRnVuYzxULCBUPiBmLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh6ZXJvcyA9PSBaZXJvcy5JbmNsdWRlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXhjZXB0aW9uKFwiQ2Fubm90IG1hcCBub24temVybyBvZmYtZGlhZ29uYWwgdmFsdWVzIGludG8gYSBkaWFnb25hbCBtYXRyaXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBEYXRhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIERhdGFbaV0gPSBmKERhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIE1hcEluZGV4ZWRJbnBsYWNlKEZ1bmM8aW50LCBpbnQsIFQsIFQ+IGYsIFplcm9zIHplcm9zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHplcm9zID09IFplcm9zLkluY2x1ZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFeGNlcHRpb24oXCJDYW5ub3QgbWFwIG5vbi16ZXJvIG9mZi1kaWFnb25hbCB2YWx1ZXMgaW50byBhIGRpYWdvbmFsIG1hdHJpeFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IERhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRGF0YVtpXSA9IGYoaSwgaSwgRGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBNYXBUb1VuY2hlY2tlZDxUVT4oTWF0cml4U3RvcmFnZTxUVT4gdGFyZ2V0LCBGdW5jPFQsIFRVPiBmLFxyXG4gICAgICAgICAgICBaZXJvcyB6ZXJvcywgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBwcm9jZXNzWmVyb3MgPSB6ZXJvcyA9PSBaZXJvcy5JbmNsdWRlIHx8ICFaZXJvLkVxdWFscyhmKFplcm8pKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkaWFnb25hbFRhcmdldCA9IHRhcmdldCBhcyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VFU+O1xyXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWxUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NaZXJvcylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXhjZXB0aW9uKFwiQ2Fubm90IG1hcCBub24temVybyBvZmYtZGlhZ29uYWwgdmFsdWVzIGludG8gYSBkaWFnb25hbCBtYXRyaXhcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBEYXRhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxUYXJnZXQuRGF0YVtpXSA9IGYoRGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRGF0YSA9PSBFeGlzdGluZ0RhdGEuQ2xlYXIgJiYgIXByb2Nlc3NaZXJvcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzWmVyb3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQoaSwgaiwgZihpID09IGogPyBEYXRhW2ldIDogWmVybykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQoaSwgaSwgZihEYXRhW2ldKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgTWFwSW5kZXhlZFRvVW5jaGVja2VkPFRVPihNYXRyaXhTdG9yYWdlPFRVPiB0YXJnZXQsIEZ1bmM8aW50LCBpbnQsIFQsIFRVPiBmLFxyXG4gICAgICAgICAgICBaZXJvcyB6ZXJvcywgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBwcm9jZXNzWmVyb3MgPSB6ZXJvcyA9PSBaZXJvcy5JbmNsdWRlIHx8ICFaZXJvLkVxdWFscyhmKDAsIDEsIFplcm8pKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkaWFnb25hbFRhcmdldCA9IHRhcmdldCBhcyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VFU+O1xyXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWxUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NaZXJvcylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXhjZXB0aW9uKFwiQ2Fubm90IG1hcCBub24temVybyBvZmYtZGlhZ29uYWwgdmFsdWVzIGludG8gYSBkaWFnb25hbCBtYXRyaXhcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBEYXRhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxUYXJnZXQuRGF0YVtpXSA9IGYoaSwgaSwgRGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRGF0YSA9PSBFeGlzdGluZ0RhdGEuQ2xlYXIgJiYgIXByb2Nlc3NaZXJvcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzWmVyb3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQoaSwgaiwgZihpLCBqLCBpID09IGogPyBEYXRhW2ldIDogWmVybykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQoaSwgaSwgZihpLCBpLCBEYXRhW2ldKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgTWFwU3ViTWF0cml4SW5kZXhlZFRvVW5jaGVja2VkPFRVPihNYXRyaXhTdG9yYWdlPFRVPiB0YXJnZXQsIEZ1bmM8aW50LCBpbnQsIFQsIFRVPiBmLFxyXG4gICAgICAgICAgICBpbnQgc291cmNlUm93SW5kZXgsIGludCB0YXJnZXRSb3dJbmRleCwgaW50IHJvd0NvdW50LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlQ29sdW1uSW5kZXgsIGludCB0YXJnZXRDb2x1bW5JbmRleCwgaW50IGNvbHVtbkNvdW50LFxyXG4gICAgICAgICAgICBaZXJvcyB6ZXJvcywgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkaWFnb25hbFRhcmdldCA9IHRhcmdldCBhcyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VFU+O1xyXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWxUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTWFwU3ViTWF0cml4SW5kZXhlZFRvVW5jaGVja2VkPFRVPihkaWFnb25hbFRhcmdldCwgKEZ1bmM8aW50LGludCxULFRVPilmLCBzb3VyY2VSb3dJbmRleCwgdGFyZ2V0Um93SW5kZXgsIHJvd0NvdW50LCBzb3VyY2VDb2x1bW5JbmRleCwgdGFyZ2V0Q29sdW1uSW5kZXgsIGNvbHVtbkNvdW50LCB6ZXJvcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkZW5zZVRhcmdldCA9IHRhcmdldCBhcyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUVT47XHJcbiAgICAgICAgICAgIGlmIChkZW5zZVRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBNYXBTdWJNYXRyaXhJbmRleGVkVG9VbmNoZWNrZWQ8VFU+KGRlbnNlVGFyZ2V0LCAoRnVuYzxpbnQsaW50LFQsVFU+KWYsIHNvdXJjZVJvd0luZGV4LCB0YXJnZXRSb3dJbmRleCwgcm93Q291bnQsIHNvdXJjZUNvbHVtbkluZGV4LCB0YXJnZXRDb2x1bW5JbmRleCwgY29sdW1uQ291bnQsIHplcm9zLCBleGlzdGluZ0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBQcm9wZXIgU3BhcnNlIEltcGxlbWVudGF0aW9uXHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0RhdGEgPT0gRXhpc3RpbmdEYXRhLkNsZWFyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQ2xlYXJVbmNoZWNrZWQodGFyZ2V0Um93SW5kZXgsIHJvd0NvdW50LCB0YXJnZXRDb2x1bW5JbmRleCwgY29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc291cmNlUm93SW5kZXggPT0gc291cmNlQ29sdW1uSW5kZXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCB0YXJnZXRSb3cgPSB0YXJnZXRSb3dJbmRleDtcclxuICAgICAgICAgICAgICAgIGludCB0YXJnZXRDb2x1bW4gPSB0YXJnZXRDb2x1bW5JbmRleDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5NaW4oY29sdW1uQ291bnQsIHJvd0NvdW50KTsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5BdCh0YXJnZXRSb3csIHRhcmdldENvbHVtbiwgZih0YXJnZXRSb3csIHRhcmdldENvbHVtbiwgRGF0YVtzb3VyY2VSb3dJbmRleCArIGldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Um93Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29sdW1uKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlUm93SW5kZXggPiBzb3VyY2VDb2x1bW5JbmRleCAmJiBzb3VyY2VDb2x1bW5JbmRleCArIGNvbHVtbkNvdW50ID4gc291cmNlUm93SW5kZXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbHVtbiBieSBjb2x1bW4sIGJ1dCBza2lwIHJlc3VsdGluZyB6ZXJvIGNvbHVtbnMgYXQgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAgICAgICAgaW50IGNvbHVtbkluaXQgPSBzb3VyY2VSb3dJbmRleCAtIHNvdXJjZUNvbHVtbkluZGV4O1xyXG4gICAgICAgICAgICAgICAgaW50IHRhcmdldFJvdyA9IHRhcmdldFJvd0luZGV4O1xyXG4gICAgICAgICAgICAgICAgaW50IHRhcmdldENvbHVtbiA9IHRhcmdldENvbHVtbkluZGV4ICsgY29sdW1uSW5pdDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5NaW4oY29sdW1uQ291bnQgLSBjb2x1bW5Jbml0LCByb3dDb3VudCk7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQodGFyZ2V0Um93LCB0YXJnZXRDb2x1bW4sIGYodGFyZ2V0Um93LCB0YXJnZXRDb2x1bW4sIERhdGFbc291cmNlUm93SW5kZXggKyBpXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFJvdysrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENvbHVtbisrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZVJvd0luZGV4IDwgc291cmNlQ29sdW1uSW5kZXggJiYgc291cmNlUm93SW5kZXggKyByb3dDb3VudCA+IHNvdXJjZUNvbHVtbkluZGV4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyByb3cgYnkgcm93LCBidXQgc2tpcCByZXN1bHRpbmcgemVybyByb3dzIGF0IHRoZSBiZWdpbm5pbmdcclxuICAgICAgICAgICAgICAgIGludCByb3dJbml0ID0gc291cmNlQ29sdW1uSW5kZXggLSBzb3VyY2VSb3dJbmRleDtcclxuICAgICAgICAgICAgICAgIGludCB0YXJnZXRSb3cgPSB0YXJnZXRSb3dJbmRleCArIHJvd0luaXQ7XHJcbiAgICAgICAgICAgICAgICBpbnQgdGFyZ2V0Q29sdW1uID0gdGFyZ2V0Q29sdW1uSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGguTWluKGNvbHVtbkNvdW50LCByb3dDb3VudCAtIHJvd0luaXQpOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkF0KHRhcmdldFJvdywgdGFyZ2V0Q29sdW1uLCBmKHRhcmdldFJvdywgdGFyZ2V0Q29sdW1uLCBEYXRhW3NvdXJjZUNvbHVtbkluZGV4ICsgaV0pKTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRSb3crKztcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb2x1bW4rKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBNYXBTdWJNYXRyaXhJbmRleGVkVG9VbmNoZWNrZWQ8VFU+KERpYWdvbmFsTWF0cml4U3RvcmFnZTxUVT4gdGFyZ2V0LCBGdW5jPGludCwgaW50LCBULCBUVT4gZixcclxuICAgICAgICAgICAgaW50IHNvdXJjZVJvd0luZGV4LCBpbnQgdGFyZ2V0Um93SW5kZXgsIGludCByb3dDb3VudCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZUNvbHVtbkluZGV4LCBpbnQgdGFyZ2V0Q29sdW1uSW5kZXgsIGludCBjb2x1bW5Db3VudCxcclxuICAgICAgICAgICAgWmVyb3MgemVyb3MpXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcHJvY2Vzc1plcm9zID0gemVyb3MgPT0gWmVyb3MuSW5jbHVkZSB8fCAhWmVyby5FcXVhbHMoZigwLCAxLCBaZXJvKSk7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzWmVyb3MgfHwgc291cmNlUm93SW5kZXggLSBzb3VyY2VDb2x1bW5JbmRleCAhPSB0YXJnZXRSb3dJbmRleCAtIHRhcmdldENvbHVtbkluZGV4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXhjZXB0aW9uKFwiQ2Fubm90IG1hcCBub24temVybyBvZmYtZGlhZ29uYWwgdmFsdWVzIGludG8gYSBkaWFnb25hbCBtYXRyaXhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBiZWdpbkluY2x1c2l2ZSA9IE1hdGguTWF4KHNvdXJjZVJvd0luZGV4LCBzb3VyY2VDb2x1bW5JbmRleCk7XHJcbiAgICAgICAgICAgIHZhciBjb3VudCA9IE1hdGguTWluKHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQsIHNvdXJjZUNvbHVtbkluZGV4ICsgY29sdW1uQ291bnQpIC0gYmVnaW5JbmNsdXNpdmU7XHJcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBiZWdpblRhcmdldCA9IE1hdGguTWF4KHRhcmdldFJvd0luZGV4LCB0YXJnZXRDb2x1bW5JbmRleCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBpbnQgdGFyZ2V0SW5kZXggPSBiZWdpblRhcmdldCArIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkRhdGFbdGFyZ2V0SW5kZXhdID0gZih0YXJnZXRJbmRleCwgdGFyZ2V0SW5kZXgsIERhdGFbYmVnaW5JbmNsdXNpdmUgKyBpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgTWFwU3ViTWF0cml4SW5kZXhlZFRvVW5jaGVja2VkPFRVPihEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxUVT4gdGFyZ2V0LCBGdW5jPGludCwgaW50LCBULCBUVT4gZixcclxuICAgICAgICAgICAgaW50IHNvdXJjZVJvd0luZGV4LCBpbnQgdGFyZ2V0Um93SW5kZXgsIGludCByb3dDb3VudCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZUNvbHVtbkluZGV4LCBpbnQgdGFyZ2V0Q29sdW1uSW5kZXgsIGludCBjb2x1bW5Db3VudCxcclxuICAgICAgICAgICAgWmVyb3MgemVyb3MsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAgICAgIHdoZXJlIFRVIDogc3RydWN0LCBJRXF1YXRhYmxlPFRVPiwgSUZvcm1hdHRhYmxlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcHJvY2Vzc1plcm9zID0gemVyb3MgPT0gWmVyb3MuSW5jbHVkZSB8fCAhWmVyby5FcXVhbHMoZigwLCAxLCBaZXJvKSk7XHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0RhdGEgPT0gRXhpc3RpbmdEYXRhLkNsZWFyICYmICFwcm9jZXNzWmVyb3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5DbGVhclVuY2hlY2tlZCh0YXJnZXRSb3dJbmRleCwgcm93Q291bnQsIHRhcmdldENvbHVtbkluZGV4LCBjb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzWmVyb3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGludCBzb3VyY2VDb2x1bW4gPSBzb3VyY2VDb2x1bW5JbmRleCArIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IHRhcmdldENvbHVtbiA9IHRhcmdldENvbHVtbkluZGV4ICsgMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGNvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnQgdGFyZ2V0SW5kZXggPSB0YXJnZXRSb3dJbmRleCArIChqICsgdGFyZ2V0Q29sdW1uSW5kZXgpKnRhcmdldC5Sb3dDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50IHNvdXJjZVJvdyA9IHNvdXJjZVJvd0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnQgdGFyZ2V0Um93ID0gdGFyZ2V0Um93SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkRhdGFbdGFyZ2V0SW5kZXgrK10gPSBmKHRhcmdldFJvdysrLCB0YXJnZXRDb2x1bW4sIHNvdXJjZVJvdysrID09IHNvdXJjZUNvbHVtbiA/IERhdGFbc291cmNlQ29sdW1uXSA6IFplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNvbHVtbisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb2x1bW4rKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VSb3dJbmRleCA+IHNvdXJjZUNvbHVtbkluZGV4ICYmIHNvdXJjZUNvbHVtbkluZGV4ICsgY29sdW1uQ291bnQgPiBzb3VyY2VSb3dJbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb2x1bW4gYnkgY29sdW1uLCBidXQgc2tpcCByZXN1bHRpbmcgemVybyBjb2x1bW5zIGF0IHRoZSBiZWdpbm5pbmdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGNvbHVtbkluaXQgPSBzb3VyY2VSb3dJbmRleCAtIHNvdXJjZUNvbHVtbkluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBvZmZzZXQgPSAoY29sdW1uSW5pdCArIHRhcmdldENvbHVtbkluZGV4KSp0YXJnZXQuUm93Q291bnQgKyB0YXJnZXRSb3dJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgc3RlcCA9IHRhcmdldC5Sb3dDb3VudCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGNvdW50ID0gTWF0aC5NaW4oY29sdW1uQ291bnQgLSBjb2x1bW5Jbml0LCByb3dDb3VudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGsgPSAwLCBqID0gb2Zmc2V0OyBrIDwgY291bnQ7IGogKz0gc3RlcCwgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkRhdGFbal0gPSBmKHRhcmdldFJvd0luZGV4ICsgaywgdGFyZ2V0Q29sdW1uSW5kZXggKyBjb2x1bW5Jbml0ICsgaywgRGF0YVtzb3VyY2VSb3dJbmRleCArIGtdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VSb3dJbmRleCA8IHNvdXJjZUNvbHVtbkluZGV4ICYmIHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQgPiBzb3VyY2VDb2x1bW5JbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByb3cgYnkgcm93LCBidXQgc2tpcCByZXN1bHRpbmcgemVybyByb3dzIGF0IHRoZSBiZWdpbm5pbmdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50IHJvd0luaXQgPSBzb3VyY2VDb2x1bW5JbmRleCAtIHNvdXJjZVJvd0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBvZmZzZXQgPSB0YXJnZXRDb2x1bW5JbmRleCp0YXJnZXQuUm93Q291bnQgKyByb3dJbml0ICsgdGFyZ2V0Um93SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IHN0ZXAgPSB0YXJnZXQuUm93Q291bnQgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBjb3VudCA9IE1hdGguTWluKGNvbHVtbkNvdW50LCByb3dDb3VudCAtIHJvd0luaXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBrID0gMCwgaiA9IG9mZnNldDsgayA8IGNvdW50OyBqICs9IHN0ZXAsIGsrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5EYXRhW2pdID0gZih0YXJnZXRSb3dJbmRleCArIHJvd0luaXQgKyBrLCB0YXJnZXRDb2x1bW5JbmRleCArIGssIERhdGFbc291cmNlQ29sdW1uSW5kZXggKyBrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBvZmZzZXQgPSB0YXJnZXRDb2x1bW5JbmRleCp0YXJnZXQuUm93Q291bnQgKyB0YXJnZXRSb3dJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgc3RlcCA9IHRhcmdldC5Sb3dDb3VudCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gTWF0aC5NaW4oY29sdW1uQ291bnQsIHJvd0NvdW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgayA9IDAsIGogPSBvZmZzZXQ7IGsgPCBjb3VudDsgaiArPSBzdGVwLCBrKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuRGF0YVtqXSA9IGYodGFyZ2V0Um93SW5kZXggKyBrLCB0YXJnZXRDb2x1bW5JbmRleCArIGssIERhdGFbc291cmNlUm93SW5kZXggKyBrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGVU5DVElPTkFMIENPTUJJTkFUT1JTOiBGT0xEXHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgRm9sZEJ5Um93VW5jaGVja2VkPFRVPihUVVtdIHRhcmdldCwgRnVuYzxUVSwgVCwgVFU+IGYsIEZ1bmM8VFUsIGludCwgVFU+IGZpbmFsaXplLCBUVVtdIHN0YXRlLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh6ZXJvcyA9PSBaZXJvcy5BbGxvd1NraXApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGsgPSAwOyBrIDwgRGF0YS5MZW5ndGg7IGsrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba10gPSBmaW5hbGl6ZShmKHN0YXRlW2tdLCBEYXRhW2tdKSwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgayA9IERhdGEuTGVuZ3RoOyBrIDwgUm93Q291bnQ7IGsrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba10gPSBmaW5hbGl6ZShzdGF0ZVtrXSwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVFUgcyA9IHN0YXRlW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBmKHMsIGkgPT0gaiA/IERhdGFbaV0gOiBaZXJvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gZmluYWxpemUocywgQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEZvbGRCeUNvbHVtblVuY2hlY2tlZDxUVT4oVFVbXSB0YXJnZXQsIEZ1bmM8VFUsIFQsIFRVPiBmLCBGdW5jPFRVLCBpbnQsIFRVPiBmaW5hbGl6ZSwgVFVbXSBzdGF0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoemVyb3MgPT0gWmVyb3MuQWxsb3dTa2lwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBrID0gMDsgayA8IERhdGEuTGVuZ3RoOyBrKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tdID0gZmluYWxpemUoZihzdGF0ZVtrXSwgRGF0YVtrXSksIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGsgPSBEYXRhLkxlbmd0aDsgayA8IENvbHVtbkNvdW50OyBrKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tdID0gZmluYWxpemUoc3RhdGVba10sIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFRVIHMgPSBzdGF0ZVtqXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gZihzLCBpID09IGogPyBEYXRhW2ldIDogWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtqXSA9IGZpbmFsaXplKHMsIFJvd0NvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgVFN0YXRlIEZvbGQyVW5jaGVja2VkPFRPdGhlciwgVFN0YXRlPihNYXRyaXhTdG9yYWdlPFRPdGhlcj4gb3RoZXIsIEZ1bmM8VFN0YXRlLCBULCBUT3RoZXIsIFRTdGF0ZT4gZiwgVFN0YXRlIHN0YXRlLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZU90aGVyID0gb3RoZXIgYXMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VE90aGVyPjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlT3RoZXIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVE90aGVyW10gb3RoZXJEYXRhID0gZGVuc2VPdGhlci5EYXRhO1xyXG4gICAgICAgICAgICAgICAgaW50IGsgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgaSA9PSBqID8gRGF0YVtpXSA6IFplcm8sIG90aGVyRGF0YVtrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkaWFnb25hbE90aGVyID0gb3RoZXIgYXMgRGlhZ29uYWxNYXRyaXhTdG9yYWdlPFRPdGhlcj47XHJcbiAgICAgICAgICAgIGlmIChkaWFnb25hbE90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRPdGhlcltdIG90aGVyRGF0YSA9IGRpYWdvbmFsT3RoZXIuRGF0YTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGYoc3RhdGUsIERhdGFbaV0sIG90aGVyRGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG8gd2UgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcz9cclxuICAgICAgICAgICAgICAgIGlmICh6ZXJvcyA9PSBaZXJvcy5JbmNsdWRlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFRPdGhlciBvdGhlclplcm8gPSBCdWlsZGVySW5zdGFuY2U8VE90aGVyPi5NYXRyaXguWmVybztcclxuICAgICAgICAgICAgICAgICAgICBpbnQgY291bnQgPSBSb3dDb3VudCpDb2x1bW5Db3VudCAtIERhdGEuTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgY291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgWmVybywgb3RoZXJaZXJvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc3BhcnNlT3RoZXIgPSBvdGhlciBhcyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUT3RoZXI+O1xyXG4gICAgICAgICAgICBpZiAoc3BhcnNlT3RoZXIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50W10gb3RoZXJSb3dQb2ludGVycyA9IHNwYXJzZU90aGVyLlJvd1BvaW50ZXJzO1xyXG4gICAgICAgICAgICAgICAgaW50W10gb3RoZXJDb2x1bW5JbmRpY2VzID0gc3BhcnNlT3RoZXIuQ29sdW1uSW5kaWNlcztcclxuICAgICAgICAgICAgICAgIFRPdGhlcltdIG90aGVyVmFsdWVzID0gc3BhcnNlT3RoZXIuVmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgVE90aGVyIG90aGVyWmVybyA9IEJ1aWxkZXJJbnN0YW5jZTxUT3RoZXI+Lk1hdHJpeC5aZXJvO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh6ZXJvcyA9PSBaZXJvcy5JbmNsdWRlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBjb2wgPSAwOyBjb2wgPCBDb2x1bW5Db3VudDsgY29sKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrIDwgb3RoZXJSb3dQb2ludGVyc1tyb3cgKyAxXSAmJiBvdGhlckNvbHVtbkluZGljZXNba10gPT0gY29sKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgcm93ID09IGNvbCA/IERhdGFbcm93XSA6IFplcm8sIG90aGVyVmFsdWVzW2srK10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgcm93ID09IGNvbCA/IERhdGFbcm93XSA6IFplcm8sIG90aGVyWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBib29sIGRpYWdvbmFsID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gb3RoZXJSb3dQb2ludGVyc1tyb3ddO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IG90aGVyUm93UG9pbnRlcnNbcm93ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0SW5kZXg7IGogPCBlbmRJbmRleDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyQ29sdW1uSW5kaWNlc1tqXSA9PSByb3cpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgRGF0YVtyb3ddLCBvdGhlclZhbHVlc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGYoc3RhdGUsIFplcm8sIG90aGVyVmFsdWVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWFnb25hbCAmJiByb3cgPCBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgRGF0YVtyb3ddLCBvdGhlclplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJhc2UuRm9sZDJVbmNoZWNrZWQ8VE90aGVyLFRTdGF0ZT4ob3RoZXIsIChGdW5jPFRTdGF0ZSxULFRPdGhlcixUU3RhdGU+KWYsIHN0YXRlLCB6ZXJvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8vIDxjb3B5cmlnaHQgZmlsZT1cIlNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlLmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTUgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGUuTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhO1xyXG51c2luZyBNYXRoTmV0TnVtZXJpY3M7XHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5MaW5xO1xyXG51c2luZyBTeXN0ZW0uUnVudGltZS5TZXJpYWxpemF0aW9uO1xyXG5cclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuU3RvcmFnZVxyXG57XHJcbiAgICBbU2VyaWFsaXphYmxlXVxyXG4gICAgW0RhdGFDb250cmFjdChOYW1lc3BhY2UgPSBcInVybjpNYXRoTmV0L051bWVyaWNzL0xpbmVhckFsZ2VicmFcIildXHJcbiAgICBwdWJsaWMgY2xhc3MgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4gOiBNYXRyaXhTdG9yYWdlPFQ+XHJcbiAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICB7XHJcbiAgICAgICAgLy8gW3J1ZWdnXSBwdWJsaWMgZmllbGRzIGFyZSBPSyBoZXJlXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGFycmF5IGNvbnRhaW5pbmcgdGhlIHJvdyBpbmRpY2VzIG9mIHRoZSBleGlzdGluZyByb3dzLiBFbGVtZW50IFwiaVwiIG9mIHRoZSBhcnJheSBnaXZlcyB0aGUgaW5kZXggb2YgdGhlXHJcbiAgICAgICAgLy8vIGVsZW1lbnQgaW4gdGhlIDxzZWUgY3JlZj1cIlZhbHVlc1wiLz4gYXJyYXkgdGhhdCBpcyBmaXJzdCBub24temVybyBlbGVtZW50IGluIGEgcm93IFwiaVwiLlxyXG4gICAgICAgIC8vLyBUaGUgbGFzdCB2YWx1ZSBpcyBlcXVhbCB0byBWYWx1ZUNvdW50LCBzbyB0aGF0IHRoZSBudW1iZXIgb2Ygbm9uLXplcm8gZW50cmllcyBpbiByb3cgXCJpXCIgaXMgYWx3YXlzXHJcbiAgICAgICAgLy8vIGdpdmVuIGJ5IFJvd1BvaW50ZXJzW2kraV0gLSBSb3dQb2ludGVyc1tpXS4gVGhpcyBhcnJheSB0aHVzIGhhcyBsZW5ndGggUm93Q291bnQrMS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFtEYXRhTWVtYmVyKE9yZGVyID0gMSldXHJcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGludFtdIFJvd1BvaW50ZXJzO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGNvbHVtbiBpbmRpY2VzIG9mIHRoZSBub24temVybyB2YWx1ZXMuIEVsZW1lbnQgXCJqXCIgb2YgdGhlIGFycmF5XHJcbiAgICAgICAgLy8vIGlzIHRoZSBudW1iZXIgb2YgdGhlIGNvbHVtbiBpbiBtYXRyaXggdGhhdCBjb250YWlucyB0aGUgai10aCB2YWx1ZSBpbiB0aGUgPHNlZSBjcmVmPVwiVmFsdWVzXCIvPiBhcnJheS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFtEYXRhTWVtYmVyKE9yZGVyID0gMildXHJcbiAgICAgICAgcHVibGljIGludFtdIENvbHVtbkluZGljZXM7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXJyYXkgdGhhdCBjb250YWlucyB0aGUgbm9uLXplcm8gZWxlbWVudHMgb2YgbWF0cml4LiBWYWx1ZXMgb2YgdGhlIG5vbi16ZXJvIGVsZW1lbnRzIG9mIG1hdHJpeCBhcmUgbWFwcGVkIGludG8gdGhlIHZhbHVlc1xyXG4gICAgICAgIC8vLyBhcnJheSB1c2luZyB0aGUgcm93LW1ham9yIHN0b3JhZ2UgbWFwcGluZyBkZXNjcmliZWQgaW4gYSBjb21wcmVzc2VkIHNwYXJzZSByb3cgKENTUikgZm9ybWF0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgW0RhdGFNZW1iZXIoT3JkZXIgPSAzKV1cclxuICAgICAgICBwdWJsaWMgVFtdIFZhbHVlcztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBudW1iZXIgb2Ygbm9uIHplcm8gZWxlbWVudHMgaW4gdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIG51bWJlciBvZiBub24gemVybyBlbGVtZW50cy48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBpbnQgVmFsdWVDb3VudFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIFJvd1BvaW50ZXJzW1Jvd0NvdW50XTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2UoaW50IHJvd3MsIGludCBjb2x1bW5zKVxyXG4gICAgICAgICAgICA6IGJhc2Uocm93cywgY29sdW1ucylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFJvd1BvaW50ZXJzID0gbmV3IGludFtyb3dzICsgMV07XHJcbiAgICAgICAgICAgIENvbHVtbkluZGljZXMgPSBuZXcgaW50WzBdO1xyXG4gICAgICAgICAgICBWYWx1ZXMgPSBuZXcgVFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVHJ1ZSBpZiB0aGUgbWF0cml4IHN0b3JhZ2UgZm9ybWF0IGlzIGRlbnNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgSXNEZW5zZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRydWUgaWYgYWxsIGZpZWxkcyBvZiB0aGlzIG1hdHJpeCBjYW4gYmUgc2V0IHRvIGFueSB2YWx1ZS5cclxuICAgICAgICAvLy8gRmFsc2UgaWYgc29tZSBmaWVsZHMgYXJlIGZpeGVkLCBsaWtlIG9uIGEgZGlhZ29uYWwgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgSXNGdWxseU11dGFibGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiB0cnVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRydWUgaWYgdGhlIHNwZWNpZmllZCBmaWVsZCBjYW4gYmUgc2V0IHRvIGFueSB2YWx1ZS5cclxuICAgICAgICAvLy8gRmFsc2UgaWYgdGhlIGZpZWxkIGlzIGZpeGVkLCBsaWtlIGFuIG9mZi1kaWFnb25hbCBmaWVsZCBvbiBhIGRpYWdvbmFsIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBib29sIElzTXV0YWJsZUF0KGludCByb3csIGludCBjb2x1bW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0cmlldmVzIHRoZSByZXF1ZXN0ZWQgZWxlbWVudCB3aXRob3V0IHJhbmdlIGNoZWNraW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm93XCI+XHJcbiAgICAgICAgLy8vIFRoZSByb3cgb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uXCI+XHJcbiAgICAgICAgLy8vIFRoZSBjb2x1bW4gb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBUaGUgcmVxdWVzdGVkIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPHJlbWFya3M+Tm90IHJhbmdlLWNoZWNrZWQuPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBUIEF0KGludCByb3csIGludCBjb2x1bW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBGaW5kSXRlbShyb3csIGNvbHVtbik7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gVmFsdWVzW2luZGV4XSA6IFplcm87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldHMgdGhlIGVsZW1lbnQgd2l0aG91dCByYW5nZSBjaGVja2luZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd1wiPiBUaGUgcm93IG9mIHRoZSBlbGVtZW50LiA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtblwiPiBUaGUgY29sdW1uIG9mIHRoZSBlbGVtZW50LiA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlXCI+IFRoZSB2YWx1ZSB0byBzZXQgdGhlIGVsZW1lbnQgdG8uIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPldBUk5JTkc6IFRoaXMgbWV0aG9kIGlzIG5vdCB0aHJlYWQgc2FmZS4gVXNlIFwibG9ja1wiIHdpdGggaXQgYW5kIGJlIHN1cmUgdG8gYXZvaWQgZGVhZGxvY2tzLjwvcmVtYXJrcz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBBdChpbnQgcm93LCBpbnQgY29sdW1uLCBUIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gRmluZEl0ZW0ocm93LCBjb2x1bW4pO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9uLXplcm8gaXRlbSBmb3VuZCBpbiBtYXRyaXhcclxuICAgICAgICAgICAgICAgIGlmIChaZXJvLkVxdWFscyh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIGV4aXN0aW5nIGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICBSZW1vdmVBdEluZGV4VW5jaGVja2VkKGluZGV4LCByb3cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBpdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgVmFsdWVzW2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gSXRlbSBub3QgZm91bmQuIEFkZCBuZXcgdmFsdWVcclxuICAgICAgICAgICAgICAgIGlmIChaZXJvLkVxdWFscyh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGluZGV4ID0gfmluZGV4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlQ291bnQgPSBSb3dQb2ludGVyc1tSb3dQb2ludGVycy5MZW5ndGggLSAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgc3RvcmFnZSBuZWVkcyB0byBiZSBpbmNyZWFzZWRcclxuICAgICAgICAgICAgICAgIGlmICgodmFsdWVDb3VudCA9PSBWYWx1ZXMuTGVuZ3RoKSAmJiAodmFsdWVDb3VudCA8ICgobG9uZylSb3dDb3VudCpDb2x1bW5Db3VudCkpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFZhbHVlIGFycmF5IGlzIGNvbXBsZXRlbHkgZnVsbCBzbyB3ZSBpbmNyZWFzZSB0aGUgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgaW5jcmVhc2UgaW4gc2l6ZS4gV2Ugd2lsbCBub3QgZ3JvdyBiZXlvbmQgdGhlIHNpemUgb2YgdGhlIG1hdHJpeFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5NaW4oVmFsdWVzLkxlbmd0aCArIEdyb3d0aFNpemUoKSwgKGxvbmcpUm93Q291bnQqQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaXplID4gaW50Lk1heFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEV4Y2VwdGlvbihcIlJlc291cmNlcy5Ub29NYW55RWxlbWVudHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBBcnJheS5SZXNpemU8VD4ocmVmIFZhbHVlcywgKGludClzaXplKTtcclxuICAgICAgICAgICAgICAgICAgICBBcnJheS5SZXNpemU8aW50PihyZWYgQ29sdW1uSW5kaWNlcywgKGludClzaXplKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIGFsbCB2YWx1ZXMgKHdpdGggYSBwb3NpdGlvbiBsYXJnZXIgdGhhbiBpbmRleCkgaW4gdGhlIHZhbHVlIGFycmF5IHRvIHRoZSBuZXh0IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGFsbCB2YWx1ZXMgKHdpdGggYSBwb3NpdGlvbiBsYXJnZXIgdGhhbiBpbmRleCkgaW4gdGhlIGNvbHVtSW5kaWNlcyBhcnJheSB0byB0aGUgbmV4dCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ29weShWYWx1ZXMsIGluZGV4LCBWYWx1ZXMsIGluZGV4ICsgMSwgdmFsdWVDb3VudCAtIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIEFycmF5LkNvcHkoQ29sdW1uSW5kaWNlcywgaW5kZXgsIENvbHVtbkluZGljZXMsIGluZGV4ICsgMSwgdmFsdWVDb3VudCAtIGluZGV4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHZhbHVlIGFuZCB0aGUgY29sdW1uIGluZGV4XHJcbiAgICAgICAgICAgICAgICBWYWx1ZXNbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBDb2x1bW5JbmRpY2VzW2luZGV4XSA9IGNvbHVtbjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgMSB0byBhbGwgdGhlIHJvdyBpbmRpY2VzIGZvciByb3dzIGJpZ2dlciB0aGFuIHJvd0luZGV4XHJcbiAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IHRoZXkgcG9pbnQgdG8gdGhlIGNvcnJlY3QgcGFydCBvZiB0aGUgdmFsdWUgYXJyYXkgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gcm93ICsgMTsgaSA8IFJvd1BvaW50ZXJzLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFJvd1BvaW50ZXJzW2ldICs9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGVsZXRlIHZhbHVlIGZyb20gaW50ZXJuYWwgc3RvcmFnZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaXRlbUluZGV4XCI+SW5kZXggb2YgdmFsdWUgaW4gbm9uWmVyb1ZhbHVlcyBhcnJheTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm93XCI+Um93IG51bWJlciBvZiBtYXRyaXg8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5XQVJOSU5HOiBUaGlzIG1ldGhvZCBpcyBub3QgdGhyZWFkIHNhZmUuIFVzZSBcImxvY2tcIiB3aXRoIGl0IGFuZCBiZSBzdXJlIHRvIGF2b2lkIGRlYWRsb2NrczwvcmVtYXJrcz5cclxuICAgICAgICB2b2lkIFJlbW92ZUF0SW5kZXhVbmNoZWNrZWQoaW50IGl0ZW1JbmRleCwgaW50IHJvdylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZUNvdW50ID0gUm93UG9pbnRlcnNbUm93UG9pbnRlcnMuTGVuZ3RoIC0gMV07XHJcblxyXG4gICAgICAgICAgICAvLyBNb3ZlIGFsbCB2YWx1ZXMgKHdpdGggYSBwb3NpdGlvbiBsYXJnZXIgdGhhbiBpbmRleCkgaW4gdGhlIHZhbHVlIGFycmF5IHRvIHRoZSBwcmV2aW91cyBwb3NpdGlvblxyXG4gICAgICAgICAgICAvLyBtb3ZlIGFsbCB2YWx1ZXMgKHdpdGggYSBwb3NpdGlvbiBsYXJnZXIgdGhhbiBpbmRleCkgaW4gdGhlIGNvbHVtSW5kaWNlcyBhcnJheSB0byB0aGUgcHJldmlvdXMgcG9zaXRpb25cclxuICAgICAgICAgICAgQXJyYXkuQ29weShWYWx1ZXMsIGl0ZW1JbmRleCArIDEsIFZhbHVlcywgaXRlbUluZGV4LCB2YWx1ZUNvdW50IC0gaXRlbUluZGV4IC0gMSk7XHJcbiAgICAgICAgICAgIEFycmF5LkNvcHkoQ29sdW1uSW5kaWNlcywgaXRlbUluZGV4ICsgMSwgQ29sdW1uSW5kaWNlcywgaXRlbUluZGV4LCB2YWx1ZUNvdW50IC0gaXRlbUluZGV4IC0gMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZWNyZWFzZSB2YWx1ZSBpbiBSb3dcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHJvdyArIDE7IGkgPCBSb3dQb2ludGVycy5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUm93UG9pbnRlcnNbaV0gLT0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFsdWVDb3VudCAtPSAxO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB3ZSBuZWVkIHRvIHNocmluayB0aGUgYXJyYXlzLiBUaGlzIGlzIHJlYXNvbmFibGUgdG8gZG8gaWZcclxuICAgICAgICAgICAgLy8gdGhlcmUgYXJlIGEgbG90IG9mIG5vbi16ZXJvIGVsZW1lbnRzIGFuZCBzdG9yYWdlIGlzIHR3byB0aW1lcyBiaWdnZXJcclxuICAgICAgICAgICAgaWYgKCh2YWx1ZUNvdW50ID4gMTAyNCkgJiYgKHZhbHVlQ291bnQgPCBWYWx1ZXMuTGVuZ3RoLzIpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5SZXNpemU8VD4ocmVmIFZhbHVlcywgdmFsdWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5SZXNpemU8aW50PihyZWYgQ29sdW1uSW5kaWNlcywgdmFsdWVDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmluZCBpdGVtIEluZGV4IGluIG5vblplcm9WYWx1ZXMgYXJyYXlcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd1wiPk1hdHJpeCByb3cgaW5kZXg8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtblwiPk1hdHJpeCBjb2x1bW4gaW5kZXg8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5JdGVtIGluZGV4PC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5XQVJOSU5HOiBUaGlzIG1ldGhvZCBpcyBub3QgdGhyZWFkIHNhZmUuIFVzZSBcImxvY2tcIiB3aXRoIGl0IGFuZCBiZSBzdXJlIHRvIGF2b2lkIGRlYWRsb2NrczwvcmVtYXJrcz5cclxuICAgICAgICBwdWJsaWMgaW50IEZpbmRJdGVtKGludCByb3csIGludCBjb2x1bW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgYm91bmRzIGluIGNvbHVtbkluZGljZXMgYXJyYXkgd2hlcmUgdGhpcyBpdGVtIHNob3VsZCBiZSBzZWFyY2hlZCAodXNpbmcgcm93SW5kZXgpXHJcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5CaW5hcnlTZWFyY2g8aW50PihDb2x1bW5JbmRpY2VzLCBSb3dQb2ludGVyc1tyb3ddLCBSb3dQb2ludGVyc1tyb3cgKyAxXSAtIFJvd1BvaW50ZXJzW3Jvd10sIGNvbHVtbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIGFtb3VudCB3aXRoIHdoaWNoIHRvIGdyb3cgdGhlIHN0b3JhZ2UgYXJyYXkncyBpZiB0aGV5IG5lZWQgdG8gYmVcclxuICAgICAgICAvLy8gaW5jcmVhc2VkIGluIHNpemUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGFtb3VudCBncm93bi48L3JldHVybnM+XHJcbiAgICAgICAgaW50IEdyb3d0aFNpemUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGRlbHRhO1xyXG4gICAgICAgICAgICBpZiAoVmFsdWVzLkxlbmd0aCA+IDEwMjQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRlbHRhID0gVmFsdWVzLkxlbmd0aC80O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKFZhbHVlcy5MZW5ndGggPiAyNTYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSA1MTI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBWYWx1ZXMuTGVuZ3RoID4gNjQgPyAxMjggOiAzMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRlbHRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgTm9ybWFsaXplKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE5vcm1hbGl6ZU9yZGVyaW5nKCk7XHJcbiAgICAgICAgICAgIE5vcm1hbGl6ZVplcm9zKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBOb3JtYWxpemVPcmRlcmluZygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBpbmRleCA9IFJvd1BvaW50ZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgaW50IGNvdW50ID0gUm93UG9pbnRlcnNbaSArIDFdIC0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAxKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFNvcnRpbmcuU29ydDxpbnQsVD4oQ29sdW1uSW5kaWNlcywgVmFsdWVzLCBpbmRleCwgY291bnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBOb3JtYWxpemVaZXJvcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXBJbnBsYWNlKChGdW5jPFQsVD4pKHggPT4geCksIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYSBoYXNoIGNvZGUgZm9yIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIEEgaGFzaCBjb2RlIGZvciB0aGlzIGluc3RhbmNlLCBzdWl0YWJsZSBmb3IgdXNlIGluIGhhc2hpbmcgYWxnb3JpdGhtcyBhbmQgZGF0YSBzdHJ1Y3R1cmVzIGxpa2UgYSBoYXNoIHRhYmxlLlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGludCBHZXRIYXNoQ29kZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gVmFsdWVzO1xyXG4gICAgICAgICAgICB2YXIgaGFzaE51bSA9IE1hdGguTWluKFZhbHVlQ291bnQsIDI1KTtcclxuICAgICAgICAgICAgaW50IGhhc2ggPSAxNztcclxuICAgICAgICAgICAgdW5jaGVja2VkXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaE51bTsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSBoYXNoKjMxICsgdmFsdWVzW2ldLkdldEhhc2hDb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDTEVBUklOR1xyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBDbGVhcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBcnJheS5DbGVhcjxpbnQ+KFJvd1BvaW50ZXJzLCAwLCBSb3dQb2ludGVycy5MZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBDbGVhclVuY2hlY2tlZChpbnQgcm93SW5kZXgsIGludCByb3dDb3VudCwgaW50IGNvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocm93SW5kZXggPT0gMCAmJiBjb2x1bW5JbmRleCA9PSAwICYmIHJvd0NvdW50ID09IFJvd0NvdW50ICYmIGNvbHVtbkNvdW50ID09IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFsdWVDb3VudCA9IFJvd1BvaW50ZXJzW1Jvd1BvaW50ZXJzLkxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gcm93SW5kZXggKyByb3dDb3VudCAtIDE7IHJvdyA+PSByb3dJbmRleDsgcm93LS0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IFJvd1BvaW50ZXJzW3JvdyArIDFdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGVtcHR5IHJvd1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT0gZW5kSW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbXVsdGlwbGUgZW50cmllcyBpbiByb3dcclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IEFycmF5LkJpbmFyeVNlYXJjaDxpbnQ+KENvbHVtbkluZGljZXMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IC0gc3RhcnRJbmRleCwgY29sdW1uSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBBcnJheS5CaW5hcnlTZWFyY2g8aW50PihDb2x1bW5JbmRpY2VzLCBzdGFydEluZGV4LCBlbmRJbmRleCAtIHN0YXJ0SW5kZXgsIGNvbHVtbkluZGV4ICsgY29sdW1uQ291bnQgLSAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChmaXJzdCA8IDApIGZpcnN0ID0gfmZpcnN0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgPCAwKSBsYXN0ID0gfmxhc3QgLSAxO1xyXG4gICAgICAgICAgICAgICAgaW50IGNvdW50ID0gbGFzdCAtIGZpcnN0ICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgYWxsIHZhbHVlcyAod2l0aCBhIHBvc2l0aW9uIGxhcmdlciB0aGFuIGluZGV4KSBpbiB0aGUgdmFsdWUgYXJyYXkgdG8gdGhlIHByZXZpb3VzIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBhbGwgdmFsdWVzICh3aXRoIGEgcG9zaXRpb24gbGFyZ2VyIHRoYW4gaW5kZXgpIGluIHRoZSBjb2x1bUluZGljZXMgYXJyYXkgdG8gdGhlIHByZXZpb3VzIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuQ29weShWYWx1ZXMsIGZpcnN0ICsgY291bnQsIFZhbHVlcywgZmlyc3QsIHZhbHVlQ291bnQgLSBmaXJzdCAtIGNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICBBcnJheS5Db3B5KENvbHVtbkluZGljZXMsIGZpcnN0ICsgY291bnQsIENvbHVtbkluZGljZXMsIGZpcnN0LCB2YWx1ZUNvdW50IC0gZmlyc3QgLSBjb3VudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlY3JlYXNlIHZhbHVlIGluIFJvd1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSByb3cgKyAxOyBrIDwgUm93UG9pbnRlcnMuTGVuZ3RoOyBrKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBSb3dQb2ludGVyc1trXSAtPSBjb3VudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlQ291bnQgLT0gY291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgd2UgbmVlZCB0byBzaHJpbmsgdGhlIGFycmF5cy4gVGhpcyBpcyByZWFzb25hYmxlIHRvIGRvIGlmXHJcbiAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBhIGxvdCBvZiBub24temVybyBlbGVtZW50cyBhbmQgc3RvcmFnZSBpcyB0d28gdGltZXMgYmlnZ2VyXHJcbiAgICAgICAgICAgIGlmICgodmFsdWVDb3VudCA+IDEwMjQpICYmICh2YWx1ZUNvdW50IDwgVmFsdWVzLkxlbmd0aC8yKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuUmVzaXplPFQ+KHJlZiBWYWx1ZXMsIHZhbHVlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuUmVzaXplPGludD4ocmVmIENvbHVtbkluZGljZXMsIHZhbHVlQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIENsZWFyUm93c1VuY2hlY2tlZChpbnRbXSByb3dJbmRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJvd3MgPSBuZXcgYm9vbFtSb3dDb3VudF07XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcm93SW5kaWNlcy5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcm93c1tyb3dJbmRpY2VzW2ldXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTWFwSW5kZXhlZElucGxhY2UoKEZ1bmM8aW50LGludCxULFQ+KSgoaSwgaiwgeCkgPT4gcm93c1tpXSA/IFplcm8gOiB4KSwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgQ2xlYXJDb2x1bW5zVW5jaGVja2VkKGludFtdIGNvbHVtbkluZGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IG5ldyBib29sW0NvbHVtbkNvdW50XTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBjb2x1bW5JbmRpY2VzLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5zW2NvbHVtbkluZGljZXNbaV1dID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBNYXBJbmRleGVkSW5wbGFjZSgoRnVuYzxpbnQsaW50LFQsVD4pKChpLCBqLCB4KSA9PiBjb2x1bW5zW2pdID8gWmVybyA6IHgpLCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSU5JVElBTElaQVRJT05cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPiBPZk1hdHJpeChNYXRyaXhTdG9yYWdlPFQ+IG1hdHJpeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+KG1hdHJpeC5Sb3dDb3VudCwgbWF0cml4LkNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgbWF0cml4LkNvcHlUb1VuY2hlY2tlZChzdG9yYWdlLCBFeGlzdGluZ0RhdGEuQXNzdW1lWmVyb3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4gT2ZWYWx1ZShpbnQgcm93cywgaW50IGNvbHVtbnMsIFQgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoWmVyby5FcXVhbHModmFsdWUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+KHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPihyb3dzLCBjb2x1bW5zKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgVFtyb3dzICogY29sdW1uc107XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmFsdWVzLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJvd1BvaW50ZXJzID0gc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPD0gcm93czsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByb3dQb2ludGVyc1tpXSA9IGkqY29sdW1ucztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBuZXcgaW50W3ZhbHVlcy5MZW5ndGhdO1xyXG4gICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IG9mZnNldCA9IHJvdypjb2x1bW5zO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgY29sID0gMDsgY29sIDwgY29sdW1uczsgY29sKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kaWNlc1tvZmZzZXQgKyBjb2xdID0gY29sO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByb3dQb2ludGVyc1tyb3dzXSA9IHZhbHVlcy5MZW5ndGg7XHJcbiAgICAgICAgICAgIHN0b3JhZ2UuQ29sdW1uSW5kaWNlcyA9IGNvbHVtbkluZGljZXM7XHJcbiAgICAgICAgICAgIHN0b3JhZ2UuVmFsdWVzID0gdmFsdWVzO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+IE9mSW5pdChpbnQgcm93cywgaW50IGNvbHVtbnMsIEZ1bmM8aW50LCBpbnQsIFQ+IGluaXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPihyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICAgICAgdmFyIHJvd1BvaW50ZXJzID0gc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBuZXcgTGlzdDxpbnQ+KCk7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgTGlzdDxUPigpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgcm93czsgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJvd1BvaW50ZXJzW3Jvd10gPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBjb2wgPSAwOyBjb2wgPCBjb2x1bW5zOyBjb2wrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGluaXQocm93LCBjb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoeCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuQWRkKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRpY2VzLkFkZChjb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcm93UG9pbnRlcnNbcm93c10gPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIHN0b3JhZ2UuQ29sdW1uSW5kaWNlcyA9IGNvbHVtbkluZGljZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICBzdG9yYWdlLlZhbHVlcyA9IHZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPiBPZkRpYWdvbmFsSW5pdChpbnQgcm93cywgaW50IGNvbHVtbnMsIEZ1bmM8aW50LCBUPiBpbml0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGRpYWdvbmFsTGVuZ3RoID0gTWF0aC5NaW4ocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+KHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgICAgICB2YXIgcm93UG9pbnRlcnMgPSBzdG9yYWdlLlJvd1BvaW50ZXJzO1xyXG4gICAgICAgICAgICB2YXIgY29sdW1uSW5kaWNlcyA9IG5ldyBMaXN0PGludD4oZGlhZ29uYWxMZW5ndGgpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gbmV3IExpc3Q8VD4oZGlhZ29uYWxMZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBkaWFnb25hbExlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByb3dQb2ludGVyc1tpXSA9IHZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gaW5pdChpKTtcclxuICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoeCkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZCh4KTtcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRpY2VzLkFkZChpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcm93UG9pbnRlcnNbcm93c10gPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIHN0b3JhZ2UuQ29sdW1uSW5kaWNlcyA9IGNvbHVtbkluZGljZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICBzdG9yYWdlLlZhbHVlcyA9IHZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPiBPZkFycmF5KFRbLF0gYXJyYXkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPihhcnJheS5HZXRMZW5ndGgoMCksIGFycmF5LkdldExlbmd0aCgxKSk7XHJcbiAgICAgICAgICAgIHZhciByb3dQb2ludGVycyA9IHN0b3JhZ2UuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5JbmRpY2VzID0gbmV3IExpc3Q8aW50PigpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gbmV3IExpc3Q8VD4oKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IHJvdyA9IDA7IHJvdyA8IHN0b3JhZ2UuUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByb3dQb2ludGVyc1tyb3ddID0gdmFsdWVzLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgY29sID0gMDsgY29sIDwgc3RvcmFnZS5Db2x1bW5Db3VudDsgY29sKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyhhcnJheVtyb3csIGNvbF0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZChhcnJheVtyb3csIGNvbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRpY2VzLkFkZChjb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcm93UG9pbnRlcnNbc3RvcmFnZS5Sb3dDb3VudF0gPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIHN0b3JhZ2UuQ29sdW1uSW5kaWNlcyA9IGNvbHVtbkluZGljZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICBzdG9yYWdlLlZhbHVlcyA9IHZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPiBPZlJvd0FycmF5cyhUW11bXSBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuTGVuZ3RoIDw9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJkYXRhXCIsIFwiUmVzb3VyY2VzLk1hdHJpeENhbk5vdEJlRW1wdHlcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+KGRhdGEuTGVuZ3RoLCBkYXRhWzBdLkxlbmd0aCk7XHJcbiAgICAgICAgICAgIHZhciByb3dQb2ludGVycyA9IHN0b3JhZ2UuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5JbmRpY2VzID0gbmV3IExpc3Q8aW50PigpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gbmV3IExpc3Q8VD4oKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IHJvdyA9IDA7IHJvdyA8IHN0b3JhZ2UuUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByb3dQb2ludGVyc1tyb3ddID0gdmFsdWVzLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgY29sID0gMDsgY29sIDwgc3RvcmFnZS5Db2x1bW5Db3VudDsgY29sKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVCB4ID0gZGF0YVtyb3ddW2NvbF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyh4KSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5BZGQoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGljZXMuQWRkKGNvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByb3dQb2ludGVyc1tzdG9yYWdlLlJvd0NvdW50XSA9IHZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgc3RvcmFnZS5Db2x1bW5JbmRpY2VzID0gY29sdW1uSW5kaWNlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgIHN0b3JhZ2UuVmFsdWVzID0gdmFsdWVzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+IE9mQ29sdW1uQXJyYXlzKFRbXVtdIGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5MZW5ndGggPD0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImRhdGFcIiwgXCJSZXNvdXJjZXMuTWF0cml4Q2FuTm90QmVFbXB0eVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBuZXcgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4oZGF0YVswXS5MZW5ndGgsIGRhdGEuTGVuZ3RoKTtcclxuICAgICAgICAgICAgdmFyIHJvd1BvaW50ZXJzID0gc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBuZXcgTGlzdDxpbnQ+KCk7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgTGlzdDxUPigpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgc3RvcmFnZS5Sb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJvd1BvaW50ZXJzW3Jvd10gPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBjb2wgPSAwOyBjb2wgPCBzdG9yYWdlLkNvbHVtbkNvdW50OyBjb2wrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBUIHggPSBkYXRhW2NvbF1bcm93XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVplcm8uRXF1YWxzKHgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kaWNlcy5BZGQoY29sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJvd1BvaW50ZXJzW3N0b3JhZ2UuUm93Q291bnRdID0gdmFsdWVzLkNvdW50O1xyXG4gICAgICAgICAgICBzdG9yYWdlLkNvbHVtbkluZGljZXMgPSBjb2x1bW5JbmRpY2VzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgc3RvcmFnZS5WYWx1ZXMgPSB2YWx1ZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4gT2ZSb3dWZWN0b3JzKFZlY3RvclN0b3JhZ2U8VD5bXSBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuTGVuZ3RoIDw9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJkYXRhXCIsIFwiUmVzb3VyY2VzLk1hdHJpeENhbk5vdEJlRW1wdHlcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+KGRhdGEuTGVuZ3RoLCBkYXRhWzBdLkxlbmd0aCk7XHJcbiAgICAgICAgICAgIHZhciByb3dQb2ludGVycyA9IHN0b3JhZ2UuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5JbmRpY2VzID0gbmV3IExpc3Q8aW50PigpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gbmV3IExpc3Q8VD4oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE8gUEVSRjogT3B0aW1pemUgZm9yIHNwYXJzZSBhbmQgZGVuc2UgY2FzZXNcclxuICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgc3RvcmFnZS5Sb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ZWN0b3IgPSBkYXRhW3Jvd107XHJcbiAgICAgICAgICAgICAgICByb3dQb2ludGVyc1tyb3ddID0gdmFsdWVzLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgY29sID0gMDsgY29sIDwgc3RvcmFnZS5Db2x1bW5Db3VudDsgY29sKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSB2ZWN0b3IuQXQoY29sKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVplcm8uRXF1YWxzKHgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kaWNlcy5BZGQoY29sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJvd1BvaW50ZXJzW3N0b3JhZ2UuUm93Q291bnRdID0gdmFsdWVzLkNvdW50O1xyXG4gICAgICAgICAgICBzdG9yYWdlLkNvbHVtbkluZGljZXMgPSBjb2x1bW5JbmRpY2VzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgc3RvcmFnZS5WYWx1ZXMgPSB2YWx1ZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4gT2ZDb2x1bW5WZWN0b3JzKFZlY3RvclN0b3JhZ2U8VD5bXSBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuTGVuZ3RoIDw9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJkYXRhXCIsIFwiUmVzb3VyY2VzLk1hdHJpeENhbk5vdEJlRW1wdHlcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+KGRhdGFbMF0uTGVuZ3RoLCBkYXRhLkxlbmd0aCk7XHJcbiAgICAgICAgICAgIHZhciByb3dQb2ludGVycyA9IHN0b3JhZ2UuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5JbmRpY2VzID0gbmV3IExpc3Q8aW50PigpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gbmV3IExpc3Q8VD4oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE8gUEVSRjogT3B0aW1pemUgZm9yIHNwYXJzZSBhbmQgZGVuc2UgY2FzZXNcclxuICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgc3RvcmFnZS5Sb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJvd1BvaW50ZXJzW3Jvd10gPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBjb2wgPSAwOyBjb2wgPCBzdG9yYWdlLkNvbHVtbkNvdW50OyBjb2wrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGRhdGFbY29sXS5BdChyb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoeCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuQWRkKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRpY2VzLkFkZChjb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcm93UG9pbnRlcnNbc3RvcmFnZS5Sb3dDb3VudF0gPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIHN0b3JhZ2UuQ29sdW1uSW5kaWNlcyA9IGNvbHVtbkluZGljZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICBzdG9yYWdlLlZhbHVlcyA9IHZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPiBPZkluZGV4ZWRFbnVtZXJhYmxlKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8VHVwbGU8aW50LCBpbnQsIFQ+PiBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHRyb3dzID0gbmV3IExpc3Q8VHVwbGU8aW50LCBUPj5bcm93c107XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKHZhciBpdGVtIGluIGRhdGEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoaXRlbS5JdGVtMykpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IHRyb3dzW2l0ZW0uSXRlbTFdID8/ICh0cm93c1tpdGVtLkl0ZW0xXSA9IG5ldyBMaXN0PFR1cGxlPGludCwgVD4+KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdy5BZGQobmV3IFR1cGxlPGludCwgVD4oaXRlbS5JdGVtMiwgaXRlbS5JdGVtMykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPihyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICAgICAgdmFyIHJvd1BvaW50ZXJzID0gc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBuZXcgTGlzdDxpbnQ+KCk7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgTGlzdDxUPigpO1xyXG5cclxuICAgICAgICAgICAgaW50IGluZGV4ID0gMDtcclxuICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgcm93czsgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJvd1BvaW50ZXJzW3Jvd10gPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHZhciB0cm93ID0gdHJvd3Nbcm93XTtcclxuICAgICAgICAgICAgICAgIGlmICh0cm93ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJvdy5Tb3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yZWFjaCAodmFyIGl0ZW0gaW4gdHJvdylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5BZGQoaXRlbS5JdGVtMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGljZXMuQWRkKGl0ZW0uSXRlbTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcm93UG9pbnRlcnNbcm93c10gPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIHN0b3JhZ2UuQ29sdW1uSW5kaWNlcyA9IGNvbHVtbkluZGljZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICBzdG9yYWdlLlZhbHVlcyA9IHZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPiBPZlJvd0VudW1lcmFibGVzKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8SUVudW1lcmFibGU8VD4+IGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPihyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICAgICAgdmFyIHJvd1BvaW50ZXJzID0gc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBuZXcgTGlzdDxpbnQ+KCk7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgTGlzdDxUPigpO1xyXG5cclxuICAgICAgICAgICAgdXNpbmcgKHZhciByb3dJdGVyYXRvciA9IGRhdGEuR2V0RW51bWVyYXRvcigpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJvd0l0ZXJhdG9yLk1vdmVOZXh0KCkpIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJkYXRhXCIsIHN0cmluZy5Gb3JtYXQgKFwiUmVzb3VyY2VzLkFyZ3VtZW50QXJyYXlXcm9uZ0xlbmd0aFwiLCByb3dzKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJvd1BvaW50ZXJzW3Jvd10gPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdXNpbmcgKHZhciBjb2x1bW5JdGVyYXRvciA9IHJvd0l0ZXJhdG9yLkN1cnJlbnQuR2V0RW51bWVyYXRvcigpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgY29sID0gMDsgY29sIDwgY29sdW1uczsgY29sKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sdW1uSXRlcmF0b3IuTW92ZU5leHQoKSkgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImRhdGFcIiwgc3RyaW5nLkZvcm1hdCAoXCJSZXNvdXJjZXMuQXJndW1lbnRBcnJheVdyb25nTGVuZ3RoXCIsIGNvbHVtbnMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoY29sdW1uSXRlcmF0b3IuQ3VycmVudCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZChjb2x1bW5JdGVyYXRvci5DdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRpY2VzLkFkZChjb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW5JdGVyYXRvci5Nb3ZlTmV4dCgpKSB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiZGF0YVwiLCBzdHJpbmcuRm9ybWF0IChcIlJlc291cmNlcy5Bcmd1bWVudEFycmF5V3JvbmdMZW5ndGhcIiwgY29sdW1ucykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyb3dJdGVyYXRvci5Nb3ZlTmV4dCgpKSB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiZGF0YVwiLCBzdHJpbmcuRm9ybWF0IChcIlJlc291cmNlcy5Bcmd1bWVudEFycmF5V3JvbmdMZW5ndGhcIiwgcm93cykpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcm93UG9pbnRlcnNbcm93c10gPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIHN0b3JhZ2UuQ29sdW1uSW5kaWNlcyA9IGNvbHVtbkluZGljZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICBzdG9yYWdlLlZhbHVlcyA9IHZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPiBPZkNvbHVtbkVudW1lcmFibGVzKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8SUVudW1lcmFibGU8VD4+IGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgdHJvd3MgPSBuZXcgTGlzdDxUdXBsZTxpbnQsIFQ+Pltyb3dzXTtcclxuICAgICAgICAgICAgdXNpbmcgKHZhciBjb2x1bW5JdGVyYXRvciA9IGRhdGEuR2V0RW51bWVyYXRvcigpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBjb2x1bW4gPSAwOyBjb2x1bW4gPCBjb2x1bW5zOyBjb2x1bW4rKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbHVtbkl0ZXJhdG9yLk1vdmVOZXh0KCkpIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJkYXRhXCIsIHN0cmluZy5Gb3JtYXQgKFwiUmVzb3VyY2VzLkFyZ3VtZW50QXJyYXlXcm9uZ0xlbmd0aFwiLCBjb2x1bW5zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXNpbmcgKHZhciByb3dJdGVyYXRvciA9IGNvbHVtbkl0ZXJhdG9yLkN1cnJlbnQuR2V0RW51bWVyYXRvcigpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgcm93czsgcm93KyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcm93SXRlcmF0b3IuTW92ZU5leHQoKSkgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImRhdGFcIiwgc3RyaW5nLkZvcm1hdCAoXCJSZXNvdXJjZXMuQXJndW1lbnRBcnJheVdyb25nTGVuZ3RoXCIsIHJvd3MpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVplcm8uRXF1YWxzKHJvd0l0ZXJhdG9yLkN1cnJlbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cm93ID0gdHJvd3Nbcm93XSA/PyAodHJvd3Nbcm93XSA9IG5ldyBMaXN0PFR1cGxlPGludCwgVD4+KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyb3cuQWRkKG5ldyBUdXBsZTxpbnQsIFQ+KGNvbHVtbiwgcm93SXRlcmF0b3IuQ3VycmVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPihyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICAgICAgdmFyIHJvd1BvaW50ZXJzID0gc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBuZXcgTGlzdDxpbnQ+KCk7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgTGlzdDxUPigpO1xyXG5cclxuICAgICAgICAgICAgaW50IGluZGV4ID0gMDtcclxuICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgcm93czsgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJvd1BvaW50ZXJzW3Jvd10gPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHZhciB0cm93ID0gdHJvd3Nbcm93XTtcclxuICAgICAgICAgICAgICAgIGlmICh0cm93ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJvdy5Tb3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yZWFjaCAodmFyIGl0ZW0gaW4gdHJvdylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5BZGQoaXRlbS5JdGVtMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGljZXMuQWRkKGl0ZW0uSXRlbTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcm93UG9pbnRlcnNbcm93c10gPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIHN0b3JhZ2UuQ29sdW1uSW5kaWNlcyA9IGNvbHVtbkluZGljZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICBzdG9yYWdlLlZhbHVlcyA9IHZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPiBPZlJvd01ham9yRW51bWVyYWJsZShpbnQgcm93cywgaW50IGNvbHVtbnMsIElFbnVtZXJhYmxlPFQ+IGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPihyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICAgICAgdmFyIHJvd1BvaW50ZXJzID0gc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBuZXcgTGlzdDxpbnQ+KCk7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgTGlzdDxUPigpO1xyXG5cclxuICAgICAgICAgICAgdXNpbmcgKHZhciBpdGVyYXRvciA9IGRhdGEuR2V0RW51bWVyYXRvcigpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByb3dQb2ludGVyc1tyb3ddID0gdmFsdWVzLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGNvbCA9IDA7IGNvbCA8IGNvbHVtbnM7IGNvbCsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuTW92ZU5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyhpdGVyYXRvci5DdXJyZW50KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZChpdGVyYXRvci5DdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGljZXMuQWRkKGNvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJvd1BvaW50ZXJzW3Jvd3NdID0gdmFsdWVzLkNvdW50O1xyXG4gICAgICAgICAgICBzdG9yYWdlLkNvbHVtbkluZGljZXMgPSBjb2x1bW5JbmRpY2VzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgc3RvcmFnZS5WYWx1ZXMgPSB2YWx1ZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4gT2ZDb2x1bW5NYWpvckxpc3QoaW50IHJvd3MsIGludCBjb2x1bW5zLCBJTGlzdDxUPiBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJvd3MqY29sdW1ucyAhPSBkYXRhLkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24gKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4RGltZW5zaW9uc1wiKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+KHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgICAgICB2YXIgcm93UG9pbnRlcnMgPSBzdG9yYWdlLlJvd1BvaW50ZXJzO1xyXG4gICAgICAgICAgICB2YXIgY29sdW1uSW5kaWNlcyA9IG5ldyBMaXN0PGludD4oKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBMaXN0PFQ+KCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcm93UG9pbnRlcnNbcm93XSA9IHZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGNvbCA9IDA7IGNvbCA8IGNvbHVtbnM7IGNvbCsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZGF0YVtyb3cgKyAoY29sKnJvd3MpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVplcm8uRXF1YWxzKGl0ZW0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kaWNlcy5BZGQoY29sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJvd1BvaW50ZXJzW3Jvd3NdID0gdmFsdWVzLkNvdW50O1xyXG4gICAgICAgICAgICBzdG9yYWdlLkNvbHVtbkluZGljZXMgPSBjb2x1bW5JbmRpY2VzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgc3RvcmFnZS5WYWx1ZXMgPSB2YWx1ZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1BVFJJWCBDT1BZXHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgQ29weVRvVW5jaGVja2VkKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHNwYXJzZVRhcmdldCA9IHRhcmdldCBhcyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUPjtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb3B5VG9VbmNoZWNrZWQoc3BhcnNlVGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRlbnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29weVRvVW5jaGVja2VkKGRlbnNlVGFyZ2V0LCBleGlzdGluZ0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0RhdGEgPT0gRXhpc3RpbmdEYXRhLkNsZWFyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFZhbHVlQ291bnQgIT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnRJbmRleDsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQocm93LCBDb2x1bW5JbmRpY2VzW2pdLCBWYWx1ZXNbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBDb3B5VG9VbmNoZWNrZWQoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGFyZ2V0LlZhbHVlcyA9IG5ldyBUW1ZhbHVlQ291bnRdO1xyXG4gICAgICAgICAgICB0YXJnZXQuQ29sdW1uSW5kaWNlcyA9IG5ldyBpbnRbVmFsdWVDb3VudF07XHJcblxyXG4gICAgICAgICAgICBpZiAoVmFsdWVDb3VudCAhPSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KFZhbHVlcywgMCwgdGFyZ2V0LlZhbHVlcywgMCwgVmFsdWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ29weShDb2x1bW5JbmRpY2VzLCAwLCB0YXJnZXQuQ29sdW1uSW5kaWNlcywgMCwgVmFsdWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KFJvd1BvaW50ZXJzLCAwLCB0YXJnZXQuUm93UG9pbnRlcnMsIDAsIChSb3dDb3VudCArIDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdm9pZCBDb3B5VG9VbmNoZWNrZWQoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRGF0YSA9PSBFeGlzdGluZ0RhdGEuQ2xlYXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5DbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBwcm9wZXIgaW1wbGVtZW50YXRpb25cclxuXHJcbiAgICAgICAgICAgIGlmIChWYWx1ZUNvdW50ICE9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IFJvd1BvaW50ZXJzW3Jvd107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gUm93UG9pbnRlcnNbcm93ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0SW5kZXg7IGogPCBlbmRJbmRleDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkF0KHJvdywgQ29sdW1uSW5kaWNlc1tqXSwgVmFsdWVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlUm93SW5kZXgsIGludCB0YXJnZXRSb3dJbmRleCwgaW50IHJvd0NvdW50LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlQ29sdW1uSW5kZXgsIGludCB0YXJnZXRDb2x1bW5JbmRleCwgaW50IGNvbHVtbkNvdW50LFxyXG4gICAgICAgICAgICBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwidGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc3BhcnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICBpZiAoc3BhcnNlVGFyZ2V0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvcHlTdWJNYXRyaXhUb1VuY2hlY2tlZChzcGFyc2VUYXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlUm93SW5kZXgsIHRhcmdldFJvd0luZGV4LCByb3dDb3VudCxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VDb2x1bW5JbmRleCwgdGFyZ2V0Q29sdW1uSW5kZXgsIGNvbHVtbkNvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRGF0YSA9PSBFeGlzdGluZ0RhdGEuQ2xlYXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5DbGVhclVuY2hlY2tlZCh0YXJnZXRSb3dJbmRleCwgcm93Q291bnQsIHRhcmdldENvbHVtbkluZGV4LCBjb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBzb3VyY2VSb3dJbmRleCwgcm93ID0gMDsgaSA8IHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQ7IGkrKywgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tpICsgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IHN0YXJ0SW5kZXg7IGogPCBlbmRJbmRleDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjb2x1bW4gaW5kZXggaXMgaW4gdGhlIHJhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChDb2x1bW5JbmRpY2VzW2pdID49IHNvdXJjZUNvbHVtbkluZGV4KSAmJiAoQ29sdW1uSW5kaWNlc1tqXSA8IHNvdXJjZUNvbHVtbkluZGV4ICsgY29sdW1uQ291bnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IENvbHVtbkluZGljZXNbal0gLSBzb3VyY2VDb2x1bW5JbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkF0KHRhcmdldFJvd0luZGV4ICsgcm93LCB0YXJnZXRDb2x1bW5JbmRleCArIGNvbHVtbiwgVmFsdWVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgQ29weVN1Yk1hdHJpeFRvVW5jaGVja2VkKFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+IHRhcmdldCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZVJvd0luZGV4LCBpbnQgdGFyZ2V0Um93SW5kZXgsIGludCByb3dDb3VudCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZUNvbHVtbkluZGV4LCBpbnQgdGFyZ2V0Q29sdW1uSW5kZXgsIGludCBjb2x1bW5Db3VudCxcclxuICAgICAgICAgICAgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByb3dPZmZzZXQgPSB0YXJnZXRSb3dJbmRleCAtIHNvdXJjZVJvd0luZGV4O1xyXG4gICAgICAgICAgICB2YXIgY29sdW1uT2Zmc2V0ID0gdGFyZ2V0Q29sdW1uSW5kZXggLSBzb3VyY2VDb2x1bW5JbmRleDtcclxuXHJcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgZW1wdHkgdGFyZ2V0IC0gbXVjaCBmYXN0ZXJcclxuICAgICAgICAgICAgaWYgKHRhcmdldC5WYWx1ZUNvdW50ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vdGU6IFZhbHVlQ291bnQgaXMgbWF4aW11bSByZXN1bHRpbmcgVmFsdWVDb3VudCAoanVzdCB1c2luZyBtYXggdG8gYXZvaWQgaW50ZXJuYWwgY29weWluZylcclxuICAgICAgICAgICAgICAgIC8vIHJlc3VsdGluZyBhcnJheXMgd2lsbCBsaWtlbHkgYmUgc21hbGxlciAtIHVubGVzcyBhbGwgdmFsdWVzIGZpdCBpbiB0aGUgY2hvc2VuIHJhbmdlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBMaXN0PFQ+KFZhbHVlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBuZXcgTGlzdDxpbnQ+KFZhbHVlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvd1BvaW50ZXJzID0gdGFyZ2V0LlJvd1BvaW50ZXJzO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSBzb3VyY2VSb3dJbmRleDsgaSA8IHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByb3dQb2ludGVyc1tpICsgcm93T2Zmc2V0XSA9IHZhbHVlcy5Db3VudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBSb3dQb2ludGVyc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tpICsgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGU6IHdlIG1pZ2h0IGJlIGFibGUgdG8gcmVwbGFjZSB0aGlzIGxvb3Agd2l0aCBBcnJheS5Db3B5IChwZXJmKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGsgPSBzdGFydEluZGV4OyBrIDwgZW5kSW5kZXg7IGsrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjb2x1bW4gaW5kZXggaXMgaW4gdGhlIHJhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoQ29sdW1uSW5kaWNlc1trXSA+PSBzb3VyY2VDb2x1bW5JbmRleCkgJiYgKENvbHVtbkluZGljZXNba10gPCBzb3VyY2VDb2x1bW5JbmRleCArIGNvbHVtbkNvdW50KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZChWYWx1ZXNba10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kaWNlcy5BZGQoQ29sdW1uSW5kaWNlc1trXSArIGNvbHVtbk9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IHRhcmdldFJvd0luZGV4ICsgcm93Q291bnQ7IGkgPCByb3dQb2ludGVycy5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByb3dQb2ludGVyc1tpXSA9IHZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuUm93UG9pbnRlcnNbdGFyZ2V0LlJvd0NvdW50XSA9IHZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5WYWx1ZXMgPSB2YWx1ZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkNvbHVtbkluZGljZXMgPSBjb2x1bW5JbmRpY2VzLlRvQXJyYXkoKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0RhdGEgPT0gRXhpc3RpbmdEYXRhLkNsZWFyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQ2xlYXJVbmNoZWNrZWQodGFyZ2V0Um93SW5kZXgsIHJvd0NvdW50LCB0YXJnZXRDb2x1bW5JbmRleCwgY29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOT1RFOiBwb3RlbnRpYWwgZm9yIG1vcmUgZWZmaWNpZW50IGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBzb3VyY2VSb3dJbmRleCwgcm93ID0gMDsgcm93IDwgcm93Q291bnQ7IGkrKywgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tpICsgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IHN0YXJ0SW5kZXg7IGogPCBlbmRJbmRleDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjb2x1bW4gaW5kZXggaXMgaW4gdGhlIHJhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChDb2x1bW5JbmRpY2VzW2pdID49IHNvdXJjZUNvbHVtbkluZGV4KSAmJiAoQ29sdW1uSW5kaWNlc1tqXSA8IHNvdXJjZUNvbHVtbkluZGV4ICsgY29sdW1uQ291bnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IENvbHVtbkluZGljZXNbal0gLSBzb3VyY2VDb2x1bW5JbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkF0KHRhcmdldFJvd0luZGV4ICsgcm93LCB0YXJnZXRDb2x1bW5JbmRleCArIGNvbHVtbiwgVmFsdWVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJPVyBDT1BZXHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgQ29weVN1YlJvd1RvVW5jaGVja2VkKFZlY3RvclN0b3JhZ2U8VD4gdGFyZ2V0LCBpbnQgcm93SW5kZXgsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VDb2x1bW5JbmRleCwgaW50IHRhcmdldENvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgYm91bmRzIGluIGNvbHVtbkluZGljZXMgYXJyYXkgd2hlcmUgdGhpcyBpdGVtIHNob3VsZCBiZSBzZWFyY2hlZCAodXNpbmcgcm93SW5kZXgpXHJcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4T2ZSb3cgPSBSb3dQb2ludGVyc1tyb3dJbmRleF07XHJcbiAgICAgICAgICAgIHZhciBlbmRJbmRleE9mUm93ID0gUm93UG9pbnRlcnNbcm93SW5kZXggKyAxXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4T2ZSb3cgPT0gZW5kSW5kZXhPZlJvdylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRGF0YSA9PSBFeGlzdGluZ0RhdGEuQ2xlYXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkNsZWFyKHRhcmdldENvbHVtbkluZGV4LCBjb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRTcGFyc2UgPSB0YXJnZXQgYXMgU3BhcnNlVmVjdG9yU3RvcmFnZTxUPjtcclxuICAgICAgICAgICAgaWYgKHRhcmdldFNwYXJzZSAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHNvdXJjZUNvbHVtbkluZGV4ID09IDApICYmICh0YXJnZXRDb2x1bW5JbmRleCA9PSAwKSAmJiAoY29sdW1uQ291bnQgPT0gQ29sdW1uQ291bnQpICYmIChDb2x1bW5Db3VudCA9PSB0YXJnZXRTcGFyc2UuTGVuZ3RoKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWJ1aWxkIG9mIHRoZSB2YWx1ZXMsIGluZGljZXMsIG5vIGNsZWFuIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNwYXJzZS5WYWx1ZUNvdW50ID0gZW5kSW5kZXhPZlJvdyAtIHN0YXJ0SW5kZXhPZlJvdztcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTcGFyc2UuVmFsdWVzID0gbmV3IFRbdGFyZ2V0U3BhcnNlLlZhbHVlQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNwYXJzZS5JbmRpY2VzID0gbmV3IGludFt0YXJnZXRTcGFyc2UuVmFsdWVDb3VudF07XHJcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuQ29weShDb2x1bW5JbmRpY2VzLCBzdGFydEluZGV4T2ZSb3csIHRhcmdldFNwYXJzZS5JbmRpY2VzLCAwLCB0YXJnZXRTcGFyc2UuVmFsdWVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuQ29weShWYWx1ZXMsIHN0YXJ0SW5kZXhPZlJvdywgdGFyZ2V0U3BhcnNlLlZhbHVlcywgMCwgdGFyZ2V0U3BhcnNlLlZhbHVlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBzb3VyY2VTdGFydFBvcyA9IEFycmF5LkJpbmFyeVNlYXJjaDxpbnQ+KENvbHVtbkluZGljZXMsIHN0YXJ0SW5kZXhPZlJvdywgZW5kSW5kZXhPZlJvdyAtIHN0YXJ0SW5kZXhPZlJvdywgc291cmNlQ29sdW1uSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VTdGFydFBvcyA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTdGFydFBvcyA9IH5zb3VyY2VTdGFydFBvcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IHNvdXJjZUVuZFBvcyA9IEFycmF5LkJpbmFyeVNlYXJjaDxpbnQ+KENvbHVtbkluZGljZXMsIHN0YXJ0SW5kZXhPZlJvdywgZW5kSW5kZXhPZlJvdyAtIHN0YXJ0SW5kZXhPZlJvdywgc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZUVuZFBvcyA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VFbmRQb3MgPSB+c291cmNlRW5kUG9zO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbnQgcG9zaXRpb25zVG9Db3B5ID0gc291cmNlRW5kUG9zIC0gc291cmNlU3RhcnRQb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1RvQ29weSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWJ1aWxkIHRoZSB0YXJnZXQgKG5vIGNsZWFuIG5lY2Vzc2FyeSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50IHRhcmdldFN0YXJ0UG9zID0gQXJyYXkuQmluYXJ5U2VhcmNoPGludD4odGFyZ2V0U3BhcnNlLkluZGljZXMsMCwgdGFyZ2V0U3BhcnNlLlZhbHVlQ291bnQsIHRhcmdldENvbHVtbkluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFN0YXJ0UG9zIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhcnRQb3MgPSB+dGFyZ2V0U3RhcnRQb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50IHRhcmdldEVuZFBvcyA9IEFycmF5LkJpbmFyeVNlYXJjaDxpbnQ+KHRhcmdldFNwYXJzZS5JbmRpY2VzLDAsdGFyZ2V0U3BhcnNlLlZhbHVlQ291bnQsICB0YXJnZXRDb2x1bW5JbmRleCArIGNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEVuZFBvcyA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVuZFBvcyA9IE1hdGguTWF4KH50YXJnZXRFbmRQb3MsIHRhcmdldFN0YXJ0UG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnQgbmV3VmFsdWVDb3VudCAgPSB0YXJnZXRTcGFyc2UuVmFsdWVDb3VudCAtICh0YXJnZXRFbmRQb3MgLSB0YXJnZXRTdGFydFBvcykgKyBwb3NpdGlvbnNUb0NvcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRbXSBuZXdWYWx1ZXMgPSBuZXcgVFtuZXdWYWx1ZUNvdW50XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50W10gbmV3SW5kaWNlcyA9IG5ldyBpbnRbbmV3VmFsdWVDb3VudF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgYmVmb3JlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LkNvcHkodGFyZ2V0U3BhcnNlLkluZGljZXMsIDAsIG5ld0luZGljZXMsIDAsIHRhcmdldFN0YXJ0UG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuQ29weSh0YXJnZXRTcGFyc2UuVmFsdWVzLCAwLCBuZXdWYWx1ZXMsIDAsIHRhcmdldFN0YXJ0UG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29weSB2YWx1ZXMgdGhlbXNlbHZlcywgd2l0aCBuZXcgcG9zaXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludCBzaGlmdFJpZ2h0ID0gdGFyZ2V0Q29sdW1uSW5kZXggLSBzb3VyY2VDb2x1bW5JbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBwb3NpdGlvbnNUb0NvcHk7KytpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbmRpY2VzW3RhcmdldFN0YXJ0UG9zICsgaV0gPSBDb2x1bW5JbmRpY2VzW3NvdXJjZVN0YXJ0UG9zICsgaV0gKyBzaGlmdFJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LkNvcHkoVmFsdWVzLCBzb3VyY2VTdGFydFBvcywgbmV3VmFsdWVzLCB0YXJnZXRTdGFydFBvcywgcG9zaXRpb25zVG9Db3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29weSBhZnRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5Db3B5KHRhcmdldFNwYXJzZS5JbmRpY2VzLCB0YXJnZXRFbmRQb3MsIG5ld0luZGljZXMsIHBvc2l0aW9uc1RvQ29weSArIHRhcmdldFN0YXJ0UG9zLCB0YXJnZXRTcGFyc2UuVmFsdWVDb3VudCAtIHRhcmdldEVuZFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LkNvcHkodGFyZ2V0U3BhcnNlLlZhbHVlcywgdGFyZ2V0RW5kUG9zLCBuZXdWYWx1ZXMsIHBvc2l0aW9uc1RvQ29weSArIHRhcmdldFN0YXJ0UG9zLCB0YXJnZXRTcGFyc2UuVmFsdWVDb3VudCAtIHRhcmdldEVuZFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFNwYXJzZS5WYWx1ZXMgPSBuZXdWYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFNwYXJzZS5JbmRpY2VzID0gbmV3SW5kaWNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3BhcnNlLlZhbHVlQ291bnQgPSBuZXdWYWx1ZUNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHRob3VnaCB0aGVyZSBhcmUgbm8gdmFsdWVzIHRvIGNvcHksIHdlIHN0aWxsIG5lZWQgdG8gY2xlYW4gdGhlIGV4aXN0aW5nIHZhbHVlcyAoaWYgbmVjZXNzYXJ5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdEYXRhID09IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkNsZWFyKHRhcmdldENvbHVtbkluZGV4LCBjb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRkFMTEJBQ0tcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRGF0YSA9PSBFeGlzdGluZ0RhdGEuQ2xlYXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5DbGVhcih0YXJnZXRDb2x1bW5JbmRleCwgY29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBub24temVybyBlbGVtZW50cyB1c2UgYmFzZSBjbGFzcyBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gc291cmNlQ29sdW1uSW5kZXgsIGogPSAwOyBpIDwgc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudDsgaSsrLCBqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IEZpbmRJdGVtKHJvd0luZGV4LCBpKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5BdChqLCBpbmRleCA+PSAwID8gVmFsdWVzW2luZGV4XSA6IFplcm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUUkFOU1BPU0VcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBUcmFuc3Bvc2VUb1VuY2hlY2tlZChNYXRyaXhTdG9yYWdlPFQ+IHRhcmdldCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VUYXJnZXQgPSB0YXJnZXQgYXMgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VD47XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVHJhbnNwb3NlVG9VbmNoZWNrZWQoc3BhcnNlVGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRlbnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVHJhbnNwb3NlVG9VbmNoZWNrZWQoZGVuc2VUYXJnZXQsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRGF0YSA9PSBFeGlzdGluZ0RhdGEuQ2xlYXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5DbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoVmFsdWVDb3VudCAhPSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBSb3dQb2ludGVyc1tyb3ddO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IFJvd1BvaW50ZXJzW3JvdyArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydEluZGV4OyBqIDwgZW5kSW5kZXg7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5BdChDb2x1bW5JbmRpY2VzW2pdLCByb3csIFZhbHVlc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2b2lkIFRyYW5zcG9zZVRvVW5jaGVja2VkKFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFQ+IHRhcmdldClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRhcmdldC5WYWx1ZXMgPSBuZXcgVFtWYWx1ZUNvdW50XTtcclxuICAgICAgICAgICAgdGFyZ2V0LkNvbHVtbkluZGljZXMgPSBuZXcgaW50W1ZhbHVlQ291bnRdO1xyXG4gICAgICAgICAgICB2YXIgY3ggPSB0YXJnZXQuVmFsdWVzO1xyXG4gICAgICAgICAgICB2YXIgY3AgPSB0YXJnZXQuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgIHZhciBjaSA9IHRhcmdldC5Db2x1bW5JbmRpY2VzO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29sdW1uIGNvdW50c1xyXG4gICAgICAgICAgICBpbnRbXSB3ID0gbmV3IGludFtDb2x1bW5Db3VudF07XHJcbiAgICAgICAgICAgIGZvciAoaW50IHAgPSAwOyBwIDwgUm93UG9pbnRlcnNbUm93Q291bnRdOyBwKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHdbQ29sdW1uSW5kaWNlc1twXV0rKztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29sdW1uIHBvaW50ZXJzXHJcbiAgICAgICAgICAgIGludCBueiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ29sdW1uQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY3BbaV0gPSBuejtcclxuICAgICAgICAgICAgICAgIG56ICs9IHdbaV07XHJcbiAgICAgICAgICAgICAgICB3W2ldID0gY3BbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3BbQ29sdW1uQ291bnRdID0gbno7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHAgPSBSb3dQb2ludGVyc1tpXTsgcCA8IFJvd1BvaW50ZXJzW2kgKyAxXTsgcCsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBqID0gd1tDb2x1bW5JbmRpY2VzW3BdXSsrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZSBBKGksaikgYXMgZW50cnkgQyhqLGkpXHJcbiAgICAgICAgICAgICAgICAgICAgY2lbal0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN4W2pdID0gVmFsdWVzW3BdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2b2lkIFRyYW5zcG9zZVRvVW5jaGVja2VkKERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFQ+IHRhcmdldCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0RhdGEgPT0gRXhpc3RpbmdEYXRhLkNsZWFyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFZhbHVlQ291bnQgIT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJbmRleCA9IHJvdyAqIENvbHVtbkNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnRJbmRleDsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuRGF0YVt0YXJnZXRJbmRleCArIENvbHVtbkluZGljZXNbal1dID0gVmFsdWVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBUcmFuc3Bvc2VTcXVhcmVJbnBsYWNlVW5jaGVja2VkKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IG5ldyBUW1ZhbHVlQ291bnRdOyAvL3RhcmdldC5WYWx1ZXM7XHJcbiAgICAgICAgICAgIHZhciBjcCA9IG5ldyBpbnRbUm93Q291bnQgKyAxXTtcclxuICAgICAgICAgICAgdmFyIGNpID0gbmV3IGludFtWYWx1ZUNvdW50XTsgLy90YXJnZXQuQ29sdW1uSW5kaWNlcztcclxuXHJcbiAgICAgICAgICAgIC8vIENvbHVtbiBjb3VudHNcclxuICAgICAgICAgICAgaW50W10gdyA9IG5ldyBpbnRbQ29sdW1uQ291bnRdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBwID0gMDsgcCA8IFJvd1BvaW50ZXJzW1Jvd0NvdW50XTsgcCsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB3W0NvbHVtbkluZGljZXNbcF1dKys7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbHVtbiBwb2ludGVyc1xyXG4gICAgICAgICAgICBpbnQgbnogPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IENvbHVtbkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNwW2ldID0gbno7XHJcbiAgICAgICAgICAgICAgICBueiArPSB3W2ldO1xyXG4gICAgICAgICAgICAgICAgd1tpXSA9IGNwW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNwW0NvbHVtbkNvdW50XSA9IG56O1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBwID0gUm93UG9pbnRlcnNbaV07IHAgPCBSb3dQb2ludGVyc1tpICsgMV07IHArKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgaiA9IHdbQ29sdW1uSW5kaWNlc1twXV0rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgQShpLGopIGFzIGVudHJ5IEMoaixpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNpW2pdID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBjeFtqXSA9IFZhbHVlc1twXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgQXJyYXkuQ29weShjeCwgMCwgVmFsdWVzLCAwLCBWYWx1ZUNvdW50KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIEFycmF5LkNvcHkoY2ksIDAsIENvbHVtbkluZGljZXMsIDAsIFZhbHVlQ291bnQpO1xyXG4gICAgICAgICAgICBBcnJheS5Db3B5KGNwLCAwLCBSb3dQb2ludGVycywgMCwgKFJvd0NvdW50ICsgMSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRVhUUkFDVFxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVFtdIFRvUm93TWFqb3JBcnJheSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFRbUm93Q291bnQqQ29sdW1uQ291bnRdO1xyXG4gICAgICAgICAgICBpZiAoVmFsdWVDb3VudCAhPSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHJvdypDb2x1bW5Db3VudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IFJvd1BvaW50ZXJzW3Jvd107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gUm93UG9pbnRlcnNbcm93ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0SW5kZXg7IGogPCBlbmRJbmRleDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W29mZnNldCArIENvbHVtbkluZGljZXNbal1dID0gVmFsdWVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFRbXSBUb0NvbHVtbk1ham9yQXJyYXkoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBUW1Jvd0NvdW50KkNvbHVtbkNvdW50XTtcclxuICAgICAgICAgICAgaWYgKFZhbHVlQ291bnQgIT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnRJbmRleDsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbKENvbHVtbkluZGljZXNbal0pKlJvd0NvdW50ICsgcm93XSA9IFZhbHVlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBUW11bXSBUb1Jvd0FycmF5cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFRbUm93Q291bnRdW107XHJcbiAgICAgICAgICAgIGlmIChWYWx1ZUNvdW50ICE9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgVFtDb2x1bW5Db3VudF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBSb3dQb2ludGVyc1tyb3ddO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IFJvd1BvaW50ZXJzW3JvdyArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydEluZGV4OyBqIDwgZW5kSW5kZXg7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W0NvbHVtbkluZGljZXNbal1dID0gVmFsdWVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXRbcm93XSA9IGFycmF5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVFtdW10gVG9Db2x1bW5BcnJheXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBUW0NvbHVtbkNvdW50XVtdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldFtqXSA9IG5ldyBUW1Jvd0NvdW50XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoVmFsdWVDb3VudCAhPSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBSb3dQb2ludGVyc1tyb3ddO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IFJvd1BvaW50ZXJzW3JvdyArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydEluZGV4OyBqIDwgZW5kSW5kZXg7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFtDb2x1bW5JbmRpY2VzW2pdXVtyb3ddID0gVmFsdWVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFRbLF0gVG9BcnJheSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFRbUm93Q291bnQsIENvbHVtbkNvdW50XTtcclxuICAgICAgICAgICAgaWYgKFZhbHVlQ291bnQgIT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnRJbmRleDsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbcm93LCBDb2x1bW5JbmRpY2VzW2pdXSA9IFZhbHVlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVOVU1FUkFUSU9OXHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBJRW51bWVyYWJsZTxUPiBFbnVtZXJhdGUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGsgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGNvbCA9IDA7IGNvbCA8IENvbHVtbkNvdW50OyBjb2wrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCByZXR1cm4gayA8IFJvd1BvaW50ZXJzW3JvdyArIDFdICYmIENvbHVtbkluZGljZXNba10gPT0gY29sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gVmFsdWVzW2srK11cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBaZXJvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgSUVudW1lcmFibGU8VHVwbGU8aW50LCBpbnQsIFQ+PiBFbnVtZXJhdGVJbmRleGVkKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBjb2wgPSAwOyBjb2wgPCBDb2x1bW5Db3VudDsgY29sKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgcmV0dXJuIGsgPCBSb3dQb2ludGVyc1tyb3cgKyAxXSAmJiBDb2x1bW5JbmRpY2VzW2tdID09IGNvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBUdXBsZTxpbnQsIGludCwgVD4ocm93LCBjb2wsIFZhbHVlc1trKytdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBUdXBsZTxpbnQsIGludCwgVD4ocm93LCBjb2wsIFplcm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgSUVudW1lcmFibGU8VD4gRW51bWVyYXRlTm9uWmVybygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5UYWtlPFQ+KFZhbHVlcyxWYWx1ZUNvdW50KS5XaGVyZSgoRnVuYzxULGJvb2w+KSh4ID0+ICFaZXJvLkVxdWFscyh4KSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIElFbnVtZXJhYmxlPFR1cGxlPGludCwgaW50LCBUPj4gRW51bWVyYXRlTm9uWmVyb0luZGV4ZWQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IFJvd1BvaW50ZXJzW3Jvd107XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydEluZGV4OyBqIDwgZW5kSW5kZXg7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVplcm8uRXF1YWxzKFZhbHVlc1tqXSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCByZXR1cm4gbmV3IFR1cGxlPGludCwgaW50LCBUPihyb3csIENvbHVtbkluZGljZXNbal0sIFZhbHVlc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGSU5EXHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBUdXBsZTxpbnQsIGludCwgVD4gRmluZChGdW5jPFQsIGJvb2w+IHByZWRpY2F0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IFJvd1BvaW50ZXJzW3JvdyArIDFdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0SW5kZXg7IGogPCBlbmRJbmRleDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoVmFsdWVzW2pdKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGU8aW50LCBpbnQsIFQ+KHJvdywgQ29sdW1uSW5kaWNlc1tqXSwgVmFsdWVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHplcm9zID09IFplcm9zLkluY2x1ZGUgJiYgVmFsdWVDb3VudCA8IChSb3dDb3VudCAqIENvbHVtbkNvdW50KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShaZXJvKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgayA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgY29sID0gMDsgY29sIDwgQ29sdW1uQ291bnQ7IGNvbCsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoayA8IFJvd1BvaW50ZXJzW3JvdyArIDFdICYmIENvbHVtbkluZGljZXNba10gPT0gY29sKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgaW50LCBUPihyb3csIGNvbCwgWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSBUdXBsZTxpbnQsIGludCwgVCwgVE90aGVyPiBGaW5kMlVuY2hlY2tlZDxUT3RoZXI+KE1hdHJpeFN0b3JhZ2U8VE90aGVyPiBvdGhlciwgRnVuYzxULCBUT3RoZXIsIGJvb2w+IHByZWRpY2F0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VPdGhlciA9IG90aGVyIGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPFRPdGhlcj47XHJcbiAgICAgICAgICAgIGlmIChkZW5zZU90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRPdGhlcltdIG90aGVyRGF0YSA9IGRlbnNlT3RoZXIuRGF0YTtcclxuICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBjb2wgPSAwOyBjb2wgPCBDb2x1bW5Db3VudDsgY29sKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib29sIGF2YWlsYWJsZSA9IGsgPCBSb3dQb2ludGVyc1tyb3cgKyAxXSAmJiBDb2x1bW5JbmRpY2VzW2tdID09IGNvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShhdmFpbGFibGUgPyBWYWx1ZXNbaysrXSA6IFplcm8sIG90aGVyRGF0YVtjb2wqUm93Q291bnQgKyByb3ddKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVCwgVE90aGVyPihyb3csIGNvbCwgYXZhaWxhYmxlID8gVmFsdWVzW2sgLSAxXSA6IFplcm8sIG90aGVyRGF0YVtjb2wqUm93Q291bnQgKyByb3ddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlhZ29uYWxPdGhlciA9IG90aGVyIGFzIERpYWdvbmFsTWF0cml4U3RvcmFnZTxUT3RoZXI+O1xyXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWxPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUT3RoZXJbXSBvdGhlckRhdGEgPSBkaWFnb25hbE90aGVyLkRhdGE7XHJcbiAgICAgICAgICAgICAgICBUT3RoZXIgb3RoZXJaZXJvID0gQnVpbGRlckluc3RhbmNlPFRPdGhlcj4uTWF0cml4Llplcm87XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRnVsbCBTY2FuXHJcbiAgICAgICAgICAgICAgICBpZiAoemVyb3MgPT0gWmVyb3MuSW5jbHVkZSAmJiBwcmVkaWNhdGUoWmVybywgb3RoZXJaZXJvKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgayA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgY29sID0gMDsgY29sIDwgQ29sdW1uQ291bnQ7IGNvbCsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib29sIGF2YWlsYWJsZSA9IGsgPCBSb3dQb2ludGVyc1tyb3cgKyAxXSAmJiBDb2x1bW5JbmRpY2VzW2tdID09IGNvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoYXZhaWxhYmxlID8gVmFsdWVzW2srK10gOiBaZXJvLCByb3cgPT0gY29sID8gb3RoZXJEYXRhW3Jvd10gOiBvdGhlclplcm8pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGU8aW50LCBpbnQsIFQsIFRPdGhlcj4ocm93LCBjb2wsIGF2YWlsYWJsZSA/IFZhbHVlc1trIC0gMV0gOiBaZXJvLCByb3cgPT0gY29sID8gb3RoZXJEYXRhW3Jvd10gOiBvdGhlclplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNwYXJzZSBTY2FuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9vbCBkaWFnb25hbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnRJbmRleDsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ29sdW1uSW5kaWNlc1tqXSA9PSByb3cpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoVmFsdWVzW2pdLCBvdGhlckRhdGFbcm93XSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVCwgVE90aGVyPihyb3csIHJvdywgVmFsdWVzW2pdLCBvdGhlckRhdGFbcm93XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKFZhbHVlc1tqXSwgb3RoZXJaZXJvKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgaW50LCBULCBUT3RoZXI+KHJvdywgQ29sdW1uSW5kaWNlc1tqXSwgVmFsdWVzW2pdLCBvdGhlclplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlhZ29uYWwgJiYgcm93IDwgQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKFplcm8sIG90aGVyRGF0YVtyb3ddKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVCwgVE90aGVyPihyb3csIHJvdywgWmVybywgb3RoZXJEYXRhW3Jvd10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VPdGhlciA9IG90aGVyIGFzIFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFRPdGhlcj47XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnRbXSBvdGhlclJvd1BvaW50ZXJzID0gc3BhcnNlT3RoZXIuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgICAgICBpbnRbXSBvdGhlckNvbHVtbkluZGljZXMgPSBzcGFyc2VPdGhlci5Db2x1bW5JbmRpY2VzO1xyXG4gICAgICAgICAgICAgICAgVE90aGVyW10gb3RoZXJWYWx1ZXMgPSBzcGFyc2VPdGhlci5WYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICBUT3RoZXIgb3RoZXJaZXJvID0gQnVpbGRlckluc3RhbmNlPFRPdGhlcj4uTWF0cml4Llplcm87XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHplcm9zID09IFplcm9zLkluY2x1ZGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGsgPSAwLCBvdGhlcmsgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGNvbCA9IDA7IGNvbCA8IENvbHVtbkNvdW50OyBjb2wrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9vbCBhdmFpbGFibGUgPSBrIDwgUm93UG9pbnRlcnNbcm93ICsgMV0gJiYgQ29sdW1uSW5kaWNlc1trXSA9PSBjb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib29sIG90aGVyQXZhaWxhYmxlID0gb3RoZXJrIDwgb3RoZXJSb3dQb2ludGVyc1tyb3cgKyAxXSAmJiBvdGhlckNvbHVtbkluZGljZXNbb3RoZXJrXSA9PSBjb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKGF2YWlsYWJsZSA/IFZhbHVlc1trKytdIDogWmVybywgb3RoZXJBdmFpbGFibGUgPyBvdGhlclZhbHVlc1tvdGhlcmsrK10gOiBvdGhlclplcm8pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGU8aW50LCBpbnQsIFQsIFRPdGhlcj4ocm93LCBjb2wsIGF2YWlsYWJsZSA/IFZhbHVlc1trIC0gMV0gOiBaZXJvLCBvdGhlckF2YWlsYWJsZSA/IG90aGVyVmFsdWVzW290aGVyayAtIDFdIDogb3RoZXJaZXJvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gUm93UG9pbnRlcnNbcm93ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyRW5kSW5kZXggPSBvdGhlclJvd1BvaW50ZXJzW3JvdyArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJrID0gb3RoZXJSb3dQb2ludGVyc1tyb3ddO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgZW5kSW5kZXggfHwgb3RoZXJrIDwgb3RoZXJFbmRJbmRleClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrID09IGVuZEluZGV4IHx8IG90aGVyayA8IG90aGVyRW5kSW5kZXggJiYgQ29sdW1uSW5kaWNlc1trXSA+IG90aGVyQ29sdW1uSW5kaWNlc1tvdGhlcmtdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKFplcm8sIG90aGVyVmFsdWVzW290aGVyaysrXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIGludCwgVCwgVE90aGVyPihyb3csIG90aGVyQ29sdW1uSW5kaWNlc1tvdGhlcmsgLSAxXSwgWmVybywgb3RoZXJWYWx1ZXNbb3RoZXJrIC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyayA9PSBvdGhlckVuZEluZGV4IHx8IENvbHVtbkluZGljZXNba10gPCBvdGhlckNvbHVtbkluZGljZXNbb3RoZXJrXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShWYWx1ZXNbaysrXSwgb3RoZXJaZXJvKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgaW50LCBULCBUT3RoZXI+KHJvdywgQ29sdW1uSW5kaWNlc1trIC0gMV0sIFZhbHVlc1trIC0gMV0sIG90aGVyWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKFZhbHVlc1trKytdLCBvdGhlclZhbHVlc1tvdGhlcmsrK10pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGU8aW50LCBpbnQsIFQsIFRPdGhlcj4ocm93LCBDb2x1bW5JbmRpY2VzW2sgLSAxXSwgVmFsdWVzW2sgLSAxXSwgb3RoZXJWYWx1ZXNbb3RoZXJrIC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJhc2UuRmluZDJVbmNoZWNrZWQ8VE90aGVyPihvdGhlciwgKEZ1bmM8VCxUT3RoZXIsYm9vbD4pcHJlZGljYXRlLCB6ZXJvcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGVU5DVElPTkFMIENPTUJJTkFUT1JTOiBNQVBcclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgTWFwSW5wbGFjZShGdW5jPFQsIFQ+IGYsIFplcm9zIHplcm9zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHplcm9zID09IFplcm9zLkluY2x1ZGUgfHwgIVplcm8uRXF1YWxzKGYoWmVybykpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3Um93UG9pbnRlcnMgPSBSb3dQb2ludGVycztcclxuICAgICAgICAgICAgICAgIHZhciBuZXdDb2x1bW5JbmRpY2VzID0gbmV3IExpc3Q8aW50PihDb2x1bW5JbmRpY2VzLkxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IExpc3Q8VD4oVmFsdWVzLkxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaW50IGsgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1Jvd1BvaW50ZXJzW3Jvd10gPSBuZXdWYWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgY29sID0gMDsgY29sIDwgQ29sdW1uQ291bnQ7IGNvbCsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBrIDwgUm93UG9pbnRlcnNbcm93ICsgMV0gJiYgQ29sdW1uSW5kaWNlc1trXSA9PSBjb2wgPyBmKFZhbHVlc1trKytdKSA6IGYoWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoaXRlbSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlcy5BZGQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb2x1bW5JbmRpY2VzLkFkZChjb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIENvbHVtbkluZGljZXMgPSBuZXdDb2x1bW5JbmRpY2VzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIFZhbHVlcyA9IG5ld1ZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBuZXdSb3dQb2ludGVyc1tSb3dDb3VudF0gPSBuZXdWYWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gc2FmZWx5IGRvIHRoaXMgaW4tcGxhY2U6XHJcbiAgICAgICAgICAgICAgICBpbnQgbm9uWmVybyA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBSb3dQb2ludGVyc1tyb3ddO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IFJvd1BvaW50ZXJzW3JvdyArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIFJvd1BvaW50ZXJzW3Jvd10gPSBub25aZXJvO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydEluZGV4OyBqIDwgZW5kSW5kZXg7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZihWYWx1ZXNbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVplcm8uRXF1YWxzKGl0ZW0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZXNbbm9uWmVyb10gPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29sdW1uSW5kaWNlc1tub25aZXJvXSA9IENvbHVtbkluZGljZXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25aZXJvKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBBcnJheS5SZXNpemU8aW50PihyZWYgQ29sdW1uSW5kaWNlcywgbm9uWmVybyk7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5SZXNpemU8VD4ocmVmIFZhbHVlcywgbm9uWmVybyk7XHJcbiAgICAgICAgICAgICAgICBSb3dQb2ludGVyc1tSb3dDb3VudF0gPSBub25aZXJvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBNYXBJbmRleGVkSW5wbGFjZShGdW5jPGludCwgaW50LCBULCBUPiBmLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh6ZXJvcyA9PSBaZXJvcy5JbmNsdWRlIHx8ICFaZXJvLkVxdWFscyhmKDAsIDEsIFplcm8pKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1Jvd1BvaW50ZXJzID0gUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q29sdW1uSW5kaWNlcyA9IG5ldyBMaXN0PGludD4oQ29sdW1uSW5kaWNlcy5MZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBMaXN0PFQ+KFZhbHVlcy5MZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdSb3dQb2ludGVyc1tyb3ddID0gbmV3VmFsdWVzLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGNvbCA9IDA7IGNvbCA8IENvbHVtbkNvdW50OyBjb2wrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gayA8IFJvd1BvaW50ZXJzW3JvdyArIDFdICYmIENvbHVtbkluZGljZXNba10gPT0gY29sID8gZihyb3csIGNvbCwgVmFsdWVzW2srK10pIDogZihyb3csIGNvbCwgWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoaXRlbSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlcy5BZGQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb2x1bW5JbmRpY2VzLkFkZChjb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIENvbHVtbkluZGljZXMgPSBuZXdDb2x1bW5JbmRpY2VzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIFZhbHVlcyA9IG5ld1ZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBuZXdSb3dQb2ludGVyc1tSb3dDb3VudF0gPSBuZXdWYWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gc2FmZWx5IGRvIHRoaXMgaW4tcGxhY2U6XHJcbiAgICAgICAgICAgICAgICBpbnQgbm9uWmVybyA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBSb3dQb2ludGVyc1tyb3ddO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IFJvd1BvaW50ZXJzW3JvdyArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIFJvd1BvaW50ZXJzW3Jvd10gPSBub25aZXJvO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydEluZGV4OyBqIDwgZW5kSW5kZXg7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZihyb3csIENvbHVtbkluZGljZXNbal0sIFZhbHVlc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoaXRlbSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlc1tub25aZXJvXSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb2x1bW5JbmRpY2VzW25vblplcm9dID0gQ29sdW1uSW5kaWNlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vblplcm8rKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEFycmF5LlJlc2l6ZTxpbnQ+KHJlZiBDb2x1bW5JbmRpY2VzLCBub25aZXJvKTtcclxuICAgICAgICAgICAgICAgIEFycmF5LlJlc2l6ZTxUPihyZWYgVmFsdWVzLCBub25aZXJvKTtcclxuICAgICAgICAgICAgICAgIFJvd1BvaW50ZXJzW1Jvd0NvdW50XSA9IG5vblplcm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgTWFwVG9VbmNoZWNrZWQ8VFU+KE1hdHJpeFN0b3JhZ2U8VFU+IHRhcmdldCwgRnVuYzxULCBUVT4gZiwgWmVyb3MgemVyb3MsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcHJvY2Vzc1plcm9zID0gemVyb3MgPT0gWmVyb3MuSW5jbHVkZSB8fCAhWmVyby5FcXVhbHMoZihaZXJvKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3BhcnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFRVPjtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3Um93UG9pbnRlcnMgPSBzcGFyc2VUYXJnZXQuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q29sdW1uSW5kaWNlcyA9IG5ldyBMaXN0PGludD4oQ29sdW1uSW5kaWNlcy5MZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBMaXN0PFRVPihWYWx1ZXMuTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc1plcm9zKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSb3dQb2ludGVyc1tyb3ddID0gbmV3VmFsdWVzLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBjb2wgPSAwOyBjb2wgPCBDb2x1bW5Db3VudDsgY29sKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gayA8IFJvd1BvaW50ZXJzW3JvdyArIDFdICYmIENvbHVtbkluZGljZXNba10gPT0gY29sID8gZihWYWx1ZXNbaysrXSkgOiBmKFplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyhpdGVtKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMuQWRkKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbHVtbkluZGljZXMuQWRkKGNvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um93UG9pbnRlcnNbcm93XSA9IG5ld1ZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBSb3dQb2ludGVyc1tyb3ddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0SW5kZXg7IGogPCBlbmRJbmRleDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGYoVmFsdWVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoaXRlbSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVzLkFkZChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb2x1bW5JbmRpY2VzLkFkZChDb2x1bW5JbmRpY2VzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzcGFyc2VUYXJnZXQuQ29sdW1uSW5kaWNlcyA9IG5ld0NvbHVtbkluZGljZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgc3BhcnNlVGFyZ2V0LlZhbHVlcyA9IG5ld1ZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBuZXdSb3dQb2ludGVyc1tSb3dDb3VudF0gPSBuZXdWYWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRGF0YSA9PSBFeGlzdGluZ0RhdGEuQ2xlYXIgJiYgIXByb2Nlc3NaZXJvcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzWmVyb3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBSb3dQb2ludGVyc1tyb3ddO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IFJvd1BvaW50ZXJzW3JvdyArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGVuZEluZGV4ICYmIGogPT0gQ29sdW1uSW5kaWNlc1tpbmRleF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5BdChyb3csIGosIGYoVmFsdWVzW2luZGV4XSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBNYXRoLk1pbihpbmRleCArIDEsIGVuZEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5BdChyb3csIGosIGYoWmVybykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnRJbmRleDsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQocm93LCBDb2x1bW5JbmRpY2VzW2pdLCBmKFZhbHVlc1tqXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBNYXBJbmRleGVkVG9VbmNoZWNrZWQ8VFU+KE1hdHJpeFN0b3JhZ2U8VFU+IHRhcmdldCwgRnVuYzxpbnQsIGludCwgVCwgVFU+IGYsIFplcm9zIHplcm9zLCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHByb2Nlc3NaZXJvcyA9IHplcm9zID09IFplcm9zLkluY2x1ZGUgfHwgIVplcm8uRXF1YWxzKGYoMCwgMSwgWmVybykpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHNwYXJzZVRhcmdldCA9IHRhcmdldCBhcyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxUVT47XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VUYXJnZXQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1Jvd1BvaW50ZXJzID0gc3BhcnNlVGFyZ2V0LlJvd1BvaW50ZXJzO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0NvbHVtbkluZGljZXMgPSBuZXcgTGlzdDxpbnQ+KENvbHVtbkluZGljZXMuTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgTGlzdDxUVT4oVmFsdWVzLkxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NaZXJvcylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgayA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um93UG9pbnRlcnNbcm93XSA9IG5ld1ZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgY29sID0gMDsgY29sIDwgQ29sdW1uQ291bnQ7IGNvbCsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGsgPCBSb3dQb2ludGVyc1tyb3cgKyAxXSAmJiBDb2x1bW5JbmRpY2VzW2tdID09IGNvbCA/IGYocm93LCBjb2wsIFZhbHVlc1trKytdKSA6IGYocm93LCBjb2wsIFplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyhpdGVtKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMuQWRkKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbHVtbkluZGljZXMuQWRkKGNvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um93UG9pbnRlcnNbcm93XSA9IG5ld1ZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBSb3dQb2ludGVyc1tyb3ddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0SW5kZXg7IGogPCBlbmRJbmRleDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGYocm93LCBDb2x1bW5JbmRpY2VzW2pdLCBWYWx1ZXNbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyhpdGVtKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMuQWRkKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbHVtbkluZGljZXMuQWRkKENvbHVtbkluZGljZXNbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNwYXJzZVRhcmdldC5Db2x1bW5JbmRpY2VzID0gbmV3Q29sdW1uSW5kaWNlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBzcGFyc2VUYXJnZXQuVmFsdWVzID0gbmV3VmFsdWVzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIG5ld1Jvd1BvaW50ZXJzW1Jvd0NvdW50XSA9IG5ld1ZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRkFMTCBCQUNLXHJcblxyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdEYXRhID09IEV4aXN0aW5nRGF0YS5DbGVhciAmJiAhcHJvY2Vzc1plcm9zKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHByb2Nlc3NaZXJvcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IFJvd1BvaW50ZXJzW3Jvd107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gUm93UG9pbnRlcnNbcm93ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgZW5kSW5kZXggJiYgaiA9PSBDb2x1bW5JbmRpY2VzW2luZGV4XSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkF0KHJvdywgaiwgZihyb3csIGosIFZhbHVlc1tpbmRleF0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gTWF0aC5NaW4oaW5kZXggKyAxLCBlbmRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQocm93LCBqLCBmKHJvdywgaiwgWmVybykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnRJbmRleDsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQocm93LCBDb2x1bW5JbmRpY2VzW2pdLCBmKHJvdywgQ29sdW1uSW5kaWNlc1tqXSwgVmFsdWVzW2pdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIE1hcFN1Yk1hdHJpeEluZGV4ZWRUb1VuY2hlY2tlZDxUVT4oTWF0cml4U3RvcmFnZTxUVT4gdGFyZ2V0LCBGdW5jPGludCwgaW50LCBULCBUVT4gZixcclxuICAgICAgICAgICAgaW50IHNvdXJjZVJvd0luZGV4LCBpbnQgdGFyZ2V0Um93SW5kZXgsIGludCByb3dDb3VudCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZUNvbHVtbkluZGV4LCBpbnQgdGFyZ2V0Q29sdW1uSW5kZXgsIGludCBjb2x1bW5Db3VudCxcclxuICAgICAgICAgICAgWmVyb3MgemVyb3MsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3BhcnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPFRVPjtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBNYXBTdWJNYXRyaXhJbmRleGVkVG9VbmNoZWNrZWQ8VFU+KHNwYXJzZVRhcmdldCwgKEZ1bmM8aW50LGludCxULFRVPilmLCBzb3VyY2VSb3dJbmRleCwgdGFyZ2V0Um93SW5kZXgsIHJvd0NvdW50LCBzb3VyY2VDb2x1bW5JbmRleCwgdGFyZ2V0Q29sdW1uSW5kZXgsIGNvbHVtbkNvdW50LCB6ZXJvcywgZXhpc3RpbmdEYXRhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRkFMTCBCQUNLXHJcblxyXG4gICAgICAgICAgICB2YXIgcHJvY2Vzc1plcm9zID0gemVyb3MgPT0gWmVyb3MuSW5jbHVkZSB8fCAhWmVyby5FcXVhbHMoZigwLCAxLCBaZXJvKSk7XHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0RhdGEgPT0gRXhpc3RpbmdEYXRhLkNsZWFyICYmICFwcm9jZXNzWmVyb3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5DbGVhclVuY2hlY2tlZCh0YXJnZXRSb3dJbmRleCwgcm93Q291bnQsIHRhcmdldENvbHVtbkluZGV4LCBjb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzWmVyb3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHNyID0gc291cmNlUm93SW5kZXgsIHRyID0gdGFyZ2V0Um93SW5kZXg7IHNyIDwgc291cmNlUm93SW5kZXggKyByb3dDb3VudDsgc3IrKywgdHIrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBSb3dQb2ludGVyc1tzcl07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gUm93UG9pbnRlcnNbc3IgKyAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBmb3J3YXJkIHRvIG91ciBzdWItcmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgQ29sdW1uSW5kaWNlc1tpbmRleF0gPCBzb3VyY2VDb2x1bW5JbmRleCAmJiBpbmRleCA8IGVuZEluZGV4OyBpbmRleCsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgc2MgPSBzb3VyY2VDb2x1bW5JbmRleCwgdGMgPSB0YXJnZXRDb2x1bW5JbmRleDsgc2MgPCBzb3VyY2VDb2x1bW5JbmRleCArIGNvbHVtbkNvdW50OyBzYysrLCB0YysrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgZW5kSW5kZXggJiYgc2MgPT0gQ29sdW1uSW5kaWNlc1tpbmRleF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5BdCh0ciwgdGMsIGYodHIsIHRjLCBWYWx1ZXNbaW5kZXhdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IE1hdGguTWluKGluZGV4ICsgMSwgZW5kSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkF0KHRyLCB0YywgZih0ciwgdGMsIFplcm8pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBjb2x1bW5PZmZzZXQgPSB0YXJnZXRDb2x1bW5JbmRleCAtIHNvdXJjZUNvbHVtbkluZGV4O1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgc3IgPSBzb3VyY2VSb3dJbmRleCwgdHIgPSB0YXJnZXRSb3dJbmRleDsgc3IgPCBzb3VyY2VSb3dJbmRleCArIHJvd0NvdW50OyBzcisrLCB0cisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbc3JdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IFJvd1BvaW50ZXJzW3NyICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgayA9IHN0YXJ0SW5kZXg7IGsgPCBlbmRJbmRleDsgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGNvbHVtbiBpbmRleCBpcyBpbiB0aGUgcmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChDb2x1bW5JbmRpY2VzW2tdID49IHNvdXJjZUNvbHVtbkluZGV4KSAmJiAoQ29sdW1uSW5kaWNlc1trXSA8IHNvdXJjZUNvbHVtbkluZGV4ICsgY29sdW1uQ291bnQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgdGMgPSBDb2x1bW5JbmRpY2VzW2tdICsgY29sdW1uT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LkF0KHRyLCB0YywgZih0ciwgdGMsIFZhbHVlc1trXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2b2lkIE1hcFN1Yk1hdHJpeEluZGV4ZWRUb1VuY2hlY2tlZDxUVT4oU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VFU+IHRhcmdldCwgRnVuYzxpbnQsIGludCwgVCwgVFU+IGYsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VSb3dJbmRleCwgaW50IHRhcmdldFJvd0luZGV4LCBpbnQgcm93Q291bnQsXHJcbiAgICAgICAgICAgIGludCBzb3VyY2VDb2x1bW5JbmRleCwgaW50IHRhcmdldENvbHVtbkluZGV4LCBpbnQgY29sdW1uQ291bnQsXHJcbiAgICAgICAgICAgIFplcm9zIHplcm9zLCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgICAgICB3aGVyZSBUVSA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUVT4sIElGb3JtYXR0YWJsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHByb2Nlc3NaZXJvcyA9IHplcm9zID09IFplcm9zLkluY2x1ZGUgfHwgIVplcm8uRXF1YWxzKGYoMCwgMSwgWmVybykpO1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdEYXRhID09IEV4aXN0aW5nRGF0YS5DbGVhciAmJiAhcHJvY2Vzc1plcm9zKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQ2xlYXJVbmNoZWNrZWQodGFyZ2V0Um93SW5kZXgsIHJvd0NvdW50LCB0YXJnZXRDb2x1bW5JbmRleCwgY29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcm93T2Zmc2V0ID0gdGFyZ2V0Um93SW5kZXggLSBzb3VyY2VSb3dJbmRleDtcclxuICAgICAgICAgICAgdmFyIGNvbHVtbk9mZnNldCA9IHRhcmdldENvbHVtbkluZGV4IC0gc291cmNlQ29sdW1uSW5kZXg7XHJcbiAgICAgICAgICAgIHZhciB6ZXJvID0gTWF0cml4PFRVPi5aZXJvO1xyXG5cclxuICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBlbXB0eSB0YXJnZXQgLSBtdWNoIGZhc3RlclxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0LlZhbHVlQ291bnQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBMaXN0PFRVPihWYWx1ZUNvdW50KTtcclxuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5JbmRpY2VzID0gbmV3IExpc3Q8aW50PihWYWx1ZUNvdW50KTtcclxuICAgICAgICAgICAgICAgIHZhciByb3dQb2ludGVycyA9IHRhcmdldC5Sb3dQb2ludGVycztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc1plcm9zKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IHNyID0gc291cmNlUm93SW5kZXg7IHNyIDwgc291cmNlUm93SW5kZXggKyByb3dDb3VudDsgc3IrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludCB0ciA9IHNyICsgcm93T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dQb2ludGVyc1t0cl0gPSB2YWx1ZXMuQ291bnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBSb3dQb2ludGVyc1tzcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IFJvd1BvaW50ZXJzW3NyICsgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGZvcndhcmQgdG8gb3VyIHN1Yi1yYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgQ29sdW1uSW5kaWNlc1tpbmRleF0gPCBzb3VyY2VDb2x1bW5JbmRleCAmJiBpbmRleCA8IGVuZEluZGV4OyBpbmRleCsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgc2MgPSBzb3VyY2VDb2x1bW5JbmRleCwgdGMgPSB0YXJnZXRDb2x1bW5JbmRleDsgc2MgPCBzb3VyY2VDb2x1bW5JbmRleCArIGNvbHVtbkNvdW50OyBzYysrLCB0YysrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBlbmRJbmRleCAmJiBzYyA9PSBDb2x1bW5JbmRpY2VzW2luZGV4XSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUVSBpdGVtID0gZih0ciwgdGMsIFZhbHVlc1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghemVyby5FcXVhbHMoaXRlbSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuQWRkKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRpY2VzLkFkZCh0Yyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gTWF0aC5NaW4oaW5kZXggKyAxLCBlbmRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVFUgaXRlbSA9IGYodHIsIHRjLCBaZXJvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXplcm8uRXF1YWxzKGl0ZW0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kaWNlcy5BZGQodGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBzciA9IHNvdXJjZVJvd0luZGV4OyBzciA8IHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQ7IHNyKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnQgdHIgPSBzciArIHJvd09mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93UG9pbnRlcnNbdHJdID0gdmFsdWVzLkNvdW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBSb3dQb2ludGVyc1tzcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IFJvd1BvaW50ZXJzW3NyICsgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBrID0gc3RhcnRJbmRleDsgayA8IGVuZEluZGV4OyBrKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjb2x1bW4gaW5kZXggaXMgaW4gdGhlIHJhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKENvbHVtbkluZGljZXNba10gPj0gc291cmNlQ29sdW1uSW5kZXgpICYmIChDb2x1bW5JbmRpY2VzW2tdIDwgc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IHRjID0gQ29sdW1uSW5kaWNlc1trXSArIGNvbHVtbk9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUVSBpdGVtID0gZih0ciwgdGMsIFZhbHVlc1trXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF6ZXJvLkVxdWFscyhpdGVtKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5BZGQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGljZXMuQWRkKHRjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IHRhcmdldFJvd0luZGV4ICsgcm93Q291bnQ7IGkgPCByb3dQb2ludGVycy5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByb3dQb2ludGVyc1tpXSA9IHZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuUm93UG9pbnRlcnNbdGFyZ2V0LlJvd0NvdW50XSA9IHZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5WYWx1ZXMgPSB2YWx1ZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkNvbHVtbkluZGljZXMgPSBjb2x1bW5JbmRpY2VzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVE9ETzogcHJvcGVyIGdlbmVyYWwgc3BhcnNlIGNhc2UgLSB0aGUgZm9sbG93aW5nIGlzIGVzc2VudGlhbGx5IGEgZmFsbCBiYWNrLCBub3QgbGV2ZXJhZ2luZyB0aGUgdGFyZ2V0IGRhdGEgc3RydWN0dXJlXHJcblxyXG4gICAgICAgICAgICBpZiAocHJvY2Vzc1plcm9zKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBzciA9IHNvdXJjZVJvd0luZGV4LCB0ciA9IHRhcmdldFJvd0luZGV4OyBzciA8IHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQ7IHNyKyssIHRyKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gUm93UG9pbnRlcnNbc3JdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IFJvd1BvaW50ZXJzW3NyICsgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgZm9yd2FyZCB0byBvdXIgc3ViLXJhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IENvbHVtbkluZGljZXNbaW5kZXhdIDwgc291cmNlQ29sdW1uSW5kZXggJiYgaW5kZXggPCBlbmRJbmRleDsgaW5kZXgrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IHNjID0gc291cmNlQ29sdW1uSW5kZXgsIHRjID0gdGFyZ2V0Q29sdW1uSW5kZXg7IHNjIDwgc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudDsgc2MrKywgdGMrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGVuZEluZGV4ICYmIHNjID09IENvbHVtbkluZGljZXNbaW5kZXhdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQodHIsIHRjLCBmKHRyLCB0YywgVmFsdWVzW2luZGV4XSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBNYXRoLk1pbihpbmRleCArIDEsIGVuZEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5BdCh0ciwgdGMsIGYodHIsIHRjLCBaZXJvKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBzciA9IHNvdXJjZVJvd0luZGV4LCB0ciA9IHRhcmdldFJvd0luZGV4OyBzciA8IHNvdXJjZVJvd0luZGV4ICsgcm93Q291bnQ7IHNyKyssIHRyKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBSb3dQb2ludGVyc1tzcl07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gUm93UG9pbnRlcnNbc3IgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBrID0gc3RhcnRJbmRleDsgayA8IGVuZEluZGV4OyBrKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgY29sdW1uIGluZGV4IGlzIGluIHRoZSByYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKENvbHVtbkluZGljZXNba10gPj0gc291cmNlQ29sdW1uSW5kZXgpICYmIChDb2x1bW5JbmRpY2VzW2tdIDwgc291cmNlQ29sdW1uSW5kZXggKyBjb2x1bW5Db3VudCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCB0YyA9IENvbHVtbkluZGljZXNba10gKyBjb2x1bW5PZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuQXQodHIsIHRjLCBmKHRyLCB0YywgVmFsdWVzW2tdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZVTkNUSU9OQUwgQ09NQklOQVRPUlM6IEZPTERcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBGb2xkQnlSb3dVbmNoZWNrZWQ8VFU+KFRVW10gdGFyZ2V0LCBGdW5jPFRVLCBULCBUVT4gZiwgRnVuYzxUVSwgaW50LCBUVT4gZmluYWxpemUsIFRVW10gc3RhdGUsIFplcm9zIHplcm9zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHplcm9zID09IFplcm9zLkFsbG93U2tpcClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBUVSBzID0gc3RhdGVbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnRJbmRleDsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gZihzLCBWYWx1ZXNbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcm93XSA9IGZpbmFsaXplKHMsIGVuZEluZGV4IC0gc3RhcnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBUVSBzID0gc3RhdGVbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBlbmRJbmRleCAmJiBqID09IENvbHVtbkluZGljZXNbaW5kZXhdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gZihzLCBWYWx1ZXNbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gTWF0aC5NaW4oaW5kZXggKyAxLCBlbmRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gZihzLCBaZXJvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcm93XSA9IGZpbmFsaXplKHMsIENvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBGb2xkQnlDb2x1bW5VbmNoZWNrZWQ8VFU+KFRVW10gdGFyZ2V0LCBGdW5jPFRVLCBULCBUVT4gZiwgRnVuYzxUVSwgaW50LCBUVT4gZmluYWxpemUsIFRVW10gc3RhdGUsIFplcm9zIHplcm9zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCFSZWZlcmVuY2VFcXVhbHMoc3RhdGUsIHRhcmdldCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEFycmF5LkNvcHkoc3RhdGUsIDAsIHRhcmdldCwgMCwgc3RhdGUuTGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoemVyb3MgPT0gWmVyb3MuQWxsb3dTa2lwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnRbXSBjb3VudCA9IG5ldyBpbnRbQ29sdW1uQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnRJbmRleDsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gQ29sdW1uSW5kaWNlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2NvbHVtbl0gPSBmKHRhcmdldFtjb2x1bW5dLCBWYWx1ZXNbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudFtjb2x1bW5dKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtqXSA9IGZpbmFsaXplKHRhcmdldFtqXSwgY291bnRbal0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IFJvd1BvaW50ZXJzW3Jvd107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gUm93UG9pbnRlcnNbcm93ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgZW5kSW5kZXggJiYgaiA9PSBDb2x1bW5JbmRpY2VzW2luZGV4XSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2pdID0gZih0YXJnZXRbal0sIFZhbHVlc1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBNYXRoLk1pbihpbmRleCArIDEsIGVuZEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtqXSA9IGYodGFyZ2V0W2pdLCBaZXJvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbal0gPSBmaW5hbGl6ZSh0YXJnZXRbal0sIFJvd0NvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgVFN0YXRlIEZvbGQyVW5jaGVja2VkPFRPdGhlciwgVFN0YXRlPihNYXRyaXhTdG9yYWdlPFRPdGhlcj4gb3RoZXIsIEZ1bmM8VFN0YXRlLCBULCBUT3RoZXIsIFRTdGF0ZT4gZiwgVFN0YXRlIHN0YXRlLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZU90aGVyID0gb3RoZXIgYXMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8VE90aGVyPjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlT3RoZXIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVE90aGVyW10gb3RoZXJEYXRhID0gZGVuc2VPdGhlci5EYXRhO1xyXG4gICAgICAgICAgICAgICAgaW50IGsgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGNvbCA9IDA7IGNvbCA8IENvbHVtbkNvdW50OyBjb2wrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgYXZhaWxhYmxlID0gayA8IFJvd1BvaW50ZXJzW3JvdyArIDFdICYmIENvbHVtbkluZGljZXNba10gPT0gY29sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGYoc3RhdGUsIGF2YWlsYWJsZSA/IFZhbHVlc1trKytdIDogWmVybywgb3RoZXJEYXRhW2NvbCpSb3dDb3VudCArIHJvd10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRpYWdvbmFsT3RoZXIgPSBvdGhlciBhcyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8VE90aGVyPjtcclxuICAgICAgICAgICAgaWYgKGRpYWdvbmFsT3RoZXIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVE90aGVyW10gb3RoZXJEYXRhID0gZGlhZ29uYWxPdGhlci5EYXRhO1xyXG4gICAgICAgICAgICAgICAgVE90aGVyIG90aGVyWmVybyA9IEJ1aWxkZXJJbnN0YW5jZTxUT3RoZXI+Lk1hdHJpeC5aZXJvO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh6ZXJvcyA9PSBaZXJvcy5JbmNsdWRlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBjb2wgPSAwOyBjb2wgPCBDb2x1bW5Db3VudDsgY29sKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgYXZhaWxhYmxlID0gayA8IFJvd1BvaW50ZXJzW3JvdyArIDFdICYmIENvbHVtbkluZGljZXNba10gPT0gY29sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBmKHN0YXRlLCBhdmFpbGFibGUgPyBWYWx1ZXNbaysrXSA6IFplcm8sIHJvdyA9PSBjb2wgPyBvdGhlckRhdGFbcm93XSA6IG90aGVyWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBib29sIGRpYWdvbmFsID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBSb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnRJbmRleDsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ29sdW1uSW5kaWNlc1tqXSA9PSByb3cpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgVmFsdWVzW2pdLCBvdGhlckRhdGFbcm93XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGYoc3RhdGUsIFZhbHVlc1tqXSwgb3RoZXJaZXJvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWFnb25hbCAmJiByb3cgPCBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgWmVybywgb3RoZXJEYXRhW3Jvd10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNwYXJzZU90aGVyID0gb3RoZXIgYXMgU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8VE90aGVyPjtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZU90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludFtdIG90aGVyUm93UG9pbnRlcnMgPSBzcGFyc2VPdGhlci5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgICAgIGludFtdIG90aGVyQ29sdW1uSW5kaWNlcyA9IHNwYXJzZU90aGVyLkNvbHVtbkluZGljZXM7XHJcbiAgICAgICAgICAgICAgICBUT3RoZXJbXSBvdGhlclZhbHVlcyA9IHNwYXJzZU90aGVyLlZhbHVlcztcclxuICAgICAgICAgICAgICAgIFRPdGhlciBvdGhlclplcm8gPSBCdWlsZGVySW5zdGFuY2U8VE90aGVyPi5NYXRyaXguWmVybztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoemVyb3MgPT0gWmVyb3MuSW5jbHVkZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgayA9IDAsIG90aGVyayA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgY29sID0gMDsgY29sIDwgQ29sdW1uQ291bnQ7IGNvbCsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib29sIGF2YWlsYWJsZSA9IGsgPCBSb3dQb2ludGVyc1tyb3cgKyAxXSAmJiBDb2x1bW5JbmRpY2VzW2tdID09IGNvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgb3RoZXJBdmFpbGFibGUgPSBvdGhlcmsgPCBvdGhlclJvd1BvaW50ZXJzW3JvdyArIDFdICYmIG90aGVyQ29sdW1uSW5kaWNlc1tvdGhlcmtdID09IGNvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgYXZhaWxhYmxlID8gVmFsdWVzW2srK10gOiBaZXJvLCBvdGhlckF2YWlsYWJsZSA/IG90aGVyVmFsdWVzW290aGVyaysrXSA6IG90aGVyWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IFJvd1BvaW50ZXJzW3Jvd107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gUm93UG9pbnRlcnNbcm93ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyU3RhcnRJbmRleCA9IG90aGVyUm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJFbmRJbmRleCA9IG90aGVyUm93UG9pbnRlcnNbcm93ICsgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBqMSA9IHN0YXJ0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGoyID0gb3RoZXJTdGFydEluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoajEgPCBlbmRJbmRleCB8fCBqMiA8IG90aGVyRW5kSW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoajEgPT0gZW5kSW5kZXggfHwgajIgPCBvdGhlckVuZEluZGV4ICYmIENvbHVtbkluZGljZXNbajFdID4gb3RoZXJDb2x1bW5JbmRpY2VzW2oyXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBmKHN0YXRlLCBaZXJvLCBvdGhlclZhbHVlc1tqMisrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoajIgPT0gb3RoZXJFbmRJbmRleCB8fCBDb2x1bW5JbmRpY2VzW2oxXSA8IG90aGVyQ29sdW1uSW5kaWNlc1tqMl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgVmFsdWVzW2oxKytdLCBvdGhlclplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBmKHN0YXRlLCBWYWx1ZXNbajErK10sIG90aGVyVmFsdWVzW2oyKytdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRkFMTCBCQUNLXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5Gb2xkMlVuY2hlY2tlZDxUT3RoZXIsVFN0YXRlPihvdGhlciwgKEZ1bmM8VFN0YXRlLFQsVE90aGVyLFRTdGF0ZT4pZiwgc3RhdGUsIHplcm9zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiU3BhcnNlVmVjdG9yU3RvcmFnZS5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDE1IE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlLk1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYTtcclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBTeXN0ZW0uTGlucTtcclxudXNpbmcgU3lzdGVtLlJ1bnRpbWUuU2VyaWFsaXphdGlvbjtcclxuXHJcblxyXG5uYW1lc3BhY2UgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLlN0b3JhZ2Vcclxue1xyXG4gICAgW1NlcmlhbGl6YWJsZV1cclxuICAgIFtEYXRhQ29udHJhY3QoTmFtZXNwYWNlID0gXCJ1cm46TWF0aE5ldC9OdW1lcmljcy9MaW5lYXJBbGdlYnJhXCIpXVxyXG4gICAgcHVibGljIGNsYXNzIFNwYXJzZVZlY3RvclN0b3JhZ2U8VD4gOiBWZWN0b3JTdG9yYWdlPFQ+XHJcbiAgICAgICAgd2hlcmUgVCA6IHN0cnVjdCwgSUVxdWF0YWJsZTxUPiwgSUZvcm1hdHRhYmxlXHJcbiAgICB7XHJcbiAgICAgICAgLy8gW3J1ZWdnXSBwdWJsaWMgZmllbGRzIGFyZSBPSyBoZXJlXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXJyYXkgdGhhdCBjb250YWlucyB0aGUgaW5kaWNlcyBvZiB0aGUgbm9uLXplcm8gdmFsdWVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgW0RhdGFNZW1iZXIoT3JkZXIgPSAxKV1cclxuICAgICAgICBwdWJsaWMgaW50W10gSW5kaWNlcztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBub24temVybyBlbGVtZW50cyBvZiB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgW0RhdGFNZW1iZXIoT3JkZXIgPSAyKV1cclxuICAgICAgICBwdWJsaWMgVFtdIFZhbHVlcztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBudW1iZXIgb2Ygbm9uLXplcm8gZWxlbWVudHMgaW4gdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFtEYXRhTWVtYmVyKE9yZGVyID0gMyldXHJcbiAgICAgICAgcHVibGljIGludCBWYWx1ZUNvdW50O1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBTcGFyc2VWZWN0b3JTdG9yYWdlKGludCBsZW5ndGgpXHJcbiAgICAgICAgICAgIDogYmFzZShsZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBJbmRpY2VzID0gbmV3IGludFswXTtcclxuICAgICAgICAgICAgVmFsdWVzID0gbmV3IFRbMF07XHJcbiAgICAgICAgICAgIFZhbHVlQ291bnQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUcnVlIGlmIHRoZSB2ZWN0b3Igc3RvcmFnZSBmb3JtYXQgaXMgZGVuc2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBJc0RlbnNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gZmFsc2U7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0cmlldmVzIHRoZSByZXF1ZXN0ZWQgZWxlbWVudCB3aXRob3V0IHJhbmdlIGNoZWNraW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFQgQXQoaW50IGluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gU2VhcmNoIGlmIGl0ZW0gaW5kZXggZXhpc3RzIGluIE5vblplcm9JbmRpY2VzIGFycmF5IGluIHJhbmdlIFwiMCAtIG5vbnplcm8gdmFsdWVzIGNvdW50XCJcclxuICAgICAgICAgICAgdmFyIGl0ZW1JbmRleCA9IEFycmF5LkJpbmFyeVNlYXJjaDxpbnQ+KEluZGljZXMsIDAsIFZhbHVlQ291bnQsIGluZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1JbmRleCA+PSAwID8gVmFsdWVzW2l0ZW1JbmRleF0gOiBaZXJvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXRzIHRoZSBlbGVtZW50IHdpdGhvdXQgcmFuZ2UgY2hlY2tpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBBdChpbnQgaW5kZXgsIFQgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBTZWFyY2ggaWYgXCJpbmRleFwiIGFscmVhZHkgZXhpc3RzIGluIHJhbmdlIFwiMCAtIG5vbnplcm8gdmFsdWVzIGNvdW50XCJcclxuICAgICAgICAgICAgdmFyIGl0ZW1JbmRleCA9IEFycmF5LkJpbmFyeVNlYXJjaDxpbnQ+KEluZGljZXMsIDAsIFZhbHVlQ291bnQsIGluZGV4KTtcclxuICAgICAgICAgICAgaWYgKGl0ZW1JbmRleCA+PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb24temVybyBpdGVtIGZvdW5kIGluIG1hdHJpeFxyXG4gICAgICAgICAgICAgICAgaWYgKFplcm8uRXF1YWxzKHZhbHVlKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgZXhpc3RpbmcgaXRlbVxyXG4gICAgICAgICAgICAgICAgICAgIFJlbW92ZUF0SW5kZXhVbmNoZWNrZWQoaXRlbUluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgaXRlbVxyXG4gICAgICAgICAgICAgICAgICAgIFZhbHVlc1tpdGVtSW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBJdGVtIG5vdCBmb3VuZC4gQWRkIG5ldyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgSW5zZXJ0QXRJbmRleFVuY2hlY2tlZCh+aXRlbUluZGV4LCBpbmRleCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIEluc2VydEF0SW5kZXhVbmNoZWNrZWQoaW50IGl0ZW1JbmRleCwgaW50IGluZGV4LCBUIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHN0b3JhZ2UgbmVlZHMgdG8gYmUgaW5jcmVhc2VkXHJcbiAgICAgICAgICAgIGlmICgoVmFsdWVDb3VudCA9PSBWYWx1ZXMuTGVuZ3RoKSAmJiAoVmFsdWVDb3VudCA8IExlbmd0aCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFZhbHVlIGFuZCBJbmRpY2VzIGFycmF5cyBhcmUgY29tcGxldGVseSBmdWxsIHNvIHdlIGluY3JlYXNlIHRoZSBzaXplXHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGguTWluKFZhbHVlcy5MZW5ndGggKyBHcm93dGhTaXplKCksIExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5SZXNpemU8VD4ocmVmIFZhbHVlcywgc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5SZXNpemU8aW50PihyZWYgSW5kaWNlcywgc2l6ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE1vdmUgYWxsIHZhbHVlcyAod2l0aCBhIHBvc2l0aW9uIGxhcmdlciB0aGFuIGluZGV4KSBpbiB0aGUgdmFsdWUgYXJyYXkgdG8gdGhlIG5leHQgcG9zaXRpb25cclxuICAgICAgICAgICAgLy8gTW92ZSBhbGwgdmFsdWVzICh3aXRoIGEgcG9zaXRpb24gbGFyZ2VyIHRoYW4gaW5kZXgpIGluIHRoZSBjb2x1bUluZGljZXMgYXJyYXkgdG8gdGhlIG5leHQgcG9zaXRpb25cclxuICAgICAgICAgICAgQXJyYXkuQ29weShWYWx1ZXMsIGl0ZW1JbmRleCwgVmFsdWVzLCBpdGVtSW5kZXggKyAxLCBWYWx1ZUNvdW50IC0gaXRlbUluZGV4KTtcclxuICAgICAgICAgICAgQXJyYXkuQ29weShJbmRpY2VzLCBpdGVtSW5kZXgsIEluZGljZXMsIGl0ZW1JbmRleCArIDEsIFZhbHVlQ291bnQgLSBpdGVtSW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSB2YWx1ZSBhbmQgdGhlIGNvbHVtbiBpbmRleFxyXG4gICAgICAgICAgICBWYWx1ZXNbaXRlbUluZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBJbmRpY2VzW2l0ZW1JbmRleF0gPSBpbmRleDtcclxuXHJcbiAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBudW1iZXIgb2Ygbm9uLXplcm8gbnVtYmVycyBieSBvbmVcclxuICAgICAgICAgICAgVmFsdWVDb3VudCArPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBSZW1vdmVBdEluZGV4VW5jaGVja2VkKGludCBpdGVtSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBWYWx1ZSBpcyB6ZXJvLiBMZXQncyBkZWxldGUgaXQgZnJvbSBWYWx1ZXMgYW5kIEluZGljZXMgYXJyYXlcclxuICAgICAgICAgICAgQXJyYXkuQ29weShWYWx1ZXMsIGl0ZW1JbmRleCArIDEsIFZhbHVlcywgaXRlbUluZGV4LCBWYWx1ZUNvdW50IC0gaXRlbUluZGV4IC0gMSk7XHJcbiAgICAgICAgICAgIEFycmF5LkNvcHkoSW5kaWNlcywgaXRlbUluZGV4ICsgMSwgSW5kaWNlcywgaXRlbUluZGV4LCBWYWx1ZUNvdW50IC0gaXRlbUluZGV4IC0gMSk7XHJcblxyXG4gICAgICAgICAgICBWYWx1ZUNvdW50IC09IDE7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHdlIG5lZWQgdG8gc2hyaW5rIHRoZSBhcnJheXMuIFRoaXMgaXMgcmVhc29uYWJsZSB0byBkbyBpZlxyXG4gICAgICAgICAgICAvLyB0aGVyZSBhcmUgYSBsb3Qgb2Ygbm9uLXplcm8gZWxlbWVudHMgYW5kIHN0b3JhZ2UgaXMgdHdvIHRpbWVzIGJpZ2dlclxyXG4gICAgICAgICAgICBpZiAoKFZhbHVlQ291bnQgPiAxMDI0KSAmJiAoVmFsdWVDb3VudCA8IEluZGljZXMuTGVuZ3RoIC8gMikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEFycmF5LlJlc2l6ZTxUPihyZWYgVmFsdWVzLCBWYWx1ZUNvdW50KTtcclxuICAgICAgICAgICAgICAgIEFycmF5LlJlc2l6ZTxpbnQ+KHJlZiBJbmRpY2VzLCBWYWx1ZUNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYWxjdWxhdGVzIHRoZSBhbW91bnQgd2l0aCB3aGljaCB0byBncm93IHRoZSBzdG9yYWdlIGFycmF5J3MgaWYgdGhleSBuZWVkIHRvIGJlXHJcbiAgICAgICAgLy8vIGluY3JlYXNlZCBpbiBzaXplLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBhbW91bnQgZ3Jvd24uPC9yZXR1cm5zPlxyXG4gICAgICAgIGludCBHcm93dGhTaXplKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBkZWx0YTtcclxuICAgICAgICAgICAgaWYgKFZhbHVlcy5MZW5ndGggPiAxMDI0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkZWx0YSA9IFZhbHVlcy5MZW5ndGggLyA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKFZhbHVlcy5MZW5ndGggPiAyNTYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSA1MTI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBWYWx1ZXMuTGVuZ3RoID4gNjQgPyAxMjggOiAzMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRlbHRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgRXF1YWxzKFZlY3RvclN0b3JhZ2U8VD4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBSZWplY3QgZXF1YWxpdHkgd2hlbiB0aGUgYXJndW1lbnQgaXMgbnVsbCBvciBoYXMgYSBkaWZmZXJlbnQgc2hhcGUuXHJcbiAgICAgICAgICAgIGlmIChvdGhlciA9PSBudWxsIHx8IExlbmd0aCAhPSBvdGhlci5MZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWNjZXB0IGlmIHRoZSBhcmd1bWVudCBpcyB0aGUgc2FtZSBvYmplY3QgYXMgdGhpcy5cclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCBvdGhlcikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb3RoZXJTcGFyc2UgPSBvdGhlciBhcyBTcGFyc2VWZWN0b3JTdG9yYWdlPFQ+O1xyXG4gICAgICAgICAgICBpZiAob3RoZXJTcGFyc2UgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuRXF1YWxzKG90aGVyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW50IGkgPSAwLCBqID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBWYWx1ZUNvdW50IHx8IGogPCBvdGhlclNwYXJzZS5WYWx1ZUNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA+PSBvdGhlclNwYXJzZS5WYWx1ZUNvdW50IHx8IGkgPCBWYWx1ZUNvdW50ICYmIEluZGljZXNbaV0gPCBvdGhlclNwYXJzZS5JbmRpY2VzW2pdKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoVmFsdWVzW2krK10pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBWYWx1ZUNvdW50IHx8IGogPCBvdGhlclNwYXJzZS5WYWx1ZUNvdW50ICYmIG90aGVyU3BhcnNlLkluZGljZXNbal0gPCBJbmRpY2VzW2ldKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMob3RoZXJTcGFyc2UuVmFsdWVzW2orK10pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIVZhbHVlc1tpXS5FcXVhbHMob3RoZXJTcGFyc2UuVmFsdWVzW2pdKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIGhhc2ggY29kZSBmb3IgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gQSBoYXNoIGNvZGUgZm9yIHRoaXMgaW5zdGFuY2UsIHN1aXRhYmxlIGZvciB1c2UgaW4gaGFzaGluZyBhbGdvcml0aG1zIGFuZCBkYXRhIHN0cnVjdHVyZXMgbGlrZSBhIGhhc2ggdGFibGUuXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IEdldEhhc2hDb2RlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBWYWx1ZXM7XHJcbiAgICAgICAgICAgIHZhciBoYXNoTnVtID0gTWF0aC5NaW4oVmFsdWVDb3VudCwgMjUpO1xyXG4gICAgICAgICAgICBpbnQgaGFzaCA9IDE3O1xyXG4gICAgICAgICAgICB1bmNoZWNrZWRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXNoTnVtOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzaCA9IGhhc2ggKiAzMSArIHZhbHVlc1tpXS5HZXRIYXNoQ29kZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ0xFQVJJTkdcclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgQ2xlYXIoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmFsdWVDb3VudCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBDbGVhcihpbnQgaW5kZXgsIGludCBjb3VudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAwICYmIGNvdW50ID09IExlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGZpcnN0ID0gQXJyYXkuQmluYXJ5U2VhcmNoPGludD4oSW5kaWNlcywgMCwgVmFsdWVDb3VudCwgaW5kZXgpO1xyXG4gICAgICAgICAgICB2YXIgbGFzdCA9IEFycmF5LkJpbmFyeVNlYXJjaDxpbnQ+KEluZGljZXMsIDAsIFZhbHVlQ291bnQsIGluZGV4ICsgY291bnQgLSAxKTtcclxuICAgICAgICAgICAgaWYgKGZpcnN0IDwgMCkgZmlyc3QgPSB+Zmlyc3Q7XHJcbiAgICAgICAgICAgIGlmIChsYXN0IDwgMCkgbGFzdCA9IH5sYXN0IC0gMTtcclxuICAgICAgICAgICAgaW50IGl0ZW1Db3VudCA9IGxhc3QgLSBmaXJzdCArIDE7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXRlbUNvdW50ID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ29weShWYWx1ZXMsIGZpcnN0ICsgaXRlbUNvdW50LCBWYWx1ZXMsIGZpcnN0LCBWYWx1ZUNvdW50IC0gZmlyc3QgLSBpdGVtQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ29weShJbmRpY2VzLCBmaXJzdCArIGl0ZW1Db3VudCwgSW5kaWNlcywgZmlyc3QsIFZhbHVlQ291bnQgLSBmaXJzdCAtIGl0ZW1Db3VudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgVmFsdWVDb3VudCAtPSBpdGVtQ291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgd2UgbmVlZCB0byBzaHJpbmsgdGhlIGFycmF5cy4gVGhpcyBpcyByZWFzb25hYmxlIHRvIGRvIGlmXHJcbiAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBhIGxvdCBvZiBub24temVybyBlbGVtZW50cyBhbmQgc3RvcmFnZSBpcyB0d28gdGltZXMgYmlnZ2VyXHJcbiAgICAgICAgICAgIGlmICgoVmFsdWVDb3VudCA+IDEwMjQpICYmIChWYWx1ZUNvdW50IDwgSW5kaWNlcy5MZW5ndGggLyAyKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuUmVzaXplPFQ+KHJlZiBWYWx1ZXMsIFZhbHVlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuUmVzaXplPGludD4ocmVmIEluZGljZXMsIFZhbHVlQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJTklUSUFMSVpBVElPTlxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZVZlY3RvclN0b3JhZ2U8VD4gT2ZWZWN0b3IoVmVjdG9yU3RvcmFnZTxUPiB2ZWN0b3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBTcGFyc2VWZWN0b3JTdG9yYWdlPFQ+KHZlY3Rvci5MZW5ndGgpO1xyXG4gICAgICAgICAgICB2ZWN0b3IuQ29weVRvVW5jaGVja2VkKHN0b3JhZ2UsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VWZWN0b3JTdG9yYWdlPFQ+IE9mVmFsdWUoaW50IGxlbmd0aCwgVCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChaZXJvLkVxdWFscyh2YWx1ZSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3BhcnNlVmVjdG9yU3RvcmFnZTxUPihsZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDwgMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImxlbmd0aFwiLCBzdHJpbmcuRm9ybWF0KFwiUmVzb3VyY2VzLkFyZ3VtZW50TGVzc1RoYW5PbmV7MH1cIiwgbGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gbmV3IGludFtsZW5ndGhdO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gbmV3IFRbbGVuZ3RoXTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBpbmRpY2VzLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzW2ldID0gaTtcclxuICAgICAgICAgICAgICAgIHZhbHVlc1tpXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZVZlY3RvclN0b3JhZ2U8VD4obGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBJbmRpY2VzID0gaW5kaWNlcyxcclxuICAgICAgICAgICAgICAgIFZhbHVlcyA9IHZhbHVlcyxcclxuICAgICAgICAgICAgICAgIFZhbHVlQ291bnQgPSBsZW5ndGhcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlVmVjdG9yU3RvcmFnZTxUPiBPZkluaXQoaW50IGxlbmd0aCwgRnVuYzxpbnQsIFQ+IGluaXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDwgMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImxlbmd0aFwiLCBzdHJpbmcuRm9ybWF0KFwiUmVzb3VyY2VzLkFyZ3VtZW50TGVzc1RoYW5PbmV7MH1cIiwgbGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gbmV3IExpc3Q8aW50PigpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gbmV3IExpc3Q8VD4oKTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbml0KGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyhpdGVtKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuQWRkKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGljZXMuQWRkKGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BhcnNlVmVjdG9yU3RvcmFnZTxUPihsZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgSW5kaWNlcyA9IGluZGljZXMuVG9BcnJheSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIFZhbHVlcyA9IHZhbHVlcy5Ub0FycmF5KCksXHJcbiAgICAgICAgICAgICAgICAgICAgVmFsdWVDb3VudCA9IHZhbHVlcy5Db3VudFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlVmVjdG9yU3RvcmFnZTxUPiBPZkVudW1lcmFibGUoSUVudW1lcmFibGU8VD4gZGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJkYXRhXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyBMaXN0PGludD4oKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBMaXN0PFQ+KCk7XHJcbiAgICAgICAgICAgIGludCBpbmRleCA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3JlYWNoIChUIGl0ZW0gaW4gZGF0YSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyhpdGVtKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuQWRkKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGljZXMuQWRkKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BhcnNlVmVjdG9yU3RvcmFnZTxUPihpbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBJbmRpY2VzID0gaW5kaWNlcy5Ub0FycmF5KCksXHJcbiAgICAgICAgICAgICAgICAgICAgVmFsdWVzID0gdmFsdWVzLlRvQXJyYXkoKSxcclxuICAgICAgICAgICAgICAgICAgICBWYWx1ZUNvdW50ID0gdmFsdWVzLkNvdW50XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VWZWN0b3JTdG9yYWdlPFQ+IE9mSW5kZXhlZEVudW1lcmFibGUoaW50IGxlbmd0aCwgSUVudW1lcmFibGU8VHVwbGU8aW50LCBUPj4gZGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJkYXRhXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyBMaXN0PGludD4oKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBMaXN0PFQ+KCk7XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKHZhciBpdGVtIGluIGRhdGEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoaXRlbS5JdGVtMikpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZChpdGVtLkl0ZW0yKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLkFkZChpdGVtLkl0ZW0xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGluZGljZXNBcnJheSA9IGluZGljZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzQXJyYXkgPSB2YWx1ZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICBTb3J0aW5nLlNvcnQ8aW50LFQ+KGluZGljZXNBcnJheSwgdmFsdWVzQXJyYXkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VWZWN0b3JTdG9yYWdlPFQ+KGxlbmd0aClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBJbmRpY2VzID0gaW5kaWNlc0FycmF5LFxyXG4gICAgICAgICAgICAgICAgICAgIFZhbHVlcyA9IHZhbHVlc0FycmF5LFxyXG4gICAgICAgICAgICAgICAgICAgIFZhbHVlQ291bnQgPSB2YWx1ZXMuQ291bnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBWRUNUT1IgQ09QWVxyXG5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIC8vIFJvdyBDT1BZXHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgQ29weVRvUm93VW5jaGVja2VkKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBpbnQgcm93SW5kZXgsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdEYXRhID09IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkNsZWFyVW5jaGVja2VkKHJvd0luZGV4LCAxLCAwLCBMZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoVmFsdWVDb3VudCA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgVmFsdWVDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQXQocm93SW5kZXgsIEluZGljZXNbaV0sIFZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENPTFVNTiBDT1BZXHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgQ29weVRvQ29sdW1uVW5jaGVja2VkKE1hdHJpeFN0b3JhZ2U8VD4gdGFyZ2V0LCBpbnQgY29sdW1uSW5kZXgsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdEYXRhID09IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkNsZWFyVW5jaGVja2VkKDAsIExlbmd0aCwgY29sdW1uSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoVmFsdWVDb3VudCA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgVmFsdWVDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQXQoSW5kaWNlc1tpXSwgY29sdW1uSW5kZXgsIFZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNVQi1WRUNUT1IgQ09QWVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIENvcHlTdWJWZWN0b3JUb1VuY2hlY2tlZChWZWN0b3JTdG9yYWdlPFQ+IHRhcmdldCxcclxuICAgICAgICAgICAgaW50IHNvdXJjZUluZGV4LCBpbnQgdGFyZ2V0SW5kZXgsIGludCBjb3VudCwgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VUYXJnZXQgPSB0YXJnZXQgYXMgU3BhcnNlVmVjdG9yU3RvcmFnZTxUPjtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb3B5U3ViVmVjdG9yVG9VbmNoZWNrZWQoc3BhcnNlVGFyZ2V0LCBzb3VyY2VJbmRleCwgdGFyZ2V0SW5kZXgsIGNvdW50LCBleGlzdGluZ0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0YXJnZXRJbmRleCAtIHNvdXJjZUluZGV4O1xyXG5cclxuICAgICAgICAgICAgdmFyIHNvdXJjZUZpcnN0ID0gQXJyYXkuQmluYXJ5U2VhcmNoPGludD4oSW5kaWNlcywgMCwgVmFsdWVDb3VudCwgc291cmNlSW5kZXgpO1xyXG4gICAgICAgICAgICB2YXIgc291cmNlTGFzdCA9IEFycmF5LkJpbmFyeVNlYXJjaDxpbnQ+KEluZGljZXMsIDAsIFZhbHVlQ291bnQsIHNvdXJjZUluZGV4ICsgY291bnQgLSAxKTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZUZpcnN0IDwgMCkgc291cmNlRmlyc3QgPSB+c291cmNlRmlyc3Q7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VMYXN0IDwgMCkgc291cmNlTGFzdCA9IH5zb3VyY2VMYXN0IC0gMTtcclxuXHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0RhdGEgPT0gRXhpc3RpbmdEYXRhLkNsZWFyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuQ2xlYXIodGFyZ2V0SW5kZXgsIGNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IHNvdXJjZUZpcnN0OyBpIDw9IHNvdXJjZUxhc3Q7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkF0KEluZGljZXNbaV0gKyBvZmZzZXQsIFZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZvaWQgQ29weVN1YlZlY3RvclRvVW5jaGVja2VkKFNwYXJzZVZlY3RvclN0b3JhZ2U8VD4gdGFyZ2V0LFxyXG4gICAgICAgICAgICBpbnQgc291cmNlSW5kZXgsIGludCB0YXJnZXRJbmRleCwgaW50IGNvdW50LFxyXG4gICAgICAgICAgICBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRhcmdldEluZGV4IC0gc291cmNlSW5kZXg7XHJcblxyXG4gICAgICAgICAgICB2YXIgc291cmNlRmlyc3QgPSBBcnJheS5CaW5hcnlTZWFyY2g8aW50PihJbmRpY2VzLCAwLCBWYWx1ZUNvdW50LCBzb3VyY2VJbmRleCk7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VMYXN0ID0gQXJyYXkuQmluYXJ5U2VhcmNoPGludD4oSW5kaWNlcywgMCwgVmFsdWVDb3VudCwgc291cmNlSW5kZXggKyBjb3VudCAtIDEpO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlRmlyc3QgPCAwKSBzb3VyY2VGaXJzdCA9IH5zb3VyY2VGaXJzdDtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZUxhc3QgPCAwKSBzb3VyY2VMYXN0ID0gfnNvdXJjZUxhc3QgLSAxO1xyXG4gICAgICAgICAgICBpbnQgc291cmNlQ291bnQgPSBzb3VyY2VMYXN0IC0gc291cmNlRmlyc3QgKyAxO1xyXG5cclxuICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIHdoZW4gY29weWluZyB0byBpdHNlbGZcclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCB0YXJnZXQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gbmV3IFRbc291cmNlQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBuZXcgaW50W3NvdXJjZUNvdW50XTtcclxuXHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KFZhbHVlcywgc291cmNlRmlyc3QsIHZhbHVlcywgMCwgc291cmNlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBpbmRpY2VzLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGljZXNbaV0gPSBJbmRpY2VzW2kgKyBzb3VyY2VGaXJzdF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRGF0YSA9PSBFeGlzdGluZ0RhdGEuQ2xlYXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xlYXIodGFyZ2V0SW5kZXgsIGNvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gc291cmNlRmlyc3Q7IGkgPD0gc291cmNlTGFzdDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEF0KGluZGljZXNbaV0gKyBvZmZzZXQsIHZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIGVtcHR5IHRhcmdldCAtIG11Y2ggZmFzdGVyXHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQuVmFsdWVDb3VudCA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gbmV3IFRbc291cmNlQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBuZXcgaW50W3NvdXJjZUNvdW50XTtcclxuXHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KFZhbHVlcywgc291cmNlRmlyc3QsIHZhbHVlcywgMCwgc291cmNlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBpbmRpY2VzLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGljZXNbaV0gPSBJbmRpY2VzW2kgKyBzb3VyY2VGaXJzdF0gKyBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LlZhbHVlQ291bnQgPSBzb3VyY2VDb3VudDtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5WYWx1ZXMgPSB2YWx1ZXM7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuSW5kaWNlcyA9IGluZGljZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdEYXRhID09IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LkNsZWFyKHRhcmdldEluZGV4LCBjb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBzb3VyY2VGaXJzdDsgaSA8PSBzb3VyY2VMYXN0OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5BdChJbmRpY2VzW2ldICsgb2Zmc2V0LCBWYWx1ZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFWFRSQUNUXHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBUW10gVG9BcnJheSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFRbTGVuZ3RoXTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBWYWx1ZUNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldFtJbmRpY2VzW2ldXSA9IFZhbHVlc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRU5VTUVSQVRJT05cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIElFbnVtZXJhYmxlPFQ+IEVudW1lcmF0ZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgayA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHJldHVybiBrIDwgVmFsdWVDb3VudCAmJiBJbmRpY2VzW2tdID09IGlcclxuICAgICAgICAgICAgICAgICAgICA/IFZhbHVlc1trKytdXHJcbiAgICAgICAgICAgICAgICAgICAgOiBaZXJvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgSUVudW1lcmFibGU8VHVwbGU8aW50LCBUPj4gRW51bWVyYXRlSW5kZXhlZCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgayA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHJldHVybiBrIDwgVmFsdWVDb3VudCAmJiBJbmRpY2VzW2tdID09IGlcclxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBUdXBsZTxpbnQsIFQ+KGksIFZhbHVlc1trKytdKVxyXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFR1cGxlPGludCwgVD4oaSwgWmVybyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBJRW51bWVyYWJsZTxUPiBFbnVtZXJhdGVOb25aZXJvKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlRha2U8VD4oVmFsdWVzLFZhbHVlQ291bnQpLldoZXJlKChGdW5jPFQsYm9vbD4pKHggPT4gIVplcm8uRXF1YWxzKHgpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgSUVudW1lcmFibGU8VHVwbGU8aW50LCBUPj4gRW51bWVyYXRlTm9uWmVyb0luZGV4ZWQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWYWx1ZUNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoVmFsdWVzW2ldKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCByZXR1cm4gbmV3IFR1cGxlPGludCwgVD4oSW5kaWNlc1tpXSwgVmFsdWVzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRklORFxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVHVwbGU8aW50LCBUPiBGaW5kKEZ1bmM8VCwgYm9vbD4gcHJlZGljYXRlLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgVmFsdWVDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKFZhbHVlc1tpXSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIFQ+KEluZGljZXNbaV0sIFZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHplcm9zID09IFplcm9zLkluY2x1ZGUgJiYgVmFsdWVDb3VudCA8IExlbmd0aCAmJiBwcmVkaWNhdGUoWmVybykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gVmFsdWVDb3VudCB8fCBJbmRpY2VzW2ldICE9IGkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgVD4oaSwgWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgVHVwbGU8aW50LCBULCBUT3RoZXI+IEZpbmQyVW5jaGVja2VkPFRPdGhlcj4oVmVjdG9yU3RvcmFnZTxUT3RoZXI+IG90aGVyLCBGdW5jPFQsIFRPdGhlciwgYm9vbD4gcHJlZGljYXRlLCBaZXJvcyB6ZXJvcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZU90aGVyID0gb3RoZXIgYXMgRGVuc2VWZWN0b3JTdG9yYWdlPFRPdGhlcj47XHJcbiAgICAgICAgICAgIGlmIChkZW5zZU90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRPdGhlcltdIG90aGVyRGF0YSA9IGRlbnNlT3RoZXIuRGF0YTtcclxuICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgb3RoZXJEYXRhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrIDwgVmFsdWVDb3VudCAmJiBJbmRpY2VzW2tdID09IGkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKFZhbHVlc1trXSwgb3RoZXJEYXRhW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZTxpbnQsIFQsIFRPdGhlcj4oaSwgVmFsdWVzW2tdLCBvdGhlckRhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShaZXJvLCBvdGhlckRhdGFbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgVCwgVE90aGVyPihpLCBaZXJvLCBvdGhlckRhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VPdGhlciA9IG90aGVyIGFzIFNwYXJzZVZlY3RvclN0b3JhZ2U8VE90aGVyPjtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZU90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludFtdIG90aGVySW5kaWNlcyA9IHNwYXJzZU90aGVyLkluZGljZXM7XHJcbiAgICAgICAgICAgICAgICBUT3RoZXJbXSBvdGhlclZhbHVlcyA9IHNwYXJzZU90aGVyLlZhbHVlcztcclxuICAgICAgICAgICAgICAgIGludCBvdGhlclZhbHVlQ291bnQgPSBzcGFyc2VPdGhlci5WYWx1ZUNvdW50O1xyXG4gICAgICAgICAgICAgICAgVE90aGVyIG90aGVyWmVybyA9IEJ1aWxkZXJJbnN0YW5jZTxUT3RoZXI+Lk1hdHJpeC5aZXJvO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZ1bGwgU2NhblxyXG4gICAgICAgICAgICAgICAgaW50IGsgPSAwLCBvdGhlcmsgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHplcm9zID09IFplcm9zLkluY2x1ZGUgJiYgVmFsdWVDb3VudCA8IExlbmd0aCAmJiBzcGFyc2VPdGhlci5WYWx1ZUNvdW50IDwgTGVuZ3RoICYmIHByZWRpY2F0ZShaZXJvLCBvdGhlclplcm8pKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGsgPCBWYWx1ZUNvdW50ICYmIEluZGljZXNba10gPT0gaSA/IFZhbHVlc1trKytdIDogWmVybztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gb3RoZXJrIDwgb3RoZXJWYWx1ZUNvdW50ICYmIG90aGVySW5kaWNlc1tvdGhlcmtdID09IGkgPyBvdGhlclZhbHVlc1tvdGhlcmsrK10gOiBvdGhlclplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobGVmdCwgcmlnaHQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgVCwgVE90aGVyPihpLCBsZWZ0LCByaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3BhcnNlIFNjYW5cclxuICAgICAgICAgICAgICAgIGsgPSAwO1xyXG4gICAgICAgICAgICAgICAgb3RoZXJrID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgVmFsdWVDb3VudCB8fCBvdGhlcmsgPCBvdGhlclZhbHVlQ291bnQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgPT0gVmFsdWVDb3VudCB8fCBvdGhlcmsgPCBvdGhlclZhbHVlQ291bnQgJiYgSW5kaWNlc1trXSA+IG90aGVySW5kaWNlc1tvdGhlcmtdKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShaZXJvLCBvdGhlclZhbHVlc1tvdGhlcmsrK10pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlPGludCwgVCwgVE90aGVyPihvdGhlckluZGljZXNbb3RoZXJrIC0gMV0sIFplcm8sIG90aGVyVmFsdWVzW290aGVyayAtIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvdGhlcmsgPT0gb3RoZXJWYWx1ZUNvdW50IHx8IEluZGljZXNba10gPCBvdGhlckluZGljZXNbb3RoZXJrXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoVmFsdWVzW2srK10sIG90aGVyWmVybykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGU8aW50LCBULCBUT3RoZXI+KEluZGljZXNbayAtIDFdLCBWYWx1ZXNbayAtIDFdLCBvdGhlclplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoVmFsdWVzW2srK10sIG90aGVyVmFsdWVzW290aGVyaysrXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGU8aW50LCBULCBUT3RoZXI+KEluZGljZXNbayAtIDFdLCBWYWx1ZXNbayAtIDFdLCBvdGhlclZhbHVlc1tvdGhlcmsgLSAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRkFMTCBCQUNLXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5GaW5kMlVuY2hlY2tlZDxUT3RoZXI+KG90aGVyLCAoRnVuYzxULFRPdGhlcixib29sPilwcmVkaWNhdGUsIHplcm9zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZVTkNUSU9OQUwgQ09NQklOQVRPUlM6IE1BUFxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBNYXBJbnBsYWNlKEZ1bmM8VCwgVD4gZiwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyBMaXN0PGludD4oKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBMaXN0PFQ+KFZhbHVlQ291bnQpO1xyXG4gICAgICAgICAgICBpZiAoemVyb3MgPT0gWmVyb3MuSW5jbHVkZSB8fCAhWmVyby5FcXVhbHMoZihaZXJvKSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBrIDwgVmFsdWVDb3VudCAmJiAoSW5kaWNlc1trXSkgPT0gaSA/IGYoVmFsdWVzW2srK10pIDogZihaZXJvKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVplcm8uRXF1YWxzKGl0ZW0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5BZGQoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBWYWx1ZUNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBmKFZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyhpdGVtKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5BZGQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXMuQWRkKEluZGljZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBJbmRpY2VzID0gaW5kaWNlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgIFZhbHVlcyA9IHZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgIFZhbHVlQ291bnQgPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBNYXBJbmRleGVkSW5wbGFjZShGdW5jPGludCwgVCwgVD4gZiwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyBMaXN0PGludD4oKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBMaXN0PFQ+KFZhbHVlQ291bnQpO1xyXG4gICAgICAgICAgICBpZiAoemVyb3MgPT0gWmVyb3MuSW5jbHVkZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGsgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGsgPCBWYWx1ZUNvdW50ICYmIChJbmRpY2VzW2tdKSA9PSBpID8gZihpLCBWYWx1ZXNbaysrXSkgOiBmKGksIFplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoaXRlbSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuQWRkKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLkFkZChpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFZhbHVlQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGYoSW5kaWNlc1tpXSwgVmFsdWVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVplcm8uRXF1YWxzKGl0ZW0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5BZGQoSW5kaWNlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEluZGljZXMgPSBpbmRpY2VzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgVmFsdWVzID0gdmFsdWVzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgVmFsdWVDb3VudCA9IHZhbHVlcy5Db3VudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgTWFwVG9VbmNoZWNrZWQ8VFU+KFZlY3RvclN0b3JhZ2U8VFU+IHRhcmdldCwgRnVuYzxULCBUVT4gZiwgWmVyb3MgemVyb3MsIEV4aXN0aW5nRGF0YSBleGlzdGluZ0RhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3BhcnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIFNwYXJzZVZlY3RvclN0b3JhZ2U8VFU+O1xyXG4gICAgICAgICAgICBpZiAoc3BhcnNlVGFyZ2V0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gbmV3IExpc3Q8aW50PigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBMaXN0PFRVPigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHplcm9zID09IFplcm9zLkluY2x1ZGUgfHwgIVplcm8uRXF1YWxzKGYoWmVybykpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IExlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBrIDwgVmFsdWVDb3VudCAmJiAoSW5kaWNlc1trXSkgPT0gaSA/IGYoVmFsdWVzW2srK10pIDogZihaZXJvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyhpdGVtKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXMuQWRkKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgVmFsdWVDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBmKFZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoaXRlbSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5BZGQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLkFkZChJbmRpY2VzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNwYXJzZVRhcmdldC5JbmRpY2VzID0gaW5kaWNlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBzcGFyc2VUYXJnZXQuVmFsdWVzID0gdmFsdWVzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHNwYXJzZVRhcmdldC5WYWx1ZUNvdW50ID0gdmFsdWVzLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGVuc2VUYXJnZXQgPSB0YXJnZXQgYXMgRGVuc2VWZWN0b3JTdG9yYWdlPFRVPjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlVGFyZ2V0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0RhdGEgPT0gRXhpc3RpbmdEYXRhLkNsZWFyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbnNlVGFyZ2V0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHplcm9zID09IFplcm9zLkluY2x1ZGUgfHwgIVplcm8uRXF1YWxzKGYoWmVybykpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBrID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IExlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVuc2VUYXJnZXQuRGF0YVtpXSA9IGsgPCBWYWx1ZUNvdW50ICYmIChJbmRpY2VzW2tdKSA9PSBpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGYoVmFsdWVzW2srK10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGYoWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFZhbHVlQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVuc2VUYXJnZXQuRGF0YVtJbmRpY2VzW2ldXSA9IGYoVmFsdWVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGQUxMIEJBQ0tcclxuXHJcbiAgICAgICAgICAgIGJhc2UuTWFwVG9VbmNoZWNrZWQ8VFU+KHRhcmdldCwgKEZ1bmM8VCxUVT4pZiwgemVyb3MsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIE1hcEluZGV4ZWRUb1VuY2hlY2tlZDxUVT4oVmVjdG9yU3RvcmFnZTxUVT4gdGFyZ2V0LCBGdW5jPGludCwgVCwgVFU+IGYsIFplcm9zIHplcm9zLCBFeGlzdGluZ0RhdGEgZXhpc3RpbmdEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHNwYXJzZVRhcmdldCA9IHRhcmdldCBhcyBTcGFyc2VWZWN0b3JTdG9yYWdlPFRVPjtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyBMaXN0PGludD4oKTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgTGlzdDxUVT4oKTtcclxuICAgICAgICAgICAgICAgIGlmICh6ZXJvcyA9PSBaZXJvcy5JbmNsdWRlIHx8ICFaZXJvLkVxdWFscyhmKDAsIFplcm8pKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgayA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gayA8IFZhbHVlQ291bnQgJiYgKEluZGljZXNba10pID09IGkgPyBmKGksIFZhbHVlc1trKytdKSA6IGYoaSwgWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHMoaXRlbSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5BZGQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLkFkZChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFZhbHVlQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZihJbmRpY2VzW2ldLCBWYWx1ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVplcm8uRXF1YWxzKGl0ZW0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuQWRkKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5BZGQoSW5kaWNlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzcGFyc2VUYXJnZXQuSW5kaWNlcyA9IGluZGljZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgc3BhcnNlVGFyZ2V0LlZhbHVlcyA9IHZhbHVlcy5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBzcGFyc2VUYXJnZXQuVmFsdWVDb3VudCA9IHZhbHVlcy5Db3VudDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRlbnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIERlbnNlVmVjdG9yU3RvcmFnZTxUVT47XHJcbiAgICAgICAgICAgIGlmIChkZW5zZVRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdEYXRhID09IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkZW5zZVRhcmdldC5DbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh6ZXJvcyA9PSBaZXJvcy5JbmNsdWRlIHx8ICFaZXJvLkVxdWFscyhmKDAsIFplcm8pKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgayA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNlVGFyZ2V0LkRhdGFbaV0gPSBrIDwgVmFsdWVDb3VudCAmJiAoSW5kaWNlc1trXSkgPT0gaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmKGksIFZhbHVlc1trKytdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmKGksIFplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBWYWx1ZUNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNlVGFyZ2V0LkRhdGFbSW5kaWNlc1tpXV0gPSBmKEluZGljZXNbaV0sIFZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRkFMTCBCQUNLXHJcblxyXG4gICAgICAgICAgICBiYXNlLk1hcEluZGV4ZWRUb1VuY2hlY2tlZDxUVT4odGFyZ2V0LCAoRnVuYzxpbnQsVCxUVT4pZiwgemVyb3MsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIE1hcDJUb1VuY2hlY2tlZChWZWN0b3JTdG9yYWdlPFQ+IHRhcmdldCwgVmVjdG9yU3RvcmFnZTxUPiBvdGhlciwgRnVuYzxULCBULCBUPiBmLCBaZXJvcyB6ZXJvcywgRXhpc3RpbmdEYXRhIGV4aXN0aW5nRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBwcm9jZXNzWmVyb3MgPSB6ZXJvcyA9PSBaZXJvcy5JbmNsdWRlIHx8ICFaZXJvLkVxdWFscyhmKFplcm8sIFplcm8pKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkZW5zZVRhcmdldCA9IHRhcmdldCBhcyBEZW5zZVZlY3RvclN0b3JhZ2U8VD47XHJcbiAgICAgICAgICAgIHZhciBkZW5zZU90aGVyID0gb3RoZXIgYXMgRGVuc2VWZWN0b3JTdG9yYWdlPFQ+O1xyXG5cclxuICAgICAgICAgICAgaWYgKGRlbnNlVGFyZ2V0ID09IG51bGwgJiYgKGRlbnNlT3RoZXIgIT0gbnVsbCB8fCBwcm9jZXNzWmVyb3MpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgaGFuZGxpbmcgaXMgZWZmZWN0aXZlbHkgZGVuc2UgYnV0IHdlJ3JlIHN1cHBvc2VkIHRvIHB1c2hcclxuICAgICAgICAgICAgICAgIC8vIHRvIGEgc3BhcnNlIHRhcmdldC4gTGV0J3MgdXNlIGEgZGVuc2UgdGFyZ2V0IGluc3RlYWQsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGNvcHkgaXQgbm9ybWFsaXplZCBiYWNrIHRvIHRoZSBzcGFyc2UgdGFyZ2V0LlxyXG4gICAgICAgICAgICAgICAgdmFyIGludGVybWVkaWF0ZSA9IG5ldyBEZW5zZVZlY3RvclN0b3JhZ2U8VD4odGFyZ2V0Lkxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBNYXAyVG9VbmNoZWNrZWQoaW50ZXJtZWRpYXRlLCBvdGhlciwgKEZ1bmM8VCxULFQ+KWYsIHplcm9zLCBFeGlzdGluZ0RhdGEuQXNzdW1lWmVyb3MpO1xyXG4gICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlLkNvcHlUbyh0YXJnZXQsIGV4aXN0aW5nRGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkZW5zZU90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRbXSB0YXJnZXREYXRhID0gZGVuc2VUYXJnZXQuRGF0YTtcclxuICAgICAgICAgICAgICAgIFRbXSBvdGhlckRhdGEgPSBkZW5zZU90aGVyLkRhdGE7XHJcblxyXG4gICAgICAgICAgICAgICAgaW50IGsgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBvdGhlckRhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgPCBWYWx1ZUNvdW50ICYmIEluZGljZXNba10gPT0gaSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldERhdGFbaV0gPSBmKFZhbHVlc1trXSwgb3RoZXJEYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXREYXRhW2ldID0gZihaZXJvLCBvdGhlckRhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VPdGhlciA9IG90aGVyIGFzIFNwYXJzZVZlY3RvclN0b3JhZ2U8VD47XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VPdGhlciAhPSBudWxsICYmIGRlbnNlVGFyZ2V0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRbXSB0YXJnZXREYXRhID0gZGVuc2VUYXJnZXQuRGF0YTtcclxuICAgICAgICAgICAgICAgIGludFtdIG90aGVySW5kaWNlcyA9IHNwYXJzZU90aGVyLkluZGljZXM7XHJcbiAgICAgICAgICAgICAgICBUW10gb3RoZXJWYWx1ZXMgPSBzcGFyc2VPdGhlci5WYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICBpbnQgb3RoZXJWYWx1ZUNvdW50ID0gc3BhcnNlT3RoZXIuVmFsdWVDb3VudDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc1plcm9zKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBwID0gMCwgcSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB0YXJnZXREYXRhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBwIDwgVmFsdWVDb3VudCAmJiBJbmRpY2VzW3BdID09IGkgPyBWYWx1ZXNbcCsrXSA6IFplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IHEgPCBvdGhlclZhbHVlQ291bnQgJiYgb3RoZXJJbmRpY2VzW3FdID09IGkgPyBvdGhlclZhbHVlc1txKytdIDogWmVybztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RGF0YVtpXSA9IGYobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdEYXRhID09IEV4aXN0aW5nRGF0YS5DbGVhcilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNlVGFyZ2V0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbnQgcCA9IDAsIHEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwIDwgVmFsdWVDb3VudCB8fCBxIDwgb3RoZXJWYWx1ZUNvdW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgPj0gb3RoZXJWYWx1ZUNvdW50IHx8IHAgPCBWYWx1ZUNvdW50ICYmIEluZGljZXNbcF0gPCBvdGhlckluZGljZXNbcV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldERhdGFbSW5kaWNlc1twXV0gPSBmKFZhbHVlc1twXSwgWmVybyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocCA+PSBWYWx1ZUNvdW50IHx8IHEgPCBvdGhlclZhbHVlQ291bnQgJiYgSW5kaWNlc1twXSA+IG90aGVySW5kaWNlc1txXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RGF0YVtvdGhlckluZGljZXNbcV1dID0gZihaZXJvLCBvdGhlclZhbHVlc1txXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoSW5kaWNlc1twXSA9PSBvdGhlckluZGljZXNbcV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RGF0YVtJbmRpY2VzW3BdXSA9IGYoVmFsdWVzW3BdLCBvdGhlclZhbHVlc1txXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc3BhcnNlVGFyZ2V0ID0gdGFyZ2V0IGFzIFNwYXJzZVZlY3RvclN0b3JhZ2U8VD47XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VPdGhlciAhPSBudWxsICYmIHNwYXJzZVRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyBMaXN0PGludD4oKTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgTGlzdDxUPigpO1xyXG4gICAgICAgICAgICAgICAgaW50W10gb3RoZXJJbmRpY2VzID0gc3BhcnNlT3RoZXIuSW5kaWNlcztcclxuICAgICAgICAgICAgICAgIFRbXSBvdGhlclZhbHVlcyA9IHNwYXJzZU90aGVyLlZhbHVlcztcclxuICAgICAgICAgICAgICAgIGludCBvdGhlclZhbHVlQ291bnQgPSBzcGFyc2VPdGhlci5WYWx1ZUNvdW50O1xyXG5cclxuICAgICAgICAgICAgICAgIGludCBwID0gMCwgcSA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocCA8IFZhbHVlQ291bnQgfHwgcSA8IG90aGVyVmFsdWVDb3VudClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocSA+PSBvdGhlclZhbHVlQ291bnQgfHwgcCA8IFZhbHVlQ291bnQgJiYgSW5kaWNlc1twXSA8IG90aGVySW5kaWNlc1txXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGYoVmFsdWVzW3BdLCBaZXJvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFaZXJvLkVxdWFscyh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXMuQWRkKEluZGljZXNbcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLkFkZCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHArKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocCA+PSBWYWx1ZUNvdW50IHx8IHEgPCBvdGhlclZhbHVlQ291bnQgJiYgSW5kaWNlc1twXSA+IG90aGVySW5kaWNlc1txXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGYoWmVybywgb3RoZXJWYWx1ZXNbcV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVplcm8uRXF1YWxzKHZhbHVlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5BZGQob3RoZXJJbmRpY2VzW3FdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5BZGQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGYoVmFsdWVzW3BdLCBvdGhlclZhbHVlc1txXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghWmVyby5FcXVhbHModmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLkFkZChJbmRpY2VzW3BdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5BZGQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHErKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3BhcnNlVGFyZ2V0LkluZGljZXMgPSBpbmRpY2VzLlRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIHNwYXJzZVRhcmdldC5WYWx1ZXMgPSB2YWx1ZXMuVG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgc3BhcnNlVGFyZ2V0LlZhbHVlQ291bnQgPSB2YWx1ZXMuQ291bnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZBTEwgQkFDS1xyXG5cclxuICAgICAgICAgICAgYmFzZS5NYXAyVG9VbmNoZWNrZWQodGFyZ2V0LCBvdGhlciwgKEZ1bmM8VCxULFQ+KWYsIHplcm9zLCBleGlzdGluZ0RhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRlVOQ1RJT05BTCBDT01CSU5BVE9SUzogTUFQXHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIFRTdGF0ZSBGb2xkMlVuY2hlY2tlZDxUT3RoZXIsIFRTdGF0ZT4oVmVjdG9yU3RvcmFnZTxUT3RoZXI+IG90aGVyLCBGdW5jPFRTdGF0ZSwgVCwgVE90aGVyLCBUU3RhdGU+IGYsIFRTdGF0ZSBzdGF0ZSwgWmVyb3MgemVyb3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3BhcnNlT3RoZXIgPSBvdGhlciBhcyBTcGFyc2VWZWN0b3JTdG9yYWdlPFRPdGhlcj47XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnRbXSBvdGhlckluZGljZXMgPSBzcGFyc2VPdGhlci5JbmRpY2VzO1xyXG4gICAgICAgICAgICAgICAgVE90aGVyW10gb3RoZXJWYWx1ZXMgPSBzcGFyc2VPdGhlci5WYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICBpbnQgb3RoZXJWYWx1ZUNvdW50ID0gc3BhcnNlT3RoZXIuVmFsdWVDb3VudDtcclxuICAgICAgICAgICAgICAgIFRPdGhlciBvdGhlclplcm8gPSBCdWlsZGVySW5zdGFuY2U8VE90aGVyPi5WZWN0b3IuWmVybztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoemVyb3MgPT0gWmVyb3MuSW5jbHVkZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgcCA9IDAsIHEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHAgPCBWYWx1ZUNvdW50ICYmIEluZGljZXNbcF0gPT0gaSA/IFZhbHVlc1twKytdIDogWmVybztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gcSA8IG90aGVyVmFsdWVDb3VudCAmJiBvdGhlckluZGljZXNbcV0gPT0gaSA/IG90aGVyVmFsdWVzW3ErK10gOiBvdGhlclplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgbGVmdCwgcmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgcCA9IDAsIHEgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwIDwgVmFsdWVDb3VudCB8fCBxIDwgb3RoZXJWYWx1ZUNvdW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgPj0gb3RoZXJWYWx1ZUNvdW50IHx8IHAgPCBWYWx1ZUNvdW50ICYmIEluZGljZXNbcF0gPCBvdGhlckluZGljZXNbcV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgVmFsdWVzW3BdLCBvdGhlclplcm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAgPj0gVmFsdWVDb3VudCB8fCBxIDwgb3RoZXJWYWx1ZUNvdW50ICYmIEluZGljZXNbcF0gPiBvdGhlckluZGljZXNbcV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgWmVybywgb3RoZXJWYWx1ZXNbcV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KEluZGljZXNbcF0gPT0gb3RoZXJJbmRpY2VzW3FdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgVmFsdWVzW3BdLCBvdGhlclZhbHVlc1txXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGVuc2VPdGhlciA9IG90aGVyIGFzIERlbnNlVmVjdG9yU3RvcmFnZTxUT3RoZXI+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUT3RoZXJbXSBvdGhlckRhdGEgPSBkZW5zZU90aGVyLkRhdGE7XHJcblxyXG4gICAgICAgICAgICAgICAgaW50IGsgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBvdGhlckRhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgPCBWYWx1ZUNvdW50ICYmIEluZGljZXNba10gPT0gaSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgVmFsdWVzW2tdLCBvdGhlckRhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZihzdGF0ZSwgWmVybywgb3RoZXJEYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5Gb2xkMlVuY2hlY2tlZDxUT3RoZXIsVFN0YXRlPihvdGhlciwgKEZ1bmM8VFN0YXRlLFQsVE90aGVyLFRTdGF0ZT4pZiwgc3RhdGUsIHplcm9zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiRGVuc2VNYXRyaXguY3NcIiBjb21wYW55PVwiTWF0aC5ORVRcIj5cclxuLy8gTWF0aC5ORVQgTnVtZXJpY3MsIHBhcnQgb2YgdGhlIE1hdGguTkVUIFByb2plY3RcclxuLy8gaHR0cDovL251bWVyaWNzLm1hdGhkb3RuZXQuY29tXHJcbi8vIGh0dHA6Ly9naXRodWIuY29tL21hdGhuZXQvbWF0aG5ldC1udW1lcmljc1xyXG4vL1xyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMyBNYXRoLk5FVFxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxyXG4vLyBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4vLyBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuLy8gcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXHJcbi8vIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4vLyBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xyXG4vLyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4vLyBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXHJcbi8vIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbi8vIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXHJcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxyXG4vLyBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4vLyBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbi8vIDwvY29weXJpZ2h0PlxyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBTeXN0ZW0uTGlucTtcclxuXHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGUuRmFjdG9yaXphdGlvbjtcclxudXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkZhY3Rvcml6YXRpb247XHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5TdG9yYWdlO1xyXG5cclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIE1hdHJpeCBjbGFzcyB3aXRoIGRlbnNlIHN0b3JhZ2UuIFRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgaXMgYSBvbmUgZGltZW5zaW9uYWwgYXJyYXkgaW4gY29sdW1uLW1ham9yIG9yZGVyIChjb2x1bW4gYnkgY29sdW1uKS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBbU2VyaWFsaXphYmxlXVxyXG4gICAgW0RlYnVnZ2VyRGlzcGxheShcIkRlbnNlTWF0cml4IHtSb3dDb3VudH14e0NvbHVtbkNvdW50fS1Eb3VibGVcIildXHJcbiAgICBwdWJsaWMgY2xhc3MgRGVuc2VNYXRyaXggOiBNYXRyaXhcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE51bWJlciBvZiByb3dzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlVzaW5nIHRoaXMgaW5zdGVhZCBvZiB0aGUgUm93Q291bnQgcHJvcGVydHkgdG8gc3BlZWQgdXAgY2FsY3VsYXRpbmdcclxuICAgICAgICAvLy8gYSBtYXRyaXggaW5kZXggaW4gdGhlIGRhdGEgYXJyYXkuPC9yZW1hcmtzPlxyXG4gICAgICAgIHJlYWRvbmx5IGludCBfcm93Q291bnQ7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTnVtYmVyIG9mIGNvbHVtbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+VXNpbmcgdGhpcyBpbnN0ZWFkIG9mIHRoZSBDb2x1bW5Db3VudCBwcm9wZXJ0eSB0byBzcGVlZCB1cCBjYWxjdWxhdGluZ1xyXG4gICAgICAgIC8vLyBhIG1hdHJpeCBpbmRleCBpbiB0aGUgZGF0YSBhcnJheS48L3JlbWFya3M+XHJcbiAgICAgICAgcmVhZG9ubHkgaW50IF9jb2x1bW5Db3VudDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBtYXRyaXgncyBkYXRhLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgbWF0cml4J3MgZGF0YS48L3ZhbHVlPlxyXG4gICAgICAgIHJlYWRvbmx5IGRvdWJsZVtdIF92YWx1ZXM7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBzdHJhaWdodCBmcm9tIGFuIGluaXRpYWxpemVkIG1hdHJpeCBzdG9yYWdlIGluc3RhbmNlLlxyXG4gICAgICAgIC8vLyBUaGUgc3RvcmFnZSBpcyB1c2VkIGRpcmVjdGx5IHdpdGhvdXQgY29weWluZy5cclxuICAgICAgICAvLy8gSW50ZW5kZWQgZm9yIGFkdmFuY2VkIHNjZW5hcmlvcyB3aGVyZSB5b3UncmUgd29ya2luZyBkaXJlY3RseSB3aXRoXHJcbiAgICAgICAgLy8vIHN0b3JhZ2UgZm9yIHBlcmZvcm1hbmNlIG9yIGludGVyb3AgcmVhc29ucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBEZW5zZU1hdHJpeChEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxkb3VibGU+IHN0b3JhZ2UpXHJcbiAgICAgICAgICAgIDogYmFzZShzdG9yYWdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3Jvd0NvdW50ID0gc3RvcmFnZS5Sb3dDb3VudDtcclxuICAgICAgICAgICAgX2NvbHVtbkNvdW50ID0gc3RvcmFnZS5Db2x1bW5Db3VudDtcclxuICAgICAgICAgICAgX3ZhbHVlcyA9IHN0b3JhZ2UuRGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNxdWFyZSBkZW5zZSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMuXHJcbiAgICAgICAgLy8vIEFsbCBjZWxscyBvZiB0aGUgbWF0cml4IHdpbGwgYmUgaW5pdGlhbGl6ZWQgdG8gemVyby5cclxuICAgICAgICAvLy8gWmVyby1sZW5ndGggbWF0cmljZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgb3JkZXIgaXMgbGVzcyB0aGFuIG9uZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgRGVuc2VNYXRyaXgoaW50IG9yZGVyKVxyXG4gICAgICAgICAgICA6IHRoaXMobmV3IERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPGRvdWJsZT4ob3JkZXIsIG9yZGVyKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMuXHJcbiAgICAgICAgLy8vIEFsbCBjZWxscyBvZiB0aGUgbWF0cml4IHdpbGwgYmUgaW5pdGlhbGl6ZWQgdG8gemVyby5cclxuICAgICAgICAvLy8gWmVyby1sZW5ndGggbWF0cmljZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgcm93IG9yIGNvbHVtbiBjb3VudCBpcyBsZXNzIHRoYW4gb25lLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBEZW5zZU1hdHJpeChpbnQgcm93cywgaW50IGNvbHVtbnMpXHJcbiAgICAgICAgICAgIDogdGhpcyhuZXcgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8ZG91YmxlPihyb3dzLCBjb2x1bW5zKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgZGlyZWN0bHkgYmluZGluZyB0byBhIHJhdyBhcnJheS5cclxuICAgICAgICAvLy8gVGhlIGFycmF5IGlzIGFzc3VtZWQgdG8gYmUgaW4gY29sdW1uLW1ham9yIG9yZGVyIChjb2x1bW4gYnkgY29sdW1uKSBhbmQgaXMgdXNlZCBkaXJlY3RseSB3aXRob3V0IGNvcHlpbmcuXHJcbiAgICAgICAgLy8vIFZlcnkgZWZmaWNpZW50LCBidXQgY2hhbmdlcyB0byB0aGUgYXJyYXkgYW5kIHRoZSBtYXRyaXggd2lsbCBhZmZlY3QgZWFjaCBvdGhlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8c2VlYWxzbyBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb3ctbWFqb3Jfb3JkZXJcIi8+XHJcbiAgICAgICAgcHVibGljIERlbnNlTWF0cml4KGludCByb3dzLCBpbnQgY29sdW1ucywgZG91YmxlW10gc3RvcmFnZSlcclxuICAgICAgICAgICAgOiB0aGlzKG5ldyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxkb3VibGU+KHJvd3MsIGNvbHVtbnMsIHN0b3JhZ2UpKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIG90aGVyIG1hdHJpeC5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgb3RoZXIgbWF0cml4LlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VNYXRyaXggT2ZNYXRyaXgoTWF0cml4PGRvdWJsZT4gbWF0cml4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeChEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mTWF0cml4KG1hdHJpeC5TdG9yYWdlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiB0d28tZGltZW5zaW9uYWwgYXJyYXkuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIHByb3ZpZGVkIGFycmF5LlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VNYXRyaXggT2ZBcnJheShkb3VibGVbLF0gYXJyYXkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZBcnJheShhcnJheSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gaW5kZXhlZCBlbnVtZXJhYmxlLlxyXG4gICAgICAgIC8vLyBLZXlzIG11c3QgYmUgcHJvdmlkZWQgYXQgbW9zdCBvbmNlLCB6ZXJvIGlzIGFzc3VtZWQgaWYgYSBrZXkgaXMgb21pdHRlZC5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTWF0cml4IE9mSW5kZXhlZChpbnQgcm93cywgaW50IGNvbHVtbnMsIElFbnVtZXJhYmxlPFR1cGxlPGludCwgaW50LCBkb3VibGU+PiBlbnVtZXJhYmxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeChEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mSW5kZXhlZEVudW1lcmFibGUocm93cywgY29sdW1ucywgZW51bWVyYWJsZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gVGhlIGVudW1lcmFibGUgaXMgYXNzdW1lZCB0byBiZSBpbiBjb2x1bW4tbWFqb3Igb3JkZXIgKGNvbHVtbiBieSBjb2x1bW4pLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VNYXRyaXggT2ZDb2x1bW5NYWpvcihpbnQgcm93cywgaW50IGNvbHVtbnMsIElFbnVtZXJhYmxlPGRvdWJsZT4gY29sdW1uTWFqb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZDb2x1bW5NYWpvckVudW1lcmFibGUocm93cywgY29sdW1ucywgY29sdW1uTWFqb3IpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGVudW1lcmFibGUgb2YgZW51bWVyYWJsZSBjb2x1bW5zLlxyXG4gICAgICAgIC8vLyBFYWNoIGVudW1lcmFibGUgaW4gdGhlIG1hc3RlciBlbnVtZXJhYmxlIHNwZWNpZmllcyBhIGNvbHVtbi5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZXMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZU1hdHJpeCBPZkNvbHVtbnMoSUVudW1lcmFibGU8SUVudW1lcmFibGU8ZG91YmxlPj4gZGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBPZkNvbHVtbkFycmF5cyhTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlNlbGVjdDxJRW51bWVyYWJsZTxkb3VibGU+LGRvdWJsZVtdPihkYXRhLChGdW5jPElFbnVtZXJhYmxlPGRvdWJsZT4sZG91YmxlW10+KSh2ID0+IFN5c3RlbS5MaW5xLkVudW1lcmFibGUuVG9BcnJheTxkb3VibGU+KHYpKSkuVG9BcnJheSgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGVudW1lcmFibGUgb2YgZW51bWVyYWJsZSBjb2x1bW5zLlxyXG4gICAgICAgIC8vLyBFYWNoIGVudW1lcmFibGUgaW4gdGhlIG1hc3RlciBlbnVtZXJhYmxlIHNwZWNpZmllcyBhIGNvbHVtbi5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZXMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZU1hdHJpeCBPZkNvbHVtbnMoaW50IHJvd3MsIGludCBjb2x1bW5zLCBJRW51bWVyYWJsZTxJRW51bWVyYWJsZTxkb3VibGU+PiBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeChEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mQ29sdW1uRW51bWVyYWJsZXMocm93cywgY29sdW1ucywgZGF0YSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gY29sdW1uIGFycmF5cy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXlzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VNYXRyaXggT2ZDb2x1bW5BcnJheXMocGFyYW1zIGRvdWJsZVtdW10gY29sdW1ucylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8ZG91YmxlPi5PZkNvbHVtbkFycmF5cyhjb2x1bW5zKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBjb2x1bW4gYXJyYXlzLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheXMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZU1hdHJpeCBPZkNvbHVtbkFycmF5cyhJRW51bWVyYWJsZTxkb3VibGVbXT4gY29sdW1ucylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8ZG91YmxlPi5PZkNvbHVtbkFycmF5cygoY29sdW1ucyBhcyBkb3VibGVbXVtdKSA/PyBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlRvQXJyYXk8ZG91YmxlW10+KGNvbHVtbnMpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBjb2x1bW4gdmVjdG9ycy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9ycy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTWF0cml4IE9mQ29sdW1uVmVjdG9ycyhwYXJhbXMgVmVjdG9yPGRvdWJsZT5bXSBjb2x1bW5zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBuZXcgVmVjdG9yU3RvcmFnZTxkb3VibGU+W2NvbHVtbnMuTGVuZ3RoXTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBjb2x1bW5zLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlW2ldID0gY29sdW1uc1tpXS5TdG9yYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8ZG91YmxlPi5PZkNvbHVtblZlY3RvcnMoc3RvcmFnZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gY29sdW1uIHZlY3RvcnMuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIHZlY3RvcnMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZU1hdHJpeCBPZkNvbHVtblZlY3RvcnMoSUVudW1lcmFibGU8VmVjdG9yPGRvdWJsZT4+IGNvbHVtbnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZDb2x1bW5WZWN0b3JzKFN5c3RlbS5MaW5xLkVudW1lcmFibGUuU2VsZWN0PFZlY3Rvcjxkb3VibGU+LFZlY3RvclN0b3JhZ2U8ZG91YmxlPj4oY29sdW1ucywoRnVuYzxWZWN0b3I8ZG91YmxlPixWZWN0b3JTdG9yYWdlPGRvdWJsZT4+KShjID0+IGMuU3RvcmFnZSkpLlRvQXJyYXkoKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gZW51bWVyYWJsZSBvZiBlbnVtZXJhYmxlIHJvd3MuXHJcbiAgICAgICAgLy8vIEVhY2ggZW51bWVyYWJsZSBpbiB0aGUgbWFzdGVyIGVudW1lcmFibGUgc3BlY2lmaWVzIGEgcm93LlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlcy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTWF0cml4IE9mUm93cyhJRW51bWVyYWJsZTxJRW51bWVyYWJsZTxkb3VibGU+PiBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9mUm93QXJyYXlzKFN5c3RlbS5MaW5xLkVudW1lcmFibGUuU2VsZWN0PElFbnVtZXJhYmxlPGRvdWJsZT4sZG91YmxlW10+KGRhdGEsKEZ1bmM8SUVudW1lcmFibGU8ZG91YmxlPixkb3VibGVbXT4pKHYgPT4gU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5Ub0FycmF5PGRvdWJsZT4odikpKS5Ub0FycmF5KCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gZW51bWVyYWJsZSBvZiBlbnVtZXJhYmxlIHJvd3MuXHJcbiAgICAgICAgLy8vIEVhY2ggZW51bWVyYWJsZSBpbiB0aGUgbWFzdGVyIGVudW1lcmFibGUgc3BlY2lmaWVzIGEgcm93LlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlcy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTWF0cml4IE9mUm93cyhpbnQgcm93cywgaW50IGNvbHVtbnMsIElFbnVtZXJhYmxlPElFbnVtZXJhYmxlPGRvdWJsZT4+IGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZSb3dFbnVtZXJhYmxlcyhyb3dzLCBjb2x1bW5zLCBkYXRhKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiByb3cgYXJyYXlzLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheXMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZU1hdHJpeCBPZlJvd0FycmF5cyhwYXJhbXMgZG91YmxlW11bXSByb3dzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeChEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mUm93QXJyYXlzKHJvd3MpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHJvdyBhcnJheXMuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGFycmF5cy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTWF0cml4IE9mUm93QXJyYXlzKElFbnVtZXJhYmxlPGRvdWJsZVtdPiByb3dzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeChEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mUm93QXJyYXlzKChyb3dzIGFzIGRvdWJsZVtdW10pID8/IFN5c3RlbS5MaW5xLkVudW1lcmFibGUuVG9BcnJheTxkb3VibGVbXT4ocm93cykpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHJvdyB2ZWN0b3JzLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3JzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VNYXRyaXggT2ZSb3dWZWN0b3JzKHBhcmFtcyBWZWN0b3I8ZG91YmxlPltdIHJvd3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBWZWN0b3JTdG9yYWdlPGRvdWJsZT5bcm93cy5MZW5ndGhdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHJvd3MuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0b3JhZ2VbaV0gPSByb3dzW2ldLlN0b3JhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeChEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mUm93VmVjdG9ycyhzdG9yYWdlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiByb3cgdmVjdG9ycy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9ycy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTWF0cml4IE9mUm93VmVjdG9ycyhJRW51bWVyYWJsZTxWZWN0b3I8ZG91YmxlPj4gcm93cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8ZG91YmxlPi5PZlJvd1ZlY3RvcnMoU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5TZWxlY3Q8VmVjdG9yPGRvdWJsZT4sVmVjdG9yU3RvcmFnZTxkb3VibGU+Pihyb3dzLChGdW5jPFZlY3Rvcjxkb3VibGU+LFZlY3RvclN0b3JhZ2U8ZG91YmxlPj4pKHIgPT4gci5TdG9yYWdlKSkuVG9BcnJheSgpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggd2l0aCB0aGUgZGlhZ29uYWwgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTWF0cml4IE9mRGlhZ29uYWxWZWN0b3IoVmVjdG9yPGRvdWJsZT4gZGlhZ29uYWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbSA9IG5ldyBEZW5zZU1hdHJpeChkaWFnb25hbC5Db3VudCwgZGlhZ29uYWwuQ291bnQpO1xyXG4gICAgICAgICAgICBtLlNldERpYWdvbmFsKGRpYWdvbmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggd2l0aCB0aGUgZGlhZ29uYWwgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTWF0cml4IE9mRGlhZ29uYWxWZWN0b3IoaW50IHJvd3MsIGludCBjb2x1bW5zLCBWZWN0b3I8ZG91YmxlPiBkaWFnb25hbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBtID0gbmV3IERlbnNlTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgICAgICBtLlNldERpYWdvbmFsKGRpYWdvbmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggd2l0aCB0aGUgZGlhZ29uYWwgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBhcnJheS5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXkuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZU1hdHJpeCBPZkRpYWdvbmFsQXJyYXkoZG91YmxlW10gZGlhZ29uYWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbSA9IG5ldyBEZW5zZU1hdHJpeChkaWFnb25hbC5MZW5ndGgsIGRpYWdvbmFsLkxlbmd0aCk7XHJcbiAgICAgICAgICAgIG0uU2V0RGlhZ29uYWwoZGlhZ29uYWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCB3aXRoIHRoZSBkaWFnb25hbCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTWF0cml4IE9mRGlhZ29uYWxBcnJheShpbnQgcm93cywgaW50IGNvbHVtbnMsIGRvdWJsZVtdIGRpYWdvbmFsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG0gPSBuZXcgRGVuc2VNYXRyaXgocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgIG0uU2V0RGlhZ29uYWwoZGlhZ29uYWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIG1hdHJpeCBhbmQgaW5pdGlhbGl6ZSBlYWNoIHZhbHVlIHRvIHRoZSBzYW1lIHByb3ZpZGVkIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZU1hdHJpeCBDcmVhdGUoaW50IHJvd3MsIGludCBjb2x1bW5zLCBkb3VibGUgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gMGQpIHJldHVybiBuZXcgRGVuc2VNYXRyaXgocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VNYXRyaXgoRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8ZG91YmxlPi5PZlZhbHVlKHJvd3MsIGNvbHVtbnMsIHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgaW5pdCBmdW5jdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VNYXRyaXggQ3JlYXRlKGludCByb3dzLCBpbnQgY29sdW1ucywgRnVuYzxpbnQsIGludCwgZG91YmxlPiBpbml0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeChEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mSW5pdChyb3dzLCBjb2x1bW5zLCAoRnVuYzxpbnQsaW50LGRvdWJsZT4paW5pdCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgZGVuc2UgbWF0cml4IGFuZCBpbml0aWFsaXplIGVhY2ggZGlhZ29uYWwgdmFsdWUgdG8gdGhlIHNhbWUgcHJvdmlkZWQgdmFsdWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTWF0cml4IENyZWF0ZURpYWdvbmFsKGludCByb3dzLCBpbnQgY29sdW1ucywgZG91YmxlIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09IDBkKSByZXR1cm4gbmV3IERlbnNlTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlTWF0cml4KERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZEaWFnb25hbEluaXQocm93cywgY29sdW1ucywgKEZ1bmM8aW50LGRvdWJsZT4pKGkgPT4gdmFsdWUpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBkZW5zZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCBkaWFnb25hbCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgaW5pdCBmdW5jdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VNYXRyaXggQ3JlYXRlRGlhZ29uYWwoaW50IHJvd3MsIGludCBjb2x1bW5zLCBGdW5jPGludCwgZG91YmxlPiBpbml0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeChEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mRGlhZ29uYWxJbml0KHJvd3MsIGNvbHVtbnMsIChGdW5jPGludCxkb3VibGU+KWluaXQpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNxdWFyZSBzcGFyc2UgaWRlbnRpdHkgbWF0cml4IHdoZXJlIGVhY2ggZGlhZ29uYWwgdmFsdWUgaXMgc2V0IHRvIE9uZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VNYXRyaXggQ3JlYXRlSWRlbnRpdHkoaW50IG9yZGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZU1hdHJpeChEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mRGlhZ29uYWxJbml0KG9yZGVyLCBvcmRlciwgKEZ1bmM8aW50LGRvdWJsZT4pKGkgPT4gT25lKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgbWF0cml4IHdpdGggdmFsdWVzIHNhbXBsZWQgZnJvbSB0aGUgcHJvdmlkZWQgcmFuZG9tIGRpc3RyaWJ1dGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIG1hdHJpeCdzIGRhdGEuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBtYXRyaXgncyBkYXRhLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGRvdWJsZVtdIFZhbHVlc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF92YWx1ZXM7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5DYWxjdWxhdGVzIHRoZSBpbmR1Y2VkIEwxIG5vcm0gb2YgdGhpcyBtYXRyaXguPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbWF4aW11bSBhYnNvbHV0ZSBjb2x1bW4gc3VtIG9mIHRoZSBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgTDFOb3JtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBub3JtID0gMGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSAwZDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzICs9IE1hdGguQWJzKEF0KGksIGopKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5vcm0gPSBNYXRoLk1heChub3JtLCBzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5DYWxjdWxhdGVzIHRoZSBpbmR1Y2VkIGluZmluaXR5IG5vcm0gb2YgdGhpcyBtYXRyaXguPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbWF4aW11bSBhYnNvbHV0ZSByb3cgc3VtIG9mIHRoZSBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgSW5maW5pdHlOb3JtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBub3JtID0gMGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSAwZDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzICs9IE1hdGguQWJzKEF0KGksIGopKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5vcm0gPSBNYXRoLk1heChub3JtLCBzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5DYWxjdWxhdGVzIHRoZSBlbnRyeS13aXNlIEZyb2Jlbml1cyBub3JtIG9mIHRoaXMgbWF0cml4Ljwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHNxdWFyZSByb290IG9mIHRoZSBzdW0gb2YgdGhlIHNxdWFyZWQgdmFsdWVzLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZG91YmxlIEZyb2Jlbml1c05vcm0oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHRyYW5zcG9zZSA9IFRyYW5zcG9zZSgpO1xyXG4gICAgICAgICAgICB2YXIgYWF0ID0gdGhpcyp0cmFuc3Bvc2U7XHJcbiAgICAgICAgICAgIHZhciBub3JtID0gMGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbm9ybSArPSBhYXQuQXQoaSwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguU3FydChub3JtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTmVnYXRlIGVhY2ggZWxlbWVudCBvZiB0aGlzIG1hdHJpeCBhbmQgcGxhY2UgdGhlIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG5lZ2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9OZWdhdGUoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlUmVzdWx0ID0gcmVzdWx0IGFzIERlbnNlTWF0cml4O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VSZXN1bHQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KSh4ID0+IC14KSwgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBiYXNlLkRvTmVnYXRlKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZCBhIHNjYWxhciB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIGFkZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb0FkZChkb3VibGUgc2NhbGFyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VSZXN1bHQgPSByZXN1bHQgYXMgRGVuc2VNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChkZW5zZVJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvQWRkKHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KSh4ID0+IHggKyBzY2FsYXIpLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGRzIGFub3RoZXIgbWF0cml4IHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIGFkZCB0byB0aGlzIG1hdHJpeC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiBhZGQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiB0aGUgb3RoZXIgbWF0cml4IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgdGhlIHR3byBtYXRyaWNlcyBkb24ndCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9BZGQoTWF0cml4PGRvdWJsZT4gb3RoZXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGRlbnNlICsgZGVuc2UgPSBkZW5zZVxyXG4gICAgICAgICAgICB2YXIgZGVuc2VPdGhlciA9IG90aGVyLlN0b3JhZ2UgYXMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8ZG91YmxlPjtcclxuICAgICAgICAgICAgdmFyIGRlbnNlUmVzdWx0ID0gcmVzdWx0LlN0b3JhZ2UgYXMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8ZG91YmxlPjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlT3RoZXIgIT0gbnVsbCAmJiBkZW5zZVJlc3VsdCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBNYXAyKChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPikoKHgsIHkpID0+IHggKyB5KSwgb3RoZXIsIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZGVuc2UgKyBkaWFnb25hbCA9IGFueVxyXG4gICAgICAgICAgICB2YXIgZGlhZ29uYWxPdGhlciA9IG90aGVyLlN0b3JhZ2UgYXMgRGlhZ29uYWxNYXRyaXhTdG9yYWdlPGRvdWJsZT47XHJcbiAgICAgICAgICAgIGlmIChkaWFnb25hbE90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFN0b3JhZ2UuQ29weVRvVW5jaGVja2VkKHJlc3VsdC5TdG9yYWdlLCBFeGlzdGluZ0RhdGEuQ2xlYXIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpYWdvbmFsID0gZGlhZ29uYWxPdGhlci5EYXRhO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBkaWFnb25hbC5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQoaSwgaSwgcmVzdWx0LkF0KGksIGkpICsgZGlhZ29uYWxbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBiYXNlLkRvQWRkKG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgYSBzY2FsYXIgZnJvbSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIHN1YnRyYWN0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvU3VidHJhY3QoZG91YmxlIHNjYWxhciwgTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlUmVzdWx0ID0gcmVzdWx0IGFzIERlbnNlTWF0cml4O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VSZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmFzZS5Eb1N1YnRyYWN0KHNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KSh4ID0+IHggLSBzY2FsYXIpLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgYW5vdGhlciBtYXRyaXggZnJvbSB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB0byBzdWJ0cmFjdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1N1YnRyYWN0KE1hdHJpeDxkb3VibGU+IG90aGVyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBkZW5zZSArIGRlbnNlID0gZGVuc2VcclxuICAgICAgICAgICAgdmFyIGRlbnNlT3RoZXIgPSBvdGhlci5TdG9yYWdlIGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPGRvdWJsZT47XHJcbiAgICAgICAgICAgIHZhciBkZW5zZVJlc3VsdCA9IHJlc3VsdC5TdG9yYWdlIGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPGRvdWJsZT47XHJcbiAgICAgICAgICAgIGlmIChkZW5zZU90aGVyICE9IG51bGwgJiYgZGVuc2VSZXN1bHQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTWFwMigoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKCh4LCB5KSA9PiB4IC0geSksIG90aGVyLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGRlbnNlICsgZGlhZ29uYWwgPSBtYXRyaXhcclxuICAgICAgICAgICAgdmFyIGRpYWdvbmFsT3RoZXIgPSBvdGhlci5TdG9yYWdlIGFzIERpYWdvbmFsTWF0cml4U3RvcmFnZTxkb3VibGU+O1xyXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWxPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb3B5VG8ocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHZhciBkaWFnb25hbCA9IGRpYWdvbmFsT3RoZXIuRGF0YTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgZGlhZ29uYWwuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KGksIGksIHJlc3VsdC5BdChpLCBpKSAtIGRpYWdvbmFsW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYmFzZS5Eb1N1YnRyYWN0KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyIGFuZCBwbGFjZXMgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBtdWx0aXBseSB0aGUgbWF0cml4IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9NdWx0aXBseShkb3VibGUgc2NhbGFyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VSZXN1bHQgPSByZXN1bHQgYXMgRGVuc2VNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChkZW5zZVJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvTXVsdGlwbHkoc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgeCA9IDA7IHggPCBDb2x1bW5Db3VudDsgeCsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IHkgPSAwOyB5IDwgUm93Q291bnQ7IHkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFt5LCB4XSA9IF92YWx1ZXNbeCozICsgeV0qc2NhbGFyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoaXMgbWF0cml4IHdpdGggYSB2ZWN0b3IgYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb011bHRpcGx5KFZlY3Rvcjxkb3VibGU+IHJpZ2h0U2lkZSwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlUmlnaHQgPSByaWdodFNpZGUgYXMgRGVuc2VWZWN0b3I7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZVJlc3VsdCA9IHJlc3VsdCBhcyBEZW5zZVZlY3RvcjtcclxuXHJcbiAgICAgICAgICAgIGlmIChkZW5zZVJpZ2h0ID09IG51bGwgfHwgZGVuc2VSZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmFzZS5Eb011bHRpcGx5KHJpZ2h0U2lkZSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IEF0KGksIGopICogcmlnaHRTaWRlW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9NdWx0aXBseShNYXRyaXg8ZG91YmxlPiBvdGhlciwgTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlT3RoZXIgPSBvdGhlciBhcyBEZW5zZU1hdHJpeDtcclxuICAgICAgICAgICAgdmFyIGRlbnNlUmVzdWx0ID0gcmVzdWx0IGFzIERlbnNlTWF0cml4O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VPdGhlciAhPSBudWxsICYmIGRlbnNlUmVzdWx0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG90aGVyLkNvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBDb2x1bW5Db3VudDsgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IEF0KGksIGspICogb3RoZXIuQXQoaywgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KGksIGosIHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRpYWdvbmFsT3RoZXIgPSBvdGhlci5TdG9yYWdlIGFzIERpYWdvbmFsTWF0cml4U3RvcmFnZTxkb3VibGU+O1xyXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWxPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlhZ29uYWwgPSBkaWFnb25hbE90aGVyLkRhdGE7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE1hdGguTWluKENvbHVtbkNvdW50LCBvdGhlci5Db2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZCA8IG90aGVyLkNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5DbGVhclN1Yk1hdHJpeCgwLCBSb3dDb3VudCwgQ29sdW1uQ291bnQsIG90aGVyLkNvbHVtbkNvdW50IC0gQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW50IGluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgZDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpLCBqLCBfdmFsdWVzW2luZGV4XSpkaWFnb25hbFtqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBiYXNlLkRvTXVsdGlwbHkob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhpcyBtYXRyaXggd2l0aCB0cmFuc3Bvc2Ugb2YgYW5vdGhlciBtYXRyaXggYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvVHJhbnNwb3NlQW5kTXVsdGlwbHkoTWF0cml4PGRvdWJsZT4gb3RoZXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZU90aGVyID0gb3RoZXIgYXMgRGVuc2VNYXRyaXg7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZVJlc3VsdCA9IHJlc3VsdCBhcyBEZW5zZU1hdHJpeDtcclxuICAgICAgICAgICAgaWYgKGRlbnNlT3RoZXIgIT0gbnVsbCAmJiBkZW5zZVJlc3VsdCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG90aGVyLlJvd0NvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgQ29sdW1uQ291bnQ7IGsrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBBdChpLCBrKSAqIG90aGVyLkF0KGosIGspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpLCBqLCBzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkaWFnb25hbE90aGVyID0gb3RoZXIuU3RvcmFnZSBhcyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8ZG91YmxlPjtcclxuICAgICAgICAgICAgaWYgKGRpYWdvbmFsT3RoZXIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpYWdvbmFsID0gZGlhZ29uYWxPdGhlci5EYXRhO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBNYXRoLk1pbihDb2x1bW5Db3VudCwgb3RoZXIuUm93Q291bnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQgPCBvdGhlci5Sb3dDb3VudClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQ2xlYXJTdWJNYXRyaXgoMCwgUm93Q291bnQsIENvbHVtbkNvdW50LCBvdGhlci5Sb3dDb3VudCAtIENvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGludCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQoaSwgaiwgX3ZhbHVlc1tpbmRleF0qZGlhZ29uYWxbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYmFzZS5Eb1RyYW5zcG9zZUFuZE11bHRpcGx5KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhpcyBtYXRyaXggd2l0aCBhIHZlY3RvciBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgdmVjdG9yIHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvVHJhbnNwb3NlVGhpc0FuZE11bHRpcGx5KFZlY3Rvcjxkb3VibGU+IHJpZ2h0U2lkZSwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlUmlnaHQgPSByaWdodFNpZGUgYXMgRGVuc2VWZWN0b3I7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZVJlc3VsdCA9IHJlc3VsdCBhcyBEZW5zZVZlY3RvcjtcclxuXHJcbiAgICAgICAgICAgIGlmIChkZW5zZVJpZ2h0ID09IG51bGwgfHwgZGVuc2VSZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmFzZS5Eb1RyYW5zcG9zZVRoaXNBbmRNdWx0aXBseShyaWdodFNpZGUsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBBdChpLCBqKSAqIHJpZ2h0U2lkZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2pdID0gcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9UcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkoTWF0cml4PGRvdWJsZT4gb3RoZXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZU90aGVyID0gb3RoZXIgYXMgRGVuc2VNYXRyaXg7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZVJlc3VsdCA9IHJlc3VsdCBhcyBEZW5zZU1hdHJpeDtcclxuICAgICAgICAgICAgaWYgKGRlbnNlT3RoZXIgIT0gbnVsbCAmJiBkZW5zZVJlc3VsdCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG90aGVyLkNvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDb2x1bW5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgUm93Q291bnQ7IGsrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBBdChrLCBpKSAqIG90aGVyLkF0KGssIGopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpLCBqLCBzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkaWFnb25hbE90aGVyID0gb3RoZXIuU3RvcmFnZSBhcyBEaWFnb25hbE1hdHJpeFN0b3JhZ2U8ZG91YmxlPjtcclxuICAgICAgICAgICAgaWYgKGRpYWdvbmFsT3RoZXIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpYWdvbmFsID0gZGlhZ29uYWxPdGhlci5EYXRhO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBNYXRoLk1pbihSb3dDb3VudCwgb3RoZXIuQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQgPCBvdGhlci5Db2x1bW5Db3VudClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQ2xlYXJTdWJNYXRyaXgoMCwgQ29sdW1uQ291bnQsIFJvd0NvdW50LCBvdGhlci5Db2x1bW5Db3VudCAtIFJvd0NvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGludCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IENvbHVtbkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBkOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQoaSwgaiwgX3ZhbHVlc1tpbmRleF0qZGlhZ29uYWxbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAoUm93Q291bnQgLSBkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYmFzZS5Eb1RyYW5zcG9zZVRoaXNBbmRNdWx0aXBseShvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGl2aWRlcyBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhciBhbmQgcGxhY2VzIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgc2NhbGFyIHRvIGRpdmlkZSB0aGUgbWF0cml4IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGRpdmlzaW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9EaXZpZGUoZG91YmxlIGRpdmlzb3IsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZVJlc3VsdCA9IHJlc3VsdCBhcyBEZW5zZU1hdHJpeDtcclxuICAgICAgICAgICAgaWYgKGRlbnNlUmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9EaXZpZGUoZGl2aXNvciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgICAgICBNYXRyaXg8ZG91YmxlPiBJID0gbV9idWlsZGVyLkRlbnNlKENvbHVtbkNvdW50LFJvd0NvdW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IoaW50IHg9MDt4PENvbHVtbkNvdW50O3grKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCB5ID0gMDsgeSA8IFJvd0NvdW50OyB5KyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBJW3ksIHhdID0gdGhpc1t5LCB4XSAvIGRpdmlzb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gSTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgbXVsdGlwbGllcyB0aGlzIG1hdHJpeCB3aXRoIGFub3RoZXIgbWF0cml4IGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIHBvaW50d2lzZSBtdWx0aXBseSB3aXRoIHRoaXMgb25lLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludHdpc2UgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZU11bHRpcGx5KE1hdHJpeDxkb3VibGU+IG90aGVyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VPdGhlciA9IG90aGVyIGFzIERlbnNlTWF0cml4O1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VSZXN1bHQgPSByZXN1bHQgYXMgRGVuc2VNYXRyaXg7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVuc2VPdGhlciA9PSBudWxsIHx8IGRlbnNlUmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9Qb2ludHdpc2VNdWx0aXBseShvdGhlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KSgoeCwgeSkgPT4geCAqIHkpLCBvdGhlciwgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBkaXZpZGUgdGhpcyBtYXRyaXggYnkgYW5vdGhlciBtYXRyaXggYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIG1hdHJpeCB0byBwb2ludHdpc2UgZGl2aWRlIHRoaXMgb25lIGJ5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludHdpc2UgZGl2aXNpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZURpdmlkZShNYXRyaXg8ZG91YmxlPiBkaXZpc29yLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VEaXZpc29yID0gZGl2aXNvciBhcyBEZW5zZU1hdHJpeDtcclxuICAgICAgICAgICAgdmFyIGRlbnNlUmVzdWx0ID0gcmVzdWx0IGFzIERlbnNlTWF0cml4O1xyXG5cclxuICAgICAgICAgICAgaWYgKGRlbnNlRGl2aXNvciA9PSBudWxsIHx8IGRlbnNlUmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9Qb2ludHdpc2VEaXZpZGUoZGl2aXNvciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KSgoeCwgeSkgPT4geCAvIHkpLCBkaXZpc29yLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSByYWlzZSB0aGlzIG1hdHJpeCB0byBhbiBleHBvbmVudCBhbmQgc3RvcmUgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXhwb25lbnRcIj5UaGUgZXhwb25lbnQgdG8gcmFpc2UgdGhpcyBtYXRyaXggdmFsdWVzIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludHdpc2UgcG93ZXIuPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZVBvd2VyKE1hdHJpeDxkb3VibGU+IGV4cG9uZW50LCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VFeHBvbmVudCA9IGV4cG9uZW50IGFzIERlbnNlTWF0cml4O1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VSZXN1bHQgPSByZXN1bHQgYXMgRGVuc2VNYXRyaXg7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVuc2VFeHBvbmVudCA9PSBudWxsIHx8IGRlbnNlUmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9Qb2ludHdpc2VQb3dlcihleHBvbmVudCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KU1hdGguUG93LCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBjYW5vbmljYWwgbW9kdWx1cywgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlzb3IsXHJcbiAgICAgICAgLy8vIGZvciB0aGUgZ2l2ZW4gZGl2aXNvciBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgc2NhbGFyIGRlbm9taW5hdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPk1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvTW9kdWx1cyhkb3VibGUgZGl2aXNvciwgTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlUmVzdWx0ID0gcmVzdWx0IGFzIERlbnNlTWF0cml4O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VSZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmFzZS5Eb01vZHVsdXMoZGl2aXNvciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFSZWZlcmVuY2VFcXVhbHModGhpcywgcmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiBFdWNsaWQuTW9kdWx1cyh4LCBkaXZpc29yKSksIHJlc3VsdCwgWmVyb3MuSW5jbHVkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBjYW5vbmljYWwgbW9kdWx1cywgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlzb3IsXHJcbiAgICAgICAgLy8vIGZvciB0aGUgZ2l2ZW4gZGl2aWRlbmQgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aWRlbmRcIj5UaGUgc2NhbGFyIG51bWVyYXRvciB0byB1c2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5BIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvTW9kdWx1c0J5VGhpcyhkb3VibGUgZGl2aWRlbmQsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZVJlc3VsdCA9IHJlc3VsdCBhcyBEZW5zZU1hdHJpeDtcclxuICAgICAgICAgICAgaWYgKGRlbnNlUmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9Nb2R1bHVzQnlUaGlzKGRpdmlkZW5kLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gRXVjbGlkLk1vZHVsdXMoZGl2aWRlbmQsIHgpKSwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gZm9yIHRoZSBnaXZlbiBkaXZpc29yIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBzY2FsYXIgZGVub21pbmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+TWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9SZW1haW5kZXIoZG91YmxlIGRpdmlzb3IsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZVJlc3VsdCA9IHJlc3VsdCBhcyBEZW5zZU1hdHJpeDtcclxuICAgICAgICAgICAgaWYgKGRlbnNlUmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9SZW1haW5kZXIoZGl2aXNvciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFSZWZlcmVuY2VFcXVhbHModGhpcywgcmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiBFdWNsaWQuUmVtYWluZGVyKHgsIGRpdmlzb3IpKSwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gZm9yIHRoZSBnaXZlbiBkaXZpZGVuZCBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpZGVuZFwiPlRoZSBzY2FsYXIgbnVtZXJhdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPkEgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9SZW1haW5kZXJCeVRoaXMoZG91YmxlIGRpdmlkZW5kLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VSZXN1bHQgPSByZXN1bHQgYXMgRGVuc2VNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChkZW5zZVJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvUmVtYWluZGVyQnlUaGlzKGRpdmlkZW5kLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4gRXVjbGlkLlJlbWFpbmRlcihkaXZpZGVuZCwgeCkpLCByZXN1bHQsIFplcm9zLkluY2x1ZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgdHJhY2Ugb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHRyYWNlIG9mIHRoaXMgbWF0cml4PC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZTwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgVHJhY2UoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9yb3dDb3VudCAhPSBfY29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeFNxdWFyZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHN1bSA9IDAuMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3VtICs9IF92YWx1ZXNbKGkgKiBfcm93Q291bnQpICsgaV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgdHdvIG1hdHJpY2VzIHRvZ2V0aGVyIGFuZCByZXR1cm5zIHRoZSByZXN1bHRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlRoaXMgb3BlcmF0b3Igd2lsbCBhbGxvY2F0ZSBuZXcgbWVtb3J5IGZvciB0aGUgcmVzdWx0LiBJdCB3aWxsXHJcbiAgICAgICAgLy8vIGNob29zZSB0aGUgcmVwcmVzZW50YXRpb24gb2YgZWl0aGVyIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBkZXBlbmRpbmcgb24gd2hpY2hcclxuICAgICAgICAvLy8gaXMgZGVuc2VyLjwvcmVtYXJrcz5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSBsZWZ0IG1hdHJpeCB0byBhZGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgcmlnaHQgbWF0cml4IHRvIGFkZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IGFuZCA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gZG9uJ3QgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTWF0cml4IG9wZXJhdG9yICsoRGVuc2VNYXRyaXggbGVmdFNpZGUsIERlbnNlTWF0cml4IHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJpZ2h0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxlZnRTaWRlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJsZWZ0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxlZnRTaWRlLl9yb3dDb3VudCAhPSByaWdodFNpZGUuX3Jvd0NvdW50IHx8IGxlZnRTaWRlLl9jb2x1bW5Db3VudCAhPSByaWdodFNpZGUuX2NvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbj4obGVmdFNpZGUsIHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoRGVuc2VNYXRyaXgpbGVmdFNpZGUuQWRkKHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYSA8c3Ryb25nPk1hdHJpeDwvc3Ryb25nPiBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBvZiA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgbWF0cml4IHRvIGdldCB0aGUgdmFsdWVzIGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBtYXRyaXggY29udGFpbmluZyBhIHRoZSBzYW1lIHZhbHVlcyBhcyA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTWF0cml4IG9wZXJhdG9yICsoRGVuc2VNYXRyaXggcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJpZ2h0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicmlnaHRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKERlbnNlTWF0cml4KXJpZ2h0U2lkZS5DbG9uZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgdHdvIG1hdHJpY2VzIHRvZ2V0aGVyIGFuZCByZXR1cm5zIHRoZSByZXN1bHRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlRoaXMgb3BlcmF0b3Igd2lsbCBhbGxvY2F0ZSBuZXcgbWVtb3J5IGZvciB0aGUgcmVzdWx0LiBJdCB3aWxsXHJcbiAgICAgICAgLy8vIGNob29zZSB0aGUgcmVwcmVzZW50YXRpb24gb2YgZWl0aGVyIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBkZXBlbmRpbmcgb24gd2hpY2hcclxuICAgICAgICAvLy8gaXMgZGVuc2VyLjwvcmVtYXJrcz5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSBsZWZ0IG1hdHJpeCB0byBzdWJ0cmFjdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSByaWdodCBtYXRyaXggdG8gc3VidHJhY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGRvbid0IGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucy48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gb3IgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZU1hdHJpeCBvcGVyYXRvciAtKERlbnNlTWF0cml4IGxlZnRTaWRlLCBEZW5zZU1hdHJpeCByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocmlnaHRTaWRlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJyaWdodFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsZWZ0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwibGVmdFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsZWZ0U2lkZS5fcm93Q291bnQgIT0gcmlnaHRTaWRlLl9yb3dDb3VudCB8fCBsZWZ0U2lkZS5fY29sdW1uQ291bnQgIT0gcmlnaHRTaWRlLl9jb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24+KGxlZnRTaWRlLCByaWdodFNpZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKERlbnNlTWF0cml4KWxlZnRTaWRlLlN1YnRyYWN0KHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE5lZ2F0ZXMgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgbWF0cml4IHRvIG5lZ2F0ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIG1hdHJpeCBjb250YWluaW5nIHRoZSBuZWdhdGVkIHZhbHVlcy48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VNYXRyaXggb3BlcmF0b3IgLShEZW5zZU1hdHJpeCByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocmlnaHRTaWRlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJyaWdodFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoRGVuc2VNYXRyaXgpcmlnaHRTaWRlLk5lZ2F0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIGEgPHN0cm9uZz5NYXRyaXg8L3N0cm9uZz4gYnkgYSBjb25zdGFudCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgbWF0cml4IHRvIG11bHRpcGx5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIGNvbnN0YW50IHRvIG11bHRpcGx5IHRoZSBtYXRyaXggYnkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VNYXRyaXggb3BlcmF0b3IgKihEZW5zZU1hdHJpeCBsZWZ0U2lkZSwgZG91YmxlIHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwibGVmdFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoRGVuc2VNYXRyaXgpbGVmdFNpZGUuTXVsdGlwbHkocmlnaHRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyBhIDxzdHJvbmc+TWF0cml4PC9zdHJvbmc+IGJ5IGEgY29uc3RhbnQgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIG1hdHJpeCB0byBtdWx0aXBseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSBjb25zdGFudCB0byBtdWx0aXBseSB0aGUgbWF0cml4IGJ5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZU1hdHJpeCBvcGVyYXRvciAqKGRvdWJsZSBsZWZ0U2lkZSwgRGVuc2VNYXRyaXggcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJpZ2h0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicmlnaHRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKERlbnNlTWF0cml4KXJpZ2h0U2lkZS5NdWx0aXBseShsZWZ0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdHdvIG1hdHJpY2VzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlRoaXMgb3BlcmF0b3Igd2lsbCBhbGxvY2F0ZSBuZXcgbWVtb3J5IGZvciB0aGUgcmVzdWx0LiBJdCB3aWxsXHJcbiAgICAgICAgLy8vIGNob29zZSB0aGUgcmVwcmVzZW50YXRpb24gb2YgZWl0aGVyIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBkZXBlbmRpbmcgb24gd2hpY2hcclxuICAgICAgICAvLy8gaXMgZGVuc2VyLjwvcmVtYXJrcz5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSBsZWZ0IG1hdHJpeCB0byBtdWx0aXBseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSByaWdodCBtYXRyaXggdG8gbXVsdGlwbHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSBkaW1lbnNpb25zIG9mIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBkb24ndCBjb25mb3JtLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VNYXRyaXggb3BlcmF0b3IgKihEZW5zZU1hdHJpeCBsZWZ0U2lkZSwgRGVuc2VNYXRyaXggcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGxlZnRTaWRlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJsZWZ0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJpZ2h0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicmlnaHRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobGVmdFNpZGUuX2NvbHVtbkNvdW50ICE9IHJpZ2h0U2lkZS5fcm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uPihsZWZ0U2lkZSwgcmlnaHRTaWRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChEZW5zZU1hdHJpeClsZWZ0U2lkZS5NdWx0aXBseShyaWdodFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIGEgPHN0cm9uZz5NYXRyaXg8L3N0cm9uZz4gYW5kIGEgVmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgbWF0cml4IHRvIG11bHRpcGx5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBtdWx0aXBseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gb3IgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEZW5zZVZlY3RvciBvcGVyYXRvciAqKERlbnNlTWF0cml4IGxlZnRTaWRlLCBEZW5zZVZlY3RvciByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobGVmdFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImxlZnRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKERlbnNlVmVjdG9yKWxlZnRTaWRlLk11bHRpcGx5KHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgYSBWZWN0b3IgYW5kIGEgPHN0cm9uZz5NYXRyaXg8L3N0cm9uZz4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSB2ZWN0b3IgdG8gbXVsdGlwbHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgbWF0cml4IHRvIG11bHRpcGx5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlVmVjdG9yIG9wZXJhdG9yICooRGVuc2VWZWN0b3IgbGVmdFNpZGUsIERlbnNlTWF0cml4IHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJpZ2h0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChEZW5zZVZlY3RvcilyaWdodFNpZGUuTGVmdE11bHRpcGx5KGxlZnRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyBhIDxzdHJvbmc+TWF0cml4PC9zdHJvbmc+IGJ5IGEgY29uc3RhbnQgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIG1hdHJpeCB0byBtdWx0aXBseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSBjb25zdGFudCB0byBtdWx0aXBseSB0aGUgbWF0cml4IGJ5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTWF0cml4IG9wZXJhdG9yICUoRGVuc2VNYXRyaXggbGVmdFNpZGUsIGRvdWJsZSByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobGVmdFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImxlZnRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKERlbnNlTWF0cml4KWxlZnRTaWRlLlJlbWFpbmRlcihyaWdodFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBFdmFsdWF0ZXMgd2hldGhlciB0aGlzIG1hdHJpeCBpcyBzeW1tZXRyaWMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBJc1N5bW1ldHJpYygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBqICogUm93Q291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaiArIDE7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdmFsdWVzWyhpKkNvbHVtbkNvdW50KSArIGpdICE9IF92YWx1ZXNbaW5kZXggKyBpXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIExVPGRvdWJsZT4gTFUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIERlbnNlTFUuQ3JlYXRlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG5ldyBTdmQ8ZG91YmxlPiBTdmQoYm9vbCBjb21wdXRlVmVjdG9ycyA9IHRydWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRGVuc2VTdmQuQ3JlYXRlKHRoaXMsIGNvbXB1dGVWZWN0b3JzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFxyXG5cclxuICAgIH1cclxufVxyXG4iLCIvLyA8Y29weXJpZ2h0IGZpbGU9XCJEZW5zZVZlY3Rvci5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDEzIE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIFN5c3RlbS5HbG9iYWxpemF0aW9uO1xyXG51c2luZyBTeXN0ZW0uTGlucTtcclxuXHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5TdG9yYWdlO1xyXG5cclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIHZlY3RvciB1c2luZyBkZW5zZSBzdG9yYWdlLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIFtTZXJpYWxpemFibGVdXHJcbiAgICBbRGVidWdnZXJEaXNwbGF5KFwiRGVuc2VWZWN0b3Ige1wiICsgXCJDb3VudFwiKyBcIn0tRG91YmxlXCIpXVxyXG4gICAgcHVibGljIGNsYXNzIERlbnNlVmVjdG9yIDogVmVjdG9yXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOdW1iZXIgb2YgZWxlbWVudHNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHJlYWRvbmx5IGludCBfbGVuZ3RoO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIHZlY3RvcidzIGRhdGEuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICByZWFkb25seSBkb3VibGVbXSBfdmFsdWVzO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3Igc3RyYWlnaHQgZnJvbSBhbiBpbml0aWFsaXplZCB2ZWN0b3Igc3RvcmFnZSBpbnN0YW5jZS5cclxuICAgICAgICAvLy8gVGhlIHN0b3JhZ2UgaXMgdXNlZCBkaXJlY3RseSB3aXRob3V0IGNvcHlpbmcuXHJcbiAgICAgICAgLy8vIEludGVuZGVkIGZvciBhZHZhbmNlZCBzY2VuYXJpb3Mgd2hlcmUgeW91J3JlIHdvcmtpbmcgZGlyZWN0bHkgd2l0aFxyXG4gICAgICAgIC8vLyBzdG9yYWdlIGZvciBwZXJmb3JtYW5jZSBvciBpbnRlcm9wIHJlYXNvbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgRGVuc2VWZWN0b3IoRGVuc2VWZWN0b3JTdG9yYWdlPGRvdWJsZT4gc3RvcmFnZSlcclxuICAgICAgICAgICAgOiBiYXNlKHN0b3JhZ2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfbGVuZ3RoID0gc3RvcmFnZS5MZW5ndGg7XHJcbiAgICAgICAgICAgIF92YWx1ZXMgPSBzdG9yYWdlLkRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gbGVuZ3RoLlxyXG4gICAgICAgIC8vLyBBbGwgY2VsbHMgb2YgdGhlIHZlY3RvciB3aWxsIGJlIGluaXRpYWxpemVkIHRvIHplcm8uXHJcbiAgICAgICAgLy8vIFplcm8tbGVuZ3RoIHZlY3RvcnMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiBsZW5ndGggaXMgbGVzcyB0aGFuIG9uZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgRGVuc2VWZWN0b3IoaW50IGxlbmd0aClcclxuICAgICAgICAgICAgOiB0aGlzKG5ldyBEZW5zZVZlY3RvclN0b3JhZ2U8ZG91YmxlPihsZW5ndGgpKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIHZlY3RvciBkaXJlY3RseSBiaW5kaW5nIHRvIGEgcmF3IGFycmF5LlxyXG4gICAgICAgIC8vLyBUaGUgYXJyYXkgaXMgdXNlZCBkaXJlY3RseSB3aXRob3V0IGNvcHlpbmcuXHJcbiAgICAgICAgLy8vIFZlcnkgZWZmaWNpZW50LCBidXQgY2hhbmdlcyB0byB0aGUgYXJyYXkgYW5kIHRoZSB2ZWN0b3Igd2lsbCBhZmZlY3QgZWFjaCBvdGhlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBEZW5zZVZlY3Rvcihkb3VibGVbXSBzdG9yYWdlKVxyXG4gICAgICAgICAgICA6IHRoaXMobmV3IERlbnNlVmVjdG9yU3RvcmFnZTxkb3VibGU+KHN0b3JhZ2UuTGVuZ3RoLCBzdG9yYWdlKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3IgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBvdGhlciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IHZlY3RvciB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIG90aGVyIHZlY3Rvci5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlVmVjdG9yIE9mVmVjdG9yKFZlY3Rvcjxkb3VibGU+IHZlY3RvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VWZWN0b3IoRGVuc2VWZWN0b3JTdG9yYWdlPGRvdWJsZT4uT2ZWZWN0b3IodmVjdG9yLlN0b3JhZ2UpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIHZlY3RvciBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyB2ZWN0b3Igd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlVmVjdG9yIE9mQXJyYXkoZG91YmxlW10gYXJyYXkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlVmVjdG9yKERlbnNlVmVjdG9yU3RvcmFnZTxkb3VibGU+Lk9mVmVjdG9yKG5ldyBEZW5zZVZlY3RvclN0b3JhZ2U8ZG91YmxlPihhcnJheS5MZW5ndGgsIGFycmF5KSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgdmVjdG9yIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgdmVjdG9yIHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlVmVjdG9yIE9mRW51bWVyYWJsZShJRW51bWVyYWJsZTxkb3VibGU+IGVudW1lcmFibGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlVmVjdG9yKERlbnNlVmVjdG9yU3RvcmFnZTxkb3VibGU+Lk9mRW51bWVyYWJsZShlbnVtZXJhYmxlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3IgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBpbmRleGVkIGVudW1lcmFibGUuXHJcbiAgICAgICAgLy8vIEtleXMgbXVzdCBiZSBwcm92aWRlZCBhdCBtb3N0IG9uY2UsIHplcm8gaXMgYXNzdW1lZCBpZiBhIGtleSBpcyBvbWl0dGVkLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyB2ZWN0b3Igd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VWZWN0b3IgT2ZJbmRleGVkRW51bWVyYWJsZShpbnQgbGVuZ3RoLCBJRW51bWVyYWJsZTxUdXBsZTxpbnQsZG91YmxlPj4gZW51bWVyYWJsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VWZWN0b3IoRGVuc2VWZWN0b3JTdG9yYWdlPGRvdWJsZT4uT2ZJbmRleGVkRW51bWVyYWJsZShsZW5ndGgsIGVudW1lcmFibGUpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRlbnNlIHZlY3RvciBhbmQgaW5pdGlhbGl6ZSBlYWNoIHZhbHVlIHVzaW5nIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VWZWN0b3IgQ3JlYXRlKGludCBsZW5ndGgsIGRvdWJsZSB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSAwZCkgcmV0dXJuIG5ldyBEZW5zZVZlY3RvcihsZW5ndGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlVmVjdG9yKERlbnNlVmVjdG9yU3RvcmFnZTxkb3VibGU+Lk9mVmFsdWUobGVuZ3RoLCB2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGVuc2UgdmVjdG9yIGFuZCBpbml0aWFsaXplIGVhY2ggdmFsdWUgdXNpbmcgdGhlIHByb3ZpZGVkIGluaXQgZnVuY3Rpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlVmVjdG9yIENyZWF0ZShpbnQgbGVuZ3RoLCBGdW5jPGludCwgZG91YmxlPiBpbml0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZW5zZVZlY3RvcihEZW5zZVZlY3RvclN0b3JhZ2U8ZG91YmxlPi5PZkluaXQobGVuZ3RoLCAoRnVuYzxpbnQsZG91YmxlPilpbml0KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkZW5zZSB2ZWN0b3Igd2l0aCB2YWx1ZXMgc2FtcGxlZCBmcm9tIHRoZSBwcm92aWRlZCByYW5kb20gZGlzdHJpYnV0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgdmVjdG9yJ3MgZGF0YS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIHZlY3RvcidzIGRhdGEuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZG91YmxlW10gVmFsdWVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3ZhbHVlczsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlY3RvclwiPlRoZSA8Yz5EZW5zZVZlY3RvcjwvYz4gd2hvc2UgaW50ZXJuYWwgZGF0YSB3ZSBhcmVcclxuICAgICAgICAvLy8gcmV0dXJuaW5nLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBBIHJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgZGF0ZSBvZiB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBleHBsaWNpdCBvcGVyYXRvciBkb3VibGVbXShEZW5zZVZlY3RvciB2ZWN0b3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmVjdG9yID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJ2ZWN0b3JcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2ZWN0b3IuVmFsdWVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgdmVjdG9yIGJvdW5kIGRpcmVjdGx5IHRvIGEgcmVmZXJlbmNlIG9mIHRoZSBwcm92aWRlZCBhcnJheS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFycmF5XCI+VGhlIGFycmF5IHRvIGJpbmQgdG8gdGhlIDxjPkRlbnNlVmVjdG9yPC9jPiBvYmplY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIEEgPGM+RGVuc2VWZWN0b3I8L2M+IHdob3NlIHZhbHVlcyBhcmUgYm91bmQgdG8gdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbXBsaWNpdCBvcGVyYXRvciBEZW5zZVZlY3Rvcihkb3VibGVbXSBhcnJheSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChhcnJheSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwiYXJyYXlcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VWZWN0b3IoYXJyYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGRzIGEgc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdG8gYWRkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvQWRkKGRvdWJsZSBzY2FsYXIsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZSA9IHJlc3VsdCBhcyBEZW5zZVZlY3RvcjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9BZGQoc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgX3ZhbHVlcy5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVuc2UuX3ZhbHVlc1tpXSA9IF92YWx1ZXNbaV0gKyBzY2FsYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGRzIGFub3RoZXIgdmVjdG9yIHRvIHRoaXMgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgdmVjdG9yIHRvIGFkZCB0byB0aGlzIG9uZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb0FkZChWZWN0b3I8ZG91YmxlPiBvdGhlciwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG90aGVyRGVuc2UgPSBvdGhlciBhcyBEZW5zZVZlY3RvcjtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdERlbnNlID0gcmVzdWx0IGFzIERlbnNlVmVjdG9yO1xyXG5cclxuICAgICAgICAgICAgaWYgKG90aGVyRGVuc2UgPT0gbnVsbCB8fCByZXN1bHREZW5zZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvQWRkKG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTWFwMigoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKCh4LCB5KSA9PiB4ICsgeSksIG90aGVyLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkcyB0d28gPHN0cm9uZz5WZWN0b3JzPC9zdHJvbmc+IHRvZ2V0aGVyIGFuZCByZXR1cm5zIHRoZSByZXN1bHRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5PbmUgb2YgdGhlIHZlY3RvcnMgdG8gYWRkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIG90aGVyIHZlY3RvciB0byBhZGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IGFuZCA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlVmVjdG9yIG9wZXJhdG9yICsoRGVuc2VWZWN0b3IgbGVmdFNpZGUsIERlbnNlVmVjdG9yIHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJpZ2h0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxlZnRTaWRlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJsZWZ0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxlZnRTaWRlLkNvdW50ICE9IHJpZ2h0U2lkZS5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIiwgXCJyaWdodFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoRGVuc2VWZWN0b3IpbGVmdFNpZGUuQWRkKHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN1YnRyYWN0cyBhIHNjYWxhciBmcm9tIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlRoZSBzY2FsYXIgdG8gc3VidHJhY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9TdWJ0cmFjdChkb3VibGUgc2NhbGFyLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2UgPSByZXN1bHQgYXMgRGVuc2VWZWN0b3I7XHJcbiAgICAgICAgICAgIGlmIChkZW5zZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvU3VidHJhY3Qoc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgX3ZhbHVlcy5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVuc2UuX3ZhbHVlc1tpXSA9IF92YWx1ZXNbaV0gLSBzY2FsYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN1YnRyYWN0cyBhbm90aGVyIHZlY3RvciB0byB0aGlzIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIHZlY3RvciB0byBzdWJ0cmFjdCBmcm9tIHRoaXMgb25lLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvU3VidHJhY3QoVmVjdG9yPGRvdWJsZT4gb3RoZXIsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBvdGhlckRlbnNlID0gb3RoZXIgYXMgRGVuc2VWZWN0b3I7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHREZW5zZSA9IHJlc3VsdCBhcyBEZW5zZVZlY3RvcjtcclxuXHJcbiAgICAgICAgICAgIGlmIChvdGhlckRlbnNlID09IG51bGwgfHwgcmVzdWx0RGVuc2UgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmFzZS5Eb1N1YnRyYWN0KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTWFwMigoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKCh4LCB5KSA9PiB4IC0geSksIG90aGVyLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIDxzdHJvbmc+VmVjdG9yPC9zdHJvbmc+IGNvbnRhaW5pbmcgdGhlIG5lZ2F0ZWQgdmFsdWVzIG9mIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSB2ZWN0b3IgdG8gZ2V0IHRoZSB2YWx1ZXMgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIHZlY3RvciBjb250YWluaW5nIHRoZSBuZWdhdGVkIHZhbHVlcyBhcyA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlVmVjdG9yIG9wZXJhdG9yIC0oRGVuc2VWZWN0b3IgcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJpZ2h0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicmlnaHRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKERlbnNlVmVjdG9yKXJpZ2h0U2lkZS5OZWdhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3VidHJhY3RzIHR3byA8c3Ryb25nPlZlY3RvcnM8L3N0cm9uZz4gYW5kIHJldHVybnMgdGhlIHJlc3VsdHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSB2ZWN0b3IgdG8gc3VidHJhY3QgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSB2ZWN0b3IgdG8gc3VidHJhY3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IGFuZCA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlVmVjdG9yIG9wZXJhdG9yIC0oRGVuc2VWZWN0b3IgbGVmdFNpZGUsIERlbnNlVmVjdG9yIHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwibGVmdFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoRGVuc2VWZWN0b3IpbGVmdFNpZGUuU3VidHJhY3QocmlnaHRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTmVnYXRlcyB2ZWN0b3IgYW5kIHNhdmVzIHJlc3VsdCB0byA8cGFyYW1yZWYgbmFtZT1cInJlc3VsdFwiLz5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRhcmdldCB2ZWN0b3I8L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvTmVnYXRlKFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZVJlc3VsdCA9IHJlc3VsdCBhcyBEZW5zZVZlY3RvcjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlUmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9OZWdhdGUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KSh4ID0+IC14ICksIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyBhIHNjYWxhciB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5UaGUgc2NhbGFyIHRvIG11bHRpcGx5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz48L3JlbWFya3M+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9NdWx0aXBseShkb3VibGUgc2NhbGFyLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VSZXN1bHQgPSByZXN1bHQgYXMgRGVuc2VWZWN0b3I7XHJcbiAgICAgICAgICAgIGlmIChkZW5zZVJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvTXVsdGlwbHkoc2NhbGFyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4geCAqIHNjYWxhciksIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgb3RoZXIgdmVjdG9yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBzdW0gb2YgYVtpXSpiW2ldIGZvciBhbGwgaS48L3JldHVybnM+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIGRvdWJsZSBEb0RvdFByb2R1Y3QoVmVjdG9yPGRvdWJsZT4gb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZG90ID0gMC4wO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IENvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRvdCArPSBBdChpKSAqIG90aGVyLkF0KGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkb3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgYSB2ZWN0b3Igd2l0aCBhIHNjYWxhci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIHZlY3RvciB0byBzY2FsZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSBzY2FsYXIgdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VWZWN0b3Igb3BlcmF0b3IgKihEZW5zZVZlY3RvciBsZWZ0U2lkZSwgZG91YmxlIHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwibGVmdFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoRGVuc2VWZWN0b3IpbGVmdFNpZGUuTXVsdGlwbHkocmlnaHRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyBhIHZlY3RvciB3aXRoIGEgc2NhbGFyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgc2NhbGFyIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBzY2FsZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VWZWN0b3Igb3BlcmF0b3IgKihkb3VibGUgbGVmdFNpZGUsIERlbnNlVmVjdG9yIHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJpZ2h0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChEZW5zZVZlY3RvcilyaWdodFNpZGUuTXVsdGlwbHkobGVmdFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0d28gPHN0cm9uZz5WZWN0b3JzPC9zdHJvbmc+LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgbGVmdCByb3cgdmVjdG9yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHJpZ2h0IGNvbHVtbiB2ZWN0b3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdGhlIHR3byB2ZWN0b3JzLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBhbmQgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGFyZSBub3QgdGhlIHNhbWUgc2l6ZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gb3IgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBkb3VibGUgb3BlcmF0b3IgKihEZW5zZVZlY3RvciBsZWZ0U2lkZSwgRGVuc2VWZWN0b3IgcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGxlZnRTaWRlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJsZWZ0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGxlZnRTaWRlLkRvdFByb2R1Y3QocmlnaHRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGl2aWRlcyBhIHZlY3RvciB3aXRoIGEgc2NhbGFyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgdmVjdG9yIHRvIGRpdmlkZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSBzY2FsYXIgdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgZGl2aXNpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGVuc2VWZWN0b3Igb3BlcmF0b3IgLyhEZW5zZVZlY3RvciBsZWZ0U2lkZSwgZG91YmxlIHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwibGVmdFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoRGVuc2VWZWN0b3IpbGVmdFNpZGUuRGl2aWRlKHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBjYW5vbmljYWwgbW9kdWx1cywgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlzb3IsXHJcbiAgICAgICAgLy8vIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBmb3IgdGhlIGdpdmVuIGRpdmlzb3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIGRpdmlzb3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+QSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb01vZHVsdXMoZG91YmxlIGRpdmlzb3IsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZSA9IHJlc3VsdCBhcyBEZW5zZVZlY3RvcjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9Nb2R1bHVzKGRpdmlzb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNlLl92YWx1ZXNbaV0gPSBFdWNsaWQuTW9kdWx1cyhfdmFsdWVzW2ldLCBkaXZpc29yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSByZW1haW5kZXIgKCUgb3BlcmF0b3IpLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aWRlbmQsXHJcbiAgICAgICAgLy8vIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBmb3IgdGhlIGdpdmVuIGRpdmlzb3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIGRpdmlzb3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+QSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1JlbWFpbmRlcihkb3VibGUgZGl2aXNvciwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlID0gcmVzdWx0IGFzIERlbnNlVmVjdG9yO1xyXG4gICAgICAgICAgICBpZiAoZGVuc2UgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmFzZS5Eb1JlbWFpbmRlcihkaXZpc29yLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfbGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5zZS5fdmFsdWVzW2ldID0gX3ZhbHVlc1tpXSVkaXZpc29yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gb2YgZWFjaCBlbGVtZW50IG9mIHRoZSB2ZWN0b3Igb2YgdGhlIGdpdmVuIGRpdmlzb3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSB2ZWN0b3Igd2hvc2UgZWxlbWVudHMgd2Ugd2FudCB0byBjb21wdXRlIHRoZSByZW1haW5kZXIgb2YuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgZGl2aXNvciB0byB1c2UsPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlVmVjdG9yIG9wZXJhdG9yICUoRGVuc2VWZWN0b3IgbGVmdFNpZGUsIGRvdWJsZSByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobGVmdFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImxlZnRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKERlbnNlVmVjdG9yKWxlZnRTaWRlLlJlbWFpbmRlcihyaWdodFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgYWJzb2x1dGUgbWluaW11bSBlbGVtZW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBpbmRleCBvZiBhYnNvbHV0ZSBtaW5pbXVtIGVsZW1lbnQuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBpbnQgQWJzb2x1dGVNaW5pbXVtSW5kZXgoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgdmFyIG1pbiA9IE1hdGguQWJzKF92YWx1ZXNbaW5kZXhdKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBfbGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXN0ID0gTWF0aC5BYnMoX3ZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVzdCA8IG1pbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gdGVzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgYWJzb2x1dGUgbWF4aW11bSBlbGVtZW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBpbmRleCBvZiBhYnNvbHV0ZSBtYXhpbXVtIGVsZW1lbnQuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBpbnQgQWJzb2x1dGVNYXhpbXVtSW5kZXgoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgdmFyIG1heCA9IE1hdGguQWJzKF92YWx1ZXNbaW5kZXhdKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBfbGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXN0ID0gTWF0aC5BYnMoX3ZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVzdCA+IG1heClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gdGVzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF4aW11bSBlbGVtZW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBpbmRleCBvZiBtYXhpbXVtIGVsZW1lbnQuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBpbnQgTWF4aW11bUluZGV4KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSBfdmFsdWVzWzBdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IF9sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heCA8IF92YWx1ZXNbaV0pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IF92YWx1ZXNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1pbmltdW0gZWxlbWVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgaW5kZXggb2YgbWluaW11bSBlbGVtZW50LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IE1pbmltdW1JbmRleCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICB2YXIgbWluID0gX3ZhbHVlc1swXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBfbGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPiBfdmFsdWVzW2ldKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBfdmFsdWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBzdW0gb2YgdGhlIHZlY3RvcidzIGVsZW1lbnRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBzdW0gb2YgdGhlIHZlY3RvcidzIGVsZW1lbnRzLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZG91YmxlIFN1bSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3VtID0gMC4wO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgX2xlbmd0aDsgaW5kZXgrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3VtICs9IF92YWx1ZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIEwxIG5vcm0gb2YgdGhlIHZlY3RvciwgYWxzbyBrbm93biBhcyBNYW5oYXR0YW4gbm9ybS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgc3VtIG9mIHRoZSBhYnNvbHV0ZSB2YWx1ZXMuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgTDFOb3JtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdW0gPSAwZDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IF9sZW5ndGg7IGluZGV4KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN1bSArPSBNYXRoLkFicyhfdmFsdWVzW2luZGV4XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsY3VsYXRlcyB0aGUgTDIgbm9ybSBvZiB0aGUgdmVjdG9yLCBhbHNvIGtub3duIGFzIEV1Y2xpZGVhbiBub3JtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVkIHZhbHVlcy48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGRvdWJsZSBMMk5vcm0oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogbmF0aXZlIHByb3ZpZGVyXHJcbiAgICAgICAgICAgIGRvdWJsZSB0b3RhbCA9IDAuMDtcclxuICAgICAgICAgICAgZm9yZWFjaChkb3VibGUgdmFsIGluIF92YWx1ZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRvdGFsKz1NYXRoLlBvdyhNYXRoLkFicyh2YWwpLDIuMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguU3FydCh0b3RhbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIGluZmluaXR5IG5vcm0gb2YgdGhlIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbWF4aW11bSBhYnNvbHV0ZSB2YWx1ZS48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGRvdWJsZSBJbmZpbml0eU5vcm0oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZG91YmxlIG1heCA9IDAuMDtcclxuICAgICAgICAgICAgZm9yZWFjaChkb3VibGUgdmFsIGluIF92YWx1ZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLkFicyh2YWwpID4gbWF4KSBtYXg9TWF0aC5BYnModmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgcC1Ob3JtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicFwiPlRoZSBwIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlNjYWxhciA8Yz5yZXQgPSAoIOKIkXx0aGlzW2ldfF5wICleKDEvcCk8L2M+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgTm9ybShkb3VibGUgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChwIDwgMGQpIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJwXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHAgPT0gMWQpIHJldHVybiBMMU5vcm0oKTtcclxuICAgICAgICAgICAgaWYgKHAgPT0gMmQpIHJldHVybiBMMk5vcm0oKTtcclxuICAgICAgICAgICAgaWYgKGRvdWJsZS5Jc1Bvc2l0aXZlSW5maW5pdHkocCkpIHJldHVybiBJbmZpbml0eU5vcm0oKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdW0gPSAwZDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IF9sZW5ndGg7IGluZGV4KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN1bSArPSBNYXRoLlBvdyhNYXRoLkFicyhfdmFsdWVzW2luZGV4XSksIHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLlBvdyhzdW0sIDEuMCAvIHApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgZGl2aWRlIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSB2ZWN0b3IgdG8gcG9pbnR3aXNlIGRpdmlkZSB0aGlzIG9uZSBieS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgcG9pbnR3aXNlIGRpdmlzaW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Qb2ludHdpc2VNdWx0aXBseShWZWN0b3I8ZG91YmxlPiBvdGhlciwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRlbnNlT3RoZXIgPSBvdGhlciBhcyBEZW5zZVZlY3RvcjtcclxuICAgICAgICAgICAgdmFyIGRlbnNlUmVzdWx0ID0gcmVzdWx0IGFzIERlbnNlVmVjdG9yO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRlbnNlT3RoZXIgPT0gbnVsbCB8fCBkZW5zZVJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvUG9pbnR3aXNlTXVsdGlwbHkob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBNYXAyKChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPikoKHgsIHkpID0+IHggKiB5KSwgb3RoZXIsIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgZGl2aWRlIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHZlY3RvciB0byBwb2ludHdpc2UgZGl2aWRlIHRoaXMgb25lIGJ5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludHdpc2UgZGl2aXNpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+PC9yZW1hcmtzPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlRGl2aWRlKFZlY3Rvcjxkb3VibGU+IGRpdmlzb3IsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZU90aGVyID0gZGl2aXNvciBhcyBEZW5zZVZlY3RvcjtcclxuICAgICAgICAgICAgdmFyIGRlbnNlUmVzdWx0ID0gcmVzdWx0IGFzIERlbnNlVmVjdG9yO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRlbnNlT3RoZXIgPT0gbnVsbCB8fCBkZW5zZVJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvUG9pbnR3aXNlRGl2aWRlKGRpdmlzb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBNYXAyKChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPikoKHgsIHkpID0+IHggLyB5KSwgZGl2aXNvciwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgcmFpc2UgdGhpcyB2ZWN0b3IgdG8gYW4gZXhwb25lbnQgdmVjdG9yIGFuZCBzdG9yZSB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJleHBvbmVudFwiPlRoZSBleHBvbmVudCB2ZWN0b3IgdG8gcmFpc2UgdGhpcyB2ZWN0b3IgdmFsdWVzIHRvLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludHdpc2UgcG93ZXIuPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZVBvd2VyKFZlY3Rvcjxkb3VibGU+IGV4cG9uZW50LCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VFeHBvbmVudCA9IGV4cG9uZW50IGFzIERlbnNlVmVjdG9yO1xyXG4gICAgICAgICAgICB2YXIgZGVuc2VSZXN1bHQgPSByZXN1bHQgYXMgRGVuc2VWZWN0b3I7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVuc2VFeHBvbmVudCA9PSBudWxsIHx8IGRlbnNlUmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9Qb2ludHdpc2VQb3dlcihleHBvbmVudCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KU1hdGguUG93LCBleHBvbmVudCwgcmVzdWx0LCBaZXJvcy5JbmNsdWRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBQYXJzZSBGdW5jdGlvbnNcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgZG91YmxlIGRlbnNlIHZlY3RvciBiYXNlZCBvbiBhIHN0cmluZy4gVGhlIHN0cmluZyBjYW4gYmUgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXRzICh3aXRob3V0IHRoZVxyXG4gICAgICAgIC8vLyBxdW90ZXMpOiAnbicsICduLG4sLi4nLCAnKG4sbiwuLiknLCAnW24sbiwuLi5dJywgd2hlcmUgbiBpcyBhIGRvdWJsZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gQSBkb3VibGUgZGVuc2UgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHN0cmluZy5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlXCI+XHJcbiAgICAgICAgLy8vIHRoZSBzdHJpbmcgdG8gcGFyc2UuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZm9ybWF0UHJvdmlkZXJcIj5cclxuICAgICAgICAvLy8gQW4gPHNlZSBjcmVmPVwiSUZvcm1hdFByb3ZpZGVyXCIvPiB0aGF0IHN1cHBsaWVzIGN1bHR1cmUtc3BlY2lmaWMgZm9ybWF0dGluZyBpbmZvcm1hdGlvbi5cclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb252ZXJ0cyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcmVhbCBkZW5zZSB2ZWN0b3IgdG8gZG91YmxlLXByZWNpc2lvbiBkZW5zZSB2ZWN0b3IgZXF1aXZhbGVudC5cclxuICAgICAgICAvLy8gQSByZXR1cm4gdmFsdWUgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbnZlcnNpb24gc3VjY2VlZGVkIG9yIGZhaWxlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlXCI+XHJcbiAgICAgICAgLy8vIEEgc3RyaW5nIGNvbnRhaW5pbmcgYSByZWFsIHZlY3RvciB0byBjb252ZXJ0LlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlxyXG4gICAgICAgIC8vLyBUaGUgcGFyc2VkIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gSWYgdGhlIGNvbnZlcnNpb24gc3VjY2VlZHMsIHRoZSByZXN1bHQgd2lsbCBjb250YWluIGEgY29tcGxleCBudW1iZXIgZXF1aXZhbGVudCB0byB2YWx1ZS5cclxuICAgICAgICAvLy8gT3RoZXJ3aXNlIHRoZSByZXN1bHQgd2lsbCBiZSA8Yz5udWxsPC9jPi5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnZlcnRzIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSByZWFsIGRlbnNlIHZlY3RvciB0byBkb3VibGUtcHJlY2lzaW9uIGRlbnNlIHZlY3RvciBlcXVpdmFsZW50LlxyXG4gICAgICAgIC8vLyBBIHJldHVybiB2YWx1ZSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgY29udmVyc2lvbiBzdWNjZWVkZWQgb3IgZmFpbGVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmFsdWVcIj5cclxuICAgICAgICAvLy8gQSBzdHJpbmcgY29udGFpbmluZyBhIHJlYWwgdmVjdG9yIHRvIGNvbnZlcnQuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZm9ybWF0UHJvdmlkZXJcIj5cclxuICAgICAgICAvLy8gQW4gPHNlZSBjcmVmPVwiSUZvcm1hdFByb3ZpZGVyXCIvPiB0aGF0IHN1cHBsaWVzIGN1bHR1cmUtc3BlY2lmaWMgZm9ybWF0dGluZyBpbmZvcm1hdGlvbiBhYm91dCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5cclxuICAgICAgICAvLy8gVGhlIHBhcnNlZCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIElmIHRoZSBjb252ZXJzaW9uIHN1Y2NlZWRzLCB0aGUgcmVzdWx0IHdpbGwgY29udGFpbiBhIGNvbXBsZXggbnVtYmVyIGVxdWl2YWxlbnQgdG8gdmFsdWUuXHJcbiAgICAgICAgLy8vIE90aGVyd2lzZSB0aGUgcmVzdWx0IHdpbGwgYmUgPGM+bnVsbDwvYz4uXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG4gICAgfVxyXG59XHJcbiIsIi8vIDxjb3B5cmlnaHQgZmlsZT1cIkRpYWdvbmFsTWF0cml4LmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTUgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgU3lzdGVtLkxpbnE7XHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5GYWN0b3JpemF0aW9uO1xyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuU3RvcmFnZTtcclxudXNpbmcgTWF0aE5ldE51bWVyaWNzO1xyXG5cclxubmFtZXNwYWNlIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGVcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgbWF0cml4IHR5cGUgZm9yIGRpYWdvbmFsIG1hdHJpY2VzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIC8vLyA8cmVtYXJrcz5cclxuICAgIC8vLyBEaWFnb25hbCBtYXRyaWNlcyBjYW4gYmUgbm9uLXNxdWFyZSBtYXRyaWNlcyBidXQgdGhlIGRpYWdvbmFsIGFsd2F5cyBzdGFydHNcclxuICAgIC8vLyBhdCBlbGVtZW50IDAsMC4gQSBkaWFnb25hbCBtYXRyaXggd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgbm9uIGRpYWdvbmFsXHJcbiAgICAvLy8gZW50cmllcyBhcmUgc2V0LiBUaGUgZXhjZXB0aW9uIHRvIHRoaXMgaXMgd2hlbiB0aGUgb2ZmIGRpYWdvbmFsIGVsZW1lbnRzIGFyZVxyXG4gICAgLy8vIDAuMCBvciBOYU47IHRoZXNlIHNldHRpbmdzIHdpbGwgY2F1c2Ugbm8gY2hhbmdlIHRvIHRoZSBkaWFnb25hbCBtYXRyaXguXHJcbiAgICAvLy8gPC9yZW1hcmtzPlxyXG4gICAgW1NlcmlhbGl6YWJsZV1cclxuICAgIFtEZWJ1Z2dlckRpc3BsYXkoXCJEaWFnb25hbE1hdHJpeCB7Um93Q291bnR9eHtDb2x1bW5Db3VudH0tRG91YmxlXCIpXVxyXG4gICAgcHVibGljIGNsYXNzIERpYWdvbmFsTWF0cml4IDogTWF0cml4XHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBtYXRyaXgncyBkYXRhLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgbWF0cml4J3MgZGF0YS48L3ZhbHVlPlxyXG4gICAgICAgIHJlYWRvbmx5IGRvdWJsZVtdIF9kYXRhO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBtYXRyaXggc3RyYWlnaHQgZnJvbSBhbiBpbml0aWFsaXplZCBtYXRyaXggc3RvcmFnZSBpbnN0YW5jZS5cclxuICAgICAgICAvLy8gVGhlIHN0b3JhZ2UgaXMgdXNlZCBkaXJlY3RseSB3aXRob3V0IGNvcHlpbmcuXHJcbiAgICAgICAgLy8vIEludGVuZGVkIGZvciBhZHZhbmNlZCBzY2VuYXJpb3Mgd2hlcmUgeW91J3JlIHdvcmtpbmcgZGlyZWN0bHkgd2l0aFxyXG4gICAgICAgIC8vLyBzdG9yYWdlIGZvciBwZXJmb3JtYW5jZSBvciBpbnRlcm9wIHJlYXNvbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgRGlhZ29uYWxNYXRyaXgoRGlhZ29uYWxNYXRyaXhTdG9yYWdlPGRvdWJsZT4gc3RvcmFnZSlcclxuICAgICAgICAgICAgOiBiYXNlKHN0b3JhZ2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfZGF0YSA9IHN0b3JhZ2UuRGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNxdWFyZSBkaWFnb25hbCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMuXHJcbiAgICAgICAgLy8vIEFsbCBjZWxscyBvZiB0aGUgbWF0cml4IHdpbGwgYmUgaW5pdGlhbGl6ZWQgdG8gemVyby5cclxuICAgICAgICAvLy8gWmVyby1sZW5ndGggbWF0cmljZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgb3JkZXIgaXMgbGVzcyB0aGFuIG9uZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgRGlhZ29uYWxNYXRyaXgoaW50IG9yZGVyKVxyXG4gICAgICAgICAgICA6IHRoaXMobmV3IERpYWdvbmFsTWF0cml4U3RvcmFnZTxkb3VibGU+KG9yZGVyLCBvcmRlcikpXHJcbiAgICAgICAgIHtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMuXHJcbiAgICAgICAgLy8vIEFsbCBjZWxscyBvZiB0aGUgbWF0cml4IHdpbGwgYmUgaW5pdGlhbGl6ZWQgdG8gemVyby5cclxuICAgICAgICAvLy8gWmVyby1sZW5ndGggbWF0cmljZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgcm93IG9yIGNvbHVtbiBjb3VudCBpcyBsZXNzIHRoYW4gb25lLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBEaWFnb25hbE1hdHJpeChpbnQgcm93cywgaW50IGNvbHVtbnMpXHJcbiAgICAgICAgICAgIDogdGhpcyhuZXcgRGlhZ29uYWxNYXRyaXhTdG9yYWdlPGRvdWJsZT4ocm93cywgY29sdW1ucykpXHJcbiAgICAgICAge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgbWF0cml4IHdpdGggdGhlIGdpdmVuIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zLlxyXG4gICAgICAgIC8vLyBBbGwgZGlhZ29uYWwgY2VsbHMgb2YgdGhlIG1hdHJpeCB3aWxsIGJlIGluaXRpYWxpemVkIHRvIHRoZSBwcm92aWRlZCB2YWx1ZSwgYWxsIG5vbi1kaWFnb25hbCBvbmVzIHRvIHplcm8uXHJcbiAgICAgICAgLy8vIFplcm8tbGVuZ3RoIG1hdHJpY2VzIGFyZSBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHJvdyBvciBjb2x1bW4gY291bnQgaXMgbGVzcyB0aGFuIG9uZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgRGlhZ29uYWxNYXRyaXgoaW50IHJvd3MsIGludCBjb2x1bW5zLCBkb3VibGUgZGlhZ29uYWxWYWx1ZSlcclxuICAgICAgICAgICAgOiB0aGlzKHJvd3MsIGNvbHVtbnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9kYXRhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfZGF0YVtpXSA9IGRpYWdvbmFsVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBkaXJlY3RseSBiaW5kaW5nIHRvIGEgcmF3IGFycmF5LlxyXG4gICAgICAgIC8vLyBUaGUgYXJyYXkgaXMgYXNzdW1lZCB0byBjb250YWluIHRoZSBkaWFnb25hbCBlbGVtZW50cyBvbmx5IGFuZCBpcyB1c2VkIGRpcmVjdGx5IHdpdGhvdXQgY29weWluZy5cclxuICAgICAgICAvLy8gVmVyeSBlZmZpY2llbnQsIGJ1dCBjaGFuZ2VzIHRvIHRoZSBhcnJheSBhbmQgdGhlIG1hdHJpeCB3aWxsIGFmZmVjdCBlYWNoIG90aGVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIERpYWdvbmFsTWF0cml4KGludCByb3dzLCBpbnQgY29sdW1ucywgZG91YmxlW10gZGlhZ29uYWxTdG9yYWdlKVxyXG4gICAgICAgICAgICA6IHRoaXMobmV3IERpYWdvbmFsTWF0cml4U3RvcmFnZTxkb3VibGU+KHJvd3MsIGNvbHVtbnMsIGRpYWdvbmFsU3RvcmFnZSkpXHJcbiAgICAgICAge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgZGlhZ29uYWwgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gb3RoZXIgbWF0cml4LlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBvdGhlciBtYXRyaXguXHJcbiAgICAgICAgLy8vIFRoZSBtYXRyaXggdG8gY29weSBmcm9tIG11c3QgYmUgZGlhZ29uYWwgYXMgd2VsbC5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERpYWdvbmFsTWF0cml4IE9mTWF0cml4KE1hdHJpeDxkb3VibGU+IG1hdHJpeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGlhZ29uYWxNYXRyaXgoRGlhZ29uYWxNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZNYXRyaXgobWF0cml4LlN0b3JhZ2UpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHR3by1kaW1lbnNpb25hbCBhcnJheS5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgcHJvdmlkZWQgYXJyYXkuXHJcbiAgICAgICAgLy8vIFRoZSBhcnJheSB0byBjb3B5IGZyb20gbXVzdCBiZSBkaWFnb25hbCBhcyB3ZWxsLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGlhZ29uYWxNYXRyaXggT2ZBcnJheShkb3VibGVbLF0gYXJyYXkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpYWdvbmFsTWF0cml4KERpYWdvbmFsTWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mQXJyYXkoYXJyYXkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIG1hdHJpeCBhbmQgaW5pdGlhbGl6ZSBlYWNoIGRpYWdvbmFsIHZhbHVlIGZyb20gdGhlIHByb3ZpZGVkIGluZGV4ZWQgZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gS2V5cyBtdXN0IGJlIHByb3ZpZGVkIGF0IG1vc3Qgb25jZSwgemVybyBpcyBhc3N1bWVkIGlmIGEga2V5IGlzIG9taXR0ZWQuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGVudW1lcmFibGUuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEaWFnb25hbE1hdHJpeCBPZkluZGV4ZWREaWFnb25hbChpbnQgcm93cywgaW50IGNvbHVtbnMsIElFbnVtZXJhYmxlPFR1cGxlPGludCwgZG91YmxlPj4gZGlhZ29uYWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpYWdvbmFsTWF0cml4KERpYWdvbmFsTWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mSW5kZXhlZEVudW1lcmFibGUocm93cywgY29sdW1ucywgZGlhZ29uYWwpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIG1hdHJpeCBhbmQgaW5pdGlhbGl6ZSBlYWNoIGRpYWdvbmFsIHZhbHVlIGZyb20gdGhlIHByb3ZpZGVkIGVudW1lcmFibGUuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGVudW1lcmFibGUuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEaWFnb25hbE1hdHJpeCBPZkRpYWdvbmFsKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8ZG91YmxlPiBkaWFnb25hbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGlhZ29uYWxNYXRyaXgoRGlhZ29uYWxNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZFbnVtZXJhYmxlKHJvd3MsIGNvbHVtbnMsIGRpYWdvbmFsKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCBkaWFnb25hbCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgaW5pdCBmdW5jdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGlhZ29uYWxNYXRyaXggQ3JlYXRlKGludCByb3dzLCBpbnQgY29sdW1ucywgRnVuYzxpbnQsIGRvdWJsZT4gaW5pdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGlhZ29uYWxNYXRyaXgoRGlhZ29uYWxNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZJbml0KHJvd3MsIGNvbHVtbnMsIChGdW5jPGludCxkb3VibGU+KWluaXQpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNxdWFyZSBzcGFyc2UgaWRlbnRpdHkgbWF0cml4IHdoZXJlIGVhY2ggZGlhZ29uYWwgdmFsdWUgaXMgc2V0IHRvIE9uZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGlhZ29uYWxNYXRyaXggQ3JlYXRlSWRlbnRpdHkoaW50IG9yZGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaWFnb25hbE1hdHJpeChEaWFnb25hbE1hdHJpeFN0b3JhZ2U8ZG91YmxlPi5PZlZhbHVlKG9yZGVyLCBvcmRlciwgT25lKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBkaWFnb25hbCBtYXRyaXggd2l0aCBkaWFnb25hbCB2YWx1ZXMgc2FtcGxlZCBmcm9tIHRoZSBwcm92aWRlZCByYW5kb20gZGlzdHJpYnV0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTmVnYXRlIGVhY2ggZWxlbWVudCBvZiB0aGlzIG1hdHJpeCBhbmQgcGxhY2UgdGhlIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG5lZ2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9OZWdhdGUoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRpYWdSZXN1bHQgPSByZXN1bHQgYXMgRGlhZ29uYWxNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChkaWFnUmVzdWx0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE1hcCgoRnVuYzxkb3VibGUsZG91YmxlPikoeCA9PiAteCksIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2RhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpLCBpLCAtX2RhdGFbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgYW5vdGhlciBtYXRyaXggdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gYWRkIHRvIHRoaXMgbWF0cml4LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb25cIj5JZiB0aGUgdHdvIG1hdHJpY2VzIGRvbid0IGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucy48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb0FkZChNYXRyaXg8ZG91YmxlPiBvdGhlciwgTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gZGlhZ29uYWwgKyBkaWFnb25hbCA9IGRpYWdvbmFsXHJcbiAgICAgICAgICAgIHZhciBkaWFnT3RoZXIgPSBvdGhlciBhcyBEaWFnb25hbE1hdHJpeDtcclxuICAgICAgICAgICAgdmFyIGRpYWdSZXN1bHQgPSByZXN1bHQgYXMgRGlhZ29uYWxNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChkaWFnT3RoZXIgIT0gbnVsbCAmJiBkaWFnUmVzdWx0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KSgoeCwgeSkgPT4geCArIHkpLCBvdGhlciwgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvdGhlci5Db3B5VG8ocmVzdWx0KTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfZGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkF0KGksIGksIHJlc3VsdC5BdChpLCBpKSArIF9kYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgYW5vdGhlciBtYXRyaXggZnJvbSB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB0byBzdWJ0cmFjdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgdGhlIHR3byBtYXRyaWNlcyBkb24ndCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9TdWJ0cmFjdChNYXRyaXg8ZG91YmxlPiBvdGhlciwgTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gZGlhZ29uYWwgLSBkaWFnb25hbCA9IGRpYWdvbmFsXHJcbiAgICAgICAgICAgIHZhciBkaWFnT3RoZXIgPSBvdGhlciBhcyBEaWFnb25hbE1hdHJpeDtcclxuICAgICAgICAgICAgdmFyIGRpYWdSZXN1bHQgPSByZXN1bHQgYXMgRGlhZ29uYWxNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChkaWFnT3RoZXIgIT0gbnVsbCAmJiBkaWFnUmVzdWx0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE1hcDIoKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KSgoeCwgeSkgPT4geCAtIHkpLCBvdGhlciwgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvdGhlci5OZWdhdGUocmVzdWx0KTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfZGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkF0KGksIGksIHJlc3VsdC5BdChpLCBpKSArIF9kYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyIGFuZCBwbGFjZXMgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBtdWx0aXBseSB0aGUgbWF0cml4IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHJlc3VsdCBtYXRyaXgncyBkaW1lbnNpb25zIGFyZSBub3QgdGhlIHNhbWUgYXMgdGhpcyBtYXRyaXguPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9NdWx0aXBseShkb3VibGUgc2NhbGFyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoc2NhbGFyID09IDAuMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzY2FsYXIgPT0gMS4wKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb3B5VG8ocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRpYWdSZXN1bHQgPSByZXN1bHQgYXMgRGlhZ29uYWxNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChkaWFnUmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9NdWx0aXBseShzY2FsYXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBNYXRyaXg8ZG91YmxlPiBJID0gbV9idWlsZGVyLkRlbnNlKENvbHVtbkNvdW50LCBSb3dDb3VudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgeCA9IDA7IHggPCBDb2x1bW5Db3VudDsgeCsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IHkgPSAwOyB5IDwgUm93Q291bnQ7IHkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIElbeSwgeF0gPSB0aGlzW3ksIHhdICogc2NhbGFyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyB0aGlzIG1hdHJpeCB3aXRoIGEgdmVjdG9yIGFuZCBwbGFjZXMgdGhlIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSB2ZWN0b3IgdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9NdWx0aXBseShWZWN0b3I8ZG91YmxlPiByaWdodFNpZGUsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5NaW4oQ29sdW1uQ291bnQsIFJvd0NvdW50KTtcclxuICAgICAgICAgICAgaWYgKGQgPCBSb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkNsZWFyU3ViVmVjdG9yKENvbHVtbkNvdW50LCBSb3dDb3VudCAtIENvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGQgPT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZW5zZU90aGVyID0gcmlnaHRTaWRlLlN0b3JhZ2UgYXMgRGVuc2VWZWN0b3JTdG9yYWdlPGRvdWJsZT47XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVuc2VSZXN1bHQgPSByZXN1bHQuU3RvcmFnZSBhcyBEZW5zZVZlY3RvclN0b3JhZ2U8ZG91YmxlPjtcclxuICAgICAgICAgICAgICAgIGlmIChkZW5zZU90aGVyICE9IG51bGwgJiYgZGVuc2VSZXN1bHQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBDb2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IEF0KGksIGopICogcmlnaHRTaWRlW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpLCBfZGF0YVtpXSpyaWdodFNpZGUuQXQoaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9NdWx0aXBseShNYXRyaXg8ZG91YmxlPiBvdGhlciwgTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGRpYWdvbmFsT3RoZXIgPSBvdGhlciBhcyBEaWFnb25hbE1hdHJpeDtcclxuICAgICAgICAgICAgdmFyIGRpYWdvbmFsUmVzdWx0ID0gcmVzdWx0IGFzIERpYWdvbmFsTWF0cml4O1xyXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWxPdGhlciAhPSBudWxsICYmIGRpYWdvbmFsUmVzdWx0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aGlzRGF0YUNvcHkgPSBuZXcgZG91YmxlW2RpYWdvbmFsUmVzdWx0Ll9kYXRhLkxlbmd0aF07XHJcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJEYXRhQ29weSA9IG5ldyBkb3VibGVbZGlhZ29uYWxSZXN1bHQuX2RhdGEuTGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgIEFycmF5LkNvcHkoX2RhdGEsIDAsIHRoaXNEYXRhQ29weSwgMCwgKGRpYWdvbmFsUmVzdWx0Ll9kYXRhLkxlbmd0aCA+IF9kYXRhLkxlbmd0aCkgPyBfZGF0YS5MZW5ndGggOiBkaWFnb25hbFJlc3VsdC5fZGF0YS5MZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ29weShkaWFnb25hbE90aGVyLl9kYXRhLCAwLCBvdGhlckRhdGFDb3B5LCAwLCAoZGlhZ29uYWxSZXN1bHQuX2RhdGEuTGVuZ3RoID4gZGlhZ29uYWxPdGhlci5fZGF0YS5MZW5ndGgpID8gZGlhZ29uYWxPdGhlci5fZGF0YS5MZW5ndGggOiBkaWFnb25hbFJlc3VsdC5fZGF0YS5MZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3RoZXIuQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IENvbHVtbkNvdW50OyBrKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gQXQoaSwgaykgKiBvdGhlci5BdChrLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQoaSwgaiwgcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGVuc2VPdGhlciA9IG90aGVyLlN0b3JhZ2UgYXMgRGVuc2VDb2x1bW5NYWpvck1hdHJpeFN0b3JhZ2U8ZG91YmxlPjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlT3RoZXIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbnNlID0gZGVuc2VPdGhlci5EYXRhO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpYWdvbmFsID0gX2RhdGE7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE1hdGguTWluKGRlbnNlT3RoZXIuUm93Q291bnQsIFJvd0NvdW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChkIDwgUm93Q291bnQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkNsZWFyU3ViTWF0cml4KGRlbnNlT3RoZXIuUm93Q291bnQsIFJvd0NvdW50IC0gZGVuc2VPdGhlci5Sb3dDb3VudCwgMCwgZGVuc2VPdGhlci5Db2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBkZW5zZU90aGVyLkNvbHVtbkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBkOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQoaiwgaSwgZGVuc2VbaW5kZXhdKmRpYWdvbmFsW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gKGRlbnNlT3RoZXIuUm93Q291bnQgLSBkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKENvbHVtbkNvdW50ID09IFJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvdGhlci5TdG9yYWdlLk1hcEluZGV4ZWRUbzxkb3VibGU+KHJlc3VsdC5TdG9yYWdlLCAoRnVuYzxpbnQsaW50LGRvdWJsZSxkb3VibGU+KSgoaSwgaiwgeCkgPT4geCpfZGF0YVtpXSksIFplcm9zLkFsbG93U2tpcCwgRXhpc3RpbmdEYXRhLkNsZWFyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5DbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgb3RoZXIuU3RvcmFnZS5NYXBTdWJNYXRyaXhJbmRleGVkVG88ZG91YmxlPihyZXN1bHQuU3RvcmFnZSwgKEZ1bmM8aW50LGludCxkb3VibGUsZG91YmxlPikoKGksIGosIHgpID0+IHgqX2RhdGFbaV0pLCAwLCAwLCBvdGhlci5Sb3dDb3VudCwgMCwgMCwgb3RoZXIuQ29sdW1uQ291bnQsIFplcm9zLkFsbG93U2tpcCwgRXhpc3RpbmdEYXRhLkFzc3VtZVplcm9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoaXMgbWF0cml4IHdpdGggdHJhbnNwb3NlIG9mIGFub3RoZXIgbWF0cml4IGFuZCBwbGFjZXMgdGhlIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1RyYW5zcG9zZUFuZE11bHRpcGx5KE1hdHJpeDxkb3VibGU+IG90aGVyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGlhZ29uYWxPdGhlciA9IG90aGVyIGFzIERpYWdvbmFsTWF0cml4O1xyXG4gICAgICAgICAgICB2YXIgZGlhZ29uYWxSZXN1bHQgPSByZXN1bHQgYXMgRGlhZ29uYWxNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChkaWFnb25hbE90aGVyICE9IG51bGwgJiYgZGlhZ29uYWxSZXN1bHQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNEYXRhQ29weSA9IG5ldyBkb3VibGVbZGlhZ29uYWxSZXN1bHQuX2RhdGEuTGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgIHZhciBvdGhlckRhdGFDb3B5ID0gbmV3IGRvdWJsZVtkaWFnb25hbFJlc3VsdC5fZGF0YS5MZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ29weShfZGF0YSwgMCwgdGhpc0RhdGFDb3B5LCAwLCAoZGlhZ29uYWxSZXN1bHQuX2RhdGEuTGVuZ3RoID4gX2RhdGEuTGVuZ3RoKSA/IF9kYXRhLkxlbmd0aCA6IGRpYWdvbmFsUmVzdWx0Ll9kYXRhLkxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KGRpYWdvbmFsT3RoZXIuX2RhdGEsIDAsIG90aGVyRGF0YUNvcHksIDAsIChkaWFnb25hbFJlc3VsdC5fZGF0YS5MZW5ndGggPiBkaWFnb25hbE90aGVyLl9kYXRhLkxlbmd0aCkgPyBkaWFnb25hbE90aGVyLl9kYXRhLkxlbmd0aCA6IGRpYWdvbmFsUmVzdWx0Ll9kYXRhLkxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG90aGVyLlJvd0NvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgQ29sdW1uQ291bnQ7IGsrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBBdChpLCBrKSAqIG90aGVyLkF0KGosIGspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpLCBqLCBzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkZW5zZU90aGVyID0gb3RoZXIuU3RvcmFnZSBhcyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxkb3VibGU+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVuc2UgPSBkZW5zZU90aGVyLkRhdGE7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlhZ29uYWwgPSBfZGF0YTtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gTWF0aC5NaW4oZGVuc2VPdGhlci5Db2x1bW5Db3VudCwgUm93Q291bnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQgPCBSb3dDb3VudClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQ2xlYXJTdWJNYXRyaXgoZGVuc2VPdGhlci5Db2x1bW5Db3VudCwgUm93Q291bnQgLSBkZW5zZU90aGVyLkNvbHVtbkNvdW50LCAwLCBkZW5zZU90aGVyLlJvd0NvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGludCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGRlbnNlT3RoZXIuUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChqLCBpLCBkZW5zZVtpbmRleF0qZGlhZ29uYWxbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYmFzZS5Eb1RyYW5zcG9zZUFuZE11bHRpcGx5KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIG1hdHJpeCBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9UcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkoTWF0cml4PGRvdWJsZT4gb3RoZXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkaWFnb25hbE90aGVyID0gb3RoZXIgYXMgRGlhZ29uYWxNYXRyaXg7XHJcbiAgICAgICAgICAgIHZhciBkaWFnb25hbFJlc3VsdCA9IHJlc3VsdCBhcyBEaWFnb25hbE1hdHJpeDtcclxuICAgICAgICAgICAgaWYgKGRpYWdvbmFsT3RoZXIgIT0gbnVsbCAmJiBkaWFnb25hbFJlc3VsdCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhpc0RhdGFDb3B5ID0gbmV3IGRvdWJsZVtkaWFnb25hbFJlc3VsdC5fZGF0YS5MZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG90aGVyRGF0YUNvcHkgPSBuZXcgZG91YmxlW2RpYWdvbmFsUmVzdWx0Ll9kYXRhLkxlbmd0aF07XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KF9kYXRhLCAwLCB0aGlzRGF0YUNvcHksIDAsIChkaWFnb25hbFJlc3VsdC5fZGF0YS5MZW5ndGggPiBfZGF0YS5MZW5ndGgpID8gX2RhdGEuTGVuZ3RoIDogZGlhZ29uYWxSZXN1bHQuX2RhdGEuTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIEFycmF5LkNvcHkoZGlhZ29uYWxPdGhlci5fZGF0YSwgMCwgb3RoZXJEYXRhQ29weSwgMCwgKGRpYWdvbmFsUmVzdWx0Ll9kYXRhLkxlbmd0aCA+IGRpYWdvbmFsT3RoZXIuX2RhdGEuTGVuZ3RoKSA/IGRpYWdvbmFsT3RoZXIuX2RhdGEuTGVuZ3RoIDogZGlhZ29uYWxSZXN1bHQuX2RhdGEuTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3RoZXIuQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IENvbHVtbkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBSb3dDb3VudDsgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IEF0KGssIGkpICogb3RoZXIuQXQoaywgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KGksIGosIHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRlbnNlT3RoZXIgPSBvdGhlci5TdG9yYWdlIGFzIERlbnNlQ29sdW1uTWFqb3JNYXRyaXhTdG9yYWdlPGRvdWJsZT47XHJcbiAgICAgICAgICAgIGlmIChkZW5zZU90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZW5zZSA9IGRlbnNlT3RoZXIuRGF0YTtcclxuICAgICAgICAgICAgICAgIHZhciBkaWFnb25hbCA9IF9kYXRhO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBNYXRoLk1pbihkZW5zZU90aGVyLlJvd0NvdW50LCBDb2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZCA8IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5DbGVhclN1Yk1hdHJpeChkZW5zZU90aGVyLlJvd0NvdW50LCBDb2x1bW5Db3VudCAtIGRlbnNlT3RoZXIuUm93Q291bnQsIDAsIGRlbnNlT3RoZXIuQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW50IGluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgZGVuc2VPdGhlci5Db2x1bW5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgZDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KGosIGksIGRlbnNlW2luZGV4XSpkaWFnb25hbFtqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IChkZW5zZU90aGVyLlJvd0NvdW50IC0gZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChDb2x1bW5Db3VudCA9PSBSb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb3RoZXIuU3RvcmFnZS5NYXBJbmRleGVkVG88ZG91YmxlPihyZXN1bHQuU3RvcmFnZSwgKEZ1bmM8aW50LGludCxkb3VibGUsZG91YmxlPikoKGksIGosIHgpID0+IHgqX2RhdGFbaV0pLCBaZXJvcy5BbGxvd1NraXAsIEV4aXN0aW5nRGF0YS5DbGVhcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIG90aGVyLlN0b3JhZ2UuTWFwU3ViTWF0cml4SW5kZXhlZFRvPGRvdWJsZT4ocmVzdWx0LlN0b3JhZ2UsIChGdW5jPGludCxpbnQsZG91YmxlLGRvdWJsZT4pKChpLCBqLCB4KSA9PiB4Kl9kYXRhW2ldKSwgMCwgMCwgb3RoZXIuUm93Q291bnQsIDAsIDAsIG90aGVyLkNvbHVtbkNvdW50LCBaZXJvcy5BbGxvd1NraXAsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyB0aGUgdHJhbnNwb3NlIG9mIHRoaXMgbWF0cml4IHdpdGggYSB2ZWN0b3IgYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1RyYW5zcG9zZVRoaXNBbmRNdWx0aXBseShWZWN0b3I8ZG91YmxlPiByaWdodFNpZGUsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5NaW4oQ29sdW1uQ291bnQsIFJvd0NvdW50KTtcclxuICAgICAgICAgICAgaWYgKGQgPCBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkNsZWFyU3ViVmVjdG9yKFJvd0NvdW50LCBDb2x1bW5Db3VudCAtIFJvd0NvdW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGQgPT0gUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZW5zZU90aGVyID0gcmlnaHRTaWRlLlN0b3JhZ2UgYXMgRGVuc2VWZWN0b3JTdG9yYWdlPGRvdWJsZT47XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVuc2VSZXN1bHQgPSByZXN1bHQuU3RvcmFnZSBhcyBEZW5zZVZlY3RvclN0b3JhZ2U8ZG91YmxlPjtcclxuICAgICAgICAgICAgICAgIGlmIChkZW5zZU90aGVyICE9IG51bGwgJiYgZGVuc2VSZXN1bHQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IEF0KGksIGopICogcmlnaHRTaWRlW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtqXSA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpLCBfZGF0YVtpXSpyaWdodFNpZGUuQXQoaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERpdmlkZXMgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIgYW5kIHBsYWNlcyByZXN1bHRzIGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIHNjYWxhciB0byBkaXZpZGUgdGhlIG1hdHJpeCB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvRGl2aWRlKGRvdWJsZSBkaXZpc29yLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvciA9PSAxLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvcHlUbyhyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlhZ1Jlc3VsdCA9IHJlc3VsdCBhcyBEaWFnb25hbE1hdHJpeDtcclxuICAgICAgICAgICAgaWYgKGRpYWdSZXN1bHQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KSh4ID0+IHggLyBkaXZpc29yKSwgcmVzdWx0LCBkaXZpc29yID09IDAuMCA/IFplcm9zLkluY2x1ZGUgOiBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXN1bHQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfZGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkF0KGksIGksIF9kYXRhW2ldL2Rpdmlzb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERpdmlkZXMgYSBzY2FsYXIgYnkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aWRlbmRcIj5UaGUgc2NhbGFyIHRvIGFkZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgZGl2aXNpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb0RpdmlkZUJ5VGhpcyhkb3VibGUgZGl2aWRlbmQsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkaWFnUmVzdWx0ID0gcmVzdWx0IGFzIERpYWdvbmFsTWF0cml4O1xyXG4gICAgICAgICAgICBpZiAoZGlhZ1Jlc3VsdCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0RGF0YSA9IGRpYWdSZXN1bHQuX2RhdGE7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9kYXRhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0RGF0YVtpXSA9IGRpdmlkZW5kL19kYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXN1bHQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfZGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkF0KGksIGksIGRpdmlkZW5kL19kYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGRldGVybWluYW50IG9mIHRoaXMgbWF0cml4LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZG91YmxlIERldGVybWluYW50KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChSb3dDb3VudCAhPSBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4U3F1YXJlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5BZ2dyZWdhdGU8ZG91YmxlLGRvdWJsZT4oX2RhdGEsMS4wLCAoRnVuYzxkb3VibGUsZG91YmxlLGRvdWJsZT4pKChjdXJyZW50LCB0KSA9PiBjdXJyZW50ICogdCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBlbGVtZW50cyBvZiB0aGUgZGlhZ29uYWwgaW4gYSA8c2VlIGNyZWY9XCJEZW5zZVZlY3RvclwiLz4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGVsZW1lbnRzIG9mIHRoZSBkaWFnb25hbC48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPkZvciBub24tc3F1YXJlIG1hdHJpY2VzLCB0aGUgbWV0aG9kIHJldHVybnMgTWluKFJvd3MsIENvbHVtbnMpIGVsZW1lbnRzIHdoZXJlXHJcbiAgICAgICAgLy8vIGkgPT0gaiAoaSBpcyB0aGUgcm93IGluZGV4LCBhbmQgaiBpcyB0aGUgY29sdW1uIGluZGV4KS48L3JlbWFya3M+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3Rvcjxkb3VibGU+IERpYWdvbmFsKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVuc2VWZWN0b3IoX2RhdGEpLkNsb25lKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBhcnJheSB0byB0aGUgZGlhZ29uYWwuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzb3VyY2VcIj5UaGUgYXJyYXkgdG8gY29weSB0aGUgdmFsdWVzIGZyb20uIFRoZSBsZW5ndGggb2YgdGhlIHZlY3RvciBzaG91bGQgYmVcclxuICAgICAgICAvLy8gTWluKFJvd3MsIENvbHVtbnMpLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIGxlbmd0aCBvZiA8cGFyYW1yZWYgbmFtZT1cInNvdXJjZVwiLz4gZG9lcyBub3RcclxuICAgICAgICAvLy8gZXF1YWwgTWluKFJvd3MsIENvbHVtbnMpLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5Gb3Igbm9uLXNxdWFyZSBtYXRyaWNlcywgdGhlIGVsZW1lbnRzIG9mIDxwYXJhbXJlZiBuYW1lPVwic291cmNlXCIvPiBhcmUgY29waWVkIHRvXHJcbiAgICAgICAgLy8vIHRoaXNbaSxpXS48L3JlbWFya3M+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgU2V0RGlhZ29uYWwoZG91YmxlW10gc291cmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZS5MZW5ndGggIT0gX2RhdGEuTGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRBcnJheXNTYW1lTGVuZ3RoXCIsIFwic291cmNlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtID0gbmV3IERlbnNlTWF0cml4KHNvdXJjZS5MZW5ndGgsIHNvdXJjZS5MZW5ndGgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBBcnJheS5Db3B5KHNvdXJjZSwgMCwgX2RhdGEsIDAsIHNvdXJjZS5MZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gPHNlZSBjcmVmPVwiVmVjdG9ye1R9XCIvPiB0byB0aGUgZGlhZ29uYWwuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzb3VyY2VcIj5UaGUgdmVjdG9yIHRvIGNvcHkgdGhlIHZhbHVlcyBmcm9tLiBUaGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3Igc2hvdWxkIGJlXHJcbiAgICAgICAgLy8vIE1pbihSb3dzLCBDb2x1bW5zKS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSBsZW5ndGggb2YgPHBhcmFtcmVmIG5hbWU9XCJzb3VyY2VcIi8+IGRvZXMgbm90XHJcbiAgICAgICAgLy8vIGVxdWFsIE1pbihSb3dzLCBDb2x1bW5zKS48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPHJlbWFya3M+Rm9yIG5vbi1zcXVhcmUgbWF0cmljZXMsIHRoZSBlbGVtZW50cyBvZiA8cGFyYW1yZWYgbmFtZT1cInNvdXJjZVwiLz4gYXJlIGNvcGllZCB0b1xyXG4gICAgICAgIC8vLyB0aGlzW2ksaV0uPC9yZW1hcmtzPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIFNldERpYWdvbmFsKFZlY3Rvcjxkb3VibGU+IHNvdXJjZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkZW5zZVNvdXJjZSA9IHNvdXJjZSBhcyBEZW5zZVZlY3RvcjtcclxuICAgICAgICAgICAgaWYgKGRlbnNlU291cmNlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuU2V0RGlhZ29uYWwoc291cmNlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9kYXRhLkxlbmd0aCAhPSBkZW5zZVNvdXJjZS5WYWx1ZXMuTGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiLCBcInNvdXJjZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgQXJyYXkuQ29weShkZW5zZVNvdXJjZS5WYWx1ZXMsIDAsIF9kYXRhLCAwLCBkZW5zZVNvdXJjZS5WYWx1ZXMuTGVuZ3RoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5DYWxjdWxhdGVzIHRoZSBpbmR1Y2VkIEwxIG5vcm0gb2YgdGhpcyBtYXRyaXguPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbWF4aW11bSBhYnNvbHV0ZSBjb2x1bW4gc3VtIG9mIHRoZSBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgTDFOb3JtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkFnZ3JlZ2F0ZTxkb3VibGUsZG91YmxlPihfZGF0YSwwZCwgKEZ1bmM8ZG91YmxlLGRvdWJsZSxkb3VibGU+KSgoY3VycmVudCwgdCkgPT4gTWF0aC5NYXgoY3VycmVudCwgTWF0aC5BYnModCkpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+Q2FsY3VsYXRlcyB0aGUgaW5kdWNlZCBMMiBub3JtIG9mIHRoZSBtYXRyaXguPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbGFyZ2VzdCBzaW5ndWxhciB2YWx1ZSBvZiB0aGUgbWF0cml4LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZG91YmxlIEwyTm9ybSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5BZ2dyZWdhdGU8ZG91YmxlLGRvdWJsZT4oX2RhdGEsMGQsIChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPikoKGN1cnJlbnQsIHQpID0+IE1hdGguTWF4KGN1cnJlbnQsIE1hdGguQWJzKHQpKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PkNhbGN1bGF0ZXMgdGhlIGluZHVjZWQgaW5maW5pdHkgbm9ybSBvZiB0aGlzIG1hdHJpeC48L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBtYXhpbXVtIGFic29sdXRlIHJvdyBzdW0gb2YgdGhlIG1hdHJpeC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGRvdWJsZSBJbmZpbml0eU5vcm0oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEwxTm9ybSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PkNhbGN1bGF0ZXMgdGhlIGVudHJ5LXdpc2UgRnJvYmVuaXVzIG5vcm0gb2YgdGhpcyBtYXRyaXguPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHN1bSBvZiB0aGUgc3F1YXJlZCB2YWx1ZXMuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgRnJvYmVuaXVzTm9ybSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5TcXJ0KFN5c3RlbS5MaW5xLkVudW1lcmFibGUuU3VtPGRvdWJsZT4oX2RhdGEsKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHQgPT4gdCAqIHQpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+Q2FsY3VsYXRlcyB0aGUgY29uZGl0aW9uIG51bWJlciBvZiB0aGlzIG1hdHJpeC48L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBjb25kaXRpb24gbnVtYmVyIG9mIHRoZSBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgQ29uZGl0aW9uTnVtYmVyKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBtYXhTdiA9IGRvdWJsZS5OZWdhdGl2ZUluZmluaXR5O1xyXG4gICAgICAgICAgICB2YXIgbWluU3YgPSBkb3VibGUuUG9zaXRpdmVJbmZpbml0eTtcclxuICAgICAgICAgICAgZm9yZWFjaCAodmFyIHQgaW4gX2RhdGEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1heFN2ID0gTWF0aC5NYXgobWF4U3YsIE1hdGguQWJzKHQpKTtcclxuICAgICAgICAgICAgICAgIG1pblN2ID0gTWF0aC5NaW4obWluU3YsIE1hdGguQWJzKHQpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1heFN2IC8gbWluU3Y7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+Q29tcHV0ZXMgdGhlIGludmVyc2Ugb2YgdGhpcyBtYXRyaXguPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzZWUgY3JlZj1cIkRpYWdvbmFsTWF0cml4XCIvPiBpcyBub3QgYSBzcXVhcmUgbWF0cml4LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxzZWUgY3JlZj1cIkRpYWdvbmFsTWF0cml4XCIvPiBpcyBzaW5ndWxhci48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGludmVyc2Ugb2YgdGhpcyBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBNYXRyaXg8ZG91YmxlPiBJbnZlcnNlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChSb3dDb3VudCAhPSBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4U3F1YXJlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaW52ZXJzZSA9IChEaWFnb25hbE1hdHJpeClDbG9uZSgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9kYXRhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2RhdGFbaV0gIT0gMC4wKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludmVyc2UuX2RhdGFbaV0gPSAxLjAgLyBfZGF0YVtpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRNYXRyaXhOb3RTaW5ndWxhclwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGludmVyc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYSBuZXcgbWF0cml4IGNvbnRhaW5pbmcgdGhlIGxvd2VyIHRyaWFuZ2xlIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBsb3dlciB0cmlhbmdsZSBvZiB0aGlzIG1hdHJpeC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIE1hdHJpeDxkb3VibGU+IExvd2VyVHJpYW5nbGUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENsb25lKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFB1dHMgdGhlIGxvd2VyIHRyaWFuZ2xlIG9mIHRoaXMgbWF0cml4IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5XaGVyZSB0byBzdG9yZSB0aGUgbG93ZXIgdHJpYW5nbGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgcmVzdWx0IG1hdHJpeCdzIGRpbWVuc2lvbnMgYXJlIG5vdCB0aGUgc2FtZSBhcyB0aGlzIG1hdHJpeC48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBMb3dlclRyaWFuZ2xlKE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuUm93Q291bnQgIT0gUm93Q291bnQgfHwgcmVzdWx0LkNvbHVtbkNvdW50ICE9IENvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBEaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPih0aGlzLCByZXN1bHQsIFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoUmVmZXJlbmNlRXF1YWxzKHRoaXMsIHJlc3VsdCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2RhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpLCBpLCBfZGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIG5ldyBtYXRyaXggY29udGFpbmluZyB0aGUgbG93ZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXguIFRoZSBuZXcgbWF0cml4XHJcbiAgICAgICAgLy8vIGRvZXMgbm90IGNvbnRhaW4gdGhlIGRpYWdvbmFsIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBsb3dlciB0cmlhbmdsZSBvZiB0aGlzIG1hdHJpeC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIE1hdHJpeDxkb3VibGU+IFN0cmljdGx5TG93ZXJUcmlhbmdsZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpYWdvbmFsTWF0cml4KFJvd0NvdW50LCBDb2x1bW5Db3VudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFB1dHMgdGhlIHN0cmljdGx5IGxvd2VyIHRyaWFuZ2xlIG9mIHRoaXMgbWF0cml4IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5XaGVyZSB0byBzdG9yZSB0aGUgbG93ZXIgdHJpYW5nbGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgcmVzdWx0IG1hdHJpeCdzIGRpbWVuc2lvbnMgYXJlIG5vdCB0aGUgc2FtZSBhcyB0aGlzIG1hdHJpeC48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBTdHJpY3RseUxvd2VyVHJpYW5nbGUoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc3VsdC5DbGVhcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgbmV3IG1hdHJpeCBjb250YWluaW5nIHRoZSB1cHBlciB0cmlhbmdsZSBvZiB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgdXBwZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXguPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBNYXRyaXg8ZG91YmxlPiBVcHBlclRyaWFuZ2xlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDbG9uZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQdXRzIHRoZSB1cHBlciB0cmlhbmdsZSBvZiB0aGlzIG1hdHJpeCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+V2hlcmUgdG8gc3RvcmUgdGhlIGxvd2VyIHRyaWFuZ2xlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHJlc3VsdCBtYXRyaXgncyBkaW1lbnNpb25zIGFyZSBub3QgdGhlIHNhbWUgYXMgdGhpcyBtYXRyaXguPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgVXBwZXJUcmlhbmdsZShNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LlJvd0NvdW50ICE9IFJvd0NvdW50IHx8IHJlc3VsdC5Db2x1bW5Db3VudCAhPSBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4odGhpcywgcmVzdWx0LCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2RhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpLCBpLCBfZGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIG5ldyBtYXRyaXggY29udGFpbmluZyB0aGUgdXBwZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXguIFRoZSBuZXcgbWF0cml4XHJcbiAgICAgICAgLy8vIGRvZXMgbm90IGNvbnRhaW4gdGhlIGRpYWdvbmFsIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSB1cHBlciB0cmlhbmdsZSBvZiB0aGlzIG1hdHJpeC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIE1hdHJpeDxkb3VibGU+IFN0cmljdGx5VXBwZXJUcmlhbmdsZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpYWdvbmFsTWF0cml4KFJvd0NvdW50LCBDb2x1bW5Db3VudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFB1dHMgdGhlIHN0cmljdGx5IHVwcGVyIHRyaWFuZ2xlIG9mIHRoaXMgbWF0cml4IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5XaGVyZSB0byBzdG9yZSB0aGUgbG93ZXIgdHJpYW5nbGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgcmVzdWx0IG1hdHJpeCdzIGRpbWVuc2lvbnMgYXJlIG5vdCB0aGUgc2FtZSBhcyB0aGlzIG1hdHJpeC48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBTdHJpY3RseVVwcGVyVHJpYW5nbGUoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc3VsdC5DbGVhcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgbWF0cml4IHRoYXQgY29udGFpbnMgdGhlIHZhbHVlcyBmcm9tIHRoZSByZXF1ZXN0ZWQgc3ViLW1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd0luZGV4XCI+VGhlIHJvdyB0byBzdGFydCBjb3B5aW5nIGZyb20uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dDb3VudFwiPlRoZSBudW1iZXIgb2Ygcm93cyB0byBjb3B5LiBNdXN0IGJlIHBvc2l0aXZlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uSW5kZXhcIj5UaGUgY29sdW1uIHRvIHN0YXJ0IGNvcHlpbmcgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtbkNvdW50XCI+VGhlIG51bWJlciBvZiBjb2x1bW5zIHRvIGNvcHkuIE11c3QgYmUgcG9zaXRpdmUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlcXVlc3RlZCBzdWItbWF0cml4LjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWY6IDxsaXN0PjxpdGVtPjxwYXJhbXJlZiBuYW1lPVwicm93SW5kZXhcIi8+IGlzXHJcbiAgICAgICAgLy8vIG5lZ2F0aXZlLCBvciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiByb3dzLjwvaXRlbT5cclxuICAgICAgICAvLy8gPGl0ZW0+PHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5JbmRleFwiLz4gaXMgbmVnYXRpdmUsIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyXHJcbiAgICAgICAgLy8vIG9mIGNvbHVtbnMuPC9pdGVtPlxyXG4gICAgICAgIC8vLyA8aXRlbT48Yz4oY29sdW1uSW5kZXggKyBjb2x1bW5MZW5ndGgpICZndDs9IENvbHVtbnM8L2M+PC9pdGVtPlxyXG4gICAgICAgIC8vLyA8aXRlbT48Yz4ocm93SW5kZXggKyByb3dMZW5ndGgpICZndDs9IFJvd3M8L2M+PC9pdGVtPjwvbGlzdD48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyb3dDb3VudFwiLz4gb3IgPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5Db3VudFwiLz5cclxuICAgICAgICAvLy8gaXMgbm90IHBvc2l0aXZlLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBNYXRyaXg8ZG91YmxlPiBTdWJNYXRyaXgoaW50IHJvd0luZGV4LCBpbnQgcm93Q291bnQsIGludCBjb2x1bW5JbmRleCwgaW50IGNvbHVtbkNvdW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHJvd0luZGV4ID09IGNvbHVtbkluZGV4XHJcbiAgICAgICAgICAgICAgICA/IChNYXRyaXg8ZG91YmxlPiluZXcgRGlhZ29uYWxNYXRyaXgocm93Q291bnQsIGNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICAgICAgOiBuZXcgU3BhcnNlTWF0cml4KHJvd0NvdW50LCBjb2x1bW5Db3VudCk7XHJcblxyXG4gICAgICAgICAgICBTdG9yYWdlLkNvcHlTdWJNYXRyaXhUbyh0YXJnZXQuU3RvcmFnZSwgcm93SW5kZXgsIDAsIHJvd0NvdW50LCBjb2x1bW5JbmRleCwgMCwgY29sdW1uQ291bnQsIEV4aXN0aW5nRGF0YS5Bc3N1bWVaZXJvcyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBlcm11dGUgdGhlIGNvbHVtbnMgb2YgYSBtYXRyaXggYWNjb3JkaW5nIHRvIGEgcGVybXV0YXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwXCI+VGhlIGNvbHVtbiBwZXJtdXRhdGlvbiB0byBhcHBseSB0byB0aGlzIG1hdHJpeC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJJbnZhbGlkT3BlcmF0aW9uRXhjZXB0aW9uXCI+QWx3YXlzIHRocm93bjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5QZXJtdXRhdGlvbiBpbiBkaWFnb25hbCBtYXRyaXggYXJlIHNlbnNlbGVzcywgYmVjYXVzZSBvZiBtYXRyaXggbmF0dXJlPC9yZW1hcmtzPlxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEV2YWx1YXRlcyB3aGV0aGVyIHRoaXMgbWF0cml4IGlzIHN5bW1ldHJpYy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzZWFsZWQgb3ZlcnJpZGUgYm9vbCBJc1N5bW1ldHJpYygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGNhbm9uaWNhbCBtb2R1bHVzLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aXNvcixcclxuICAgICAgICAvLy8gZm9yIHRoZSBnaXZlbiBkaXZpc29yIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBzY2FsYXIgZGVub21pbmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+TWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Nb2R1bHVzKGRvdWJsZSBkaXZpc29yLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGlhZ29uYWxSZXN1bHQgPSByZXN1bHQgYXMgRGlhZ29uYWxNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChkaWFnb25hbFJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvTW9kdWx1cyhkaXZpc29yLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciByID0gZGlhZ29uYWxSZXN1bHQuX2RhdGE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9kYXRhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJbaV0gPSBFdWNsaWQuTW9kdWx1cyhfZGF0YVtpXSwgZGl2aXNvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgY2Fub25pY2FsIG1vZHVsdXMsIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpc29yLFxyXG4gICAgICAgIC8vLyBmb3IgdGhlIGdpdmVuIGRpdmlkZW5kIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHNjYWxhciBudW1lcmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+QSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb01vZHVsdXNCeVRoaXMoZG91YmxlIGRpdmlkZW5kLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGlhZ29uYWxSZXN1bHQgPSByZXN1bHQgYXMgRGlhZ29uYWxNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChkaWFnb25hbFJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvTW9kdWx1c0J5VGhpcyhkaXZpZGVuZCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IGRpYWdvbmFsUmVzdWx0Ll9kYXRhO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfZGF0YS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByW2ldID0gRXVjbGlkLk1vZHVsdXMoZGl2aWRlbmQsIF9kYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSByZW1haW5kZXIgKCUgb3BlcmF0b3IpLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aWRlbmQsXHJcbiAgICAgICAgLy8vIGZvciB0aGUgZ2l2ZW4gZGl2aXNvciBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgc2NhbGFyIGRlbm9taW5hdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPk1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUmVtYWluZGVyKGRvdWJsZSBkaXZpc29yLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZGlhZ29uYWxSZXN1bHQgPSByZXN1bHQgYXMgRGlhZ29uYWxNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChkaWFnb25hbFJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvUmVtYWluZGVyKGRpdmlzb3IsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBkaWFnb25hbFJlc3VsdC5fZGF0YTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2RhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcltpXSA9IF9kYXRhW2ldJWRpdmlzb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgcmVtYWluZGVyICglIG9wZXJhdG9yKSwgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlkZW5kLFxyXG4gICAgICAgIC8vLyBmb3IgdGhlIGdpdmVuIGRpdmlkZW5kIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlkZW5kXCI+VGhlIHNjYWxhciBudW1lcmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+QSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1JlbWFpbmRlckJ5VGhpcyhkb3VibGUgZGl2aWRlbmQsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBkaWFnb25hbFJlc3VsdCA9IHJlc3VsdCBhcyBEaWFnb25hbE1hdHJpeDtcclxuICAgICAgICAgICAgaWYgKGRpYWdvbmFsUmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9SZW1haW5kZXJCeVRoaXMoZGl2aWRlbmQsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBkaWFnb25hbFJlc3VsdC5fZGF0YTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2RhdGEuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcltpXSA9IGRpdmlkZW5kJV9kYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBMVTxkb3VibGU+IExVKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvLyA8Y29weXJpZ2h0IGZpbGU9XCJMVS5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDEzIE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRmFjdG9yaXphdGlvbjtcclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlLkZhY3Rvcml6YXRpb25cclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIDxwYXJhPkEgY2xhc3Mgd2hpY2ggZW5jYXBzdWxhdGVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIExVIGZhY3Rvcml6YXRpb24uPC9wYXJhPlxyXG4gICAgLy8vIDxwYXJhPkZvciBhIG1hdHJpeCBBLCB0aGUgTFUgZmFjdG9yaXphdGlvbiBpcyBhIHBhaXIgb2YgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXggTCBhbmRcclxuICAgIC8vLyB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCBVIHNvIHRoYXQgQSA9IEwqVS48L3BhcmE+XHJcbiAgICAvLy8gPHBhcmE+SW4gdGhlIE1hdGguTmV0IGltcGxlbWVudGF0aW9uIHdlIGFsc28gc3RvcmUgYSBzZXQgb2YgcGl2b3QgZWxlbWVudHMgZm9yIGluY3JlYXNlZFxyXG4gICAgLy8vIG51bWVyaWNhbCBzdGFiaWxpdHkuIFRoZSBwaXZvdCBlbGVtZW50cyBlbmNvZGUgYSBwZXJtdXRhdGlvbiBtYXRyaXggUCBzdWNoIHRoYXQgUCpBID0gTCpVLjwvcGFyYT5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAvLy8gPHJlbWFya3M+XHJcbiAgICAvLy8gVGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBMVSBmYWN0b3JpemF0aW9uIGlzIGRvbmUgYXQgY29uc3RydWN0aW9uIHRpbWUuXHJcbiAgICAvLy8gPC9yZW1hcmtzPlxyXG4gICAgaW50ZXJuYWwgYWJzdHJhY3QgY2xhc3MgTFUgOiBMVTxkb3VibGU+XHJcbiAgICB7XHJcbiAgICAgICAgcHJvdGVjdGVkIExVKE1hdHJpeDxkb3VibGU+IGZhY3RvcnMsIGludFtdIHBpdm90cylcclxuICAgICAgICAgICAgOiBiYXNlKGZhY3RvcnMsIHBpdm90cylcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIGRldGVybWluYW50IG9mIHRoZSBtYXRyaXggZm9yIHdoaWNoIHRoZSBMVSBmYWN0b3JpemF0aW9uIHdhcyBjb21wdXRlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgRGV0ZXJtaW5hbnRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGV0ID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBGYWN0b3JzLlJvd0NvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBpdm90c1tqXSAhPSBqKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0ICo9IC1GYWN0b3JzLkF0KGosIGopO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXQgKj0gRmFjdG9ycy5BdChqLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvLyA8Y29weXJpZ2h0IGZpbGU9XCJTdmQuY3NcIiBjb21wYW55PVwiTWF0aC5ORVRcIj5cclxuLy8gTWF0aC5ORVQgTnVtZXJpY3MsIHBhcnQgb2YgdGhlIE1hdGguTkVUIFByb2plY3RcclxuLy8gaHR0cDovL251bWVyaWNzLm1hdGhkb3RuZXQuY29tXHJcbi8vIGh0dHA6Ly9naXRodWIuY29tL21hdGhuZXQvbWF0aG5ldC1udW1lcmljc1xyXG4vL1xyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNSBNYXRoLk5FVFxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxyXG4vLyBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4vLyBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuLy8gcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXHJcbi8vIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4vLyBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xyXG4vLyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4vLyBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXHJcbi8vIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbi8vIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXHJcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxyXG4vLyBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4vLyBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbi8vIDwvY29weXJpZ2h0PlxyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uTGlucTtcclxudXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkZhY3Rvcml6YXRpb247XHJcblxyXG5uYW1lc3BhY2UgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkRvdWJsZS5GYWN0b3JpemF0aW9uXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyA8cGFyYT5BIGNsYXNzIHdoaWNoIGVuY2Fwc3VsYXRlcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiB0aGUgc2luZ3VsYXIgdmFsdWUgZGVjb21wb3NpdGlvbiAoU1ZEKS48L3BhcmE+XHJcbiAgICAvLy8gPHBhcmE+U3VwcG9zZSBNIGlzIGFuIG0tYnktbiBtYXRyaXggd2hvc2UgZW50cmllcyBhcmUgcmVhbCBudW1iZXJzLlxyXG4gICAgLy8vIFRoZW4gdGhlcmUgZXhpc3RzIGEgZmFjdG9yaXphdGlvbiBvZiB0aGUgZm9ybSBNID0gVc6jVlQgd2hlcmU6XHJcbiAgICAvLy8gLSBVIGlzIGFuIG0tYnktbSB1bml0YXJ5IG1hdHJpeDtcclxuICAgIC8vLyAtIM6jIGlzIG0tYnktbiBkaWFnb25hbCBtYXRyaXggd2l0aCBub25uZWdhdGl2ZSByZWFsIG51bWJlcnMgb24gdGhlIGRpYWdvbmFsO1xyXG4gICAgLy8vIC0gVlQgZGVub3RlcyB0cmFuc3Bvc2Ugb2YgViwgYW4gbi1ieS1uIHVuaXRhcnkgbWF0cml4O1xyXG4gICAgLy8vIFN1Y2ggYSBmYWN0b3JpemF0aW9uIGlzIGNhbGxlZCBhIHNpbmd1bGFyLXZhbHVlIGRlY29tcG9zaXRpb24gb2YgTS4gQSBjb21tb24gY29udmVudGlvbiBpcyB0byBvcmRlciB0aGUgZGlhZ29uYWxcclxuICAgIC8vLyBlbnRyaWVzIM6jKGksaSkgaW4gZGVzY2VuZGluZyBvcmRlci4gSW4gdGhpcyBjYXNlLCB0aGUgZGlhZ29uYWwgbWF0cml4IM6jIGlzIHVuaXF1ZWx5IGRldGVybWluZWRcclxuICAgIC8vLyBieSBNICh0aG91Z2ggdGhlIG1hdHJpY2VzIFUgYW5kIFYgYXJlIG5vdCkuIFRoZSBkaWFnb25hbCBlbnRyaWVzIG9mIM6jIGFyZSBrbm93biBhcyB0aGUgc2luZ3VsYXIgdmFsdWVzIG9mIE0uPC9wYXJhPlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIC8vLyA8cmVtYXJrcz5cclxuICAgIC8vLyBUaGUgY29tcHV0YXRpb24gb2YgdGhlIHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gaXMgZG9uZSBhdCBjb25zdHJ1Y3Rpb24gdGltZS5cclxuICAgIC8vLyA8L3JlbWFya3M+XHJcbiAgICBpbnRlcm5hbCBhYnN0cmFjdCBjbGFzcyBTdmQgOiBTdmQ8ZG91YmxlPlxyXG4gICAge1xyXG4gICAgICAgIHByb3RlY3RlZCBTdmQoVmVjdG9yPGRvdWJsZT4gcywgTWF0cml4PGRvdWJsZT4gdSwgTWF0cml4PGRvdWJsZT4gdnQsIGJvb2wgdmVjdG9yc0NvbXB1dGVkKVxyXG4gICAgICAgICAgICA6IGJhc2UocywgdSwgdnQsIHZlY3RvcnNDb21wdXRlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIGVmZmVjdGl2ZSBudW1lcmljYWwgbWF0cml4IHJhbmsuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBudW1iZXIgb2Ygbm9uLW5lZ2xpZ2libGUgc2luZ3VsYXIgdmFsdWVzLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGludCBSYW5rXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIHRvbGVyYW5jZSA9IGRvdWJsZS5FcHNpbG9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN5c3RlbS5MaW5xLkVudW1lcmFibGUuQ291bnQ8ZG91YmxlPihTLChGdW5jPGRvdWJsZSxib29sPikodCA9PiBNYXRoLkFicyh0KSA+IHRvbGVyYW5jZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIHR3byBub3JtIG9mIHRoZSA8c2VlIGNyZWY9XCJNYXRyaXh7VH1cIi8+LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSAyLW5vcm0gb2YgdGhlIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4uPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgTDJOb3JtXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguQWJzKFNbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIGNvbmRpdGlvbiBudW1iZXIgPGI+bWF4KFMpIC8gbWluKFMpPC9iPlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBjb25kaXRpb24gbnVtYmVyLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZG91YmxlIENvbmRpdGlvbk51bWJlclxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBNYXRoLk1pbihVLlJvd0NvdW50LCBWVC5Db2x1bW5Db3VudCkgLSAxO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguQWJzKFNbMF0pIC8gTWF0aC5BYnMoU1t0bXBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBkZXRlcm1pbmFudCBvZiB0aGUgc3F1YXJlIG1hdHJpeCBmb3Igd2hpY2ggdGhlIFNWRCB3YXMgY29tcHV0ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZG91YmxlIERldGVybWluYW50XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKFUuUm93Q291bnQgIT0gVlQuQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4U3F1YXJlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkZXQgPSAxLjA7XHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoICh2YXIgdmFsdWUgaW4gUylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXQgKj0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguQWJzKHZhbHVlKTw9KE1hdGguUG93KDEwLC01KSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguQWJzKGRldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiU3BhcnNlTWF0cml4LmNzXCIgY29tcGFueT1cIk1hdGguTkVUXCI+XHJcbi8vIE1hdGguTkVUIE51bWVyaWNzLCBwYXJ0IG9mIHRoZSBNYXRoLk5FVCBQcm9qZWN0XHJcbi8vIGh0dHA6Ly9udW1lcmljcy5tYXRoZG90bmV0LmNvbVxyXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXRobmV0L21hdGhuZXQtbnVtZXJpY3NcclxuLy9cclxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTMgTWF0aC5ORVRcclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuLy8gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbi8vIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4vLyBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuLy8gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuLy8gY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbi8vIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xyXG4vLyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcclxuLy8gV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuLy8gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4vLyA8L2NvcHlyaWdodD5cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgU3lzdGVtLkxpbnE7XHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5GYWN0b3JpemF0aW9uO1xyXG51c2luZyBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuU3RvcmFnZTtcclxudXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkRvdWJsZS5NYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmE7XHJcblxyXG5cclxubmFtZXNwYWNlIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGVcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgTWF0cml4IHdpdGggc3BhcnNlIHN0b3JhZ2UsIGludGVuZGVkIGZvciB2ZXJ5IGxhcmdlIG1hdHJpY2VzIHdoZXJlIG1vc3Qgb2YgdGhlIGNlbGxzIGFyZSB6ZXJvLlxyXG4gICAgLy8vIFRoZSB1bmRlcmx5aW5nIHN0b3JhZ2Ugc2NoZW1lIGlzIDMtYXJyYXkgY29tcHJlc3NlZC1zcGFyc2Utcm93IChDU1IpIEZvcm1hdC5cclxuICAgIC8vLyA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGFyc2VfbWF0cml4I0NvbXByZXNzZWRfc3BhcnNlX3Jvd18uMjhDU1Jfb3JfQ1JTLjI5XCI+V2lraXBlZGlhIC0gQ1NSPC9hPi5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBbU2VyaWFsaXphYmxlXVxyXG4gICAgW0RlYnVnZ2VyRGlzcGxheShcIlNwYXJzZU1hdHJpeCB7Um93Q291bnR9eHtDb2x1bW5Db3VudH0tRG91YmxlIHtOb25aZXJvc0NvdW50fS1Ob25aZXJvXCIpXVxyXG4gICAgcHVibGljIGNsYXNzIFNwYXJzZU1hdHJpeCA6IE1hdHJpeFxyXG4gICAge1xyXG4gICAgICAgIHJlYWRvbmx5IFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPGRvdWJsZT4gX3N0b3JhZ2U7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgbnVtYmVyIG9mIG5vbiB6ZXJvIGVsZW1lbnRzIGluIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBudW1iZXIgb2Ygbm9uIHplcm8gZWxlbWVudHMuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgaW50IE5vblplcm9zQ291bnRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfc3RvcmFnZS5WYWx1ZUNvdW50OyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IHN0cmFpZ2h0IGZyb20gYW4gaW5pdGlhbGl6ZWQgbWF0cml4IHN0b3JhZ2UgaW5zdGFuY2UuXHJcbiAgICAgICAgLy8vIFRoZSBzdG9yYWdlIGlzIHVzZWQgZGlyZWN0bHkgd2l0aG91dCBjb3B5aW5nLlxyXG4gICAgICAgIC8vLyBJbnRlbmRlZCBmb3IgYWR2YW5jZWQgc2NlbmFyaW9zIHdoZXJlIHlvdSdyZSB3b3JraW5nIGRpcmVjdGx5IHdpdGhcclxuICAgICAgICAvLy8gc3RvcmFnZSBmb3IgcGVyZm9ybWFuY2Ugb3IgaW50ZXJvcCByZWFzb25zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFNwYXJzZU1hdHJpeChTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxkb3VibGU+IHN0b3JhZ2UpXHJcbiAgICAgICAgICAgIDogYmFzZShzdG9yYWdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3N0b3JhZ2UgPSBzdG9yYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3F1YXJlIHNwYXJzZSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMuXHJcbiAgICAgICAgLy8vIEFsbCBjZWxscyBvZiB0aGUgbWF0cml4IHdpbGwgYmUgaW5pdGlhbGl6ZWQgdG8gemVyby5cclxuICAgICAgICAvLy8gWmVyby1sZW5ndGggbWF0cmljZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgb3JkZXIgaXMgbGVzcyB0aGFuIG9uZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgU3BhcnNlTWF0cml4KGludCBvcmRlcilcclxuICAgICAgICAgICAgOiB0aGlzKG9yZGVyLCBvcmRlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IHdpdGggdGhlIGdpdmVuIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zLlxyXG4gICAgICAgIC8vLyBBbGwgY2VsbHMgb2YgdGhlIG1hdHJpeCB3aWxsIGJlIGluaXRpYWxpemVkIHRvIHplcm8uXHJcbiAgICAgICAgLy8vIFplcm8tbGVuZ3RoIG1hdHJpY2VzIGFyZSBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHJvdyBvciBjb2x1bW4gY291bnQgaXMgbGVzcyB0aGFuIG9uZS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgU3BhcnNlTWF0cml4KGludCByb3dzLCBpbnQgY29sdW1ucylcclxuICAgICAgICAgICAgOiB0aGlzKG5ldyBTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxkb3VibGU+KHJvd3MsIGNvbHVtbnMpKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBvdGhlciBtYXRyaXguXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIG90aGVyIG1hdHJpeC5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZU1hdHJpeCBPZk1hdHJpeChNYXRyaXg8ZG91YmxlPiBtYXRyaXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeChTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mTWF0cml4KG1hdHJpeC5TdG9yYWdlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdHdvLWRpbWVuc2lvbmFsIGFycmF5LlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBwcm92aWRlZCBhcnJheS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZU1hdHJpeCBPZkFycmF5KGRvdWJsZVssXSBhcnJheSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZBcnJheShhcnJheSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGluZGV4ZWQgZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gS2V5cyBtdXN0IGJlIHByb3ZpZGVkIGF0IG1vc3Qgb25jZSwgemVybyBpcyBhc3N1bWVkIGlmIGEga2V5IGlzIG9taXR0ZWQuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGVudW1lcmFibGUuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VNYXRyaXggT2ZJbmRleGVkKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8VHVwbGU8aW50LCBpbnQsIGRvdWJsZT4+IGVudW1lcmFibGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeChTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mSW5kZXhlZEVudW1lcmFibGUocm93cywgY29sdW1ucywgZW51bWVyYWJsZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGVudW1lcmFibGUuXHJcbiAgICAgICAgLy8vIFRoZSBlbnVtZXJhYmxlIGlzIGFzc3VtZWQgdG8gYmUgaW4gcm93LW1ham9yIG9yZGVyIChyb3cgYnkgcm93KS5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHNlZWFsc28gaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm93LW1ham9yX29yZGVyXCIvPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlTWF0cml4IE9mUm93TWFqb3IoaW50IHJvd3MsIGludCBjb2x1bW5zLCBJRW51bWVyYWJsZTxkb3VibGU+IHJvd01ham9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VNYXRyaXgoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8ZG91YmxlPi5PZlJvd01ham9yRW51bWVyYWJsZShyb3dzLCBjb2x1bW5zLCByb3dNYWpvcikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICAgIC8vLyBUaGUgYXJyYXkgaXMgYXNzdW1lZCB0byBiZSBpbiBjb2x1bW4tbWFqb3Igb3JkZXIgKGNvbHVtbiBieSBjb2x1bW4pLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBwcm92aWRlZCBhcnJheS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHNlZWFsc28gaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm93LW1ham9yX29yZGVyXCIvPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlTWF0cml4IE9mQ29sdW1uTWFqb3IoaW50IHJvd3MsIGludCBjb2x1bW5zLCBJTGlzdDxkb3VibGU+IGNvbHVtbk1ham9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VNYXRyaXgoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8ZG91YmxlPi5PZkNvbHVtbk1ham9yTGlzdChyb3dzLCBjb2x1bW5zLCBjb2x1bW5NYWpvcikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGVudW1lcmFibGUgb2YgZW51bWVyYWJsZSBjb2x1bW5zLlxyXG4gICAgICAgIC8vLyBFYWNoIGVudW1lcmFibGUgaW4gdGhlIG1hc3RlciBlbnVtZXJhYmxlIHNwZWNpZmllcyBhIGNvbHVtbi5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZXMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VNYXRyaXggT2ZDb2x1bW5zKElFbnVtZXJhYmxlPElFbnVtZXJhYmxlPGRvdWJsZT4+IGRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gT2ZDb2x1bW5BcnJheXMoU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5TZWxlY3Q8SUVudW1lcmFibGU8ZG91YmxlPixkb3VibGVbXT4oZGF0YSwoRnVuYzxJRW51bWVyYWJsZTxkb3VibGU+LGRvdWJsZVtdPikodiA9PiBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlRvQXJyYXk8ZG91YmxlPih2KSkpLlRvQXJyYXkoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gZW51bWVyYWJsZSBvZiBlbnVtZXJhYmxlIGNvbHVtbnMuXHJcbiAgICAgICAgLy8vIEVhY2ggZW51bWVyYWJsZSBpbiB0aGUgbWFzdGVyIGVudW1lcmFibGUgc3BlY2lmaWVzIGEgY29sdW1uLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBlbnVtZXJhYmxlcy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZU1hdHJpeCBPZkNvbHVtbnMoaW50IHJvd3MsIGludCBjb2x1bW5zLCBJRW51bWVyYWJsZTxJRW51bWVyYWJsZTxkb3VibGU+PiBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VNYXRyaXgoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8ZG91YmxlPi5PZkNvbHVtbkVudW1lcmFibGVzKHJvd3MsIGNvbHVtbnMsIGRhdGEpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBjb2x1bW4gYXJyYXlzLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheXMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VNYXRyaXggT2ZDb2x1bW5BcnJheXMocGFyYW1zIGRvdWJsZVtdW10gY29sdW1ucylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZDb2x1bW5BcnJheXMoY29sdW1ucykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGNvbHVtbiBhcnJheXMuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGFycmF5cy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZU1hdHJpeCBPZkNvbHVtbkFycmF5cyhJRW51bWVyYWJsZTxkb3VibGVbXT4gY29sdW1ucylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZDb2x1bW5BcnJheXMoKGNvbHVtbnMgYXMgZG91YmxlW11bXSkgPz8gU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5Ub0FycmF5PGRvdWJsZVtdPihjb2x1bW5zKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGNvbHVtbiB2ZWN0b3JzLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3JzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlTWF0cml4IE9mQ29sdW1uVmVjdG9ycyhwYXJhbXMgVmVjdG9yPGRvdWJsZT5bXSBjb2x1bW5zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBuZXcgVmVjdG9yU3RvcmFnZTxkb3VibGU+W2NvbHVtbnMuTGVuZ3RoXTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBjb2x1bW5zLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzdG9yYWdlW2ldID0gY29sdW1uc1tpXS5TdG9yYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZDb2x1bW5WZWN0b3JzKHN0b3JhZ2UpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBjb2x1bW4gdmVjdG9ycy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9ycy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZU1hdHJpeCBPZkNvbHVtblZlY3RvcnMoSUVudW1lcmFibGU8VmVjdG9yPGRvdWJsZT4+IGNvbHVtbnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeChTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mQ29sdW1uVmVjdG9ycyhTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlNlbGVjdDxWZWN0b3I8ZG91YmxlPixWZWN0b3JTdG9yYWdlPGRvdWJsZT4+KGNvbHVtbnMsKEZ1bmM8VmVjdG9yPGRvdWJsZT4sVmVjdG9yU3RvcmFnZTxkb3VibGU+PikoYyA9PiBjLlN0b3JhZ2UpKS5Ub0FycmF5KCkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBlbnVtZXJhYmxlIG9mIGVudW1lcmFibGUgcm93cy5cclxuICAgICAgICAvLy8gRWFjaCBlbnVtZXJhYmxlIGluIHRoZSBtYXN0ZXIgZW51bWVyYWJsZSBzcGVjaWZpZXMgYSByb3cuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGVudW1lcmFibGVzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlTWF0cml4IE9mUm93cyhJRW51bWVyYWJsZTxJRW51bWVyYWJsZTxkb3VibGU+PiBkYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9mUm93QXJyYXlzKFN5c3RlbS5MaW5xLkVudW1lcmFibGUuU2VsZWN0PElFbnVtZXJhYmxlPGRvdWJsZT4sZG91YmxlW10+KGRhdGEsKEZ1bmM8SUVudW1lcmFibGU8ZG91YmxlPixkb3VibGVbXT4pKHYgPT4gU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5Ub0FycmF5PGRvdWJsZT4odikpKS5Ub0FycmF5KCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGVudW1lcmFibGUgb2YgZW51bWVyYWJsZSByb3dzLlxyXG4gICAgICAgIC8vLyBFYWNoIGVudW1lcmFibGUgaW4gdGhlIG1hc3RlciBlbnVtZXJhYmxlIHNwZWNpZmllcyBhIHJvdy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZXMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VNYXRyaXggT2ZSb3dzKGludCByb3dzLCBpbnQgY29sdW1ucywgSUVudW1lcmFibGU8SUVudW1lcmFibGU8ZG91YmxlPj4gZGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZSb3dFbnVtZXJhYmxlcyhyb3dzLCBjb2x1bW5zLCBkYXRhKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gcm93IGFycmF5cy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXlzLlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlTWF0cml4IE9mUm93QXJyYXlzKHBhcmFtcyBkb3VibGVbXVtdIHJvd3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeChTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mUm93QXJyYXlzKHJvd3MpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiByb3cgYXJyYXlzLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBhcnJheXMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VNYXRyaXggT2ZSb3dBcnJheXMoSUVudW1lcmFibGU8ZG91YmxlW10+IHJvd3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeChTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mUm93QXJyYXlzKChyb3dzIGFzIGRvdWJsZVtdW10pID8/IFN5c3RlbS5MaW5xLkVudW1lcmFibGUuVG9BcnJheTxkb3VibGVbXT4ocm93cykpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiByb3cgdmVjdG9ycy5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgdmVjdG9ycy5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZU1hdHJpeCBPZlJvd1ZlY3RvcnMocGFyYW1zIFZlY3Rvcjxkb3VibGU+W10gcm93cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gbmV3IFZlY3RvclN0b3JhZ2U8ZG91YmxlPltyb3dzLkxlbmd0aF07XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcm93cy5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3RvcmFnZVtpXSA9IHJvd3NbaV0uU3RvcmFnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeChTcGFyc2VDb21wcmVzc2VkUm93TWF0cml4U3RvcmFnZTxkb3VibGU+Lk9mUm93VmVjdG9ycyhzdG9yYWdlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gcm93IHZlY3RvcnMuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIHZlY3RvcnMuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VNYXRyaXggT2ZSb3dWZWN0b3JzKElFbnVtZXJhYmxlPFZlY3Rvcjxkb3VibGU+PiByb3dzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VNYXRyaXgoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8ZG91YmxlPi5PZlJvd1ZlY3RvcnMoU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5TZWxlY3Q8VmVjdG9yPGRvdWJsZT4sVmVjdG9yU3RvcmFnZTxkb3VibGU+Pihyb3dzLChGdW5jPFZlY3Rvcjxkb3VibGU+LFZlY3RvclN0b3JhZ2U8ZG91YmxlPj4pKHIgPT4gci5TdG9yYWdlKSkuVG9BcnJheSgpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IHdpdGggdGhlIGRpYWdvbmFsIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VNYXRyaXggT2ZEaWFnb25hbFZlY3RvcihWZWN0b3I8ZG91YmxlPiBkaWFnb25hbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBtID0gbmV3IFNwYXJzZU1hdHJpeChkaWFnb25hbC5Db3VudCwgZGlhZ29uYWwuQ291bnQpO1xyXG4gICAgICAgICAgICBtLlNldERpYWdvbmFsKGRpYWdvbmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IHdpdGggdGhlIGRpYWdvbmFsIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyBtYXRyaXggd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VNYXRyaXggT2ZEaWFnb25hbFZlY3RvcihpbnQgcm93cywgaW50IGNvbHVtbnMsIFZlY3Rvcjxkb3VibGU+IGRpYWdvbmFsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIG0gPSBuZXcgU3BhcnNlTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xyXG4gICAgICAgICAgICBtLlNldERpYWdvbmFsKGRpYWdvbmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgbWF0cml4IHdpdGggdGhlIGRpYWdvbmFsIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gYXJyYXkuXHJcbiAgICAgICAgLy8vIFRoaXMgbmV3IG1hdHJpeCB3aWxsIGJlIGluZGVwZW5kZW50IGZyb20gdGhlIGFycmF5LlxyXG4gICAgICAgIC8vLyBBIG5ldyBtZW1vcnkgYmxvY2sgd2lsbCBiZSBhbGxvY2F0ZWQgZm9yIHN0b3JpbmcgdGhlIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlTWF0cml4IE9mRGlhZ29uYWxBcnJheShkb3VibGVbXSBkaWFnb25hbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBtID0gbmV3IFNwYXJzZU1hdHJpeChkaWFnb25hbC5MZW5ndGgsIGRpYWdvbmFsLkxlbmd0aCk7XHJcbiAgICAgICAgICAgIG0uU2V0RGlhZ29uYWwoZGlhZ29uYWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggd2l0aCB0aGUgZGlhZ29uYWwgYXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBhcnJheS5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgbWF0cml4IHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgYXJyYXkuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VNYXRyaXggT2ZEaWFnb25hbEFycmF5KGludCByb3dzLCBpbnQgY29sdW1ucywgZG91YmxlW10gZGlhZ29uYWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbSA9IG5ldyBTcGFyc2VNYXRyaXgocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgIG0uU2V0RGlhZ29uYWwoZGlhZ29uYWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IHNwYXJzZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCB2YWx1ZSB0byB0aGUgc2FtZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlTWF0cml4IENyZWF0ZShpbnQgcm93cywgaW50IGNvbHVtbnMsIGRvdWJsZSB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSAwZCkgcmV0dXJuIG5ldyBTcGFyc2VNYXRyaXgocm93cywgY29sdW1ucyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZWYWx1ZShyb3dzLCBjb2x1bW5zLCB2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIG1hdHJpeCBhbmQgaW5pdGlhbGl6ZSBlYWNoIHZhbHVlIHVzaW5nIHRoZSBwcm92aWRlZCBpbml0IGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VNYXRyaXggQ3JlYXRlKGludCByb3dzLCBpbnQgY29sdW1ucywgRnVuYzxpbnQsIGludCwgZG91YmxlPiBpbml0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VNYXRyaXgoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8ZG91YmxlPi5PZkluaXQocm93cywgY29sdW1ucywgKEZ1bmM8aW50LGludCxkb3VibGU+KWluaXQpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIHNwYXJzZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCBkaWFnb25hbCB2YWx1ZSB0byB0aGUgc2FtZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlTWF0cml4IENyZWF0ZURpYWdvbmFsKGludCByb3dzLCBpbnQgY29sdW1ucywgZG91YmxlIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09IDBkKSByZXR1cm4gbmV3IFNwYXJzZU1hdHJpeChyb3dzLCBjb2x1bW5zKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VNYXRyaXgoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8ZG91YmxlPi5PZkRpYWdvbmFsSW5pdChyb3dzLCBjb2x1bW5zLCAoRnVuYzxpbnQsZG91YmxlPikoaSA9PiB2YWx1ZSkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgbmV3IGRpYWdvbmFsIHNwYXJzZSBtYXRyaXggYW5kIGluaXRpYWxpemUgZWFjaCBkaWFnb25hbCB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgaW5pdCBmdW5jdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlTWF0cml4IENyZWF0ZURpYWdvbmFsKGludCByb3dzLCBpbnQgY29sdW1ucywgRnVuYzxpbnQsIGRvdWJsZT4gaW5pdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BhcnNlTWF0cml4KFNwYXJzZUNvbXByZXNzZWRSb3dNYXRyaXhTdG9yYWdlPGRvdWJsZT4uT2ZEaWFnb25hbEluaXQocm93cywgY29sdW1ucywgKEZ1bmM8aW50LGRvdWJsZT4paW5pdCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3F1YXJlIHNwYXJzZSBpZGVudGl0eSBtYXRyaXggd2hlcmUgZWFjaCBkaWFnb25hbCB2YWx1ZSBpcyBzZXQgdG8gT25lLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VNYXRyaXggQ3JlYXRlSWRlbnRpdHkoaW50IG9yZGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VNYXRyaXgoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8ZG91YmxlPi5PZkRpYWdvbmFsSW5pdChvcmRlciwgb3JkZXIsIChGdW5jPGludCxkb3VibGU+KShpID0+IE9uZSkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIG5ldyBtYXRyaXggY29udGFpbmluZyB0aGUgbG93ZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGxvd2VyIHRyaWFuZ2xlIG9mIHRoaXMgbWF0cml4LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgTWF0cml4PGRvdWJsZT4gTG93ZXJUcmlhbmdsZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxkb3VibGU+KHRoaXMpO1xyXG4gICAgICAgICAgICBMb3dlclRyaWFuZ2xlSW1wbChyZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQdXRzIHRoZSBsb3dlciB0cmlhbmdsZSBvZiB0aGlzIG1hdHJpeCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+V2hlcmUgdG8gc3RvcmUgdGhlIGxvd2VyIHRyaWFuZ2xlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSByZXN1bHQgbWF0cml4J3MgZGltZW5zaW9ucyBhcmUgbm90IHRoZSBzYW1lIGFzIHRoaXMgbWF0cml4LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIExvd2VyVHJpYW5nbGUoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0LlJvd0NvdW50ICE9IFJvd0NvdW50IHx8IHJlc3VsdC5Db2x1bW5Db3VudCAhPSBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4odGhpcywgcmVzdWx0LCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCByZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gbV9idWlsZGVyLlNhbWVBczxkb3VibGU+KHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBMb3dlclRyaWFuZ2xlKHRtcCk7XHJcbiAgICAgICAgICAgICAgICB0bXAuQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIExvd2VyVHJpYW5nbGVJbXBsKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUHV0cyB0aGUgbG93ZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXggaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPldoZXJlIHRvIHN0b3JlIHRoZSBsb3dlciB0cmlhbmdsZS48L3BhcmFtPlxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBMb3dlclRyaWFuZ2xlSW1wbChNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcm93UG9pbnRlcnMgPSBfc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBfc3RvcmFnZS5Db2x1bW5JbmRpY2VzO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gX3N0b3JhZ2UuVmFsdWVzO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgcmVzdWx0LlJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gcm93UG9pbnRlcnNbcm93ICsgMV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gcm93UG9pbnRlcnNbcm93XTsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdyA+PSBjb2x1bW5JbmRpY2VzW2pdKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KHJvdywgY29sdW1uSW5kaWNlc1tqXSwgdmFsdWVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIG5ldyBtYXRyaXggY29udGFpbmluZyB0aGUgdXBwZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHVwcGVyIHRyaWFuZ2xlIG9mIHRoaXMgbWF0cml4LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgTWF0cml4PGRvdWJsZT4gVXBwZXJUcmlhbmdsZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxkb3VibGU+KHRoaXMpO1xyXG4gICAgICAgICAgICBVcHBlclRyaWFuZ2xlSW1wbChyZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQdXRzIHRoZSB1cHBlciB0cmlhbmdsZSBvZiB0aGlzIG1hdHJpeCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+V2hlcmUgdG8gc3RvcmUgdGhlIGxvd2VyIHRyaWFuZ2xlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIHRoZSByZXN1bHQgbWF0cml4J3MgZGltZW5zaW9ucyBhcmUgbm90IHRoZSBzYW1lIGFzIHRoaXMgbWF0cml4LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIFVwcGVyVHJpYW5nbGUoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicmVzdWx0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0LlJvd0NvdW50ICE9IFJvd0NvdW50IHx8IHJlc3VsdC5Db2x1bW5Db3VudCAhPSBDb2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4odGhpcywgcmVzdWx0LCBcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCByZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gbV9idWlsZGVyLlNhbWVBczxkb3VibGU+KHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBVcHBlclRyaWFuZ2xlKHRtcCk7XHJcbiAgICAgICAgICAgICAgICB0bXAuQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIFVwcGVyVHJpYW5nbGVJbXBsKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUHV0cyB0aGUgdXBwZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXggaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPldoZXJlIHRvIHN0b3JlIHRoZSBsb3dlciB0cmlhbmdsZS48L3BhcmFtPlxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBVcHBlclRyaWFuZ2xlSW1wbChNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcm93UG9pbnRlcnMgPSBfc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBfc3RvcmFnZS5Db2x1bW5JbmRpY2VzO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gX3N0b3JhZ2UuVmFsdWVzO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgcmVzdWx0LlJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gcm93UG9pbnRlcnNbcm93ICsgMV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gcm93UG9pbnRlcnNbcm93XTsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdyA8PSBjb2x1bW5JbmRpY2VzW2pdKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KHJvdywgY29sdW1uSW5kaWNlc1tqXSwgdmFsdWVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIG5ldyBtYXRyaXggY29udGFpbmluZyB0aGUgbG93ZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXguIFRoZSBuZXcgbWF0cml4XHJcbiAgICAgICAgLy8vIGRvZXMgbm90IGNvbnRhaW4gdGhlIGRpYWdvbmFsIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBsb3dlciB0cmlhbmdsZSBvZiB0aGlzIG1hdHJpeC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIE1hdHJpeDxkb3VibGU+IFN0cmljdGx5TG93ZXJUcmlhbmdsZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxkb3VibGU+KHRoaXMpO1xyXG4gICAgICAgICAgICBTdHJpY3RseUxvd2VyVHJpYW5nbGVJbXBsKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFB1dHMgdGhlIHN0cmljdGx5IGxvd2VyIHRyaWFuZ2xlIG9mIHRoaXMgbWF0cml4IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5XaGVyZSB0byBzdG9yZSB0aGUgbG93ZXIgdHJpYW5nbGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHJlc3VsdCBtYXRyaXgncyBkaW1lbnNpb25zIGFyZSBub3QgdGhlIHNhbWUgYXMgdGhpcyBtYXRyaXguPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgU3RyaWN0bHlMb3dlclRyaWFuZ2xlKE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHModGhpcywgcmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IG1fYnVpbGRlci5TYW1lQXM8ZG91YmxlPihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgU3RyaWN0bHlMb3dlclRyaWFuZ2xlKHRtcCk7XHJcbiAgICAgICAgICAgICAgICB0bXAuQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIFN0cmljdGx5TG93ZXJUcmlhbmdsZUltcGwocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQdXRzIHRoZSBzdHJpY3RseSBsb3dlciB0cmlhbmdsZSBvZiB0aGlzIG1hdHJpeCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+V2hlcmUgdG8gc3RvcmUgdGhlIGxvd2VyIHRyaWFuZ2xlLjwvcGFyYW0+XHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIFN0cmljdGx5TG93ZXJUcmlhbmdsZUltcGwoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJvd1BvaW50ZXJzID0gX3N0b3JhZ2UuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5JbmRpY2VzID0gX3N0b3JhZ2UuQ29sdW1uSW5kaWNlcztcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IF9zdG9yYWdlLlZhbHVlcztcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHJlc3VsdC5Sb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHJvd1BvaW50ZXJzW3JvdyArIDFdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHJvd1BvaW50ZXJzW3Jvd107IGogPCBlbmRJbmRleDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cgPiBjb2x1bW5JbmRpY2VzW2pdKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KHJvdywgY29sdW1uSW5kaWNlc1tqXSwgdmFsdWVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIG5ldyBtYXRyaXggY29udGFpbmluZyB0aGUgdXBwZXIgdHJpYW5nbGUgb2YgdGhpcyBtYXRyaXguIFRoZSBuZXcgbWF0cml4XHJcbiAgICAgICAgLy8vIGRvZXMgbm90IGNvbnRhaW4gdGhlIGRpYWdvbmFsIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSB1cHBlciB0cmlhbmdsZSBvZiB0aGlzIG1hdHJpeC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIE1hdHJpeDxkb3VibGU+IFN0cmljdGx5VXBwZXJUcmlhbmdsZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbV9idWlsZGVyLlNhbWVBczxkb3VibGU+KHRoaXMpO1xyXG4gICAgICAgICAgICBTdHJpY3RseVVwcGVyVHJpYW5nbGVJbXBsKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFB1dHMgdGhlIHN0cmljdGx5IHVwcGVyIHRyaWFuZ2xlIG9mIHRoaXMgbWF0cml4IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5XaGVyZSB0byBzdG9yZSB0aGUgbG93ZXIgdHJpYW5nbGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyZXN1bHRcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgdGhlIHJlc3VsdCBtYXRyaXgncyBkaW1lbnNpb25zIGFyZSBub3QgdGhlIHNhbWUgYXMgdGhpcyBtYXRyaXguPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgU3RyaWN0bHlVcHBlclRyaWFuZ2xlKE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5Sb3dDb3VudCAhPSBSb3dDb3VudCB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KHRoaXMsIHJlc3VsdCwgXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHModGhpcywgcmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IG1fYnVpbGRlci5TYW1lQXM8ZG91YmxlPihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgU3RyaWN0bHlVcHBlclRyaWFuZ2xlKHRtcCk7XHJcbiAgICAgICAgICAgICAgICB0bXAuQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIFN0cmljdGx5VXBwZXJUcmlhbmdsZUltcGwocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQdXRzIHRoZSBzdHJpY3RseSB1cHBlciB0cmlhbmdsZSBvZiB0aGlzIG1hdHJpeCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+V2hlcmUgdG8gc3RvcmUgdGhlIGxvd2VyIHRyaWFuZ2xlLjwvcGFyYW0+XHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIFN0cmljdGx5VXBwZXJUcmlhbmdsZUltcGwoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHJvd1BvaW50ZXJzID0gX3N0b3JhZ2UuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5JbmRpY2VzID0gX3N0b3JhZ2UuQ29sdW1uSW5kaWNlcztcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IF9zdG9yYWdlLlZhbHVlcztcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHJlc3VsdC5Sb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHJvd1BvaW50ZXJzW3JvdyArIDFdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHJvd1BvaW50ZXJzW3Jvd107IGogPCBlbmRJbmRleDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cgPCBjb2x1bW5JbmRpY2VzW2pdKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KHJvdywgY29sdW1uSW5kaWNlc1tqXSwgdmFsdWVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTmVnYXRlIGVhY2ggZWxlbWVudCBvZiB0aGlzIG1hdHJpeCBhbmQgcGxhY2UgdGhlIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG5lZ2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9OZWdhdGUoTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIERvTXVsdGlwbHkoLTEsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+Q2FsY3VsYXRlcyB0aGUgaW5kdWNlZCBpbmZpbml0eSBub3JtIG9mIHRoaXMgbWF0cml4Ljwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIG1heGltdW0gYWJzb2x1dGUgcm93IHN1bSBvZiB0aGUgbWF0cml4LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZG91YmxlIEluZmluaXR5Tm9ybSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcm93UG9pbnRlcnMgPSBfc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IF9zdG9yYWdlLlZhbHVlcztcclxuICAgICAgICAgICAgdmFyIG5vcm0gPSAwZDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IHJvd1BvaW50ZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gcm93UG9pbnRlcnNbaSArIDFdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09IGVuZEluZGV4KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlZ2luIGFuZCBlbmQgYXJlIGVxdWFsLiBUaGVyZSBhcmUgbm8gdmFsdWVzIGluIHRoZSByb3csIE1vdmUgdG8gdGhlIG5leHQgcm93XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSAwZDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydEluZGV4OyBqIDwgZW5kSW5kZXg7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzICs9IE1hdGguQWJzKHZhbHVlc1tqXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub3JtID0gTWF0aC5NYXgobm9ybSwgcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vcm07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+Q2FsY3VsYXRlcyB0aGUgZW50cnktd2lzZSBGcm9iZW5pdXMgbm9ybSBvZiB0aGlzIG1hdHJpeC48L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVkIHZhbHVlcy48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGRvdWJsZSBGcm9iZW5pdXNOb3JtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBhYXQgPSAoU3BhcnNlQ29tcHJlc3NlZFJvd01hdHJpeFN0b3JhZ2U8ZG91YmxlPikgKHRoaXMqVHJhbnNwb3NlKCkpLlN0b3JhZ2U7XHJcbiAgICAgICAgICAgIHZhciBub3JtID0gMGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWF0LlJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gYWF0LlJvd1BvaW50ZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gYWF0LlJvd1BvaW50ZXJzW2kgKyAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSBlbmRJbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCZWdpbiBhbmQgZW5kIGFyZSBlcXVhbC4gVGhlcmUgYXJlIG5vIHZhbHVlcyBpbiB0aGUgcm93LCBNb3ZlIHRvIHRoZSBuZXh0IHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydEluZGV4OyBqIDwgZW5kSW5kZXg7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBhYXQuQ29sdW1uSW5kaWNlc1tqXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm0gKz0gTWF0aC5BYnMoYWF0LlZhbHVlc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLlNxcnQobm9ybSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgYW5vdGhlciBtYXRyaXggdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBtYXRyaXggdG8gYWRkIHRvIHRoaXMgbWF0cml4LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiB0aGUgb3RoZXIgbWF0cml4IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgdGhlIHR3byBtYXRyaWNlcyBkb24ndCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9BZGQoTWF0cml4PGRvdWJsZT4gb3RoZXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VPdGhlciA9IG90aGVyIGFzIFNwYXJzZU1hdHJpeDtcclxuICAgICAgICAgICAgdmFyIHNwYXJzZVJlc3VsdCA9IHJlc3VsdCBhcyBTcGFyc2VNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VPdGhlciA9PSBudWxsIHx8IHNwYXJzZVJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvQWRkKG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoUmVmZXJlbmNlRXF1YWxzKHRoaXMsIG90aGVyKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFSZWZlcmVuY2VFcXVhbHModGhpcywgcmVzdWx0KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBDb3B5VG8ocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBNYXAyKChGdW5jPGRvdWJsZSxkb3VibGUsZG91YmxlPikoKHgsIHkpID0+IHggKyB5KSwgb3RoZXIsIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgU3BhcnNlTWF0cml4IGxlZnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoUmVmZXJlbmNlRXF1YWxzKHNwYXJzZU90aGVyLCBzcGFyc2VSZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChSZWZlcmVuY2VFcXVhbHModGhpcywgc3BhcnNlUmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IHNwYXJzZU90aGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29weVRvKHNwYXJzZVJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gc3BhcnNlT3RoZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBsZWZ0U3RvcmFnZSA9IGxlZnQuX3N0b3JhZ2U7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdFN0b3JhZ2UuUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gbGVmdFN0b3JhZ2UuUm93UG9pbnRlcnNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGxlZnRTdG9yYWdlLlJvd1BvaW50ZXJzW2ldOyBqIDwgZW5kSW5kZXg7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uSW5kZXggPSBsZWZ0U3RvcmFnZS5Db2x1bW5JbmRpY2VzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNWYWwgPSBsZWZ0U3RvcmFnZS5WYWx1ZXNbal0gKyByZXN1bHQuQXQoaSwgY29sdW1uSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpLCBjb2x1bW5JbmRleCwgcmVzVmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgYW5vdGhlciBtYXRyaXggZnJvbSB0aGlzIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB0byBzdWJ0cmFjdCB0byB0aGlzIG1hdHJpeC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiB0aGUgb3RoZXIgbWF0cml4IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgdGhlIHR3byBtYXRyaWNlcyBkb24ndCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9TdWJ0cmFjdChNYXRyaXg8ZG91YmxlPiBvdGhlciwgTWF0cml4PGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHNwYXJzZU90aGVyID0gb3RoZXIgYXMgU3BhcnNlTWF0cml4O1xyXG4gICAgICAgICAgICB2YXIgc3BhcnNlUmVzdWx0ID0gcmVzdWx0IGFzIFNwYXJzZU1hdHJpeDtcclxuXHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VPdGhlciA9PSBudWxsIHx8IHNwYXJzZVJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvU3VidHJhY3Qob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHModGhpcywgb3RoZXIpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG90aGVyU3RvcmFnZSA9IHNwYXJzZU90aGVyLl9zdG9yYWdlO1xyXG5cclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCBzcGFyc2VSZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyU3RvcmFnZS5Sb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IG90aGVyU3RvcmFnZS5Sb3dQb2ludGVyc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IG90aGVyU3RvcmFnZS5Sb3dQb2ludGVyc1tpXTsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uSW5kZXggPSBvdGhlclN0b3JhZ2UuQ29sdW1uSW5kaWNlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc1ZhbCA9IHNwYXJzZVJlc3VsdC5BdChpLCBjb2x1bW5JbmRleCkgLSBvdGhlclN0b3JhZ2UuVmFsdWVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQoaSwgY29sdW1uSW5kZXgsIHJlc1ZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFSZWZlcmVuY2VFcXVhbHMoc3BhcnNlT3RoZXIsIHNwYXJzZVJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhcnNlT3RoZXIuQ29weVRvKHNwYXJzZVJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3BhcnNlUmVzdWx0Lk5lZ2F0ZShzcGFyc2VSZXN1bHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciByb3dQb2ludGVycyA9IF9zdG9yYWdlLlJvd1BvaW50ZXJzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBfc3RvcmFnZS5Db2x1bW5JbmRpY2VzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IF9zdG9yYWdlLlZhbHVlcztcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gcm93UG9pbnRlcnNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSByb3dQb2ludGVyc1tpXTsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uSW5kZXggPSBjb2x1bW5JbmRpY2VzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzVmFsID0gc3BhcnNlUmVzdWx0LkF0KGksIGNvbHVtbkluZGV4KSArIHZhbHVlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KGksIGNvbHVtbkluZGV4LCByZXNWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyIGFuZCBwbGFjZXMgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2NhbGFyXCI+VGhlIHNjYWxhciB0byBtdWx0aXBseSB0aGUgbWF0cml4IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9NdWx0aXBseShkb3VibGUgc2NhbGFyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoc2NhbGFyID09IDEuMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzY2FsYXIgPT0gMC4wIHx8IE5vblplcm9zQ291bnQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VSZXN1bHQgPSByZXN1bHQgYXMgU3BhcnNlTWF0cml4O1xyXG4gICAgICAgICAgICBpZiAoc3BhcnNlUmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5DbGVhcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciByb3dQb2ludGVycyA9IF9zdG9yYWdlLlJvd1BvaW50ZXJzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBfc3RvcmFnZS5Db2x1bW5JbmRpY2VzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IF9zdG9yYWdlLlZhbHVlcztcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBSb3dDb3VudDsgcm93KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gcm93UG9pbnRlcnNbcm93ICsgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBlbmQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gc3RhcnQ7IGluZGV4IDwgZW5kOyBpbmRleCsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbkluZGljZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQocm93LCBjb2x1bW4sIHZhbHVlc1tpbmRleF0gKiBzY2FsYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghUmVmZXJlbmNlRXF1YWxzKHRoaXMsIHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29weVRvKHNwYXJzZVJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KSh4ID0+IHggKiBzY2FsYXIpLCByZXN1bHQsIFplcm9zLkFsbG93U2tpcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyB0aGlzIG1hdHJpeCB3aXRoIGFub3RoZXIgbWF0cml4IGFuZCBwbGFjZXMgdGhlIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG1hdHJpeCB0byBtdWx0aXBseSB3aXRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb011bHRpcGx5KE1hdHJpeDxkb3VibGU+IG90aGVyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3BhcnNlT3RoZXIgPSBvdGhlciBhcyBTcGFyc2VNYXRyaXg7XHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VSZXN1bHQgPSByZXN1bHQgYXMgU3BhcnNlTWF0cml4O1xyXG4gICAgICAgICAgICBpZiAoc3BhcnNlT3RoZXIgIT0gbnVsbCAmJiBzcGFyc2VSZXN1bHQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRG9NdWx0aXBseVNwYXJzZShzcGFyc2VPdGhlciwgc3BhcnNlUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRpYWdvbmFsT3RoZXIgPSBvdGhlci5TdG9yYWdlIGFzIERpYWdvbmFsTWF0cml4U3RvcmFnZTxkb3VibGU+O1xyXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWxPdGhlciAhPSBudWxsICYmIHNwYXJzZVJlc3VsdCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlhZ29uYWwgPSBkaWFnb25hbE90aGVyLkRhdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAob3RoZXIuQ29sdW1uQ291bnQgPT0gb3RoZXIuUm93Q291bnQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgU3RvcmFnZS5NYXBJbmRleGVkVG88ZG91YmxlPihyZXN1bHQuU3RvcmFnZSwgKEZ1bmM8aW50LGludCxkb3VibGUsZG91YmxlPikoKGksIGosIHgpID0+IHgqZGlhZ29uYWxbal0pLCBaZXJvcy5BbGxvd1NraXAsIEV4aXN0aW5nRGF0YS5DbGVhcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LlN0b3JhZ2UuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBTdG9yYWdlLk1hcFN1Yk1hdHJpeEluZGV4ZWRUbzxkb3VibGU+KHJlc3VsdC5TdG9yYWdlLCAoRnVuYzxpbnQsaW50LGRvdWJsZSxkb3VibGU+KSgoaSwgaiwgeCkgPT4geCpkaWFnb25hbFtqXSksIDAsIDAsIFJvd0NvdW50LCAwLCAwLCBDb2x1bW5Db3VudCwgWmVyb3MuQWxsb3dTa2lwLCBFeGlzdGluZ0RhdGEuQXNzdW1lWmVyb3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXN1bHQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgdmFyIHJvd1BvaW50ZXJzID0gX3N0b3JhZ2UuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5JbmRpY2VzID0gX3N0b3JhZ2UuQ29sdW1uSW5kaWNlcztcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IF9zdG9yYWdlLlZhbHVlcztcclxuXHJcbiAgICAgICAgICAgIHZhciBkZW5zZU90aGVyID0gb3RoZXIuU3RvcmFnZSBhcyBEZW5zZUNvbHVtbk1ham9yTWF0cml4U3RvcmFnZTxkb3VibGU+O1xyXG4gICAgICAgICAgICBpZiAoZGVuc2VPdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2UgY2FuIGRpcmVjdGx5IGFkZHJlc3MgdGhlIHVuZGVybHlpbmcgZGF0YS1hcnJheVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gcm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSByb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT0gZW5kSW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8IG90aGVyLkNvbHVtbkNvdW50OyBjb2x1bW4rKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludCBvdGhlckNvbHVtblN0YXJ0UG9zaXRpb24gPSBjb2x1bW4gKiBvdGhlci5Sb3dDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IDBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDwgZW5kSW5kZXg7IGluZGV4KyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSB2YWx1ZXNbaW5kZXhdICogZGVuc2VPdGhlci5EYXRhW290aGVyQ29sdW1uU3RhcnRQb3NpdGlvbiArIGNvbHVtbkluZGljZXNbaW5kZXhdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KHJvdywgY29sdW1uLCBzdW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbHVtblZlY3RvciA9IG5ldyBEZW5zZVZlY3RvcihvdGhlci5Sb3dDb3VudCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSByb3dQb2ludGVyc1tyb3ddO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gcm93UG9pbnRlcnNbcm93ICsgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT0gZW5kSW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDwgb3RoZXIuQ29sdW1uQ291bnQ7IGNvbHVtbisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE11bHRpcGx5IHJvdyBvZiBtYXRyaXggQSBvbiBjb2x1bW4gb2YgbWF0cml4IEJcclxuICAgICAgICAgICAgICAgICAgICBvdGhlci5Db2x1bW4oY29sdW1uLCBjb2x1bW5WZWN0b3IpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gMGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSBzdGFydEluZGV4OyBpbmRleCA8IGVuZEluZGV4OyBpbmRleCsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IHZhbHVlc1tpbmRleF0gKiBjb2x1bW5WZWN0b3JbY29sdW1uSW5kaWNlc1tpbmRleF1dO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KHJvdywgY29sdW1uLCBzdW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2b2lkIERvTXVsdGlwbHlTcGFyc2UoU3BhcnNlTWF0cml4IG90aGVyLCBTcGFyc2VNYXRyaXggcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVzdWx0LkNsZWFyKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYXggPSBfc3RvcmFnZS5WYWx1ZXM7XHJcbiAgICAgICAgICAgIHZhciBhcCA9IF9zdG9yYWdlLlJvd1BvaW50ZXJzO1xyXG4gICAgICAgICAgICB2YXIgYWkgPSBfc3RvcmFnZS5Db2x1bW5JbmRpY2VzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJ4ID0gb3RoZXIuX3N0b3JhZ2UuVmFsdWVzO1xyXG4gICAgICAgICAgICB2YXIgYnAgPSBvdGhlci5fc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgdmFyIGJpID0gb3RoZXIuX3N0b3JhZ2UuQ29sdW1uSW5kaWNlcztcclxuXHJcbiAgICAgICAgICAgIGludCByb3dzID0gUm93Q291bnQ7XHJcbiAgICAgICAgICAgIGludCBjb2xzID0gb3RoZXIuQ29sdW1uQ291bnQ7XHJcblxyXG4gICAgICAgICAgICBpbnRbXSBjcCA9IHJlc3VsdC5fc3RvcmFnZS5Sb3dQb2ludGVycztcclxuXHJcbiAgICAgICAgICAgIHZhciBtYXJrZXIgPSBuZXcgaW50W2NvbHNdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpYiA9IDA7IGliIDwgY29sczsgaWIrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbWFya2VyW2liXSA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpbnQgY291bnQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHJvd3M7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggcm93IG9mIEFcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSBhcFtpXTsgaiA8IGFwW2kgKyAxXTsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJvdyBudW1iZXIgdG8gYmUgYWRkZWRcclxuICAgICAgICAgICAgICAgICAgICBpbnQgYSA9IGFpW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGsgPSBicFthXTsgayA8IGJwW2EgKyAxXTsgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50IGIgPSBiaVtrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlcltiXSAhPSBpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJbYl0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWNvcmQgbm9uLXplcm8gY291bnQuXHJcbiAgICAgICAgICAgICAgICBjcFtpICsgMV0gPSBjb3VudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNpID0gbmV3IGludFtjb3VudF07XHJcbiAgICAgICAgICAgIHZhciBjeCA9IG5ldyBkb3VibGVbY291bnRdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaWIgPSAwOyBpYiA8IGNvbHM7IGliKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1hcmtlcltpYl0gPSAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY291bnQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHJvd3M7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IHJvd1N0YXJ0ID0gY3BbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gYXBbaV07IGogPCBhcFtpICsgMV07IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgYSA9IGFpW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZSBhRW50cnkgPSBheFtqXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBrID0gYnBbYV07IGsgPCBicFthICsgMV07IGsrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludCBiID0gYmlba107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZSBiRW50cnkgPSBieFtrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlcltiXSA8IHJvd1N0YXJ0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJbYl0gPSBjb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpW21hcmtlcltiXV0gPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3hbbWFya2VyW2JdXSA9IGFFbnRyeSAqIGJFbnRyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeFttYXJrZXJbYl1dICs9IGFFbnRyeSAqIGJFbnRyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0Ll9zdG9yYWdlLlZhbHVlcyA9IGN4O1xyXG4gICAgICAgICAgICByZXN1bHQuX3N0b3JhZ2UuQ29sdW1uSW5kaWNlcyA9IGNpO1xyXG4gICAgICAgICAgICByZXN1bHQuX3N0b3JhZ2UuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhpcyBtYXRyaXggd2l0aCBhIHZlY3RvciBhbmQgcGxhY2VzIHRoZSByZXN1bHRzIGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgdmVjdG9yIHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvTXVsdGlwbHkoVmVjdG9yPGRvdWJsZT4gcmlnaHRTaWRlLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcm93UG9pbnRlcnMgPSBfc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBfc3RvcmFnZS5Db2x1bW5JbmRpY2VzO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gX3N0b3JhZ2UuVmFsdWVzO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IHJvd1BvaW50ZXJzW3Jvd107XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSByb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSBlbmRJbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gMGQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDwgZW5kSW5kZXg7IGluZGV4KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IHZhbHVlc1tpbmRleF0gKiByaWdodFNpZGVbY29sdW1uSW5kaWNlc1tpbmRleF1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlc3VsdFtyb3ddID0gc3VtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhpcyBtYXRyaXggd2l0aCB0cmFuc3Bvc2Ugb2YgYW5vdGhlciBtYXRyaXggYW5kIHBsYWNlcyB0aGUgcmVzdWx0cyBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIG11bHRpcGx5IHdpdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvVHJhbnNwb3NlQW5kTXVsdGlwbHkoTWF0cml4PGRvdWJsZT4gb3RoZXIsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBvdGhlclNwYXJzZSA9IG90aGVyIGFzIFNwYXJzZU1hdHJpeDtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdFNwYXJzZSA9IHJlc3VsdCBhcyBTcGFyc2VNYXRyaXg7XHJcblxyXG4gICAgICAgICAgICBpZiAob3RoZXJTcGFyc2UgPT0gbnVsbCB8fCByZXN1bHRTcGFyc2UgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmFzZS5Eb1RyYW5zcG9zZUFuZE11bHRpcGx5KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXN1bHRTcGFyc2UuQ2xlYXIoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByb3dQb2ludGVycyA9IF9zdG9yYWdlLlJvd1BvaW50ZXJzO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gX3N0b3JhZ2UuVmFsdWVzO1xyXG5cclxuICAgICAgICAgICAgdmFyIG90aGVyU3RvcmFnZSA9IG90aGVyU3BhcnNlLl9zdG9yYWdlO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBSb3dDb3VudDsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleE90aGVyID0gb3RoZXJTdG9yYWdlLlJvd1BvaW50ZXJzW2pdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4T3RoZXIgPSBvdGhlclN0b3JhZ2UuUm93UG9pbnRlcnNbaiArIDFdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4T3RoZXIgPT0gZW5kSW5kZXhPdGhlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXhUaGlzID0gcm93UG9pbnRlcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4VGhpcyA9IHJvd1BvaW50ZXJzW2kgKyAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXhUaGlzID09IGVuZEluZGV4VGhpcylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IDBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gc3RhcnRJbmRleE90aGVyOyBpbmRleCA8IGVuZEluZGV4T3RoZXI7IGluZGV4KyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kID0gX3N0b3JhZ2UuRmluZEl0ZW0oaSwgb3RoZXJTdG9yYWdlLkNvbHVtbkluZGljZXNbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZCA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gb3RoZXJTdG9yYWdlLlZhbHVlc1tpbmRleF0qdmFsdWVzW2luZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFNwYXJzZS5fc3RvcmFnZS5BdChpLCBqLCBzdW0gKyByZXN1bHQuQXQoaSwgaikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgdGhlIHRyYW5zcG9zZSBvZiB0aGlzIG1hdHJpeCB3aXRoIGEgdmVjdG9yIGFuZCBwbGFjZXMgdGhlIHJlc3VsdHMgaW50byB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSB2ZWN0b3IgdG8gbXVsdGlwbHkgd2l0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9UcmFuc3Bvc2VUaGlzQW5kTXVsdGlwbHkoVmVjdG9yPGRvdWJsZT4gcmlnaHRTaWRlLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcm93UG9pbnRlcnMgPSBfc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBfc3RvcmFnZS5Db2x1bW5JbmRpY2VzO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gX3N0b3JhZ2UuVmFsdWVzO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgUm93Q291bnQ7IHJvdysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IHJvd1BvaW50ZXJzW3Jvd107XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSByb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSBlbmRJbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRTaWRlVmFsdWUgPSByaWdodFNpZGVbcm93XTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gc3RhcnRJbmRleDsgaW5kZXggPCBlbmRJbmRleDsgaW5kZXgrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbY29sdW1uSW5kaWNlc1tpbmRleF1dICs9IHZhbHVlc1tpbmRleF0gKiByaWdodFNpZGVWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHdpc2UgbXVsdGlwbGllcyB0aGlzIG1hdHJpeCB3aXRoIGFub3RoZXIgbWF0cml4IGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgbWF0cml4IHRvIHBvaW50d2lzZSBtdWx0aXBseSB3aXRoIHRoaXMgb25lLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludHdpc2UgbXVsdGlwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZU11bHRpcGx5KE1hdHJpeDxkb3VibGU+IG90aGVyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXN1bHQuQ2xlYXIoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByb3dQb2ludGVycyA9IF9zdG9yYWdlLlJvd1BvaW50ZXJzO1xyXG4gICAgICAgICAgICB2YXIgY29sdW1uSW5kaWNlcyA9IF9zdG9yYWdlLkNvbHVtbkluZGljZXM7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBfc3RvcmFnZS5WYWx1ZXM7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHJvd1BvaW50ZXJzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSByb3dQb2ludGVyc1tpXTsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc1ZhbCA9IHZhbHVlc1tqXSpvdGhlci5BdChpLCBjb2x1bW5JbmRpY2VzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzVmFsICE9IDBkKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KGksIGNvbHVtbkluZGljZXNbal0sIHJlc1ZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBkaXZpZGUgdGhpcyBtYXRyaXggYnkgYW5vdGhlciBtYXRyaXggYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXZpc29yXCI+VGhlIG1hdHJpeCB0byBwb2ludHdpc2UgZGl2aWRlIHRoaXMgb25lIGJ5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBwb2ludHdpc2UgZGl2aXNpb24uPC9wYXJhbT5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdm9pZCBEb1BvaW50d2lzZURpdmlkZShNYXRyaXg8ZG91YmxlPiBkaXZpc29yLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXN1bHQuQ2xlYXIoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByb3dQb2ludGVycyA9IF9zdG9yYWdlLlJvd1BvaW50ZXJzO1xyXG4gICAgICAgICAgICB2YXIgY29sdW1uSW5kaWNlcyA9IF9zdG9yYWdlLkNvbHVtbkluZGljZXM7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBfc3RvcmFnZS5WYWx1ZXM7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHJvd1BvaW50ZXJzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSByb3dQb2ludGVyc1tpXTsgaiA8IGVuZEluZGV4OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXSAhPSAwZClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpLCBjb2x1bW5JbmRpY2VzW2pdLCB2YWx1ZXNbal0vZGl2aXNvci5BdChpLCBjb2x1bW5JbmRpY2VzW2pdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBLcm9uZWNrZXJQcm9kdWN0KE1hdHJpeDxkb3VibGU+IG90aGVyLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAob3RoZXIgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcIm90aGVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuUm93Q291bnQgIT0gKFJvd0NvdW50Km90aGVyLlJvd0NvdW50KSB8fCByZXN1bHQuQ29sdW1uQ291bnQgIT0gKENvbHVtbkNvdW50Km90aGVyLkNvbHVtbkNvdW50KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24+KHRoaXMsIG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcm93UG9pbnRlcnMgPSBfc3RvcmFnZS5Sb3dQb2ludGVycztcclxuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGljZXMgPSBfc3RvcmFnZS5Db2x1bW5JbmRpY2VzO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gX3N0b3JhZ2UuVmFsdWVzO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBSb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSByb3dQb2ludGVyc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gcm93UG9pbnRlcnNbaV07IGogPCBlbmRJbmRleDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbal0gIT0gMGQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuU2V0U3ViTWF0cml4KGkqb3RoZXIuUm93Q291bnQsIG90aGVyLlJvd0NvdW50LCBjb2x1bW5JbmRpY2VzW2pdKm90aGVyLkNvbHVtbkNvdW50LCBvdGhlci5Db2x1bW5Db3VudCwgdmFsdWVzW2pdKm90aGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGNhbm9uaWNhbCBtb2R1bHVzLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aXNvcixcclxuICAgICAgICAvLy8gZm9yIHRoZSBnaXZlbiBkaXZpc29yIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBzY2FsYXIgZGVub21pbmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+TWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Nb2R1bHVzKGRvdWJsZSBkaXZpc29yLCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgc3BhcnNlUmVzdWx0ID0gcmVzdWx0IGFzIFNwYXJzZU1hdHJpeDtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvTW9kdWx1cyhkaXZpc29yLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIVJlZmVyZW5jZUVxdWFscyh0aGlzLCByZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb3B5VG8ocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdFN0b3JhZ2UgPSBzcGFyc2VSZXN1bHQuX3N0b3JhZ2U7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCByZXN1bHRTdG9yYWdlLlZhbHVlcy5MZW5ndGg7IGluZGV4KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFN0b3JhZ2UuVmFsdWVzW2luZGV4XSA9IEV1Y2xpZC5Nb2R1bHVzKHJlc3VsdFN0b3JhZ2UuVmFsdWVzW2luZGV4XSwgZGl2aXNvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gZm9yIHRoZSBnaXZlbiBkaXZpc29yIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGl2aXNvclwiPlRoZSBzY2FsYXIgZGVub21pbmF0b3IgdG8gdXNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+TWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9SZW1haW5kZXIoZG91YmxlIGRpdmlzb3IsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBzcGFyc2VSZXN1bHQgPSByZXN1bHQgYXMgU3BhcnNlTWF0cml4O1xyXG4gICAgICAgICAgICBpZiAoc3BhcnNlUmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9SZW1haW5kZXIoZGl2aXNvciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFSZWZlcmVuY2VFcXVhbHModGhpcywgcmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHRTdG9yYWdlID0gc3BhcnNlUmVzdWx0Ll9zdG9yYWdlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgcmVzdWx0U3RvcmFnZS5WYWx1ZXMuTGVuZ3RoOyBpbmRleCsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRTdG9yYWdlLlZhbHVlc1tpbmRleF0gJT0gZGl2aXNvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBFdmFsdWF0ZXMgd2hldGhlciB0aGlzIG1hdHJpeCBpcyBzeW1tZXRyaWMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBJc1N5bW1ldHJpYygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoUm93Q291bnQgIT0gQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJvd1BvaW50ZXJzID0gX3N0b3JhZ2UuUm93UG9pbnRlcnM7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5JbmRpY2VzID0gX3N0b3JhZ2UuQ29sdW1uSW5kaWNlcztcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IF9zdG9yYWdlLlZhbHVlcztcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IFJvd0NvdW50OyByb3crKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcm93UG9pbnRlcnNbcm93XTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSByb3dQb2ludGVyc1tyb3cgKyAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gc3RhcnQ7IGluZGV4IDwgZW5kOyBpbmRleCsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5JbmRpY2VzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlc1tpbmRleF0uRXF1YWxzKEF0KGNvbHVtbiwgcm93KSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkcyB0d28gbWF0cmljZXMgdG9nZXRoZXIgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+VGhpcyBvcGVyYXRvciB3aWxsIGFsbG9jYXRlIG5ldyBtZW1vcnkgZm9yIHRoZSByZXN1bHQuIEl0IHdpbGxcclxuICAgICAgICAvLy8gY2hvb3NlIHRoZSByZXByZXNlbnRhdGlvbiBvZiBlaXRoZXIgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gb3IgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGRlcGVuZGluZyBvbiB3aGljaFxyXG4gICAgICAgIC8vLyBpcyBkZW5zZXIuPC9yZW1hcmtzPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIGxlZnQgbWF0cml4IHRvIGFkZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSByaWdodCBtYXRyaXggdG8gYWRkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gYW5kIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBkb24ndCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlTWF0cml4IG9wZXJhdG9yICsoU3BhcnNlTWF0cml4IGxlZnRTaWRlLCBTcGFyc2VNYXRyaXggcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJpZ2h0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicmlnaHRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobGVmdFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImxlZnRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobGVmdFNpZGUuUm93Q291bnQgIT0gcmlnaHRTaWRlLlJvd0NvdW50IHx8IGxlZnRTaWRlLkNvbHVtbkNvdW50ICE9IHJpZ2h0U2lkZS5Db2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24+KGxlZnRTaWRlLCByaWdodFNpZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKFNwYXJzZU1hdHJpeClsZWZ0U2lkZS5BZGQocmlnaHRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIDxzdHJvbmc+TWF0cml4PC9zdHJvbmc+IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIG9mIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSBtYXRyaXggdG8gZ2V0IHRoZSB2YWx1ZXMgZnJvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIG1hdHJpeCBjb250YWluaW5nIGEgdGhlIHNhbWUgdmFsdWVzIGFzIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlTWF0cml4IG9wZXJhdG9yICsoU3BhcnNlTWF0cml4IHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJpZ2h0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChTcGFyc2VNYXRyaXgpcmlnaHRTaWRlLkNsb25lKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN1YnRyYWN0cyB0d28gbWF0cmljZXMgdG9nZXRoZXIgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+VGhpcyBvcGVyYXRvciB3aWxsIGFsbG9jYXRlIG5ldyBtZW1vcnkgZm9yIHRoZSByZXN1bHQuIEl0IHdpbGxcclxuICAgICAgICAvLy8gY2hvb3NlIHRoZSByZXByZXNlbnRhdGlvbiBvZiBlaXRoZXIgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gb3IgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGRlcGVuZGluZyBvbiB3aGljaFxyXG4gICAgICAgIC8vLyBpcyBkZW5zZXIuPC9yZW1hcmtzPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIGxlZnQgbWF0cml4IHRvIHN1YnRyYWN0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHJpZ2h0IG1hdHJpeCB0byBzdWJ0cmFjdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IGFuZCA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gZG9uJ3QgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZU1hdHJpeCBvcGVyYXRvciAtKFNwYXJzZU1hdHJpeCBsZWZ0U2lkZSwgU3BhcnNlTWF0cml4IHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJpZ2h0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxlZnRTaWRlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJsZWZ0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxlZnRTaWRlLlJvd0NvdW50ICE9IHJpZ2h0U2lkZS5Sb3dDb3VudCB8fCBsZWZ0U2lkZS5Db2x1bW5Db3VudCAhPSByaWdodFNpZGUuQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IERpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KGxlZnRTaWRlLCByaWdodFNpZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKFNwYXJzZU1hdHJpeClsZWZ0U2lkZS5TdWJ0cmFjdChyaWdodFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOZWdhdGVzIGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIG1hdHJpeCB0byBuZWdhdGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBtYXRyaXggY29udGFpbmluZyB0aGUgbmVnYXRlZCB2YWx1ZXMuPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZU1hdHJpeCBvcGVyYXRvciAtKFNwYXJzZU1hdHJpeCByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocmlnaHRTaWRlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJyaWdodFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoU3BhcnNlTWF0cml4KXJpZ2h0U2lkZS5OZWdhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyBhIDxzdHJvbmc+TWF0cml4PC9zdHJvbmc+IGJ5IGEgY29uc3RhbnQgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIG1hdHJpeCB0byBtdWx0aXBseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJpZ2h0U2lkZVwiPlRoZSBjb25zdGFudCB0byBtdWx0aXBseSB0aGUgbWF0cml4IGJ5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZU1hdHJpeCBvcGVyYXRvciAqKFNwYXJzZU1hdHJpeCBsZWZ0U2lkZSwgZG91YmxlIHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwibGVmdFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoU3BhcnNlTWF0cml4KWxlZnRTaWRlLk11bHRpcGx5KHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgYSA8c3Ryb25nPk1hdHJpeDwvc3Ryb25nPiBieSBhIGNvbnN0YW50IGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgY29uc3RhbnQgdG8gbXVsdGlwbHkgdGhlIG1hdHJpeCBieS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlTWF0cml4IG9wZXJhdG9yICooZG91YmxlIGxlZnRTaWRlLCBTcGFyc2VNYXRyaXggcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJpZ2h0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicmlnaHRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKFNwYXJzZU1hdHJpeClyaWdodFNpZGUuTXVsdGlwbHkobGVmdFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIHR3byBtYXRyaWNlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5UaGlzIG9wZXJhdG9yIHdpbGwgYWxsb2NhdGUgbmV3IG1lbW9yeSBmb3IgdGhlIHJlc3VsdC4gSXQgd2lsbFxyXG4gICAgICAgIC8vLyBjaG9vc2UgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGVpdGhlciA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gZGVwZW5kaW5nIG9uIHdoaWNoXHJcbiAgICAgICAgLy8vIGlzIGRlbnNlci48L3JlbWFya3M+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgbGVmdCBtYXRyaXggdG8gbXVsdGlwbHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgcmlnaHQgbWF0cml4IHRvIG11bHRpcGx5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiB0aGUgZGltZW5zaW9ucyBvZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gZG9uJ3QgY29uZm9ybS48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZU1hdHJpeCBvcGVyYXRvciAqKFNwYXJzZU1hdHJpeCBsZWZ0U2lkZSwgU3BhcnNlTWF0cml4IHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwibGVmdFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyaWdodFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJpZ2h0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxlZnRTaWRlLkNvbHVtbkNvdW50ICE9IHJpZ2h0U2lkZS5Sb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4obGVmdFNpZGUsIHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoU3BhcnNlTWF0cml4KWxlZnRTaWRlLk11bHRpcGx5KHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgYSA8c3Ryb25nPk1hdHJpeDwvc3Ryb25nPiBhbmQgYSBWZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgdmVjdG9yIHRvIG11bHRpcGx5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZVZlY3RvciBvcGVyYXRvciAqKFNwYXJzZU1hdHJpeCBsZWZ0U2lkZSwgU3BhcnNlVmVjdG9yIHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwibGVmdFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoU3BhcnNlVmVjdG9yKWxlZnRTaWRlLk11bHRpcGx5KHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgYSBWZWN0b3IgYW5kIGEgPHN0cm9uZz5NYXRyaXg8L3N0cm9uZz4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSB2ZWN0b3IgdG8gbXVsdGlwbHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgbWF0cml4IHRvIG11bHRpcGx5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZVZlY3RvciBvcGVyYXRvciAqKFNwYXJzZVZlY3RvciBsZWZ0U2lkZSwgU3BhcnNlTWF0cml4IHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJpZ2h0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChTcGFyc2VWZWN0b3IpcmlnaHRTaWRlLkxlZnRNdWx0aXBseShsZWZ0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE11bHRpcGxpZXMgYSA8c3Ryb25nPk1hdHJpeDwvc3Ryb25nPiBieSBhIGNvbnN0YW50IGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSBtYXRyaXggdG8gbXVsdGlwbHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgY29uc3RhbnQgdG8gbXVsdGlwbHkgdGhlIG1hdHJpeCBieS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VNYXRyaXggb3BlcmF0b3IgJShTcGFyc2VNYXRyaXggbGVmdFNpZGUsIGRvdWJsZSByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobGVmdFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImxlZnRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKFNwYXJzZU1hdHJpeClsZWZ0U2lkZS5SZW1haW5kZXIocmlnaHRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBzdHJpbmcgVG9UeXBlU3RyaW5nKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcuRm9ybWF0KFwiU3BhcnNlTWF0cml4IHswfXh7MX0tRG91YmxlIHsyOlAyfSBGaWxsZWRcIiwgUm93Q291bnQsIENvbHVtbkNvdW50LCBOb25aZXJvc0NvdW50IC8gKFJvd0NvdW50ICogKGRvdWJsZSlDb2x1bW5Db3VudCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIExVPGRvdWJsZT4gTFUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8vIDxjb3B5cmlnaHQgZmlsZT1cIlNwYXJzZVZlY3Rvci5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDE1IE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIFN5c3RlbS5HbG9iYWxpemF0aW9uO1xyXG51c2luZyBTeXN0ZW0uTGlucTtcclxudXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLlN0b3JhZ2U7XHJcbnVzaW5nIE1hdGhOZXROdW1lcmljcztcclxuXHJcbm5hbWVzcGFjZSBNYXRoTmV0Lk51bWVyaWNzLkxpbmVhckFsZ2VicmEuRG91YmxlXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIHZlY3RvciB3aXRoIHNwYXJzZSBzdG9yYWdlLCBpbnRlbmRlZCBmb3IgdmVyeSBsYXJnZSB2ZWN0b3JzIHdoZXJlIG1vc3Qgb2YgdGhlIGNlbGxzIGFyZSB6ZXJvLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIC8vLyA8cmVtYXJrcz5UaGUgc3BhcnNlIHZlY3RvciBpcyBub3QgdGhyZWFkIHNhZmUuPC9yZW1hcmtzPlxyXG4gICAgW1NlcmlhbGl6YWJsZV1cclxuICAgIFtEZWJ1Z2dlckRpc3BsYXkoXCJTcGFyc2VWZWN0b3Ige0NvdW50fS1Eb3VibGUge05vblplcm9zQ291bnR9LU5vblplcm9cIildXHJcbiAgICBwdWJsaWMgY2xhc3MgU3BhcnNlVmVjdG9yIDogVmVjdG9yXHJcbiAgICB7XHJcbiAgICAgICAgcmVhZG9ubHkgU3BhcnNlVmVjdG9yU3RvcmFnZTxkb3VibGU+IF9zdG9yYWdlO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIG51bWJlciBvZiBub24gemVybyBlbGVtZW50cyBpbiB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgbnVtYmVyIG9mIG5vbiB6ZXJvIGVsZW1lbnRzLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGludCBOb25aZXJvc0NvdW50XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3N0b3JhZ2UuVmFsdWVDb3VudDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIHZlY3RvciBzdHJhaWdodCBmcm9tIGFuIGluaXRpYWxpemVkIHZlY3RvciBzdG9yYWdlIGluc3RhbmNlLlxyXG4gICAgICAgIC8vLyBUaGUgc3RvcmFnZSBpcyB1c2VkIGRpcmVjdGx5IHdpdGhvdXQgY29weWluZy5cclxuICAgICAgICAvLy8gSW50ZW5kZWQgZm9yIGFkdmFuY2VkIHNjZW5hcmlvcyB3aGVyZSB5b3UncmUgd29ya2luZyBkaXJlY3RseSB3aXRoXHJcbiAgICAgICAgLy8vIHN0b3JhZ2UgZm9yIHBlcmZvcm1hbmNlIG9yIGludGVyb3AgcmVhc29ucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBTcGFyc2VWZWN0b3IoU3BhcnNlVmVjdG9yU3RvcmFnZTxkb3VibGU+IHN0b3JhZ2UpXHJcbiAgICAgICAgICAgIDogYmFzZShzdG9yYWdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3N0b3JhZ2UgPSBzdG9yYWdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBsZW5ndGguXHJcbiAgICAgICAgLy8vIEFsbCBjZWxscyBvZiB0aGUgdmVjdG9yIHdpbGwgYmUgaW5pdGlhbGl6ZWQgdG8gemVyby5cclxuICAgICAgICAvLy8gWmVyby1sZW5ndGggdmVjdG9ycyBhcmUgbm90IHN1cHBvcnRlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIGxlbmd0aCBpcyBsZXNzIHRoYW4gb25lLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBTcGFyc2VWZWN0b3IoaW50IGxlbmd0aClcclxuICAgICAgICAgICAgOiB0aGlzKG5ldyBTcGFyc2VWZWN0b3JTdG9yYWdlPGRvdWJsZT4obGVuZ3RoKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgdmVjdG9yIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gb3RoZXIgdmVjdG9yLlxyXG4gICAgICAgIC8vLyBUaGlzIG5ldyB2ZWN0b3Igd2lsbCBiZSBpbmRlcGVuZGVudCBmcm9tIHRoZSBvdGhlciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIEEgbmV3IG1lbW9yeSBibG9jayB3aWxsIGJlIGFsbG9jYXRlZCBmb3Igc3RvcmluZyB0aGUgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VWZWN0b3IgT2ZWZWN0b3IoVmVjdG9yPGRvdWJsZT4gdmVjdG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VWZWN0b3IoU3BhcnNlVmVjdG9yU3RvcmFnZTxkb3VibGU+Lk9mVmVjdG9yKHZlY3Rvci5TdG9yYWdlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgdmVjdG9yIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgdmVjdG9yIHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZVZlY3RvciBPZkVudW1lcmFibGUoSUVudW1lcmFibGU8ZG91YmxlPiBlbnVtZXJhYmxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGFyc2VWZWN0b3IoU3BhcnNlVmVjdG9yU3RvcmFnZTxkb3VibGU+Lk9mRW51bWVyYWJsZShlbnVtZXJhYmxlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgdmVjdG9yIGFzIGEgY29weSBvZiB0aGUgZ2l2ZW4gaW5kZXhlZCBlbnVtZXJhYmxlLlxyXG4gICAgICAgIC8vLyBLZXlzIG11c3QgYmUgcHJvdmlkZWQgYXQgbW9zdCBvbmNlLCB6ZXJvIGlzIGFzc3VtZWQgaWYgYSBrZXkgaXMgb21pdHRlZC5cclxuICAgICAgICAvLy8gVGhpcyBuZXcgdmVjdG9yIHdpbGwgYmUgaW5kZXBlbmRlbnQgZnJvbSB0aGUgZW51bWVyYWJsZS5cclxuICAgICAgICAvLy8gQSBuZXcgbWVtb3J5IGJsb2NrIHdpbGwgYmUgYWxsb2NhdGVkIGZvciBzdG9yaW5nIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZVZlY3RvciBPZkluZGV4ZWRFbnVtZXJhYmxlKGludCBsZW5ndGgsIElFbnVtZXJhYmxlPFR1cGxlPGludCwgZG91YmxlPj4gZW51bWVyYWJsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BhcnNlVmVjdG9yKFNwYXJzZVZlY3RvclN0b3JhZ2U8ZG91YmxlPi5PZkluZGV4ZWRFbnVtZXJhYmxlKGxlbmd0aCwgZW51bWVyYWJsZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBuZXcgc3BhcnNlIHZlY3RvciBhbmQgaW5pdGlhbGl6ZSBlYWNoIHZhbHVlIHVzaW5nIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlVmVjdG9yIENyZWF0ZShpbnQgbGVuZ3RoLCBkb3VibGUgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZVZlY3RvcihTcGFyc2VWZWN0b3JTdG9yYWdlPGRvdWJsZT4uT2ZWYWx1ZShsZW5ndGgsIHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIG5ldyBzcGFyc2UgdmVjdG9yIGFuZCBpbml0aWFsaXplIGVhY2ggdmFsdWUgdXNpbmcgdGhlIHByb3ZpZGVkIGluaXQgZnVuY3Rpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZVZlY3RvciBDcmVhdGUoaW50IGxlbmd0aCwgRnVuYzxpbnQsIGRvdWJsZT4gaW5pdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3BhcnNlVmVjdG9yKFNwYXJzZVZlY3RvclN0b3JhZ2U8ZG91YmxlPi5PZkluaXQobGVuZ3RoLCAoRnVuYzxpbnQsZG91YmxlPilpbml0KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgYSBzY2FsYXIgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyBXYXJuaW5nLCB0aGUgbmV3ICdzcGFyc2UgdmVjdG9yJyB3aXRoIGEgbm9uLXplcm8gc2NhbGFyIGFkZGVkIHRvIGl0IHdpbGwgYmUgYSAxMDAlIGZpbGxlZFxyXG4gICAgICAgIC8vLyBzcGFyc2UgdmVjdG9yIGFuZCB2ZXJ5IGluZWZmaWNpZW50LiBXb3VsZCBiZSBiZXR0ZXIgdG8gd29yayB3aXRoIGEgZGVuc2UgdmVjdG9yIGluc3RlYWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzY2FsYXJcIj5cclxuICAgICAgICAvLy8gVGhlIHNjYWxhciB0byBhZGQuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+XHJcbiAgICAgICAgLy8vIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9BZGQoZG91YmxlIHNjYWxhciwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHNjYWxhciA9PSAwLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghUmVmZXJlbmNlRXF1YWxzKHRoaXMsIHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29weVRvKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoUmVmZXJlbmNlRXF1YWxzKHRoaXMsIHJlc3VsdCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIHBvcHVsYXRlIGEgbmV3IHZlY3RvciB3aXRoIHRoZSBzY2FsYXJcclxuICAgICAgICAgICAgICAgIHZhciB2bm9uWmVyb1ZhbHVlcyA9IG5ldyBkb3VibGVbQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZub25aZXJvSW5kaWNlcyA9IG5ldyBpbnRbQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaW5kZXggPSAwOyBpbmRleCA8IENvdW50OyBpbmRleCsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZub25aZXJvSW5kaWNlc1tpbmRleF0gPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB2bm9uWmVyb1ZhbHVlc1tpbmRleF0gPSBzY2FsYXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcG9wdWxhdGUgdGhlIG5vbiB6ZXJvIHZhbHVlcyBmcm9tIHRoaXNcclxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gX3N0b3JhZ2UuSW5kaWNlcztcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBfc3RvcmFnZS5WYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IF9zdG9yYWdlLlZhbHVlQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9uWmVyb1ZhbHVlc1tpbmRpY2VzW2pdXSA9IHZhbHVlc1tqXSArIHNjYWxhcjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gdGhpcyB2ZWN0b3JzIGFycmF5IHRvIHRoZSBuZXcgYXJyYXlzLlxyXG4gICAgICAgICAgICAgICAgX3N0b3JhZ2UuVmFsdWVzID0gdm5vblplcm9WYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICBfc3RvcmFnZS5JbmRpY2VzID0gdm5vblplcm9JbmRpY2VzO1xyXG4gICAgICAgICAgICAgICAgX3N0b3JhZ2UuVmFsdWVDb3VudCA9IENvdW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IENvdW50OyBpbmRleCsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChpbmRleCwgQXQoaW5kZXgpICsgc2NhbGFyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGRzIGFub3RoZXIgdmVjdG9yIHRvIHRoaXMgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5cclxuICAgICAgICAvLy8gVGhlIHZlY3RvciB0byBhZGQgdG8gdGhpcyBvbmUuXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+XHJcbiAgICAgICAgLy8vIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9BZGQoVmVjdG9yPGRvdWJsZT4gb3RoZXIsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBvdGhlclNwYXJzZSA9IG90aGVyIGFzIFNwYXJzZVZlY3RvcjtcclxuICAgICAgICAgICAgaWYgKG90aGVyU3BhcnNlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9BZGQob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHRTcGFyc2UgPSByZXN1bHQgYXMgU3BhcnNlVmVjdG9yO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0U3BhcnNlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJhc2UuRG9BZGQob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE8gKHJ1ZWdnLCAyMDExLTEwLTExKTogT3B0aW9ucyB0byBvcHRpbWl6ZT9cclxuXHJcbiAgICAgICAgICAgIHZhciBvdGhlclN0b3JhZ2UgPSBvdGhlclNwYXJzZS5fc3RvcmFnZTtcclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCByZXN1bHRTcGFyc2UpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgaSA9IDAsIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBvdGhlclN0b3JhZ2UuVmFsdWVDb3VudClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBfc3RvcmFnZS5WYWx1ZUNvdW50IHx8IF9zdG9yYWdlLkluZGljZXNbaV0gPiBvdGhlclN0b3JhZ2UuSW5kaWNlc1tqXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlclZhbHVlID0gb3RoZXJTdG9yYWdlLlZhbHVlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyVmFsdWUgIT0gMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RvcmFnZS5JbnNlcnRBdEluZGV4VW5jaGVja2VkKGkrKywgb3RoZXJTdG9yYWdlLkluZGljZXNbal0sIG90aGVyVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3N0b3JhZ2UuSW5kaWNlc1tpXSA9PSBvdGhlclN0b3JhZ2UuSW5kaWNlc1tqXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlc3VsdCBjYW4gYmUgemVybywgcmVtb3ZlP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RvcmFnZS5WYWx1ZXNbaSsrXSArPSBvdGhlclN0b3JhZ2UuVmFsdWVzW2orK107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIGludCBpID0gMCwgaiA9IDAsIGxhc3QgPSAtMTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgX3N0b3JhZ2UuVmFsdWVDb3VudCB8fCBqIDwgb3RoZXJTdG9yYWdlLlZhbHVlQ291bnQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPj0gb3RoZXJTdG9yYWdlLlZhbHVlQ291bnQgfHwgaSA8IF9zdG9yYWdlLlZhbHVlQ291bnQgJiYgX3N0b3JhZ2UuSW5kaWNlc1tpXSA8PSBvdGhlclN0b3JhZ2UuSW5kaWNlc1tqXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gX3N0b3JhZ2UuSW5kaWNlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gbGFzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQobmV4dCwgX3N0b3JhZ2UuVmFsdWVzW2ldICsgb3RoZXJTcGFyc2UuQXQobmV4dCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBvdGhlclN0b3JhZ2UuSW5kaWNlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gbGFzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQobmV4dCwgQXQobmV4dCkgKyBvdGhlclN0b3JhZ2UuVmFsdWVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN1YnRyYWN0cyBhIHNjYWxhciBmcm9tIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlxyXG4gICAgICAgIC8vLyBUaGUgc2NhbGFyIHRvIHN1YnRyYWN0LlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlxyXG4gICAgICAgIC8vLyBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvU3VidHJhY3QoZG91YmxlIHNjYWxhciwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRG9BZGQoLXNjYWxhciwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3VidHJhY3RzIGFub3RoZXIgdmVjdG9yIHRvIHRoaXMgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5cclxuICAgICAgICAvLy8gVGhlIHZlY3RvciB0byBzdWJ0cmFjdCBmcm9tIHRoaXMgb25lLlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlxyXG4gICAgICAgIC8vLyBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvU3VidHJhY3QoVmVjdG9yPGRvdWJsZT4gb3RoZXIsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHModGhpcywgb3RoZXIpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG90aGVyU3BhcnNlID0gb3RoZXIgYXMgU3BhcnNlVmVjdG9yO1xyXG4gICAgICAgICAgICBpZiAob3RoZXJTcGFyc2UgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmFzZS5Eb1N1YnRyYWN0KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0U3BhcnNlID0gcmVzdWx0IGFzIFNwYXJzZVZlY3RvcjtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdFNwYXJzZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBiYXNlLkRvU3VidHJhY3Qob3RoZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE8gKHJ1ZWdnLCAyMDExLTEwLTExKTogT3B0aW9ucyB0byBvcHRpbWl6ZT9cclxuXHJcbiAgICAgICAgICAgIHZhciBvdGhlclN0b3JhZ2UgPSBvdGhlclNwYXJzZS5fc3RvcmFnZTtcclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCByZXN1bHRTcGFyc2UpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgaSA9IDAsIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBvdGhlclN0b3JhZ2UuVmFsdWVDb3VudClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBfc3RvcmFnZS5WYWx1ZUNvdW50IHx8IF9zdG9yYWdlLkluZGljZXNbaV0gPiBvdGhlclN0b3JhZ2UuSW5kaWNlc1tqXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlclZhbHVlID0gb3RoZXJTdG9yYWdlLlZhbHVlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyVmFsdWUgIT0gMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RvcmFnZS5JbnNlcnRBdEluZGV4VW5jaGVja2VkKGkrKywgb3RoZXJTdG9yYWdlLkluZGljZXNbal0sIC1vdGhlclZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9zdG9yYWdlLkluZGljZXNbaV0gPT0gb3RoZXJTdG9yYWdlLkluZGljZXNbal0pXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZXN1bHQgY2FuIGJlIHplcm8sIHJlbW92ZT9cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0b3JhZ2UuVmFsdWVzW2krK10gLT0gb3RoZXJTdG9yYWdlLlZhbHVlc1tqKytdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICBpbnQgaSA9IDAsIGogPSAwLCBsYXN0ID0gLTE7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IF9zdG9yYWdlLlZhbHVlQ291bnQgfHwgaiA8IG90aGVyU3RvcmFnZS5WYWx1ZUNvdW50KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqID49IG90aGVyU3RvcmFnZS5WYWx1ZUNvdW50IHx8IGkgPCBfc3RvcmFnZS5WYWx1ZUNvdW50ICYmIF9zdG9yYWdlLkluZGljZXNbaV0gPD0gb3RoZXJTdG9yYWdlLkluZGljZXNbal0pXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IF9zdG9yYWdlLkluZGljZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IGxhc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KG5leHQsIF9zdG9yYWdlLlZhbHVlc1tpXSAtIG90aGVyU3BhcnNlLkF0KG5leHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gb3RoZXJTdG9yYWdlLkluZGljZXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IGxhc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KG5leHQsIEF0KG5leHQpIC0gb3RoZXJTdG9yYWdlLlZhbHVlc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOZWdhdGVzIHZlY3RvciBhbmQgc2F2ZXMgcmVzdWx0IHRvIDxwYXJhbXJlZiBuYW1lPVwicmVzdWx0XCIvPlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGFyZ2V0IHZlY3RvcjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9OZWdhdGUoVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHNwYXJzZVJlc3VsdCA9IHJlc3VsdCBhcyBTcGFyc2VWZWN0b3I7XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VSZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgX3N0b3JhZ2UuVmFsdWVDb3VudDsgaW5kZXgrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQoX3N0b3JhZ2UuSW5kaWNlc1tpbmRleF0sIC1fc3RvcmFnZS5WYWx1ZXNbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFSZWZlcmVuY2VFcXVhbHModGhpcywgcmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3BhcnNlUmVzdWx0Ll9zdG9yYWdlLlZhbHVlQ291bnQgPSBfc3RvcmFnZS5WYWx1ZUNvdW50O1xyXG4gICAgICAgICAgICAgICAgc3BhcnNlUmVzdWx0Ll9zdG9yYWdlLkluZGljZXMgPSBuZXcgaW50W19zdG9yYWdlLlZhbHVlQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgYnl0ZVtdIHNvdXJjZWJ5dGVzID0gbmV3IGJ5dGVbX3N0b3JhZ2UuSW5kaWNlcy5MZW5ndGggKiA4XTtcclxuICAgICAgICAgICAgICAgIHNvdXJjZWJ5dGVzID0gU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5TZWxlY3RNYW55PGludCxieXRlPihfc3RvcmFnZS5JbmRpY2VzLChGdW5jPGludCxJRW51bWVyYWJsZTxieXRlPj4pKHZhbHVlID0+IEJpdENvbnZlcnRlci5HZXRCeXRlcyh2YWx1ZSkpKS5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KF9zdG9yYWdlLkluZGljZXMsIDAsIHNwYXJzZVJlc3VsdC5fc3RvcmFnZS5JbmRpY2VzLCAwLCBfc3RvcmFnZS5WYWx1ZUNvdW50ICk7XHJcbiAgICAgICAgICAgICAgICBzcGFyc2VSZXN1bHQuX3N0b3JhZ2UuVmFsdWVzID0gbmV3IGRvdWJsZVtfc3RvcmFnZS5WYWx1ZUNvdW50XTtcclxuICAgICAgICAgICAgICAgIEFycmF5LkNvcHkoX3N0b3JhZ2UuVmFsdWVzLCAwLCBzcGFyc2VSZXN1bHQuX3N0b3JhZ2UuVmFsdWVzLCAwLCBfc3RvcmFnZS5WYWx1ZUNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgTWFwKChGdW5jPGRvdWJsZSxkb3VibGU+KSh4ID0+IC14KSwgcmVzdWx0LCBaZXJvcy5BbGxvd1NraXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIGEgc2NhbGFyIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgcmVzdWx0IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNjYWxhclwiPlxyXG4gICAgICAgIC8vLyBUaGUgc2NhbGFyIHRvIG11bHRpcGx5LlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlxyXG4gICAgICAgIC8vLyBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvTXVsdGlwbHkoZG91YmxlIHNjYWxhciwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHNwYXJzZVJlc3VsdCA9IHJlc3VsdCBhcyBTcGFyc2VWZWN0b3I7XHJcbiAgICAgICAgICAgIGlmIChzcGFyc2VSZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgX3N0b3JhZ2UuVmFsdWVDb3VudDsgaW5kZXgrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQoX3N0b3JhZ2UuSW5kaWNlc1tpbmRleF0sIHNjYWxhciAqIF9zdG9yYWdlLlZhbHVlc1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFSZWZlcmVuY2VFcXVhbHModGhpcywgcmVzdWx0KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzcGFyc2VSZXN1bHQuX3N0b3JhZ2UuVmFsdWVDb3VudCA9IF9zdG9yYWdlLlZhbHVlQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhcnNlUmVzdWx0Ll9zdG9yYWdlLkluZGljZXMgPSBuZXcgaW50W19zdG9yYWdlLlZhbHVlQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LkNvcHkoX3N0b3JhZ2UuSW5kaWNlcywgMCwgc3BhcnNlUmVzdWx0Ll9zdG9yYWdlLkluZGljZXMsIDAsIF9zdG9yYWdlLlZhbHVlQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYXJzZVJlc3VsdC5fc3RvcmFnZS5WYWx1ZXMgPSBuZXcgZG91YmxlW19zdG9yYWdlLlZhbHVlQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LkNvcHkoX3N0b3JhZ2UuVmFsdWVzLCAwLCBzcGFyc2VSZXN1bHQuX3N0b3JhZ2UuVmFsdWVzLCAwLCBfc3RvcmFnZS5WYWx1ZUNvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBNYXAoKEZ1bmM8ZG91YmxlLGRvdWJsZT4pKHggPT4geCAqIHNjYWxhciksIHJlc3VsdCwgWmVyb3MuQWxsb3dTa2lwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlciB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSBvdGhlciB2ZWN0b3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHN1bSBvZiBhW2ldKmJbaV0gZm9yIGFsbCBpLjwvcmV0dXJucz5cclxuICAgICAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZG91YmxlIERvRG90UHJvZHVjdChWZWN0b3I8ZG91YmxlPiBvdGhlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAwZDtcclxuICAgICAgICAgICAgaWYgKFJlZmVyZW5jZUVxdWFscyh0aGlzLCBvdGhlcikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3N0b3JhZ2UuVmFsdWVDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBfc3RvcmFnZS5WYWx1ZXNbaV0gKiBfc3RvcmFnZS5WYWx1ZXNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9zdG9yYWdlLlZhbHVlQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gX3N0b3JhZ2UuVmFsdWVzW2ldICogb3RoZXIuQXQoX3N0b3JhZ2UuSW5kaWNlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIGNhbm9uaWNhbCBtb2R1bHVzLCB3aGVyZSB0aGUgcmVzdWx0IGhhcyB0aGUgc2lnbiBvZiB0aGUgZGl2aXNvcixcclxuICAgICAgICAvLy8gZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGZvciB0aGUgZ2l2ZW4gZGl2aXNvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgc2NhbGFyIGRlbm9taW5hdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPkEgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9Nb2R1bHVzKGRvdWJsZSBkaXZpc29yLCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoUmVmZXJlbmNlRXF1YWxzKHRoaXMsIHJlc3VsdCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBfc3RvcmFnZS5WYWx1ZUNvdW50OyBpbmRleCsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdG9yYWdlLlZhbHVlc1tpbmRleF0gPSBFdWNsaWQuTW9kdWx1cyhfc3RvcmFnZS5WYWx1ZXNbaW5kZXhdLCBkaXZpc29yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5DbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IF9zdG9yYWdlLlZhbHVlQ291bnQ7IGluZGV4KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkF0KF9zdG9yYWdlLkluZGljZXNbaW5kZXhdLCBFdWNsaWQuTW9kdWx1cyhfc3RvcmFnZS5WYWx1ZXNbaW5kZXhdLCBkaXZpc29yKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciAoJSBvcGVyYXRvciksIHdoZXJlIHRoZSByZXN1bHQgaGFzIHRoZSBzaWduIG9mIHRoZSBkaXZpZGVuZCxcclxuICAgICAgICAvLy8gZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGZvciB0aGUgZ2l2ZW4gZGl2aXNvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpdmlzb3JcIj5UaGUgc2NhbGFyIGRlbm9taW5hdG9yIHRvIHVzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPkEgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLjwvcGFyYW0+XHJcbiAgICAgICAgcHJvdGVjdGVkIG92ZXJyaWRlIHZvaWQgRG9SZW1haW5kZXIoZG91YmxlIGRpdmlzb3IsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHModGhpcywgcmVzdWx0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IF9zdG9yYWdlLlZhbHVlQ291bnQ7IGluZGV4KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N0b3JhZ2UuVmFsdWVzW2luZGV4XSAlPSBkaXZpc29yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgX3N0b3JhZ2UuVmFsdWVDb3VudDsgaW5kZXgrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQXQoX3N0b3JhZ2UuSW5kaWNlc1tpbmRleF0sIF9zdG9yYWdlLlZhbHVlc1tpbmRleF0lZGl2aXNvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkcyB0d28gPHN0cm9uZz5WZWN0b3JzPC9zdHJvbmc+IHRvZ2V0aGVyIGFuZCByZXR1cm5zIHRoZSByZXN1bHRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5PbmUgb2YgdGhlIHZlY3RvcnMgdG8gYWRkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIG90aGVyIHZlY3RvciB0byBhZGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IGFuZCA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZVZlY3RvciBvcGVyYXRvciArKFNwYXJzZVZlY3RvciBsZWZ0U2lkZSwgU3BhcnNlVmVjdG9yIHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwibGVmdFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoU3BhcnNlVmVjdG9yKWxlZnRTaWRlLkFkZChyaWdodFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgPHN0cm9uZz5WZWN0b3I8L3N0cm9uZz4gY29udGFpbmluZyB0aGUgbmVnYXRlZCB2YWx1ZXMgb2YgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBnZXQgdGhlIHZhbHVlcyBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIG5lZ2F0ZWQgdmFsdWVzIGFzIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlVmVjdG9yIG9wZXJhdG9yIC0oU3BhcnNlVmVjdG9yIHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJpZ2h0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChTcGFyc2VWZWN0b3IpcmlnaHRTaWRlLk5lZ2F0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdWJ0cmFjdHMgdHdvIDxzdHJvbmc+VmVjdG9yczwvc3Ryb25nPiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIHZlY3RvciB0byBzdWJ0cmFjdCBmcm9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHZlY3RvciB0byBzdWJ0cmFjdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50RXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gYW5kIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBhcmUgbm90IHRoZSBzYW1lIHNpemUuPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IG9yIDxwYXJhbXJlZiBuYW1lPVwicmlnaHRTaWRlXCIvPiBpcyA8c2VlIGxhbmd3b3JkPVwibnVsbFwiIC8+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU3BhcnNlVmVjdG9yIG9wZXJhdG9yIC0oU3BhcnNlVmVjdG9yIGxlZnRTaWRlLCBTcGFyc2VWZWN0b3IgcmlnaHRTaWRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGxlZnRTaWRlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJsZWZ0U2lkZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChTcGFyc2VWZWN0b3IpbGVmdFNpZGUuU3VidHJhY3QocmlnaHRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTXVsdGlwbGllcyBhIHZlY3RvciB3aXRoIGEgc2NhbGFyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVmdFNpZGVcIj5UaGUgdmVjdG9yIHRvIHNjYWxlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmlnaHRTaWRlXCI+VGhlIHNjYWxhciB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgcmVzdWx0IG9mIHRoZSBtdWx0aXBsaWNhdGlvbi48L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VWZWN0b3Igb3BlcmF0b3IgKihTcGFyc2VWZWN0b3IgbGVmdFNpZGUsIGRvdWJsZSByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobGVmdFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImxlZnRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKFNwYXJzZVZlY3RvcilsZWZ0U2lkZS5NdWx0aXBseShyaWdodFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNdWx0aXBsaWVzIGEgdmVjdG9yIHdpdGggYSBzY2FsYXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSBzY2FsYXIgdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgdmVjdG9yIHRvIHNjYWxlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJyaWdodFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VWZWN0b3Igb3BlcmF0b3IgKihkb3VibGUgbGVmdFNpZGUsIFNwYXJzZVZlY3RvciByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocmlnaHRTaWRlID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJyaWdodFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoU3BhcnNlVmVjdG9yKXJpZ2h0U2lkZS5NdWx0aXBseShsZWZ0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGVzIHRoZSBkb3QgcHJvZHVjdCBiZXR3ZWVuIHR3byA8c3Ryb25nPlZlY3RvcnM8L3N0cm9uZz4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZWZ0U2lkZVwiPlRoZSBsZWZ0IHJvdyB2ZWN0b3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgcmlnaHQgY29sdW1uIHZlY3Rvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0aGUgdHdvIHZlY3RvcnMuPC9yZXR1cm5zPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IGFuZCA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gYXJlIG5vdCB0aGUgc2FtZSBzaXplLjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cImxlZnRTaWRlXCIvPiBvciA8cGFyYW1yZWYgbmFtZT1cInJpZ2h0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGRvdWJsZSBvcGVyYXRvciAqKFNwYXJzZVZlY3RvciBsZWZ0U2lkZSwgU3BhcnNlVmVjdG9yIHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwibGVmdFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0U2lkZS5Eb3RQcm9kdWN0KHJpZ2h0U2lkZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERpdmlkZXMgYSB2ZWN0b3Igd2l0aCBhIHNjYWxhci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIHZlY3RvciB0byBkaXZpZGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgc2NhbGFyIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSByZXN1bHQgb2YgdGhlIGRpdmlzaW9uLjwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJsZWZ0U2lkZVwiLz4gaXMgPHNlZSBsYW5nd29yZD1cIm51bGxcIiAvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNwYXJzZVZlY3RvciBvcGVyYXRvciAvKFNwYXJzZVZlY3RvciBsZWZ0U2lkZSwgZG91YmxlIHJpZ2h0U2lkZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0U2lkZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwibGVmdFNpZGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoU3BhcnNlVmVjdG9yKWxlZnRTaWRlLkRpdmlkZShyaWdodFNpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlcyB0aGUgcmVtYWluZGVyICglIG9wZXJhdG9yKSwgd2hlcmUgdGhlIHJlc3VsdCBoYXMgdGhlIHNpZ24gb2YgdGhlIGRpdmlkZW5kLFxyXG4gICAgICAgIC8vLyBvZiBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBvZiB0aGUgZ2l2ZW4gZGl2aXNvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxlZnRTaWRlXCI+VGhlIHZlY3RvciB3aG9zZSBlbGVtZW50cyB3ZSB3YW50IHRvIGNvbXB1dGUgdGhlIG1vZHVsdXMgb2YuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyaWdodFNpZGVcIj5UaGUgZGl2aXNvciB0byB1c2UsPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHJlc3VsdCBvZiB0aGUgY2FsY3VsYXRpb248L3JldHVybnM+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibGVmdFNpZGVcIi8+IGlzIDxzZWUgbGFuZ3dvcmQ9XCJudWxsXCIgLz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTcGFyc2VWZWN0b3Igb3BlcmF0b3IgJShTcGFyc2VWZWN0b3IgbGVmdFNpZGUsIGRvdWJsZSByaWdodFNpZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobGVmdFNpZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImxlZnRTaWRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKFNwYXJzZVZlY3RvcilsZWZ0U2lkZS5SZW1haW5kZXIocmlnaHRTaWRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGFic29sdXRlIG1pbmltdW0gZWxlbWVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgaW5kZXggb2YgYWJzb2x1dGUgbWluaW11bSBlbGVtZW50LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IEFic29sdXRlTWluaW11bUluZGV4KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfc3RvcmFnZS5WYWx1ZUNvdW50ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIG5vbi16ZXJvIGVsZW1lbnRzLiBSZXR1cm4gMFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLkFicyhfc3RvcmFnZS5WYWx1ZXNbaW5kZXhdKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBfc3RvcmFnZS5WYWx1ZUNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXN0ID0gTWF0aC5BYnMoX3N0b3JhZ2UuVmFsdWVzW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXN0IDwgbWluKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSB0ZXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gX3N0b3JhZ2UuSW5kaWNlc1tpbmRleF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBhYnNvbHV0ZSBtYXhpbXVtIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGluZGV4IG9mIGFic29sdXRlIG1heGltdW0gZWxlbWVudC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGludCBBYnNvbHV0ZU1heGltdW1JbmRleCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX3N0b3JhZ2UuVmFsdWVDb3VudCA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBub24temVybyBlbGVtZW50cy4gUmV0dXJuIDBcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5BYnMoX3N0b3JhZ2UuVmFsdWVzW2luZGV4XSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgX3N0b3JhZ2UuVmFsdWVDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVzdCA9IE1hdGguQWJzKF9zdG9yYWdlLlZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVzdCA+IG1heClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gdGVzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIF9zdG9yYWdlLkluZGljZXNbaW5kZXhdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF4aW11bSBlbGVtZW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBpbmRleCBvZiBtYXhpbXVtIGVsZW1lbnQuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBpbnQgTWF4aW11bUluZGV4KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfc3RvcmFnZS5WYWx1ZUNvdW50ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICB2YXIgbWF4ID0gX3N0b3JhZ2UuVmFsdWVzWzBdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IF9zdG9yYWdlLlZhbHVlQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heCA8IF9zdG9yYWdlLlZhbHVlc1tpXSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gX3N0b3JhZ2UuVmFsdWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gX3N0b3JhZ2UuSW5kaWNlc1tpbmRleF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtaW5pbXVtIGVsZW1lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGluZGV4IG9mIG1pbmltdW0gZWxlbWVudC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGludCBNaW5pbXVtSW5kZXgoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9zdG9yYWdlLlZhbHVlQ291bnQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBtaW4gPSBfc3RvcmFnZS5WYWx1ZXNbMF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgX3N0b3JhZ2UuVmFsdWVDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWluID4gX3N0b3JhZ2UuVmFsdWVzW2ldKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBfc3RvcmFnZS5WYWx1ZXNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfc3RvcmFnZS5JbmRpY2VzW2luZGV4XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgdmVjdG9yJ3MgZWxlbWVudHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHN1bSBvZiB0aGUgdmVjdG9yJ3MgZWxlbWVudHMuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgU3VtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSByZXN1bHQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9zdG9yYWdlLlZhbHVlQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IF9zdG9yYWdlLlZhbHVlc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYWxjdWxhdGVzIHRoZSBMMSBub3JtIG9mIHRoZSB2ZWN0b3IsIGFsc28ga25vd24gYXMgTWFuaGF0dGFuIG5vcm0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHN1bSBvZiB0aGUgYWJzb2x1dGUgdmFsdWVzLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZG91YmxlIEwxTm9ybSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gMGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3N0b3JhZ2UuVmFsdWVDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gTWF0aC5BYnMoX3N0b3JhZ2UuVmFsdWVzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYWxjdWxhdGVzIHRoZSBpbmZpbml0eSBub3JtIG9mIHRoZSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIG1heGltdW0gYWJzb2x1dGUgdmFsdWUuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBkb3VibGUgSW5maW5pdHlOb3JtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSBtYXggPSAwLjA7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguQWJzKEF0KGkpKSA+IG1heCkgbWF4ID0gQXQoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1heDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZXMgdGhlIHAtTm9ybS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBcIj5UaGUgcCB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5TY2FsYXIgPGM+cmV0ID0gKCDiiJF8dGhpc1tpXXxecCApXigxL3ApPC9jPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZG91YmxlIE5vcm0oZG91YmxlIHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocCA8IDBkKSB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwicFwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfc3RvcmFnZS5WYWx1ZUNvdW50ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHAgPT0gMWQpIHJldHVybiBMMU5vcm0oKTtcclxuICAgICAgICAgICAgaWYgKHAgPT0gMmQpIHJldHVybiBMMk5vcm0oKTtcclxuICAgICAgICAgICAgaWYgKGRvdWJsZS5Jc1Bvc2l0aXZlSW5maW5pdHkocCkpIHJldHVybiBJbmZpbml0eU5vcm0oKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdW0gPSAwZDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IF9zdG9yYWdlLlZhbHVlQ291bnQ7IGluZGV4KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN1bSArPSBNYXRoLlBvdyhNYXRoLkFicyhfc3RvcmFnZS5WYWx1ZXNbaW5kZXhdKSwgcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguUG93KHN1bSwgMS4wIC8gcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50d2lzZSBtdWx0aXBsaWVzIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdGhlclwiPlRoZSB2ZWN0b3IgdG8gcG9pbnR3aXNlIG11bHRpcGx5IHdpdGggdGhpcyBvbmUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIHBvaW50d2lzZSBtdWx0aXBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIERvUG9pbnR3aXNlTXVsdGlwbHkoVmVjdG9yPGRvdWJsZT4gb3RoZXIsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHModGhpcywgb3RoZXIpICYmIFJlZmVyZW5jZUVxdWFscyh0aGlzLCByZXN1bHQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9zdG9yYWdlLlZhbHVlQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3RvcmFnZS5WYWx1ZXNbaV0gKj0gX3N0b3JhZ2UuVmFsdWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYmFzZS5Eb1BvaW50d2lzZU11bHRpcGx5KG90aGVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjcmVnaW9uIFBhcnNlIEZ1bmN0aW9uc1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSBkb3VibGUgc3BhcnNlIHZlY3RvciBiYXNlZCBvbiBhIHN0cmluZy4gVGhlIHN0cmluZyBjYW4gYmUgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXRzICh3aXRob3V0IHRoZVxyXG4gICAgICAgIC8vLyBxdW90ZXMpOiAnbicsICduLG4sLi4nLCAnKG4sbiwuLiknLCAnW24sbiwuLi5dJywgd2hlcmUgbiBpcyBhIGRvdWJsZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gQSBkb3VibGUgc3BhcnNlIHZlY3RvciBjb250YWluaW5nIHRoZSB2YWx1ZXMgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2YWx1ZVwiPlxyXG4gICAgICAgIC8vLyB0aGUgc3RyaW5nIHRvIHBhcnNlLlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZvcm1hdFByb3ZpZGVyXCI+XHJcbiAgICAgICAgLy8vIEFuIDxzZWUgY3JlZj1cIklGb3JtYXRQcm92aWRlclwiLz4gdGhhdCBzdXBwbGllcyBjdWx0dXJlLXNwZWNpZmljIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29udmVydHMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHJlYWwgc3BhcnNlIHZlY3RvciB0byBkb3VibGUtcHJlY2lzaW9uIHNwYXJzZSB2ZWN0b3IgZXF1aXZhbGVudC5cclxuICAgICAgICAvLy8gQSByZXR1cm4gdmFsdWUgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbnZlcnNpb24gc3VjY2VlZGVkIG9yIGZhaWxlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlXCI+XHJcbiAgICAgICAgLy8vIEEgc3RyaW5nIGNvbnRhaW5pbmcgYSByZWFsIHZlY3RvciB0byBjb252ZXJ0LlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlxyXG4gICAgICAgIC8vLyBUaGUgcGFyc2VkIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gSWYgdGhlIGNvbnZlcnNpb24gc3VjY2VlZHMsIHRoZSByZXN1bHQgd2lsbCBjb250YWluIGEgY29tcGxleCBudW1iZXIgZXF1aXZhbGVudCB0byB2YWx1ZS5cclxuICAgICAgICAvLy8gT3RoZXJ3aXNlIHRoZSByZXN1bHQgd2lsbCBiZSA8Yz5udWxsPC9jPi5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnZlcnRzIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSByZWFsIHNwYXJzZSB2ZWN0b3IgdG8gZG91YmxlLXByZWNpc2lvbiBzcGFyc2UgdmVjdG9yIGVxdWl2YWxlbnQuXHJcbiAgICAgICAgLy8vIEEgcmV0dXJuIHZhbHVlIGluZGljYXRlcyB3aGV0aGVyIHRoZSBjb252ZXJzaW9uIHN1Y2NlZWRlZCBvciBmYWlsZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2YWx1ZVwiPlxyXG4gICAgICAgIC8vLyBBIHN0cmluZyBjb250YWluaW5nIGEgcmVhbCB2ZWN0b3IgdG8gY29udmVydC5cclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmb3JtYXRQcm92aWRlclwiPlxyXG4gICAgICAgIC8vLyBBbiA8c2VlIGNyZWY9XCJJRm9ybWF0UHJvdmlkZXJcIi8+IHRoYXQgc3VwcGxpZXMgY3VsdHVyZS1zcGVjaWZpYyBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIGFib3V0IHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlxyXG4gICAgICAgIC8vLyBUaGUgcGFyc2VkIHZhbHVlLlxyXG4gICAgICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gSWYgdGhlIGNvbnZlcnNpb24gc3VjY2VlZHMsIHRoZSByZXN1bHQgd2lsbCBjb250YWluIGEgY29tcGxleCBudW1iZXIgZXF1aXZhbGVudCB0byB2YWx1ZS5cclxuICAgICAgICAvLy8gT3RoZXJ3aXNlIHRoZSByZXN1bHQgd2lsbCBiZSA8Yz5udWxsPC9jPi5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgXHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHN0cmluZyBUb1R5cGVTdHJpbmcoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5Gb3JtYXQoXCJTcGFyc2VWZWN0b3IgezB9LURvdWJsZSB7MTpQMn0gRmlsbGVkXCIsIENvdW50LCBOb25aZXJvc0NvdW50IC8gKGRvdWJsZSlDb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8vIDxjb3B5cmlnaHQgZmlsZT1cIkRlbnNlTFUuY3NcIiBjb21wYW55PVwiTWF0aC5ORVRcIj5cclxuLy8gTWF0aC5ORVQgTnVtZXJpY3MsIHBhcnQgb2YgdGhlIE1hdGguTkVUIFByb2plY3RcclxuLy8gaHR0cDovL251bWVyaWNzLm1hdGhkb3RuZXQuY29tXHJcbi8vIGh0dHA6Ly9naXRodWIuY29tL21hdGhuZXQvbWF0aG5ldC1udW1lcmljc1xyXG4vL1xyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMyBNYXRoLk5FVFxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxyXG4vLyBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4vLyBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuLy8gcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXHJcbi8vIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4vLyBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xyXG4vLyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4vLyBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXHJcbi8vIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbi8vIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXHJcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxyXG4vLyBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4vLyBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbi8vIDwvY29weXJpZ2h0PlxyXG5cclxudXNpbmcgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkZhY3Rvcml6YXRpb247XHJcbnVzaW5nIFN5c3RlbTtcclxuXHJcblxyXG5uYW1lc3BhY2UgTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhLkRvdWJsZS5GYWN0b3JpemF0aW9uXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyA8cGFyYT5BIGNsYXNzIHdoaWNoIGVuY2Fwc3VsYXRlcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhbiBMVSBmYWN0b3JpemF0aW9uLjwvcGFyYT5cclxuICAgIC8vLyA8cGFyYT5Gb3IgYSBtYXRyaXggQSwgdGhlIExVIGZhY3Rvcml6YXRpb24gaXMgYSBwYWlyIG9mIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4IEwgYW5kXHJcbiAgICAvLy8gdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggVSBzbyB0aGF0IEEgPSBMKlUuPC9wYXJhPlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIC8vLyA8cmVtYXJrcz5cclxuICAgIC8vLyBUaGUgY29tcHV0YXRpb24gb2YgdGhlIExVIGZhY3Rvcml6YXRpb24gaXMgZG9uZSBhdCBjb25zdHJ1Y3Rpb24gdGltZS5cclxuICAgIC8vLyA8L3JlbWFya3M+XHJcbiAgICBpbnRlcm5hbCBzZWFsZWQgY2xhc3MgRGVuc2VMVSA6IExVXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgPHNlZSBjcmVmPVwiRGVuc2VMVVwiLz4gY2xhc3MuIFRoaXMgb2JqZWN0IHdpbGwgY29tcHV0ZSB0aGVcclxuICAgICAgICAvLy8gTFUgZmFjdG9yaXphdGlvbiB3aGVuIHRoZSBjb25zdHJ1Y3RvciBpcyBjYWxsZWQgYW5kIGNhY2hlIGl0J3MgZmFjdG9yaXphdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1hdHJpeFwiPlRoZSBtYXRyaXggdG8gZmFjdG9yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIkFyZ3VtZW50TnVsbEV4Y2VwdGlvblwiPklmIDxwYXJhbXJlZiBuYW1lPVwibWF0cml4XCIvPiBpcyA8Yz5udWxsPC9jPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnRFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cIm1hdHJpeFwiLz4gaXMgbm90IGEgc3F1YXJlIG1hdHJpeC48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlTFUgQ3JlYXRlKERlbnNlTWF0cml4IG1hdHJpeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChtYXRyaXggPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcIm1hdHJpeFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG1hdHJpeC5Sb3dDb3VudCAhPSBtYXRyaXguQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeFNxdWFyZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGFycmF5IGZvciB0aGUgcGl2b3QgaW5kaWNlcy5cclxuICAgICAgICAgICAgdmFyIHBpdm90cyA9IG5ldyBpbnRbbWF0cml4LlJvd0NvdW50XTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBtYXRyaXggZm9yIHRoZSBMVSBmYWN0b3JzLCB0aGVuIHBlcmZvcm0gZmFjdG9yaXphdGlvbiAod2hpbGUgb3ZlcndyaXRpbmcpLlxyXG4gICAgICAgICAgICB2YXIgZmFjdG9ycyA9IChEZW5zZU1hdHJpeCkgbWF0cml4LkNsb25lKCk7XHJcbiAgICAgICAgICAgIC8vTGluZWFyQWxnZWJyYUNvbnRyb2wuUHJvdmlkZXIuTFVGYWN0b3IoZmFjdG9ycy5WYWx1ZXMsIGZhY3RvcnMuUm93Q291bnQsIHBpdm90cyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlTFUoZmFjdG9ycywgcGl2b3RzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIERlbnNlTFUoTWF0cml4PGRvdWJsZT4gZmFjdG9ycywgaW50W10gcGl2b3RzKVxyXG4gICAgICAgICAgICA6IGJhc2UoZmFjdG9ycywgcGl2b3RzKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29sdmVzIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMsIDxjPkFYID0gQjwvYz4sIHdpdGggQSBMVSBmYWN0b3JpemVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5wdXRcIj5UaGUgcmlnaHQgaGFuZCBzaWRlIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4sIDxjPkI8L2M+LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIGxlZnQgaGFuZCBzaWRlIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4sIDxjPlg8L2M+LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgU29sdmUoTWF0cml4PGRvdWJsZT4gaW5wdXQsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBwcm9wZXIgYXJndW1lbnRzLlxyXG4gICAgICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImlucHV0XCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJyZXN1bHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBwcm9wZXIgZGltZW5zaW9ucy5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5Sb3dDb3VudCAhPSBpbnB1dC5Sb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4U2FtZVJvd0RpbWVuc2lvblwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5Db2x1bW5Db3VudCAhPSBpbnB1dC5Db2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4U2FtZUNvbHVtbkRpbWVuc2lvblwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGlucHV0LlJvd0NvdW50ICE9IEZhY3RvcnMuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IE1hdHJpeC5EaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPihpbnB1dCwgRmFjdG9ycyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkaW5wdXQgPSBpbnB1dCBhcyBEZW5zZU1hdHJpeDtcclxuICAgICAgICAgICAgaWYgKGRpbnB1dCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXhjZXB0aW9uKFwiQ2FuIG9ubHkgZG8gTFUgZmFjdG9yaXphdGlvbiBmb3IgZGVuc2UgbWF0cmljZXMgYXQgdGhlIG1vbWVudC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkcmVzdWx0ID0gcmVzdWx0IGFzIERlbnNlTWF0cml4O1xyXG4gICAgICAgICAgICBpZiAoZHJlc3VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXhjZXB0aW9uKFwiQ2FuIG9ubHkgZG8gTFUgZmFjdG9yaXphdGlvbiBmb3IgZGVuc2UgbWF0cmljZXMgYXQgdGhlIG1vbWVudC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvcHkgdGhlIGNvbnRlbnRzIG9mIGlucHV0IHRvIHJlc3VsdC5cclxuICAgICAgICAgICAgQXJyYXkuQ29weShkaW5wdXQuVmFsdWVzLCAwLCBkcmVzdWx0LlZhbHVlcywgMCwgZGlucHV0LlZhbHVlcy5MZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgLy8gTFUgc29sdmUgYnkgb3ZlcndyaXRpbmcgcmVzdWx0LlxyXG4gICAgICAgICAgICB2YXIgZGZhY3RvcnMgPSAoRGVuc2VNYXRyaXgpIEZhY3RvcnM7XHJcbiAgICAgICAgICAgIC8vTGluZWFyQWxnZWJyYUNvbnRyb2wuUHJvdmlkZXIuTFVTb2x2ZUZhY3RvcmVkKGlucHV0LkNvbHVtbkNvdW50LCBkZmFjdG9ycy5WYWx1ZXMsIGRmYWN0b3JzLlJvd0NvdW50LCBQaXZvdHMsIGRyZXN1bHQuVmFsdWVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29sdmVzIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMsIDxjPkF4ID0gYjwvYz4sIHdpdGggQSBMVSBmYWN0b3JpemVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5wdXRcIj5UaGUgcmlnaHQgaGFuZCBzaWRlIHZlY3RvciwgPGM+YjwvYz4uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN1bHRcIj5UaGUgbGVmdCBoYW5kIHNpZGUgPHNlZSBjcmVmPVwiTWF0cml4e1R9XCIvPiwgPGM+eDwvYz4uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBTb2x2ZShWZWN0b3I8ZG91YmxlPiBpbnB1dCwgVmVjdG9yPGRvdWJsZT4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHByb3BlciBhcmd1bWVudHMuXHJcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwiaW5wdXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInJlc3VsdFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHByb3BlciBkaW1lbnNpb25zLlxyXG4gICAgICAgICAgICBpZiAoaW5wdXQuQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGlucHV0LkNvdW50ICE9IEZhY3RvcnMuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IE1hdHJpeC5EaW1lbnNpb25zRG9udE1hdGNoPEFyZ3VtZW50RXhjZXB0aW9uPihpbnB1dCwgRmFjdG9ycyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkaW5wdXQgPSBpbnB1dCBhcyBEZW5zZVZlY3RvcjtcclxuICAgICAgICAgICAgaWYgKGRpbnB1dCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkRXhjZXB0aW9uKFwiQ2FuIG9ubHkgZG8gTFUgZmFjdG9yaXphdGlvbiBmb3IgZGVuc2UgdmVjdG9ycyBhdCB0aGUgbW9tZW50LlwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRyZXN1bHQgPSByZXN1bHQgYXMgRGVuc2VWZWN0b3I7XHJcbiAgICAgICAgICAgIGlmIChkcmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFeGNlcHRpb24oXCJDYW4gb25seSBkbyBMVSBmYWN0b3JpemF0aW9uIGZvciBkZW5zZSB2ZWN0b3JzIGF0IHRoZSBtb21lbnQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb3B5IHRoZSBjb250ZW50cyBvZiBpbnB1dCB0byByZXN1bHQuXHJcbiAgICAgICAgICAgIEFycmF5LkNvcHkoZGlucHV0LlZhbHVlcywgMCwgZHJlc3VsdC5WYWx1ZXMsIDAsIGRpbnB1dC5WYWx1ZXMuTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIExVIHNvbHZlIGJ5IG92ZXJ3cml0aW5nIHJlc3VsdC5cclxuICAgICAgICAgICAgdmFyIGRmYWN0b3JzID0gKERlbnNlTWF0cml4KSBGYWN0b3JzO1xyXG4gICAgICAgICAgICAvL0xpbmVhckFsZ2VicmFDb250cm9sLlByb3ZpZGVyLkxVU29sdmVGYWN0b3JlZCgxLCBkZmFjdG9ycy5WYWx1ZXMsIGRmYWN0b3JzLlJvd0NvdW50LCBQaXZvdHMsIGRyZXN1bHQuVmFsdWVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGlzIG1hdHJpeC4gVGhlIGludmVyc2UgaXMgY2FsY3VsYXRlZCB1c2luZyBMVSBkZWNvbXBvc2l0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBpbnZlcnNlIG9mIHRoaXMgbWF0cml4LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgTWF0cml4PGRvdWJsZT4gSW52ZXJzZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gKERlbnNlTWF0cml4KSBGYWN0b3JzLkNsb25lKCk7XHJcbiAgICAgICAgICAgIC8vTGluZWFyQWxnZWJyYUNvbnRyb2wuUHJvdmlkZXIuTFVJbnZlcnNlRmFjdG9yZWQocmVzdWx0LlZhbHVlcywgcmVzdWx0LlJvd0NvdW50LCBQaXZvdHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvLyA8Y29weXJpZ2h0IGZpbGU9XCJEZW5zZVN2ZC5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDEzIE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBTeXN0ZW07XHJcblxyXG5cclxubmFtZXNwYWNlIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGUuRmFjdG9yaXphdGlvblxyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gPHBhcmE+QSBjbGFzcyB3aGljaCBlbmNhcHN1bGF0ZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gKFNWRCkgZm9yIDxzZWUgY3JlZj1cIkRlbnNlTWF0cml4XCIvPi48L3BhcmE+XHJcbiAgICAvLy8gPHBhcmE+U3VwcG9zZSBNIGlzIGFuIG0tYnktbiBtYXRyaXggd2hvc2UgZW50cmllcyBhcmUgcmVhbCBudW1iZXJzLlxyXG4gICAgLy8vIFRoZW4gdGhlcmUgZXhpc3RzIGEgZmFjdG9yaXphdGlvbiBvZiB0aGUgZm9ybSBNID0gVc6jVlQgd2hlcmU6XHJcbiAgICAvLy8gLSBVIGlzIGFuIG0tYnktbSB1bml0YXJ5IG1hdHJpeDtcclxuICAgIC8vLyAtIM6jIGlzIG0tYnktbiBkaWFnb25hbCBtYXRyaXggd2l0aCBub25uZWdhdGl2ZSByZWFsIG51bWJlcnMgb24gdGhlIGRpYWdvbmFsO1xyXG4gICAgLy8vIC0gVlQgZGVub3RlcyB0cmFuc3Bvc2Ugb2YgViwgYW4gbi1ieS1uIHVuaXRhcnkgbWF0cml4O1xyXG4gICAgLy8vIFN1Y2ggYSBmYWN0b3JpemF0aW9uIGlzIGNhbGxlZCBhIHNpbmd1bGFyLXZhbHVlIGRlY29tcG9zaXRpb24gb2YgTS4gQSBjb21tb24gY29udmVudGlvbiBpcyB0byBvcmRlciB0aGUgZGlhZ29uYWxcclxuICAgIC8vLyBlbnRyaWVzIM6jKGksaSkgaW4gZGVzY2VuZGluZyBvcmRlci4gSW4gdGhpcyBjYXNlLCB0aGUgZGlhZ29uYWwgbWF0cml4IM6jIGlzIHVuaXF1ZWx5IGRldGVybWluZWRcclxuICAgIC8vLyBieSBNICh0aG91Z2ggdGhlIG1hdHJpY2VzIFUgYW5kIFYgYXJlIG5vdCkuIFRoZSBkaWFnb25hbCBlbnRyaWVzIG9mIM6jIGFyZSBrbm93biBhcyB0aGUgc2luZ3VsYXIgdmFsdWVzIG9mIE0uPC9wYXJhPlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIC8vLyA8cmVtYXJrcz5cclxuICAgIC8vLyBUaGUgY29tcHV0YXRpb24gb2YgdGhlIHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gaXMgZG9uZSBhdCBjb25zdHJ1Y3Rpb24gdGltZS5cclxuICAgIC8vLyA8L3JlbWFya3M+XHJcbiAgICBpbnRlcm5hbCBzZWFsZWQgY2xhc3MgRGVuc2VTdmQgOiBTdmRcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSA8c2VlIGNyZWY9XCJEZW5zZVN2ZFwiLz4gY2xhc3MuIFRoaXMgb2JqZWN0IHdpbGwgY29tcHV0ZSB0aGVcclxuICAgICAgICAvLy8gdGhlIHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gd2hlbiB0aGUgY29uc3RydWN0b3IgaXMgY2FsbGVkIGFuZCBjYWNoZSBpdCdzIGRlY29tcG9zaXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtYXRyaXhcIj5UaGUgbWF0cml4IHRvIGZhY3Rvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbXB1dGVWZWN0b3JzXCI+Q29tcHV0ZSB0aGUgc2luZ3VsYXIgVSBhbmQgVlQgdmVjdG9ycyBvciBub3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPGV4Y2VwdGlvbiBjcmVmPVwiQXJndW1lbnROdWxsRXhjZXB0aW9uXCI+SWYgPHBhcmFtcmVmIG5hbWU9XCJtYXRyaXhcIi8+IGlzIDxjPm51bGw8L2M+LjwvZXhjZXB0aW9uPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudEV4Y2VwdGlvblwiPklmIFNWRCBhbGdvcml0aG0gZmFpbGVkIHRvIGNvbnZlcmdlIHdpdGggbWF0cml4IDxwYXJhbXJlZiBuYW1lPVwibWF0cml4XCIvPi48L2V4Y2VwdGlvbj5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIERlbnNlU3ZkIENyZWF0ZShEZW5zZU1hdHJpeCBtYXRyaXgsIGJvb2wgY29tcHV0ZVZlY3RvcnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbm0gPSBNYXRoLk1pbihtYXRyaXguUm93Q291bnQsIG1hdHJpeC5Db2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIHZhciBzID0gbmV3IERlbnNlVmVjdG9yKG5tKTtcclxuICAgICAgICAgICAgdmFyIHUgPSBuZXcgRGVuc2VNYXRyaXgobWF0cml4LlJvd0NvdW50KTtcclxuICAgICAgICAgICAgdmFyIHZ0ID0gbmV3IERlbnNlTWF0cml4KG1hdHJpeC5Db2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIE1hdGhOZXROdW1lcmljcy5NYW5hZ2VkTGluZWFyQWxnZWJyYVByb3ZpZGVyIHN2ZGVyID0gbmV3IE1hdGhOZXROdW1lcmljcy5NYW5hZ2VkTGluZWFyQWxnZWJyYVByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHN2ZGVyLlNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uKGNvbXB1dGVWZWN0b3JzLCAoKERlbnNlTWF0cml4KW1hdHJpeC5DbG9uZSgpKS5WYWx1ZXMsIG1hdHJpeC5Sb3dDb3VudCwgbWF0cml4LkNvbHVtbkNvdW50LCBzLlZhbHVlcywgdS5WYWx1ZXMsIHZ0LlZhbHVlcyk7XHJcbiAgICAgICAgICAgIC8vTGluZWFyQWxnZWJyYUNvbnRyb2wuUHJvdmlkZXIuU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24oY29tcHV0ZVZlY3RvcnMsICgoRGVuc2VNYXRyaXgpIG1hdHJpeC5DbG9uZSgpKS5WYWx1ZXMsIG1hdHJpeC5Sb3dDb3VudCwgbWF0cml4LkNvbHVtbkNvdW50LCBzLlZhbHVlcywgdS5WYWx1ZXMsIHZ0LlZhbHVlcyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbnNlU3ZkKHMsIHUsIHZ0LCBjb21wdXRlVmVjdG9ycyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBEZW5zZVN2ZChWZWN0b3I8ZG91YmxlPiBzLCBNYXRyaXg8ZG91YmxlPiB1LCBNYXRyaXg8ZG91YmxlPiB2dCwgYm9vbCB2ZWN0b3JzQ29tcHV0ZWQpXHJcbiAgICAgICAgICAgIDogYmFzZShzLCB1LCB2dCwgdmVjdG9yc0NvbXB1dGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29sdmVzIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMsIDxiPkFYID0gQjwvYj4sIHdpdGggQSBTVkQgZmFjdG9yaXplZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlucHV0XCI+VGhlIHJpZ2h0IGhhbmQgc2lkZSA8c2VlIGNyZWY9XCJNYXRyaXh7VH1cIi8+LCA8Yj5CPC9iPi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBsZWZ0IGhhbmQgc2lkZSA8c2VlIGNyZWY9XCJNYXRyaXh7VH1cIi8+LCA8Yj5YPC9iPi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIFNvbHZlKE1hdHJpeDxkb3VibGU+IGlucHV0LCBNYXRyaXg8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIVZlY3RvcnNDb21wdXRlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcGVyYXRpb25FeGNlcHRpb24oXCJSZXNvdXJjZXMuU2luZ3VsYXJWZWN0b3JzTm90Q29tcHV0ZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBzb2x1dGlvbiBYIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBjb2x1bW5zIGFzIEJcclxuICAgICAgICAgICAgaWYgKGlucHV0LkNvbHVtbkNvdW50ICE9IHJlc3VsdC5Db2x1bW5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4U2FtZUNvbHVtbkRpbWVuc2lvblwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGRpbWVuc2lvbiBjb21wYXRpYmlsaXR5IGNvbmRpdGlvbnMgZm9yIFggPSBBXFxCIHJlcXVpcmUgdGhlIHR3byBtYXRyaWNlcyBBIGFuZCBCIHRvIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHJvd3NcclxuICAgICAgICAgICAgaWYgKFUuUm93Q291bnQgIT0gaW5wdXQuUm93Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlJlc291cmNlcy5Bcmd1bWVudE1hdHJpeFNhbWVSb3dEaW1lbnNpb25cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBzb2x1dGlvbiBYIHJvdyBkaW1lbnNpb24gaXMgZXF1YWwgdG8gdGhlIGNvbHVtbiBkaW1lbnNpb24gb2YgQVxyXG4gICAgICAgICAgICBpZiAoVlQuQ29sdW1uQ291bnQgIT0gcmVzdWx0LlJvd0NvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRNYXRyaXhTYW1lQ29sdW1uRGltZW5zaW9uXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlucHV0ID0gaW5wdXQgYXMgRGVuc2VNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChkaW5wdXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEV4Y2VwdGlvbihcIkNhbiBvbmx5IGRvIFNWRCBmYWN0b3JpemF0aW9uIGZvciBkZW5zZSBtYXRyaWNlcyBhdCB0aGUgbW9tZW50LlwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRyZXN1bHQgPSByZXN1bHQgYXMgRGVuc2VNYXRyaXg7XHJcbiAgICAgICAgICAgIGlmIChkcmVzdWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFeGNlcHRpb24oXCJDYW4gb25seSBkbyBTVkQgZmFjdG9yaXphdGlvbiBmb3IgZGVuc2UgbWF0cmljZXMgYXQgdGhlIG1vbWVudC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTWF0aE5ldE51bWVyaWNzLk1hbmFnZWRMaW5lYXJBbGdlYnJhUHJvdmlkZXIgc3ZkZXIgPSBuZXcgTWF0aE5ldE51bWVyaWNzLk1hbmFnZWRMaW5lYXJBbGdlYnJhUHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgc3ZkZXIuU3ZkU29sdmVGYWN0b3JlZChVLlJvd0NvdW50LCBWVC5Db2x1bW5Db3VudCwgKChEZW5zZVZlY3RvcilTKS5WYWx1ZXMsICgoRGVuc2VNYXRyaXgpVSkuVmFsdWVzLCAoKERlbnNlTWF0cml4KVZUKS5WYWx1ZXMsIGRpbnB1dC5WYWx1ZXMsIGlucHV0LkNvbHVtbkNvdW50LCBkcmVzdWx0LlZhbHVlcyk7XHJcbiAgICAgICAgICAgIC8vTGluZWFyQWxnZWJyYUNvbnRyb2wuUHJvdmlkZXIuU3ZkU29sdmVGYWN0b3JlZChVLlJvd0NvdW50LCBWVC5Db2x1bW5Db3VudCwgKChEZW5zZVZlY3RvcikgUykuVmFsdWVzLCAoKERlbnNlTWF0cml4KSBVKS5WYWx1ZXMsICgoRGVuc2VNYXRyaXgpIFZUKS5WYWx1ZXMsIGRpbnB1dC5WYWx1ZXMsIGlucHV0LkNvbHVtbkNvdW50LCBkcmVzdWx0LlZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNvbHZlcyBhIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zLCA8Yj5BeCA9IGI8L2I+LCB3aXRoIEEgU1ZEIGZhY3Rvcml6ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnB1dFwiPlRoZSByaWdodCBoYW5kIHNpZGUgdmVjdG9yLCA8Yj5iPC9iPi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3VsdFwiPlRoZSBsZWZ0IGhhbmQgc2lkZSA8c2VlIGNyZWY9XCJNYXRyaXh7VH1cIi8+LCA8Yj54PC9iPi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIFNvbHZlKFZlY3Rvcjxkb3VibGU+IGlucHV0LCBWZWN0b3I8ZG91YmxlPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIVZlY3RvcnNDb21wdXRlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcGVyYXRpb25FeGNlcHRpb24oXCJSZXNvdXJjZXMuU2luZ3VsYXJWZWN0b3JzTm90Q29tcHV0ZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEF4PWIgd2hlcmUgQSBpcyBhbiBtIHggbiBtYXRyaXhcclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCBiIGlzIGEgY29sdW1uIHZlY3RvciB3aXRoIG0gZW50cmllc1xyXG4gICAgICAgICAgICBpZiAoVS5Sb3dDb3VudCAhPSBpbnB1dC5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50VmVjdG9yc1NhbWVMZW5ndGhcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgeCBpcyBhIGNvbHVtbiB2ZWN0b3Igd2l0aCBuIGVudHJpZXNcclxuICAgICAgICAgICAgaWYgKFZULkNvbHVtbkNvdW50ICE9IHJlc3VsdC5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgTWF0cml4LkRpbWVuc2lvbnNEb250TWF0Y2g8QXJndW1lbnRFeGNlcHRpb24+KFZULCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGlucHV0ID0gaW5wdXQgYXMgRGVuc2VWZWN0b3I7XHJcbiAgICAgICAgICAgIGlmIChkaW5wdXQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEV4Y2VwdGlvbihcIkNhbiBvbmx5IGRvIFNWRCBmYWN0b3JpemF0aW9uIGZvciBkZW5zZSB2ZWN0b3JzIGF0IHRoZSBtb21lbnQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZHJlc3VsdCA9IHJlc3VsdCBhcyBEZW5zZVZlY3RvcjtcclxuICAgICAgICAgICAgaWYgKGRyZXN1bHQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEV4Y2VwdGlvbihcIkNhbiBvbmx5IGRvIFNWRCBmYWN0b3JpemF0aW9uIGZvciBkZW5zZSB2ZWN0b3JzIGF0IHRoZSBtb21lbnQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE1hdGhOZXROdW1lcmljcy5NYW5hZ2VkTGluZWFyQWxnZWJyYVByb3ZpZGVyIHN2ZGVyID0gbmV3IE1hdGhOZXROdW1lcmljcy5NYW5hZ2VkTGluZWFyQWxnZWJyYVByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHN2ZGVyLlN2ZFNvbHZlRmFjdG9yZWQoVS5Sb3dDb3VudCwgVlQuQ29sdW1uQ291bnQsICgoRGVuc2VWZWN0b3IpUykuVmFsdWVzLCAoKERlbnNlTWF0cml4KVUpLlZhbHVlcywgKChEZW5zZU1hdHJpeClWVCkuVmFsdWVzLCBkaW5wdXQuVmFsdWVzLCAxLCBkcmVzdWx0LlZhbHVlcyk7XHJcbiAgICAgICAgICAgIC8vTGluZWFyQWxnZWJyYUNvbnRyb2wuUHJvdmlkZXIuU3ZkU29sdmVGYWN0b3JlZChVLlJvd0NvdW50LCBWVC5Db2x1bW5Db3VudCwgKChEZW5zZVZlY3RvcikgUykuVmFsdWVzLCAoKERlbnNlTWF0cml4KSBVKS5WYWx1ZXMsICgoRGVuc2VNYXRyaXgpIFZUKS5WYWx1ZXMsIGRpbnB1dC5WYWx1ZXMsIDEsIGRyZXN1bHQuVmFsdWVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gPGNvcHlyaWdodCBmaWxlPVwiVXNlclN2ZC5jc1wiIGNvbXBhbnk9XCJNYXRoLk5FVFwiPlxyXG4vLyBNYXRoLk5FVCBOdW1lcmljcywgcGFydCBvZiB0aGUgTWF0aC5ORVQgUHJvamVjdFxyXG4vLyBodHRwOi8vbnVtZXJpY3MubWF0aGRvdG5ldC5jb21cclxuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWF0aG5ldC9tYXRobmV0LW51bWVyaWNzXHJcbi8vXHJcbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDEzIE1hdGguTkVUXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbi8vIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbi8vIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxyXG4vLyByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuLy8gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXHJcbi8vIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbi8vIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbi8vIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuLy8gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbi8vIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbi8vIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuLy8gPC9jb3B5cmlnaHQ+XHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGUuTWF0aE5ldC5OdW1lcmljcy5MaW5lYXJBbGdlYnJhO1xyXG5cclxubmFtZXNwYWNlIE1hdGhOZXQuTnVtZXJpY3MuTGluZWFyQWxnZWJyYS5Eb3VibGUuRmFjdG9yaXphdGlvblxyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gPHBhcmE+QSBjbGFzcyB3aGljaCBlbmNhcHN1bGF0ZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gKFNWRCkgZm9yIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4uPC9wYXJhPlxyXG4gICAgLy8vIDxwYXJhPlN1cHBvc2UgTSBpcyBhbiBtLWJ5LW4gbWF0cml4IHdob3NlIGVudHJpZXMgYXJlIHJlYWwgbnVtYmVycy5cclxuICAgIC8vLyBUaGVuIHRoZXJlIGV4aXN0cyBhIGZhY3Rvcml6YXRpb24gb2YgdGhlIGZvcm0gTSA9IFXOo1ZUIHdoZXJlOlxyXG4gICAgLy8vIC0gVSBpcyBhbiBtLWJ5LW0gdW5pdGFyeSBtYXRyaXg7XHJcbiAgICAvLy8gLSDOoyBpcyBtLWJ5LW4gZGlhZ29uYWwgbWF0cml4IHdpdGggbm9ubmVnYXRpdmUgcmVhbCBudW1iZXJzIG9uIHRoZSBkaWFnb25hbDtcclxuICAgIC8vLyAtIFZUIGRlbm90ZXMgdHJhbnNwb3NlIG9mIFYsIGFuIG4tYnktbiB1bml0YXJ5IG1hdHJpeDtcclxuICAgIC8vLyBTdWNoIGEgZmFjdG9yaXphdGlvbiBpcyBjYWxsZWQgYSBzaW5ndWxhci12YWx1ZSBkZWNvbXBvc2l0aW9uIG9mIE0uIEEgY29tbW9uIGNvbnZlbnRpb24gaXMgdG8gb3JkZXIgdGhlIGRpYWdvbmFsXHJcbiAgICAvLy8gZW50cmllcyDOoyhpLGkpIGluIGRlc2NlbmRpbmcgb3JkZXIuIEluIHRoaXMgY2FzZSwgdGhlIGRpYWdvbmFsIG1hdHJpeCDOoyBpcyB1bmlxdWVseSBkZXRlcm1pbmVkXHJcbiAgICAvLy8gYnkgTSAodGhvdWdoIHRoZSBtYXRyaWNlcyBVIGFuZCBWIGFyZSBub3QpLiBUaGUgZGlhZ29uYWwgZW50cmllcyBvZiDOoyBhcmUga25vd24gYXMgdGhlIHNpbmd1bGFyIHZhbHVlcyBvZiBNLjwvcGFyYT5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAvLy8gPHJlbWFya3M+XHJcbiAgICAvLy8gVGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBzaW5ndWxhciB2YWx1ZSBkZWNvbXBvc2l0aW9uIGlzIGRvbmUgYXQgY29uc3RydWN0aW9uIHRpbWUuXHJcbiAgICAvLy8gPC9yZW1hcmtzPlxyXG4gICAgaW50ZXJuYWwgc2VhbGVkIGNsYXNzIFVzZXJTdmQgOiBTdmRcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSA8c2VlIGNyZWY9XCJVc2VyU3ZkXCIvPiBjbGFzcy4gVGhpcyBvYmplY3Qgd2lsbCBjb21wdXRlIHRoZVxyXG4gICAgICAgIC8vLyB0aGUgc2luZ3VsYXIgdmFsdWUgZGVjb21wb3NpdGlvbiB3aGVuIHRoZSBjb25zdHJ1Y3RvciBpcyBjYWxsZWQgYW5kIGNhY2hlIGl0J3MgZGVjb21wb3NpdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1hdHJpeFwiPlRoZSBtYXRyaXggdG8gZmFjdG9yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29tcHV0ZVZlY3RvcnNcIj5Db21wdXRlIHRoZSBzaW5ndWxhciBVIGFuZCBWVCB2ZWN0b3JzIG9yIG5vdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8ZXhjZXB0aW9uIGNyZWY9XCJBcmd1bWVudE51bGxFeGNlcHRpb25cIj5JZiA8cGFyYW1yZWYgbmFtZT1cIm1hdHJpeFwiLz4gaXMgPGM+bnVsbDwvYz4uPC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIDxleGNlcHRpb24gY3JlZj1cIk5vbkNvbnZlcmdlbmNlRXhjZXB0aW9uXCI+PC9leGNlcHRpb24+XHJcbiAgICAgICAgLy8vIFxyXG5cclxuICAgICAgICBwcml2YXRlIG5ldyBzdGF0aWMgVmVjdG9yQnVpbGRlcjxkb3VibGU+IHZfYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxkb3VibGU+LlZlY3RvcjtcclxuICAgICAgICBwcml2YXRlIG5ldyBzdGF0aWMgTWF0cml4QnVpbGRlcjxkb3VibGU+IG1fYnVpbGRlciA9IEJ1aWxkZXJJbnN0YW5jZTxkb3VibGU+Lk1hdHJpeDtcclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBVc2VyU3ZkIENyZWF0ZShNYXRyaXg8ZG91YmxlPiBtYXRyaXgsIGJvb2wgY29tcHV0ZVZlY3RvcnMpXHJcbiAgICAgICAge1xyXG5TeXN0ZW0uRnVuYzxkb3VibGUsIGRvdWJsZSwgYm9vbD4gQWxtb3N0RXF1YWxzID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBubSA9IE1hdGguTWluKG1hdHJpeC5Sb3dDb3VudCArIDEsIG1hdHJpeC5Db2x1bW5Db3VudCk7XHJcbiAgICAgICAgICAgIHZhciBtYXRyaXhDb3B5ID0gbWF0cml4LkNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcyA9IHZfYnVpbGRlci5TYW1lQXM8ZG91YmxlPihtYXRyaXhDb3B5LCBubSk7XHJcbiAgICAgICAgICAgIHZhciB1ID0gbV9idWlsZGVyLlNhbWVBczxkb3VibGU+KG1hdHJpeENvcHksIG1hdHJpeENvcHkuUm93Q291bnQsIG1hdHJpeENvcHkuUm93Q291bnQsIGZ1bGx5TXV0YWJsZTogdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciB2dCA9IG1fYnVpbGRlci5TYW1lQXM8ZG91YmxlPihtYXRyaXhDb3B5LCBtYXRyaXhDb3B5LkNvbHVtbkNvdW50LCBtYXRyaXhDb3B5LkNvbHVtbkNvdW50LCBmdWxseU11dGFibGU6IHRydWUpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgaW50IG1heGl0ZXIgPSAxMDAwO1xyXG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBkb3VibGVbbWF0cml4Q29weS5Db2x1bW5Db3VudF07XHJcbiAgICAgICAgICAgIHZhciB3b3JrID0gbmV3IGRvdWJsZVttYXRyaXhDb3B5LlJvd0NvdW50XTtcclxuICAgICAgICAgICAgaW50IGksIGo7XHJcbiAgICAgICAgICAgIGludCBsLCBscDE7XHJcbiAgICAgICAgICAgIGRvdWJsZSB0O1xyXG5cclxuICAgICAgICAgICAgdmFyIG5jdSA9IG1hdHJpeENvcHkuUm93Q291bnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWR1Y2UgbWF0cml4Q29weSB0byBiaWRpYWdvbmFsIGZvcm0sIHN0b3JpbmcgdGhlIGRpYWdvbmFsIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIC8vIEluIHMgYW5kIHRoZSBzdXBlci1kaWFnb25hbCBlbGVtZW50cyBpbiBlLlxyXG4gICAgICAgICAgICB2YXIgbmN0ID0gTWF0aC5NaW4obWF0cml4Q29weS5Sb3dDb3VudCAtIDEsIG1hdHJpeENvcHkuQ29sdW1uQ291bnQpO1xyXG4gICAgICAgICAgICB2YXIgbnJ0ID0gTWF0aC5NYXgoMCwgTWF0aC5NaW4obWF0cml4Q29weS5Db2x1bW5Db3VudCAtIDIsIG1hdHJpeENvcHkuUm93Q291bnQpKTtcclxuICAgICAgICAgICAgdmFyIGx1ID0gTWF0aC5NYXgobmN0LCBucnQpO1xyXG4gICAgICAgICAgICBmb3IgKGwgPSAwOyBsIDwgbHU7IGwrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbHAxID0gbCArIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAobCA8IG5jdClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSB0cmFuc2Zvcm1hdGlvbiBmb3IgdGhlIGwtdGggY29sdW1uIGFuZCBwbGFjZSB0aGUgbC10aCBkaWFnb25hbCBpbiBWZWN0b3JTW2xdLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4bm9ybSA9IERucm0yQ29sdW1uKG1hdHJpeENvcHksIG1hdHJpeENvcHkuUm93Q291bnQsIGwsIGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNbbF0gPSB4bm9ybTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc1tsXSAhPSAwLjApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0cml4Q29weS5BdChsLCBsKSAhPSAwLjApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNbbF0gPSBEc2lnbihzW2xdLCBtYXRyaXhDb3B5LkF0KGwsIGwpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgRHNjYWxDb2x1bW4obWF0cml4Q29weSwgbWF0cml4Q29weS5Sb3dDb3VudCwgbCwgbCwgMS4wL3NbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXhDb3B5LkF0KGwsIGwsICgxLjAgKyBtYXRyaXhDb3B5LkF0KGwsIGwpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzW2xdID0gLXNbbF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gbHAxOyBqIDwgbWF0cml4Q29weS5Db2x1bW5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsIDwgbmN0KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNbbF0gIT0gMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUgdHJhbnNmb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gLURkb3QobWF0cml4Q29weSwgbWF0cml4Q29weS5Sb3dDb3VudCwgbCwgaiwgbCkvbWF0cml4Q29weS5BdChsLCBsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gbDsgaWkgPCBtYXRyaXhDb3B5LlJvd0NvdW50OyBpaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeENvcHkuQXQoaWksIGosIG1hdHJpeENvcHkuQXQoaWksIGopICsgKHQqbWF0cml4Q29weS5BdChpaSwgbCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgdGhlIGwtdGggcm93IG9mIG1hdHJpeENvcHkgaW50byAgZSBmb3IgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3Vic2VxdWVudCBjYWxjdWxhdGlvbiBvZiB0aGUgcm93IHRyYW5zZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIGVbal0gPSBtYXRyaXhDb3B5LkF0KGwsIGopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb21wdXRlVmVjdG9ycyAmJiBsIDwgbmN0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIHRoZSB0cmFuc2Zvcm1hdGlvbiBpbiB1IGZvciBzdWJzZXF1ZW50IGJhY2sgbXVsdGlwbGljYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gbDsgaSA8IG1hdHJpeENvcHkuUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHUuQXQoaSwgbCwgbWF0cml4Q29weS5BdChpLCBsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsID49IG5ydClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBsLXRoIHJvdyB0cmFuc2Zvcm1hdGlvbiBhbmQgcGxhY2UgdGhlIGwtdGggc3VwZXItZGlhZ29uYWwgaW4gZShsKS5cclxuICAgICAgICAgICAgICAgIHZhciBlbm9ybSA9IERucm0yVmVjdG9yKGUsIGxwMSk7XHJcbiAgICAgICAgICAgICAgICBlW2xdID0gZW5vcm07XHJcbiAgICAgICAgICAgICAgICBpZiAoZVtsXSAhPSAwLjApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVbbHAxXSAhPSAwLjApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlW2xdID0gRHNpZ24oZVtsXSwgZVtscDFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIERzY2FsVmVjdG9yKGUsIGxwMSwgMS4wL2VbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVbbHAxXSA9IDEuMCArIGVbbHAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlW2xdID0gLWVbbF07XHJcbiAgICAgICAgICAgICAgICBpZiAobHAxIDwgbWF0cml4Q29weS5Sb3dDb3VudCAmJiBlW2xdICE9IDAuMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUgdHJhbnNmb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gbHAxOyBpIDwgbWF0cml4Q29weS5Sb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya1tpXSA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGxwMTsgaiA8IG1hdHJpeENvcHkuQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gbHAxOyBpaSA8IG1hdHJpeENvcHkuUm93Q291bnQ7IGlpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtbaWldICs9IGVbal0qbWF0cml4Q29weS5BdChpaSwgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGxwMTsgaiA8IG1hdHJpeENvcHkuQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3dyA9IC1lW2pdL2VbbHAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSBscDE7IGlpIDwgbWF0cml4Q29weS5Sb3dDb3VudDsgaWkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4Q29weS5BdChpaSwgaiwgbWF0cml4Q29weS5BdChpaSwgaikgKyAod3cqd29ya1tpaV0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZVZlY3RvcnMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgdGhlIHRyYW5zZm9ybWF0aW9uIGluIHYgZm9yIHN1YnNlcXVlbnQgYmFjayBtdWx0aXBsaWNhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBscDE7IGkgPCBtYXRyaXhDb3B5LkNvbHVtbkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2dC5BdChpLCBsLCBlW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBmaW5hbCBiaWRpYWdvbmFsIG1hdHJpeENvcHkgb3Igb3JkZXIgbS5cclxuICAgICAgICAgICAgdmFyIG0gPSBNYXRoLk1pbihtYXRyaXhDb3B5LkNvbHVtbkNvdW50LCBtYXRyaXhDb3B5LlJvd0NvdW50ICsgMSk7XHJcbiAgICAgICAgICAgIHZhciBuY3RwMSA9IG5jdCArIDE7XHJcbiAgICAgICAgICAgIHZhciBucnRwMSA9IG5ydCArIDE7XHJcbiAgICAgICAgICAgIGlmIChuY3QgPCBtYXRyaXhDb3B5LkNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzW25jdHAxIC0gMV0gPSBtYXRyaXhDb3B5LkF0KChuY3RwMSAtIDEpLCAobmN0cDEgLSAxKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChtYXRyaXhDb3B5LlJvd0NvdW50IDwgbSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc1ttIC0gMV0gPSAwLjA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChucnRwMSA8IG0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGVbbnJ0cDEgLSAxXSA9IG1hdHJpeENvcHkuQXQoKG5ydHAxIC0gMSksIChtIC0gMSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlW20gLSAxXSA9IDAuMDtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHJlcXVpcmVkLCBnZW5lcmF0ZSB1LlxyXG4gICAgICAgICAgICBpZiAoY29tcHV0ZVZlY3RvcnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IG5jdHAxIC0gMTsgaiA8IG5jdTsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXRyaXhDb3B5LlJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1LkF0KGksIGosIDAuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB1LkF0KGosIGosIDEuMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsID0gbmN0IC0gMTsgbCA+PSAwOyBsLS0pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNbbF0gIT0gMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gbCArIDE7IGogPCBuY3U7IGorKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IC1EZG90KHUsIG1hdHJpeENvcHkuUm93Q291bnQsIGwsIGosIGwpL3UuQXQobCwgbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IGw7IGlpIDwgbWF0cml4Q29weS5Sb3dDb3VudDsgaWkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1LkF0KGlpLCBqLCB1LkF0KGlpLCBqKSArICh0KnUuQXQoaWksIGwpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERzY2FsQ29sdW1uKHUsIG1hdHJpeENvcHkuUm93Q291bnQsIGwsIGwsIC0xLjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1LkF0KGwsIGwsIDEuMCArIHUuQXQobCwgbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1LkF0KGksIGwsIDAuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hdHJpeENvcHkuUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdS5BdChpLCBsLCAwLjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1LkF0KGwsIGwsIDEuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBpdCBpcyByZXF1aXJlZCwgZ2VuZXJhdGUgdi5cclxuICAgICAgICAgICAgaWYgKGNvbXB1dGVWZWN0b3JzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGwgPSBtYXRyaXhDb3B5LkNvbHVtbkNvdW50IC0gMTsgbCA+PSAwOyBsLS0pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbHAxID0gbCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwgPCBucnQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtsXSAhPSAwLjApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGxwMTsgaiA8IG1hdHJpeENvcHkuQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gLURkb3QodnQsIG1hdHJpeENvcHkuQ29sdW1uQ291bnQsIGwsIGosIGxwMSkvdnQuQXQobHAxLCBsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IGw7IGlpIDwgbWF0cml4Q29weS5Db2x1bW5Db3VudDsgaWkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZ0LkF0KGlpLCBqLCB2dC5BdChpaSwgaikgKyAodCp2dC5BdChpaSwgbCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXRyaXhDb3B5LkNvbHVtbkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2dC5BdChpLCBsLCAwLjApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdnQuQXQobCwgbCwgMS4wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHMgYW5kIGUgc28gdGhhdCB0aGV5IGFyZSAgZG91YmxlIC5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG07IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIHI7XHJcbiAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPSAwLjApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHNbaV0vdDtcclxuICAgICAgICAgICAgICAgICAgICBzW2ldID0gdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IG0gLSAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVtpXSA9IGVbaV0vcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wdXRlVmVjdG9ycylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERzY2FsQ29sdW1uKHUsIG1hdHJpeENvcHkuUm93Q291bnQsIGksIDAsIHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeGl0XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBtIC0gMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZVtpXSAhPSAwLjApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IGVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHQvZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICBlW2ldID0gdDtcclxuICAgICAgICAgICAgICAgICAgICBzW2kgKyAxXSA9IHNbaSArIDFdKnI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVWZWN0b3JzKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRHNjYWxDb2x1bW4odnQsIG1hdHJpeENvcHkuQ29sdW1uQ291bnQsIGkgKyAxLCAwLCByKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE1haW4gaXRlcmF0aW9uIGxvb3AgZm9yIHRoZSBzaW5ndWxhciB2YWx1ZXMuXHJcbiAgICAgICAgICAgIHZhciBtbiA9IG07XHJcbiAgICAgICAgICAgIHZhciBpdGVyID0gMDtcclxuICAgICAgICAgICAgXHJcbkFsbW9zdEVxdWFscyA9ICh2YWwxLCB2YWwyKSA9PlxyXG57XHJcbiAgICBpZiAoTWF0aC5BYnModmFsMSAtIHZhbDIpIDwgMWUtOClcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuO1xuXHJcbiAgICAgICAgICAgIHdoaWxlIChtID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gUXVpdCBpZiBhbGwgdGhlIHNpbmd1bGFyIHZhbHVlcyBoYXZlIGJlZW4gZm91bmQuIElmIHRvbyBtYW55IGl0ZXJhdGlvbnMgaGF2ZSBiZWVuIHBlcmZvcm1lZCxcclxuICAgICAgICAgICAgICAgIC8vIHRocm93IGV4Y2VwdGlvbiB0aGF0IENvbnZlcmdlbmNlIEZhaWxlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIgPj0gbWF4aXRlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJOb25Db252ZXJnZW5jZUV4Y2VwdGlvbigpXCIpOyA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzZWN0aW9uIG9mIHRoZSBwcm9ncmFtIGluc3BlY3RzIGZvciBuZWdsaWdpYmxlIGVsZW1lbnRzIGluIHRoZSBzIGFuZCBlIGFycmF5cy4gT25cclxuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRpb24gdGhlIHZhcmlhYmxlcyBjYXNlIGFuZCBsIGFyZSBzZXQgYXMgZm9sbG93cy5cclxuICAgICAgICAgICAgICAgIC8vIENhc2UgPSAxICAgICBpZiBWZWN0b3JTW21dIGFuZCBlW2wtMV0gYXJlIG5lZ2xpZ2libGUgYW5kIGwgPCBtXHJcbiAgICAgICAgICAgICAgICAvLyBDYXNlID0gMiAgICAgaWYgVmVjdG9yU1tsXSBpcyBuZWdsaWdpYmxlIGFuZCBsIDwgbVxyXG4gICAgICAgICAgICAgICAgLy8gQ2FzZSA9IDMgICAgIGlmIGVbbC0xXSBpcyBuZWdsaWdpYmxlLCBsIDwgbSwgYW5kIFZlY3RvclNbbCwgLi4uLCBWZWN0b3JTW21dIGFyZSBub3QgbmVnbGlnaWJsZSAocXIgc3RlcCkuXHJcbiAgICAgICAgICAgICAgICAvLyBDYXNlID0gNCAgICAgaWYgZVttLTFdIGlzIG5lZ2xpZ2libGUgKGNvbnZlcmdlbmNlKS5cclxuICAgICAgICAgICAgICAgIGRvdWJsZSB6dGVzdDtcclxuICAgICAgICAgICAgICAgIGRvdWJsZSB0ZXN0O1xyXG4gICAgICAgICAgICAgICAgZm9yIChsID0gbSAtIDI7IGwgPj0gMDsgbC0tKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3QgPSBNYXRoLkFicyhzW2xdKSArIE1hdGguQWJzKHNbbCArIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICB6dGVzdCA9IHRlc3QgKyBNYXRoLkFicyhlW2xdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQWxtb3N0RXF1YWxzKHRlc3QsIHp0ZXN0KSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVbbF0gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpbnQga2FzZTtcclxuICAgICAgICAgICAgICAgIGlmIChsID09IG0gLSAyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGthc2UgPSA0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBscztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxzID0gbSAtIDE7IGxzID4gbDsgbHMtLSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChscyAhPSBtIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdCA9IHRlc3QgKyBNYXRoLkFicyhlW2xzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChscyAhPSBsICsgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdCA9IHRlc3QgKyBNYXRoLkFicyhlW2xzIC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB6dGVzdCA9IHRlc3QgKyBNYXRoLkFicyhzW2xzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBbG1vc3RFcXVhbHModGVzdCwgenRlc3QpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzW2xzXSA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobHMgPT0gbClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGthc2UgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChscyA9PSBtIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGthc2UgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrYXNlID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IGxzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsID0gbCArIDE7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIHRhc2sgaW5kaWNhdGVkIGJ5IGNhc2UuXHJcbiAgICAgICAgICAgICAgICBpbnQgaztcclxuICAgICAgICAgICAgICAgIGRvdWJsZSBmO1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIHNuO1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIGNzO1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIHQxO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChrYXNlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZsYXRlIG5lZ2xpZ2libGUgVmVjdG9yU1ttXS5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBlW20gLSAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVttIC0gMl0gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtrID0gbDsga2sgPCBtIC0gMTsga2srKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IG0gLSAyIC0ga2sgKyBsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDEgPSBzW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRHJvdGcocmVmIHQxLCByZWYgZiwgb3V0IGNzLCBvdXQgc24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc1trXSA9IHQxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGsgIT0gbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gLXNuKmVbayAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVbayAtIDFdID0gY3MqZVtrIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVWZWN0b3JzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERyb3QodnQsIG1hdHJpeENvcHkuQ29sdW1uQ291bnQsIGssIG0gLSAxLCBjcywgc24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwbGl0IGF0IG5lZ2xpZ2libGUgVmVjdG9yU1tsXS5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBlW2wgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVtsIC0gMV0gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IGw7IGsgPCBtOyBrKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gc1trXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERyb3RnKHJlZiB0MSwgcmVmIGYsIG91dCBjcywgb3V0IHNuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNba10gPSB0MTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAtc24qZVtrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVba10gPSBjcyplW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVWZWN0b3JzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERyb3QodSwgbWF0cml4Q29weS5Sb3dDb3VudCwgaywgbCAtIDEsIGNzLCBzbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIG9uZSBxciBzdGVwLlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzaGlmdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IE1hdGguTWF4KHNjYWxlLCBNYXRoLkFicyhzW20gLSAxXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IE1hdGguTWF4KHNjYWxlLCBNYXRoLkFicyhzW20gLSAyXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IE1hdGguTWF4KHNjYWxlLCBNYXRoLkFicyhlW20gLSAyXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IE1hdGguTWF4KHNjYWxlLCBNYXRoLkFicyhzW2xdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlID0gTWF0aC5NYXgoc2NhbGUsIE1hdGguQWJzKGVbbF0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNtID0gc1ttIC0gMV0vc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbW0xID0gc1ttIC0gMl0vc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbW0xID0gZVttIC0gMl0vc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbCA9IHNbbF0vc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGVbbF0vc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gKCgoc21tMSArIHNtKSooc21tMSAtIHNtKSkgKyAoZW1tMSplbW0xKSkvMi4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IChzbSplbW0xKSooc20qZW1tMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGlmdCA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgIT0gMC4wIHx8IGMgIT0gMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IE1hdGguU3FydCgoYipiKSArIGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgPCAwLjApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAtc2hpZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBjLyhiICsgc2hpZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gKChzbCArIHNtKSooc2wgLSBzbSkpICsgc2hpZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnID0gc2wqZWw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGFzZSB6ZXJvcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gbDsgayA8IG0gLSAxOyBrKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERyb3RnKHJlZiBmLCByZWYgZywgb3V0IGNzLCBvdXQgc24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGsgIT0gbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlW2sgLSAxXSA9IGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IChjcypzW2tdKSArIChzbiplW2tdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVba10gPSAoY3MqZVtrXSkgLSAoc24qc1trXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gc24qc1trICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzW2sgKyAxXSA9IGNzKnNbayArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVWZWN0b3JzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERyb3QodnQsIG1hdHJpeENvcHkuQ29sdW1uQ291bnQsIGssIGsgKyAxLCBjcywgc24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERyb3RnKHJlZiBmLCByZWYgZywgb3V0IGNzLCBvdXQgc24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc1trXSA9IGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gKGNzKmVba10pICsgKHNuKnNbayArIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNbayArIDFdID0gKC1zbiplW2tdKSArIChjcypzW2sgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gc24qZVtrICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlW2sgKyAxXSA9IGNzKmVbayArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVWZWN0b3JzICYmIGsgPCBtYXRyaXhDb3B5LlJvd0NvdW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERyb3QodSwgbWF0cml4Q29weS5Sb3dDb3VudCwgaywgayArIDEsIGNzLCBzbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVbbSAtIDJdID0gZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlciA9IGl0ZXIgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcmdlbmNlLlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgc2luZ3VsYXIgdmFsdWUgIHBvc2l0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzW2xdIDwgMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzW2xdID0gLXNbbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZVZlY3RvcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRHNjYWxDb2x1bW4odnQsIG1hdHJpeENvcHkuQ29sdW1uQ291bnQsIGwsIDAsIC0xLjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcmRlciB0aGUgc2luZ3VsYXIgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsICE9IG1uIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNbbF0gPj0gc1tsICsgMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHNbbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzW2xdID0gc1tsICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzW2wgKyAxXSA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZVZlY3RvcnMgJiYgbCA8IG1hdHJpeENvcHkuQ29sdW1uQ291bnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRHN3YXAodnQsIG1hdHJpeENvcHkuQ29sdW1uQ291bnQsIGwsIGwgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZVZlY3RvcnMgJiYgbCA8IG1hdHJpeENvcHkuUm93Q291bnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRHN3YXAodSwgbWF0cml4Q29weS5Sb3dDb3VudCwgbCwgbCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBsICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBtIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICBpZiAoY29tcHV0ZVZlY3RvcnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZ0ID0gdnQuVHJhbnNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkanVzdCB0aGUgc2l6ZSBvZiBzIGlmIHJvd3MgPCBjb2x1bW5zLiBXZSBhcmUgdXNpbmcgcG9ydGVkIGNvcHkgb2YgbGlucGFjaydzIHN2ZCBjb2RlIGFuZCBpdCB1c2VzXHJcbiAgICAgICAgICAgIC8vIGEgc2luZ3VsYXIgdmVjdG9yIG9mIGxlbmd0aCBtUm93cysxIHdoZW4gbVJvd3MgPCBtQ29sdW1ucy4gVGhlIGxhc3QgZWxlbWVudCBpcyBub3QgdXNlZCBhbmQgbmVlZHMgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIHBvcnQgbGFwYWNrJ3Mgc3ZkIHJvdXRpbmUgdG8gcmVtb3ZlIHRoaXMgcHJvYmxlbS5cclxuICAgICAgICAgICAgaWYgKG1hdHJpeENvcHkuUm93Q291bnQgPCBtYXRyaXhDb3B5LkNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBubS0tO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IHZfYnVpbGRlci5TYW1lQXM8ZG91YmxlPihtYXRyaXhDb3B5LCBubSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm07IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0bXBbaV0gPSBzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHMgPSB0bXA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXNlclN2ZChzLCB1LCB2dCwgY29tcHV0ZVZlY3RvcnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgVXNlclN2ZChWZWN0b3I8ZG91YmxlPiBzLCBNYXRyaXg8ZG91YmxlPiB1LCBNYXRyaXg8ZG91YmxlPiB2dCwgYm9vbCB2ZWN0b3JzQ29tcHV0ZWQpXHJcbiAgICAgICAgICAgIDogYmFzZShzLCB1LCB2dCwgdmVjdG9yc0NvbXB1dGVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsY3VsYXRlcyBhYnNvbHV0ZSB2YWx1ZSBvZiA8cGFyYW1yZWYgbmFtZT1cInoxXCIvPiBtdWx0aXBsaWVkIG9uIHNpZ251bSBmdW5jdGlvbiBvZiA8cGFyYW1yZWYgbmFtZT1cInoyXCIvPlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiejFcIj5Eb3VibGUgdmFsdWUgejE8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInoyXCI+RG91YmxlIHZhbHVlIHoyPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+UmVzdWx0IG11bHRpcGxpY2F0aW9uIG9mIHNpZ251bSBmdW5jdGlvbiBhbmQgYWJzb2x1dGUgdmFsdWU8L3JldHVybnM+XHJcbiAgICAgICAgc3RhdGljIGRvdWJsZSBEc2lnbihkb3VibGUgejEsIGRvdWJsZSB6MilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLkFicyh6MSkqKHoyL01hdGguQWJzKHoyKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN3YXAgY29sdW1uICA8cGFyYW1yZWYgbmFtZT1cImNvbHVtbkFcIi8+ICBhbmQgIDxwYXJhbXJlZiBuYW1lPVwiY29sdW1uQlwiLz5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFcIj5Tb3VyY2UgbWF0cml4PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dDb3VudFwiPlRoZSBudW1iZXIgb2Ygcm93cyBpbiA8cGFyYW1yZWYgbmFtZT1cImFcIi8+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb2x1bW5BXCI+Q29sdW1uIEEgaW5kZXggdG8gc3dhcDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uQlwiPkNvbHVtbiBCIGluZGV4IHRvIHN3YXA8L3BhcmFtPlxyXG4gICAgICAgIHN0YXRpYyB2b2lkIERzd2FwKE1hdHJpeDxkb3VibGU+IGEsIGludCByb3dDb3VudCwgaW50IGNvbHVtbkEsIGludCBjb2x1bW5CKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeiA9IGEuQXQoaSwgY29sdW1uQSk7XHJcbiAgICAgICAgICAgICAgICBhLkF0KGksIGNvbHVtbkEsIGEuQXQoaSwgY29sdW1uQikpO1xyXG4gICAgICAgICAgICAgICAgYS5BdChpLCBjb2x1bW5CLCB6KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTY2FsZSBjb2x1bW4gPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5cIi8+IGJ5IDxwYXJhbXJlZiBuYW1lPVwielwiLz4gc3RhcnRpbmcgZnJvbSByb3cgPHBhcmFtcmVmIG5hbWU9XCJyb3dTdGFydFwiLz5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFcIj5Tb3VyY2UgbWF0cml4PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dDb3VudFwiPlRoZSBudW1iZXIgb2Ygcm93cyBpbiA8cGFyYW1yZWYgbmFtZT1cImFcIi8+IDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uXCI+Q29sdW1uIHRvIHNjYWxlPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dTdGFydFwiPlJvdyB0byBzY2FsZSBmcm9tPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ6XCI+U2NhbGUgdmFsdWU8L3BhcmFtPlxyXG4gICAgICAgIHN0YXRpYyB2b2lkIERzY2FsQ29sdW1uKE1hdHJpeDxkb3VibGU+IGEsIGludCByb3dDb3VudCwgaW50IGNvbHVtbiwgaW50IHJvd1N0YXJ0LCBkb3VibGUgeilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSByb3dTdGFydDsgaSA8IHJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGEuQXQoaSwgY29sdW1uLCBhLkF0KGksIGNvbHVtbikqeik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2NhbGUgdmVjdG9yIDxwYXJhbXJlZiBuYW1lPVwiYVwiLz4gYnkgPHBhcmFtcmVmIG5hbWU9XCJ6XCIvPiBzdGFydGluZyBmcm9tIGluZGV4IDxwYXJhbXJlZiBuYW1lPVwic3RhcnRcIi8+XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhXCI+U291cmNlIHZlY3RvcjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic3RhcnRcIj5Sb3cgdG8gc2NhbGUgZnJvbTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwielwiPlNjYWxlIHZhbHVlPC9wYXJhbT5cclxuICAgICAgICBzdGF0aWMgdm9pZCBEc2NhbFZlY3Rvcihkb3VibGVbXSBhLCBpbnQgc3RhcnQsIGRvdWJsZSB6KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgYS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYVtpXSA9IGFbaV0qejtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHaXZlbiB0aGUgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIChkYSwgZGIpIG9mIGEgcG9pbnQgcCwgdGhlc2UgZnVuY3Rpb24gcmV0dXJuIHRoZSBwYXJhbWV0ZXJzIGRhLCBkYiwgYywgYW5kIHNcclxuICAgICAgICAvLy8gYXNzb2NpYXRlZCB3aXRoIHRoZSBHaXZlbnMgcm90YXRpb24gdGhhdCB6ZXJvcyB0aGUgeS1jb29yZGluYXRlIG9mIHRoZSBwb2ludC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRhXCI+UHJvdmlkZXMgdGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgcC4gT24gZXhpdCBjb250YWlucyB0aGUgcGFyYW1ldGVyIHIgYXNzb2NpYXRlZCB3aXRoIHRoZSBHaXZlbnMgcm90YXRpb248L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRiXCI+UHJvdmlkZXMgdGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgcC4gT24gZXhpdCBjb250YWlucyB0aGUgcGFyYW1ldGVyIHogYXNzb2NpYXRlZCB3aXRoIHRoZSBHaXZlbnMgcm90YXRpb248L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNcIj5Db250YWlucyB0aGUgcGFyYW1ldGVyIGMgYXNzb2NpYXRlZCB3aXRoIHRoZSBHaXZlbnMgcm90YXRpb248L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNcIj5Db250YWlucyB0aGUgcGFyYW1ldGVyIHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBHaXZlbnMgcm90YXRpb248L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5UaGlzIGlzIGVxdWl2YWxlbnQgdG8gdGhlIERST1RHIExBUEFDSyByb3V0aW5lLjwvcmVtYXJrcz5cclxuICAgICAgICBzdGF0aWMgdm9pZCBEcm90ZyhyZWYgZG91YmxlIGRhLCByZWYgZG91YmxlIGRiLCBvdXQgZG91YmxlIGMsIG91dCBkb3VibGUgcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSByLCB6O1xyXG4gICAgICAgICAgICB2YXIgcm9lID0gZGI7XHJcbiAgICAgICAgICAgIHZhciBhYnNkYSA9IE1hdGguQWJzKGRhKTtcclxuICAgICAgICAgICAgdmFyIGFic2RiID0gTWF0aC5BYnMoZGIpO1xyXG4gICAgICAgICAgICBpZiAoYWJzZGEgPiBhYnNkYilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcm9lID0gZGE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IGFic2RhICsgYWJzZGI7XHJcbiAgICAgICAgICAgIGlmIChzY2FsZSA9PSAwLjApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGMgPSAxLjA7XHJcbiAgICAgICAgICAgICAgICBzID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgciA9IDAuMDtcclxuICAgICAgICAgICAgICAgIHogPSAwLjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2RhID0gZGEvc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2RiID0gZGIvc2NhbGU7XHJcbiAgICAgICAgICAgICAgICByID0gc2NhbGUqTWF0aC5TcXJ0KChzZGEqc2RhKSArIChzZGIqc2RiKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocm9lIDwgMC4wKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSAtcjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjID0gZGEvcjtcclxuICAgICAgICAgICAgICAgIHMgPSBkYi9yO1xyXG4gICAgICAgICAgICAgICAgeiA9IDEuMDtcclxuICAgICAgICAgICAgICAgIGlmIChhYnNkYSA+IGFic2RiKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHogPSBzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhYnNkYiA+PSBhYnNkYSAmJiBjICE9IDAuMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB6ID0gMS4wL2M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRhID0gcjtcclxuICAgICAgICAgICAgZGIgPSB6O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYWxjdWxhdGUgTm9ybSAyIG9mIHRoZSBjb2x1bW4gPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5cIi8+IGluIG1hdHJpeCA8cGFyYW1yZWYgbmFtZT1cImFcIi8+IHN0YXJ0aW5nIGZyb20gcm93IDxwYXJhbXJlZiBuYW1lPVwicm93U3RhcnRcIi8+XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhXCI+U291cmNlIG1hdHJpeDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm93Q291bnRcIj5UaGUgbnVtYmVyIG9mIHJvd3MgaW4gPHBhcmFtcmVmIG5hbWU9XCJhXCIvPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uXCI+Q29sdW1uIGluZGV4PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dTdGFydFwiPlN0YXJ0IHJvdyBpbmRleDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPk5vcm0yIChFdWNsaWRlYW4gbm9ybSkgb2YgdGhlIGNvbHVtbjwvcmV0dXJucz5cclxuICAgICAgICBzdGF0aWMgZG91YmxlIERucm0yQ29sdW1uKE1hdHJpeDxkb3VibGU+IGEsIGludCByb3dDb3VudCwgaW50IGNvbHVtbiwgaW50IHJvd1N0YXJ0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZG91YmxlIHMgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcm93U3RhcnQ7IGkgPCByb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzICs9IGEuQXQoaSwgY29sdW1uKSphLkF0KGksIGNvbHVtbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLlNxcnQocyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZSBOb3JtIDIgb2YgdGhlIHZlY3RvciA8cGFyYW1yZWYgbmFtZT1cImFcIi8+IHN0YXJ0aW5nIGZyb20gaW5kZXggPHBhcmFtcmVmIG5hbWU9XCJyb3dTdGFydFwiLz5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFcIj5Tb3VyY2UgdmVjdG9yPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dTdGFydFwiPlN0YXJ0IGluZGV4PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+Tm9ybTIgKEV1Y2xpZGVhbiBub3JtKSBvZiB0aGUgdmVjdG9yPC9yZXR1cm5zPlxyXG4gICAgICAgIHN0YXRpYyBkb3VibGUgRG5ybTJWZWN0b3IoZG91YmxlW10gYSwgaW50IHJvd1N0YXJ0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZG91YmxlIHMgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcm93U3RhcnQ7IGkgPCBhLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzICs9IGFbaV0qYVtpXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguU3FydChzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsY3VsYXRlIGRvdCBwcm9kdWN0IG9mIDxwYXJhbXJlZiBuYW1lPVwiY29sdW1uQVwiLz4gYW5kIDxwYXJhbXJlZiBuYW1lPVwiY29sdW1uQlwiLz5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFcIj5Tb3VyY2UgbWF0cml4PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3dDb3VudFwiPlRoZSBudW1iZXIgb2Ygcm93cyBpbiA8cGFyYW1yZWYgbmFtZT1cImFcIi8+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb2x1bW5BXCI+SW5kZXggb2YgY29sdW1uIEE8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtbkJcIj5JbmRleCBvZiBjb2x1bW4gQjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm93U3RhcnRcIj5TdGFydGluZyByb3cgaW5kZXg8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5Eb3QgcHJvZHVjdCB2YWx1ZTwvcmV0dXJucz5cclxuICAgICAgICBzdGF0aWMgZG91YmxlIERkb3QoTWF0cml4PGRvdWJsZT4gYSwgaW50IHJvd0NvdW50LCBpbnQgY29sdW1uQSwgaW50IGNvbHVtbkIsIGludCByb3dTdGFydClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB6ID0gMC4wO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcm93U3RhcnQ7IGkgPCByb3dDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB6ICs9IGEuQXQoaSwgY29sdW1uQikqYS5BdChpLCBjb2x1bW5BKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHo7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBlcmZvcm1zIHJvdGF0aW9uIG9mIHBvaW50cyBpbiB0aGUgcGxhbmUuIEdpdmVuIHR3byB2ZWN0b3JzIHggPHBhcmFtcmVmIG5hbWU9XCJjb2x1bW5BXCIvPiBhbmQgeSA8cGFyYW1yZWYgbmFtZT1cImNvbHVtbkJcIi8+LFxyXG4gICAgICAgIC8vLyBlYWNoIHZlY3RvciBlbGVtZW50IG9mIHRoZXNlIHZlY3RvcnMgaXMgcmVwbGFjZWQgYXMgZm9sbG93czogeChpKSA9IGMqeChpKSArIHMqeShpKTsgeShpKSA9IGMqeShpKSAtIHMqeChpKVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYVwiPlNvdXJjZSBtYXRyaXg8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvd0NvdW50XCI+VGhlIG51bWJlciBvZiByb3dzIGluIDxwYXJhbXJlZiBuYW1lPVwiYVwiLz48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbHVtbkFcIj5JbmRleCBvZiBjb2x1bW4gQTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sdW1uQlwiPkluZGV4IG9mIGNvbHVtbiBCPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjXCI+U2NhbGFyIFwiY1wiIHZhbHVlPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzXCI+U2NhbGFyIFwic1wiIHZhbHVlPC9wYXJhbT5cclxuICAgICAgICBzdGF0aWMgdm9pZCBEcm90KE1hdHJpeDxkb3VibGU+IGEsIGludCByb3dDb3VudCwgaW50IGNvbHVtbkEsIGludCBjb2x1bW5CLCBkb3VibGUgYywgZG91YmxlIHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhciB6ID0gKGMqYS5BdChpLCBjb2x1bW5BKSkgKyAocyphLkF0KGksIGNvbHVtbkIpKTtcclxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSAoYyphLkF0KGksIGNvbHVtbkIpKSAtIChzKmEuQXQoaSwgY29sdW1uQSkpO1xyXG4gICAgICAgICAgICAgICAgYS5BdChpLCBjb2x1bW5CLCB0bXApO1xyXG4gICAgICAgICAgICAgICAgYS5BdChpLCBjb2x1bW5BLCB6KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTb2x2ZXMgYSBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucywgPGI+QVggPSBCPC9iPiwgd2l0aCBBIFNWRCBmYWN0b3JpemVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5wdXRcIj5UaGUgcmlnaHQgaGFuZCBzaWRlIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4sIDxiPkI8L2I+LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIGxlZnQgaGFuZCBzaWRlIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4sIDxiPlg8L2I+LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgU29sdmUoTWF0cml4PGRvdWJsZT4gaW5wdXQsIE1hdHJpeDxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICghVmVjdG9yc0NvbXB1dGVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9wZXJhdGlvbkV4Y2VwdGlvbihcIlJlc291cmNlcy5TaW5ndWxhclZlY3RvcnNOb3RDb21wdXRlZFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIHNvbHV0aW9uIFggc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGNvbHVtbnMgYXMgQlxyXG4gICAgICAgICAgICBpZiAoaW5wdXQuQ29sdW1uQ291bnQgIT0gcmVzdWx0LkNvbHVtbkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRNYXRyaXhTYW1lQ29sdW1uRGltZW5zaW9uXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZGltZW5zaW9uIGNvbXBhdGliaWxpdHkgY29uZGl0aW9ucyBmb3IgWCA9IEFcXEIgcmVxdWlyZSB0aGUgdHdvIG1hdHJpY2VzIEEgYW5kIEIgdG8gaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygcm93c1xyXG4gICAgICAgICAgICBpZiAoVS5Sb3dDb3VudCAhPSBpbnB1dC5Sb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4U2FtZVJvd0RpbWVuc2lvblwiKTtcclxuXHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgc29sdXRpb24gWCByb3cgZGltZW5zaW9uIGlzIGVxdWFsIHRvIHRoZSBjb2x1bW4gZGltZW5zaW9uIG9mIEFcclxuICAgICAgICAgICAgaWYgKFZULkNvbHVtbkNvdW50ICE9IHJlc3VsdC5Sb3dDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiUmVzb3VyY2VzLkFyZ3VtZW50TWF0cml4U2FtZUNvbHVtbkRpbWVuc2lvblwiKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBtbiA9IE1hdGguTWluKFUuUm93Q291bnQsIFZULkNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgdmFyIGJuID0gaW5wdXQuQ29sdW1uQ291bnQ7XHJcblxyXG4gICAgICAgICAgICB2YXIgdG1wID0gbmV3IGRvdWJsZVtWVC5Db2x1bW5Db3VudF07XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGJuOyBrKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgVlQuQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkb3VibGUgdmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgbW4pXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFUuUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVS5BdChpLCBqKSppbnB1dC5BdChpLCBrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgLz0gU1tqXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRtcFtqXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgVlQuQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkb3VibGUgdmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVlQuQ29sdW1uQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFZULkF0KGksIGopKnRtcFtpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BdChqLCBrLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29sdmVzIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMsIDxiPkF4ID0gYjwvYj4sIHdpdGggQSBTVkQgZmFjdG9yaXplZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlucHV0XCI+VGhlIHJpZ2h0IGhhbmQgc2lkZSB2ZWN0b3IsIDxiPmI8L2I+LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdWx0XCI+VGhlIGxlZnQgaGFuZCBzaWRlIDxzZWUgY3JlZj1cIk1hdHJpeHtUfVwiLz4sIDxiPng8L2I+LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgU29sdmUoVmVjdG9yPGRvdWJsZT4gaW5wdXQsIFZlY3Rvcjxkb3VibGU+IHJlc3VsdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICghVmVjdG9yc0NvbXB1dGVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9wZXJhdGlvbkV4Y2VwdGlvbihcIlJlc291cmNlcy5TaW5ndWxhclZlY3RvcnNOb3RDb21wdXRlZFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXg9YiB3aGVyZSBBIGlzIGFuIG0geCBuIG1hdHJpeFxyXG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IGIgaXMgYSBjb2x1bW4gdmVjdG9yIHdpdGggbSBlbnRyaWVzXHJcbiAgICAgICAgICAgIGlmIChVLlJvd0NvdW50ICE9IGlucHV0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJSZXNvdXJjZXMuQXJndW1lbnRWZWN0b3JzU2FtZUxlbmd0aFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB4IGlzIGEgY29sdW1uIHZlY3RvciB3aXRoIG4gZW50cmllc1xyXG4gICAgICAgICAgICBpZiAoVlQuQ29sdW1uQ291bnQgIT0gcmVzdWx0LkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBNYXRyaXguRGltZW5zaW9uc0RvbnRNYXRjaDxBcmd1bWVudEV4Y2VwdGlvbj4oVlQsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBtbiA9IE1hdGguTWluKFUuUm93Q291bnQsIFZULkNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgdmFyIHRtcCA9IG5ldyBkb3VibGVbVlQuQ29sdW1uQ291bnRdO1xyXG4gICAgICAgICAgICBkb3VibGUgdmFsdWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgVlQuQ29sdW1uQ291bnQ7IGorKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPCBtbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFUuUm93Q291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFUuQXQoaSwgaikqaW5wdXRbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAvPSBTW2pdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRtcFtqXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IFZULkNvbHVtbkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgVlQuQ29sdW1uQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBWVC5BdChpLCBqKSp0bXBbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2pdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl0KfQo=
